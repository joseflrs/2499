From 82a9e72244c25709f9e2f3aad7ec9c9e3aed0d8c Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Tue, 16 Jan 2024 20:23:04 -0500
Subject: [PATCH 01/24] CI: build bcm2711 RPi 4B firmware

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 .github/workflows/bcm2711.yaml                |  89 +++
 .github/workflows/config.buildinfo            | 691 ++++++++++++++++++
 .../workflows/{coverity.yml => coverityyml}   |   0
 .github/workflows/{formal.yml => formalyml}   |   0
 .../{github-release.yml => github-releaseyml} |   0
 .github/workflows/{kernel.yml => kernelyml}   |   0
 .../{label-kernel.yml => label-kernelyml}     |   0
 .../{label-target.yml => label-targetyml}     |   0
 .github/workflows/{labeler.yml => labeleryml} |   0
 .../workflows/{packages.yml => packagesyml}   |   0
 ...push-containers.yml => push-containersyml} |   0
 .../workflows/{toolchain.yml => toolchainyml} |   0
 .github/workflows/{tools.yml => toolsyml}     |   0
 config/Config-images.in                       |   2 +-
 .../bcm27xx/base-files/etc/board.d/02_network |   2 +-
 15 files changed, 782 insertions(+), 2 deletions(-)
 create mode 100755 .github/workflows/bcm2711.yaml
 create mode 100644 .github/workflows/config.buildinfo
 rename .github/workflows/{coverity.yml => coverityyml} (100%)
 rename .github/workflows/{formal.yml => formalyml} (100%)
 rename .github/workflows/{github-release.yml => github-releaseyml} (100%)
 rename .github/workflows/{kernel.yml => kernelyml} (100%)
 rename .github/workflows/{label-kernel.yml => label-kernelyml} (100%)
 rename .github/workflows/{label-target.yml => label-targetyml} (100%)
 rename .github/workflows/{labeler.yml => labeleryml} (100%)
 rename .github/workflows/{packages.yml => packagesyml} (100%)
 rename .github/workflows/{push-containers.yml => push-containersyml} (100%)
 rename .github/workflows/{toolchain.yml => toolchainyml} (100%)
 rename .github/workflows/{tools.yml => toolsyml} (100%)

diff --git a/.github/workflows/bcm2711.yaml b/.github/workflows/bcm2711.yaml
new file mode 100755
index 0000000000..898bb90bed
--- /dev/null
+++ b/.github/workflows/bcm2711.yaml
@@ -0,0 +1,89 @@
+name: Build bcm2711 RPi 4B
+on: [push]
+
+jobs:
+    build:
+        name: Build Raspberry Pi 4 images
+        runs-on: ubuntu-latest
+
+        steps:
+            - name: Setup Ubuntu
+              run: |
+                sudo apt update
+                sudo apt install -y python3 python3-pip python3-ply python3-distutils python3-pyelftools libpython3-dev swig
+            - name: Maximize build space
+              uses: AdityaGarg8/remove-unwanted-software@v1
+              with:
+                remove-android: 'true'
+                remove-dotnet: 'true'
+            - name: Checkout
+              uses: actions/checkout@v3
+
+            - name: Build
+              run: |
+                ./scripts/feeds update -a
+                ./scripts/feeds install -a
+                cd feeds/luci
+                wget https://gist.githubusercontent.com/mj22226/f6db007367a22a31f9cb1c109a032b45/raw/be368c4f1605f652a001d81548c3a3e14adf6cb7/luci-app-diskman.patch
+                git apply luci-app-diskman.patch
+                cd -
+                cd  feeds/packages
+                wget https://gist.githubusercontent.com/mj22226/351f11e66f08f06e37a985719a31ddb4/raw/b35ba7a3aac1949bd6bbeaad065a0a93dc3c34f0/01-cpu.patch
+                wget https://gist.githubusercontent.com/mj22226/b66f5c1bd5fc7e1cb3cf2c690b5dbd5a/raw/b955e726cbb0948d932c8d6143229ad604320149/20-lxc.patch
+                wget https://patch-diff.githubusercontent.com/raw/openwrt/packages/pull/23113.patch
+                git apply 01-cpu.patch
+                git apply 20-lxc.patch
+                git apply 23113.patch
+                cd -
+                sed -i "70s/'0'/'1'/" feeds/luci/applications/luci-app-statistics/root/etc/config/luci_statistics
+                sed -i "83s/'0'/'1'/" feeds/luci/applications/luci-app-statistics/root/etc/config/luci_statistics
+                sed -i "194s/'0'/'1'/" feeds/luci/applications/luci-app-statistics/root/etc/config/luci_statistics
+                sed -i "211s/'0'/'1'/" feeds/luci/applications/luci-app-statistics/root/etc/config/luci_statistics
+                sed -i "13s/'1'/'0'/" feeds/packages/utils/dockerd/files/etc/config/dockerd
+                sed -i 's/default n/default y/g' feeds/packages/utils/dockerd/Config.in
+                ./scripts/feeds update -a
+                ./scripts/feeds install -a -f
+                cp .github/workflows/config.buildinfo .config
+                make defconfig
+                wget https://gist.githubusercontent.com/mj22226/23edc25efeb65ef69d8eb6598f4f8179/raw/29c862e3e2558852523f4e8edd5f3d0cc145067e/01-key.patch
+                git apply 01-key.patch
+                make download -j32
+                rm 01-key.patch
+                sed -i '129d' package/base-files/Makefile
+                sed -i '135d' package/base-files/Makefile
+                mkdir -p files/www/repo
+                wget https://gist.githubusercontent.com/mj22226/681178b344f588b4625a7f83febd9131/raw/73ff0c720a0eefb99fe086ec2d715e0052976df0/03.patch
+                git apply 03.patch
+                make -j$(nproc) 'IGNORE_ERRORS=n m'
+                cp -R bin/targets/bcm27xx/bcm2711/packages/ files/www/repo/
+                make -j$(nproc) 'IGNORE_ERRORS=n m'
+                tar -cvf bcm27xx-images.tar bin/targets/bcm27xx/bcm2711
+
+            - name: Upload artifacts
+              uses: actions/upload-artifact@v3
+              with:
+                name: bcm27xx-images
+                path: bcm27xx-images.tar
+
+    release:
+          name: Make a release
+          runs-on: ubuntu-latest
+          needs: build
+
+          steps:
+            - name: Download the image artifacts
+              uses: actions/download-artifact@v3
+              with:
+                name: bcm27xx-images
+
+            - name: Extract the image artifacts
+              run: tar xf bcm27xx-images.tar
+
+            - name: Create a release
+              uses: "marvinpinto/action-automatic-releases@latest"
+              with:
+                repo_token: "${{ secrets.GITHUB_TOKEN }}"
+                prerelease: true
+                title: "Raspberry Pi 4 Firmware Images"
+                automatic_release_tag: "bcm2711-6.1"
+                files: bin/targets/bcm27xx/bcm2711/*
diff --git a/.github/workflows/config.buildinfo b/.github/workflows/config.buildinfo
new file mode 100644
index 0000000000..ff2ca7ca3f
--- /dev/null
+++ b/.github/workflows/config.buildinfo
@@ -0,0 +1,691 @@
+CONFIG_TARGET_bcm27xx=y
+CONFIG_TARGET_bcm27xx_bcm2711=y
+CONFIG_TARGET_MULTI_PROFILE=y
+CONFIG_TARGET_DEVICE_bcm27xx_bcm2711_DEVICE_rpi-4=y
+CONFIG_TARGET_DEVICE_PACKAGES_bcm27xx_bcm2711_DEVICE_rpi-4=""
+CONFIG_ALL_KMODS=y
+CONFIG_ALL_NONSHARED=y
+CONFIG_DEVEL=y
+CONFIG_BUSYBOX_CUSTOM=y
+CONFIG_TARGET_PER_DEVICE_ROOTFS=y
+CONFIG_BPF_TOOLCHAIN_BUILD_LLVM=y
+# CONFIG_BPF_TOOLCHAIN_NONE is not set
+CONFIG_BUILDBOT=y
+CONFIG_BUILD_LOG=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_GETOPT_LONG=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_SEAMLESS_XZ=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_TAR_LONG_OPTIONS=y
+CONFIG_BUSYBOX_CONFIG_GETOPT=y
+CONFIG_BUSYBOX_CONFIG_MOUNTPOINT=y
+CONFIG_BUSYBOX_CONFIG_UNXZ=y
+CONFIG_BUSYBOX_CONFIG_XZ=y
+CONFIG_CGROUPFS_MOUNT_KERNEL_CGROUPS=y
+CONFIG_DOCKER_CGROUP_OPTIONS=y
+CONFIG_DOCKER_CHECK_CONFIG=y
+CONFIG_DOCKER_NET_ENCRYPT=y
+CONFIG_DOCKER_NET_MACVLAN=y
+CONFIG_DOCKER_NET_OVERLAY=y
+CONFIG_DOCKER_NET_TFTP=y
+CONFIG_DOCKER_OPTIONAL_FEATURES=y
+CONFIG_DOCKER_STO_BTRFS=y
+CONFIG_DOCKER_STO_DEVMAPPER=y
+CONFIG_DOCKER_STO_EXT4=y
+CONFIG_GNUTLS_ALPN=y
+CONFIG_GNUTLS_ANON=y
+CONFIG_GNUTLS_DTLS_SRTP=y
+CONFIG_GNUTLS_HEARTBEAT=y
+CONFIG_GNUTLS_OCSP=y
+CONFIG_GNUTLS_PSK=y
+CONFIG_HAS_BPF_TOOLCHAIN=y
+CONFIG_HTOP_LMSENSORS=y
+CONFIG_JSON_CYCLONEDX_SBOM=y
+CONFIG_KERNEL_ARM_PMU=y
+CONFIG_KERNEL_BTRFS_FS_POSIX_ACL=y
+CONFIG_KERNEL_BUILD_DOMAIN="buildhost"
+CONFIG_KERNEL_BUILD_USER="builder"
+CONFIG_KERNEL_CFQ_GROUP_IOSCHED=y
+CONFIG_KERNEL_CGROUP_DEVICE=y
+CONFIG_KERNEL_CGROUP_FREEZER=y
+CONFIG_KERNEL_CGROUP_HUGETLB=y
+CONFIG_KERNEL_CGROUP_NET_PRIO=y
+CONFIG_KERNEL_CGROUP_PERF=y
+CONFIG_KERNEL_EXT4_FS_POSIX_ACL=y
+CONFIG_KERNEL_EXT4_FS_SECURITY=y
+CONFIG_KERNEL_FS_POSIX_ACL=y
+CONFIG_KERNEL_HUGETLBFS=y
+CONFIG_KERNEL_HUGETLB_PAGE=y
+CONFIG_KERNEL_MEMCG_SWAP_ENABLED=y
+CONFIG_KERNEL_NET_CLS_CGROUP=y
+CONFIG_KERNEL_PERF_EVENTS=y
+CONFIG_KERNEL_RPI_AXIPERF=y
+CONFIG_KERNEL_TRANSPARENT_HUGEPAGE=y
+CONFIG_KERNEL_TRANSPARENT_HUGEPAGE_ALWAYS=y
+CONFIG_KERNEL_WERROR=y
+CONFIG_LIBCURL_COOKIES=y
+CONFIG_LIBCURL_FILE=y
+CONFIG_LIBCURL_FTP=y
+CONFIG_LIBCURL_HTTP=y
+CONFIG_LIBCURL_MBEDTLS=y
+CONFIG_LIBCURL_NGHTTP2=y
+CONFIG_LIBCURL_NO_SMB="!"
+CONFIG_LIBCURL_PROXY=y
+CONFIG_LIBCURL_UNIX_SOCKETS=y
+CONFIG_LXC_BUSYBOX_OPTIONS=y
+CONFIG_LXC_KERNEL_OPTIONS=y
+CONFIG_LXC_NETWORKING=y
+CONFIG_LXC_SECCOMP=y
+CONFIG_OPENSSL_ENGINE=y
+CONFIG_OPENSSL_ENGINE_BUILTIN=y
+CONFIG_OPENSSL_ENGINE_BUILTIN_DEVCRYPTO=y
+CONFIG_OPENSSL_OPTIMIZE_SPEED=y
+CONFIG_OPENSSL_WITH_ASM=y
+CONFIG_OPENSSL_WITH_CHACHA_POLY1305=y
+CONFIG_OPENSSL_WITH_CMS=y
+CONFIG_OPENSSL_WITH_DEPRECATED=y
+CONFIG_OPENSSL_WITH_ERROR_MESSAGES=y
+CONFIG_OPENSSL_WITH_IDEA=y
+CONFIG_OPENSSL_WITH_MDC2=y
+CONFIG_OPENSSL_WITH_PSK=y
+CONFIG_OPENSSL_WITH_SEED=y
+CONFIG_OPENSSL_WITH_SRP=y
+CONFIG_OPENSSL_WITH_TLS13=y
+CONFIG_OPENSSL_WITH_WHIRLPOOL=y
+CONFIG_OPENVPN_openssl_ENABLE_FRAGMENT=y
+CONFIG_OPENVPN_openssl_ENABLE_LZ4=y
+CONFIG_OPENVPN_openssl_ENABLE_LZO=y
+CONFIG_OPENVPN_openssl_ENABLE_PORT_SHARE=y
+CONFIG_OPENVPN_openssl_ENABLE_X509_ALT_USERNAME=y
+CONFIG_PACKAGE_TAR_BZIP2=y
+CONFIG_PACKAGE_TAR_GZIP=y
+CONFIG_PACKAGE_TAR_POSIX_ACL=y
+CONFIG_PACKAGE_TAR_XATTR=y
+CONFIG_PACKAGE_TAR_XZ=y
+CONFIG_PACKAGE_TAR_ZSTD=y
+CONFIG_PACKAGE_adb=y
+CONFIG_PACKAGE_adblock=y
+CONFIG_PACKAGE_arp-scan=y
+CONFIG_PACKAGE_arp-scan-database=y
+CONFIG_PACKAGE_atop=y
+CONFIG_PACKAGE_bash=y
+CONFIG_PACKAGE_bcm2711-eeprom=y
+CONFIG_PACKAGE_bcm27xx-eeprom=y
+# CONFIG_PACKAGE_bcm27xx-userland is not set
+CONFIG_PACKAGE_bcm27xx-utils=y
+CONFIG_PACKAGE_blkdiscard=y
+CONFIG_PACKAGE_blkid=y
+CONFIG_PACKAGE_block-mount=y
+CONFIG_PACKAGE_blockd=y
+CONFIG_PACKAGE_blockdev=y
+CONFIG_PACKAGE_bluez-daemon=y
+CONFIG_PACKAGE_bluez-libs=y
+CONFIG_PACKAGE_bluez-tools=y
+CONFIG_PACKAGE_bluez-utils=y
+CONFIG_PACKAGE_bluez-utils-extra=y
+CONFIG_PACKAGE_btop=y
+CONFIG_PACKAGE_btrfs-progs=y
+CONFIG_PACKAGE_bzip2=y
+CONFIG_PACKAGE_ca-certificates=y
+CONFIG_PACKAGE_ccrypt=y
+CONFIG_PACKAGE_certtool=y
+CONFIG_PACKAGE_cfdisk=y
+CONFIG_PACKAGE_cgdisk=y
+CONFIG_PACKAGE_cgi-io=y
+CONFIG_PACKAGE_cgroup-tools=y
+CONFIG_PACKAGE_cgroupfs-mount=y
+CONFIG_PACKAGE_collectd=y
+CONFIG_PACKAGE_collectd-mod-conntrack=y
+CONFIG_PACKAGE_collectd-mod-cpu=y
+CONFIG_PACKAGE_collectd-mod-cpufreq=y
+CONFIG_PACKAGE_collectd-mod-interface=y
+CONFIG_PACKAGE_collectd-mod-irq=y
+CONFIG_PACKAGE_collectd-mod-iwinfo=y
+CONFIG_PACKAGE_collectd-mod-load=y
+CONFIG_PACKAGE_collectd-mod-memory=y
+CONFIG_PACKAGE_collectd-mod-network=y
+CONFIG_PACKAGE_collectd-mod-rrdtool=y
+CONFIG_PACKAGE_collectd-mod-sensors=y
+CONFIG_PACKAGE_collectd-mod-thermal=y
+CONFIG_PACKAGE_containerd=y
+CONFIG_PACKAGE_coreutils=y
+CONFIG_PACKAGE_coreutils-od=y
+CONFIG_PACKAGE_coreutils-sort=y
+CONFIG_PACKAGE_cryptsetup=y
+CONFIG_PACKAGE_cryptsetup-ssh=y
+CONFIG_PACKAGE_dbus=y
+CONFIG_PACKAGE_debugfs=y
+CONFIG_PACKAGE_dnsmasq=m
+CONFIG_PACKAGE_dnsmasq-full=y
+CONFIG_PACKAGE_dnsmasq_full_auth=y
+CONFIG_PACKAGE_dnsmasq_full_conntrack=y
+CONFIG_PACKAGE_dnsmasq_full_dhcp=y
+CONFIG_PACKAGE_dnsmasq_full_dhcpv6=y
+CONFIG_PACKAGE_dnsmasq_full_dnssec=y
+CONFIG_PACKAGE_dnsmasq_full_nftset=y
+CONFIG_PACKAGE_dnsmasq_full_noid=y
+CONFIG_PACKAGE_dnsmasq_full_tftp=y
+CONFIG_PACKAGE_docker=y
+CONFIG_PACKAGE_docker-compose=y
+CONFIG_PACKAGE_dockerd=y
+CONFIG_PACKAGE_dosfstools=y
+CONFIG_PACKAGE_dumpe2fs=y
+CONFIG_PACKAGE_e2freefrag=y
+CONFIG_PACKAGE_e4crypt=y
+CONFIG_PACKAGE_eject=y
+CONFIG_PACKAGE_ethtool-full=y
+CONFIG_PACKAGE_exfat-fsck=y
+CONFIG_PACKAGE_exfat-mkfs=y
+CONFIG_PACKAGE_f2fs-tools=m
+CONFIG_PACKAGE_f2fs-tools-selinux=y
+CONFIG_PACKAGE_f2fsck=m
+CONFIG_PACKAGE_f2fsck-selinux=y
+CONFIG_PACKAGE_fdisk=y
+CONFIG_PACKAGE_findfs=y
+CONFIG_PACKAGE_fixparts=y
+CONFIG_PACKAGE_flock=y
+CONFIG_PACKAGE_fuse-utils=y
+CONFIG_PACKAGE_gdisk=y
+CONFIG_PACKAGE_getopt=y
+CONFIG_PACKAGE_glib2=y
+CONFIG_PACKAGE_gnupg=y
+CONFIG_PACKAGE_gnupg-utils=y
+CONFIG_PACKAGE_gnupg2=y
+CONFIG_PACKAGE_gnupg2-utils=y
+CONFIG_PACKAGE_gzip=y
+CONFIG_PACKAGE_hdparm=y
+CONFIG_PACKAGE_hostapd-common=y
+CONFIG_PACKAGE_htop=y
+CONFIG_PACKAGE_hwclock=y
+CONFIG_PACKAGE_ip-full=y
+CONFIG_PACKAGE_ip6tables-nft=y
+CONFIG_PACKAGE_iperf3-ssl=y
+CONFIG_PACKAGE_ipset=y
+CONFIG_PACKAGE_iptables-mod-extra=y
+CONFIG_PACKAGE_iptables-mod-ipopt=y
+CONFIG_PACKAGE_iptables-nft=y
+CONFIG_PACKAGE_irqbalance=y
+CONFIG_PACKAGE_iw=y
+CONFIG_PACKAGE_iwinfo=y
+CONFIG_PACKAGE_kmod-asn1-decoder=y
+CONFIG_PACKAGE_kmod-asn1-encoder=y
+CONFIG_PACKAGE_kmod-ata-ahci=y
+CONFIG_PACKAGE_kmod-ata-core=y
+CONFIG_PACKAGE_kmod-atm=y
+CONFIG_PACKAGE_kmod-bluetooth=y
+CONFIG_PACKAGE_kmod-br-netfilter=y
+CONFIG_PACKAGE_kmod-cdrom=y
+CONFIG_PACKAGE_kmod-cfg80211=y
+CONFIG_PACKAGE_kmod-crypto-aead=y
+CONFIG_PACKAGE_kmod-crypto-arc4=y
+CONFIG_PACKAGE_kmod-crypto-authenc=y
+CONFIG_PACKAGE_kmod-crypto-cbc=y
+CONFIG_PACKAGE_kmod-crypto-ccm=y
+CONFIG_PACKAGE_kmod-crypto-chacha20poly1305=y
+CONFIG_PACKAGE_kmod-crypto-cmac=y
+CONFIG_PACKAGE_kmod-crypto-crc32=y
+CONFIG_PACKAGE_kmod-crypto-ctr=y
+CONFIG_PACKAGE_kmod-crypto-cts=y
+CONFIG_PACKAGE_kmod-crypto-deflate=y
+CONFIG_PACKAGE_kmod-crypto-des=y
+CONFIG_PACKAGE_kmod-crypto-ecb=y
+CONFIG_PACKAGE_kmod-crypto-ecdh=y
+CONFIG_PACKAGE_kmod-crypto-echainiv=y
+CONFIG_PACKAGE_kmod-crypto-essiv=y
+CONFIG_PACKAGE_kmod-crypto-fcrypt=y
+CONFIG_PACKAGE_kmod-crypto-gcm=y
+CONFIG_PACKAGE_kmod-crypto-gf128=y
+CONFIG_PACKAGE_kmod-crypto-ghash=y
+CONFIG_PACKAGE_kmod-crypto-hmac=y
+CONFIG_PACKAGE_kmod-crypto-kpp=y
+CONFIG_PACKAGE_kmod-crypto-lib-chacha20=y
+CONFIG_PACKAGE_kmod-crypto-lib-chacha20poly1305=y
+CONFIG_PACKAGE_kmod-crypto-lib-curve25519=y
+CONFIG_PACKAGE_kmod-crypto-lib-poly1305=y
+CONFIG_PACKAGE_kmod-crypto-manager=y
+CONFIG_PACKAGE_kmod-crypto-md4=y
+CONFIG_PACKAGE_kmod-crypto-md5=y
+CONFIG_PACKAGE_kmod-crypto-michael-mic=y
+CONFIG_PACKAGE_kmod-crypto-misc=y
+CONFIG_PACKAGE_kmod-crypto-null=y
+CONFIG_PACKAGE_kmod-crypto-pcbc=y
+CONFIG_PACKAGE_kmod-crypto-rmd160=y
+CONFIG_PACKAGE_kmod-crypto-rng=y
+CONFIG_PACKAGE_kmod-crypto-seqiv=y
+CONFIG_PACKAGE_kmod-crypto-sha1=y
+CONFIG_PACKAGE_kmod-crypto-sha256=y
+CONFIG_PACKAGE_kmod-crypto-sha512=y
+CONFIG_PACKAGE_kmod-crypto-test=y
+CONFIG_PACKAGE_kmod-crypto-user=y
+CONFIG_PACKAGE_kmod-crypto-xcbc=y
+CONFIG_PACKAGE_kmod-crypto-xts=y
+CONFIG_PACKAGE_kmod-cryptodev=y
+CONFIG_PACKAGE_kmod-dax=y
+CONFIG_PACKAGE_kmod-dm=y
+CONFIG_PACKAGE_kmod-dummy=y
+CONFIG_PACKAGE_kmod-fs-autofs4=y
+CONFIG_PACKAGE_kmod-fs-btrfs=y
+CONFIG_PACKAGE_kmod-fs-configfs=y
+CONFIG_PACKAGE_kmod-fs-exfat=y
+CONFIG_PACKAGE_kmod-fs-exportfs=y
+CONFIG_PACKAGE_kmod-fs-ext4=y
+CONFIG_PACKAGE_kmod-fs-f2fs=y
+CONFIG_PACKAGE_kmod-fs-hfs=y
+CONFIG_PACKAGE_kmod-fs-hfsplus=y
+CONFIG_PACKAGE_kmod-fs-ksmbd=y
+CONFIG_PACKAGE_kmod-fs-ntfs3=y
+CONFIG_PACKAGE_kmod-fs-smbfs-common=y
+CONFIG_PACKAGE_kmod-fs-squashfs=y
+CONFIG_PACKAGE_kmod-fs-xfs=y
+CONFIG_PACKAGE_kmod-fuse=y
+CONFIG_PACKAGE_kmod-gre=y
+CONFIG_PACKAGE_kmod-hwmon-core=y
+CONFIG_PACKAGE_kmod-i2c-bcm2835=y
+CONFIG_PACKAGE_kmod-i2c-core=y
+CONFIG_PACKAGE_kmod-ifb=y
+CONFIG_PACKAGE_kmod-ikconfig=y
+CONFIG_PACKAGE_kmod-ip6tables=y
+CONFIG_PACKAGE_kmod-ipsec=y
+CONFIG_PACKAGE_kmod-ipt-conntrack=y
+CONFIG_PACKAGE_kmod-ipt-core=y
+CONFIG_PACKAGE_kmod-ipt-extra=y
+CONFIG_PACKAGE_kmod-ipt-ipopt=y
+CONFIG_PACKAGE_kmod-ipt-ipset=y
+CONFIG_PACKAGE_kmod-ipt-nat=y
+CONFIG_PACKAGE_kmod-ipt-nat6=y
+CONFIG_PACKAGE_kmod-ipt-physdev=y
+CONFIG_PACKAGE_kmod-iptunnel=y
+CONFIG_PACKAGE_kmod-keys-encrypted=y
+CONFIG_PACKAGE_kmod-keys-trusted=y
+CONFIG_PACKAGE_kmod-l2tp=y
+CONFIG_PACKAGE_kmod-lib-crc16=y
+CONFIG_PACKAGE_kmod-lib-raid6=y
+CONFIG_PACKAGE_kmod-lib-textsearch=y
+CONFIG_PACKAGE_kmod-lib-xor=y
+CONFIG_PACKAGE_kmod-lib-zlib-deflate=y
+CONFIG_PACKAGE_kmod-lib-zlib-inflate=y
+CONFIG_PACKAGE_kmod-lib-zstd=y
+CONFIG_PACKAGE_kmod-libphy=y
+CONFIG_PACKAGE_kmod-mac80211=y
+CONFIG_PACKAGE_kmod-macvlan=y
+CONFIG_PACKAGE_kmod-md-mod=y
+CONFIG_PACKAGE_kmod-md-raid0=y
+CONFIG_PACKAGE_kmod-md-raid1=y
+CONFIG_PACKAGE_kmod-md-raid10=y
+CONFIG_PACKAGE_kmod-mdio-devres=y
+CONFIG_PACKAGE_kmod-mii=y
+CONFIG_PACKAGE_kmod-mppe=y
+CONFIG_PACKAGE_kmod-mt76-connac=y
+CONFIG_PACKAGE_kmod-mt76-core=y
+CONFIG_PACKAGE_kmod-mt76-usb=y
+CONFIG_PACKAGE_kmod-mt76x02-common=y
+CONFIG_PACKAGE_kmod-mt76x02-usb=y
+CONFIG_PACKAGE_kmod-mt76x2-common=y
+CONFIG_PACKAGE_kmod-mt76x2u=y
+CONFIG_PACKAGE_kmod-mt7921-common=y
+CONFIG_PACKAGE_kmod-mt7921-firmware=y
+CONFIG_PACKAGE_kmod-mt7921u=y
+CONFIG_PACKAGE_kmod-mt792x-common=y
+CONFIG_PACKAGE_kmod-mt792x-usb=y
+CONFIG_PACKAGE_kmod-net-selftests=y
+CONFIG_PACKAGE_kmod-nf-conntrack-netlink=y
+CONFIG_PACKAGE_kmod-nf-ipt=y
+CONFIG_PACKAGE_kmod-nf-ipt6=y
+CONFIG_PACKAGE_kmod-nf-ipvs=y
+CONFIG_PACKAGE_kmod-nf-nat6=y
+CONFIG_PACKAGE_kmod-nf-nathelper=y
+CONFIG_PACKAGE_kmod-nf-nathelper-extra=y
+CONFIG_PACKAGE_kmod-nft-compat=y
+CONFIG_PACKAGE_kmod-nvme=y
+CONFIG_PACKAGE_kmod-oid-registry=y
+CONFIG_PACKAGE_kmod-phy-ax88796b=y
+CONFIG_PACKAGE_kmod-phy-realtek=y
+CONFIG_PACKAGE_kmod-phylink=y
+CONFIG_PACKAGE_kmod-pppoa=y
+CONFIG_PACKAGE_kmod-pppol2tp=y
+CONFIG_PACKAGE_kmod-pptp=y
+CONFIG_PACKAGE_kmod-r8169=y
+CONFIG_PACKAGE_kmod-random-core=y
+CONFIG_PACKAGE_kmod-regmap-core=y
+CONFIG_PACKAGE_kmod-rtl8812au-ac=y
+CONFIG_PACKAGE_kmod-rtw88=y
+CONFIG_PACKAGE_kmod-rtw88-8821c=y
+CONFIG_PACKAGE_kmod-rtw88-8821cu=y
+CONFIG_PACKAGE_kmod-rtw88-8822b=y
+CONFIG_PACKAGE_kmod-rtw88-8822bu=y
+CONFIG_PACKAGE_kmod-rtw88-8822c=y
+CONFIG_PACKAGE_kmod-rtw88-8822cu=y
+CONFIG_PACKAGE_kmod-rtw88-usb=y
+CONFIG_PACKAGE_kmod-sched-bpf=y
+CONFIG_PACKAGE_kmod-sched-cake=y
+CONFIG_PACKAGE_kmod-sched-core=y
+CONFIG_PACKAGE_kmod-scsi-core=y
+CONFIG_PACKAGE_kmod-tpm=y
+CONFIG_PACKAGE_kmod-tun=y
+CONFIG_PACKAGE_kmod-udptunnel4=y
+CONFIG_PACKAGE_kmod-udptunnel6=y
+CONFIG_PACKAGE_kmod-usb-net=y
+CONFIG_PACKAGE_kmod-usb-net-aqc111=y
+CONFIG_PACKAGE_kmod-usb-net-asix=y
+CONFIG_PACKAGE_kmod-usb-net-asix-ax88179=y
+CONFIG_PACKAGE_kmod-usb-net-cdc-ether=y
+CONFIG_PACKAGE_kmod-usb-net-cdc-ncm=y
+CONFIG_PACKAGE_kmod-usb-net-ipheth=y
+CONFIG_PACKAGE_kmod-usb-net-rndis=y
+CONFIG_PACKAGE_kmod-usb-net-rtl8150=y
+CONFIG_PACKAGE_kmod-usb-net-rtl8152=y
+CONFIG_PACKAGE_kmod-usb-ohci=y
+CONFIG_PACKAGE_kmod-usb-storage=y
+CONFIG_PACKAGE_kmod-usb-storage-extras=y
+CONFIG_PACKAGE_kmod-usb-storage-uas=y
+CONFIG_PACKAGE_kmod-usb-wdm=y
+CONFIG_PACKAGE_kmod-veth=y
+CONFIG_PACKAGE_kmod-vxlan=y
+CONFIG_PACKAGE_kmod-wireguard=y
+CONFIG_PACKAGE_ksmbd-server=y
+CONFIG_PACKAGE_libacl=y
+CONFIG_PACKAGE_libaio=y
+CONFIG_PACKAGE_libassuan=y
+CONFIG_PACKAGE_libatomic=y
+CONFIG_PACKAGE_libattr=y
+CONFIG_PACKAGE_libbfd=m
+CONFIG_PACKAGE_libbpf=y
+CONFIG_PACKAGE_libbz2=y
+CONFIG_PACKAGE_libcap=y
+CONFIG_PACKAGE_libcap-ng=y
+CONFIG_PACKAGE_libcgroup=y
+CONFIG_PACKAGE_libctf=m
+CONFIG_PACKAGE_libcurl=y
+CONFIG_PACKAGE_libdbus=y
+CONFIG_PACKAGE_libdevmapper=y
+CONFIG_PACKAGE_libdw=m
+CONFIG_PACKAGE_libelf=y
+CONFIG_PACKAGE_libevdev=y
+CONFIG_PACKAGE_libexpat=y
+CONFIG_PACKAGE_libf2fs=m
+CONFIG_PACKAGE_libf2fs-selinux=y
+CONFIG_PACKAGE_libfdisk=y
+CONFIG_PACKAGE_libfdt=y
+CONFIG_PACKAGE_libffi=y
+CONFIG_PACKAGE_libfuse=y
+CONFIG_PACKAGE_libgcrypt=y
+CONFIG_PACKAGE_libgmp=y
+CONFIG_PACKAGE_libgnutls=y
+CONFIG_PACKAGE_libgpg-error=y
+CONFIG_PACKAGE_libical=y
+CONFIG_PACKAGE_libipset=y
+CONFIG_PACKAGE_libiptext=y
+CONFIG_PACKAGE_libiptext-nft=y
+CONFIG_PACKAGE_libiptext6=y
+CONFIG_PACKAGE_libiwinfo=y
+CONFIG_PACKAGE_libiwinfo-data=y
+CONFIG_PACKAGE_libkmod=y
+CONFIG_PACKAGE_libksba=y
+CONFIG_PACKAGE_libltdl=y
+CONFIG_PACKAGE_liblua=y
+CONFIG_PACKAGE_liblucihttp=y
+CONFIG_PACKAGE_liblucihttp-lua=y
+CONFIG_PACKAGE_liblucihttp-ucode=y
+CONFIG_PACKAGE_liblxc=y
+CONFIG_PACKAGE_liblz4=y
+CONFIG_PACKAGE_liblzma=y
+CONFIG_PACKAGE_liblzo=y
+CONFIG_PACKAGE_libmount=y
+CONFIG_PACKAGE_libncurses=y
+CONFIG_PACKAGE_libnetfilter-conntrack=y
+CONFIG_PACKAGE_libnettle=y
+CONFIG_PACKAGE_libnfnetlink=y
+CONFIG_PACKAGE_libnghttp2=y
+CONFIG_PACKAGE_libnl-core=y
+CONFIG_PACKAGE_libnl-genl=y
+CONFIG_PACKAGE_libnpth=y
+CONFIG_PACKAGE_libopcodes=m
+CONFIG_PACKAGE_libopenssl=y
+CONFIG_PACKAGE_libopenssl-conf=y
+CONFIG_PACKAGE_libparted=y
+CONFIG_PACKAGE_libpcap=y
+CONFIG_PACKAGE_libpci=y
+CONFIG_PACKAGE_libpcre2=y
+CONFIG_PACKAGE_libpopt=y
+CONFIG_PACKAGE_libpython3=y
+CONFIG_PACKAGE_libqrencode=y
+CONFIG_PACKAGE_libreadline=y
+CONFIG_PACKAGE_librrd1=y
+CONFIG_PACKAGE_libseccomp=y
+CONFIG_PACKAGE_libselinux=y
+CONFIG_PACKAGE_libsensors=y
+CONFIG_PACKAGE_libsepol=y
+CONFIG_PACKAGE_libssh=y
+CONFIG_PACKAGE_libstdcpp=y
+CONFIG_PACKAGE_libsysfs=y
+CONFIG_PACKAGE_libtirpc=y
+CONFIG_PACKAGE_libubus-lua=y
+CONFIG_PACKAGE_libudev-zero=y
+CONFIG_PACKAGE_libusb-1.0=y
+CONFIG_PACKAGE_libuv=y
+CONFIG_PACKAGE_libwebsockets-full=y
+CONFIG_PACKAGE_libxdp=m
+CONFIG_PACKAGE_libxtables=y
+CONFIG_PACKAGE_libzstd=y
+CONFIG_PACKAGE_linux-atm=y
+CONFIG_PACKAGE_lm-sensors=y
+CONFIG_PACKAGE_losetup=y
+CONFIG_PACKAGE_lsblk=y
+CONFIG_PACKAGE_lscpu=y
+CONFIG_PACKAGE_lua=y
+CONFIG_PACKAGE_luci=y
+CONFIG_PACKAGE_luci-app-adblock=y
+CONFIG_PACKAGE_luci-app-commands=y
+CONFIG_PACKAGE_luci-app-diskman=y
+CONFIG_PACKAGE_luci-app-diskman_INCLUDE_btrfs_progs=y
+CONFIG_PACKAGE_luci-app-diskman_INCLUDE_lsblk=y
+CONFIG_PACKAGE_luci-app-dockerman=y
+CONFIG_PACKAGE_luci-app-firewall=y
+CONFIG_PACKAGE_luci-app-ksmbd=y
+CONFIG_PACKAGE_luci-app-lxc=y
+CONFIG_PACKAGE_luci-app-nlbwmon=y
+CONFIG_PACKAGE_luci-app-openvpn=y
+CONFIG_PACKAGE_luci-app-opkg=y
+CONFIG_PACKAGE_luci-app-pbr=y
+CONFIG_PACKAGE_luci-app-sqm=y
+CONFIG_PACKAGE_luci-app-statistics=y
+CONFIG_PACKAGE_luci-app-ttyd=y
+CONFIG_PACKAGE_luci-base=y
+CONFIG_PACKAGE_luci-compat=y
+CONFIG_PACKAGE_luci-lib-base=y
+CONFIG_PACKAGE_luci-lib-docker=y
+CONFIG_PACKAGE_luci-lib-ip=y
+CONFIG_PACKAGE_luci-lib-jsonc=y
+CONFIG_PACKAGE_luci-lib-nixio=y
+CONFIG_PACKAGE_luci-light=y
+CONFIG_PACKAGE_luci-lua-runtime=y
+CONFIG_PACKAGE_luci-mod-admin-full=y
+CONFIG_PACKAGE_luci-mod-network=y
+CONFIG_PACKAGE_luci-mod-status=y
+CONFIG_PACKAGE_luci-mod-system=y
+CONFIG_PACKAGE_luci-proto-ipv6=y
+CONFIG_PACKAGE_luci-proto-ppp=y
+CONFIG_PACKAGE_luci-proto-vxlan=y
+CONFIG_PACKAGE_luci-proto-wireguard=y
+CONFIG_PACKAGE_luci-theme-bootstrap=y
+CONFIG_PACKAGE_lvm2=y
+CONFIG_PACKAGE_lxc=y
+CONFIG_PACKAGE_lxc-attach=y
+CONFIG_PACKAGE_lxc-auto=y
+CONFIG_PACKAGE_lxc-autostart=y
+CONFIG_PACKAGE_lxc-cgroup=y
+CONFIG_PACKAGE_lxc-checkconfig=y
+CONFIG_PACKAGE_lxc-common=y
+CONFIG_PACKAGE_lxc-config=y
+CONFIG_PACKAGE_lxc-configs=y
+CONFIG_PACKAGE_lxc-console=y
+CONFIG_PACKAGE_lxc-copy=y
+CONFIG_PACKAGE_lxc-create=y
+CONFIG_PACKAGE_lxc-destroy=y
+CONFIG_PACKAGE_lxc-device=y
+CONFIG_PACKAGE_lxc-execute=y
+CONFIG_PACKAGE_lxc-freeze=y
+CONFIG_PACKAGE_lxc-hooks=y
+CONFIG_PACKAGE_lxc-info=y
+CONFIG_PACKAGE_lxc-init=y
+CONFIG_PACKAGE_lxc-ls=y
+CONFIG_PACKAGE_lxc-monitor=y
+CONFIG_PACKAGE_lxc-monitord=y
+CONFIG_PACKAGE_lxc-snapshot=y
+CONFIG_PACKAGE_lxc-start=y
+CONFIG_PACKAGE_lxc-stop=y
+CONFIG_PACKAGE_lxc-templates=y
+CONFIG_PACKAGE_lxc-top=y
+CONFIG_PACKAGE_lxc-unfreeze=y
+CONFIG_PACKAGE_lxc-unprivileged=y
+CONFIG_PACKAGE_lxc-unshare=y
+CONFIG_PACKAGE_lxc-user-nic=y
+CONFIG_PACKAGE_lxc-usernsexec=y
+CONFIG_PACKAGE_lxc-wait=y
+CONFIG_PACKAGE_lz4=y
+CONFIG_PACKAGE_lzmadec=y
+CONFIG_PACKAGE_lzmainfo=y
+CONFIG_PACKAGE_mdadm=y
+CONFIG_PACKAGE_mkf2fs=m
+CONFIG_PACKAGE_mkf2fs-selinux=y
+CONFIG_PACKAGE_mmc-utils=y
+CONFIG_PACKAGE_mount-utils=y
+CONFIG_PACKAGE_mtools=y
+CONFIG_PACKAGE_musl-fts=y
+CONFIG_PACKAGE_nano=y
+CONFIG_PACKAGE_nfs-utils=y
+CONFIG_PACKAGE_nlbwmon=y
+CONFIG_PACKAGE_objdump=m
+CONFIG_PACKAGE_openssl-util=y
+CONFIG_PACKAGE_openvpn-easy-rsa=y
+CONFIG_PACKAGE_openvpn-openssl=y
+CONFIG_PACKAGE_parted=y
+CONFIG_PACKAGE_pbr=y
+CONFIG_PACKAGE_pciids=y
+CONFIG_PACKAGE_pciutils=y
+CONFIG_PACKAGE_perf=m
+CONFIG_PACKAGE_ppp-mod-passwordfd=y
+CONFIG_PACKAGE_ppp-mod-pppoa=y
+CONFIG_PACKAGE_ppp-mod-pppol2tp=y
+CONFIG_PACKAGE_ppp-mod-pptp=y
+CONFIG_PACKAGE_ppp-mod-radius=y
+CONFIG_PACKAGE_pppdump=y
+CONFIG_PACKAGE_pppoe-discovery=y
+CONFIG_PACKAGE_pptpd=y
+CONFIG_PACKAGE_python3-base=y
+CONFIG_PACKAGE_python3-light=y
+CONFIG_PACKAGE_qosify=y
+CONFIG_PACKAGE_qrencode=y
+CONFIG_PACKAGE_r8152-firmware=y
+CONFIG_PACKAGE_r8169-firmware=y
+CONFIG_PACKAGE_resize2fs=y
+CONFIG_PACKAGE_resolveip=y
+CONFIG_PACKAGE_rpcd=y
+CONFIG_PACKAGE_rpcd-mod-file=y
+CONFIG_PACKAGE_rpcd-mod-iwinfo=y
+CONFIG_PACKAGE_rpcd-mod-luci=y
+CONFIG_PACKAGE_rpcd-mod-lxc=y
+CONFIG_PACKAGE_rpcd-mod-rrdns=y
+CONFIG_PACKAGE_rpcd-mod-ucode=y
+CONFIG_PACKAGE_rrdtool1=y
+CONFIG_PACKAGE_rtl8821ce-firmware=y
+CONFIG_PACKAGE_rtl8822be-firmware=y
+CONFIG_PACKAGE_rtl8822ce-firmware=y
+CONFIG_PACKAGE_runc=y
+CONFIG_PACKAGE_sfdisk=y
+CONFIG_PACKAGE_sgdisk=y
+CONFIG_PACKAGE_shadow=y
+CONFIG_PACKAGE_shadow-chage=y
+CONFIG_PACKAGE_shadow-chfn=y
+CONFIG_PACKAGE_shadow-chgpasswd=y
+CONFIG_PACKAGE_shadow-chpasswd=y
+CONFIG_PACKAGE_shadow-chsh=y
+CONFIG_PACKAGE_shadow-common=y
+CONFIG_PACKAGE_shadow-expiry=y
+CONFIG_PACKAGE_shadow-faillog=y
+CONFIG_PACKAGE_shadow-gpasswd=y
+CONFIG_PACKAGE_shadow-groupadd=y
+CONFIG_PACKAGE_shadow-groupdel=y
+CONFIG_PACKAGE_shadow-groupmems=y
+CONFIG_PACKAGE_shadow-groupmod=y
+CONFIG_PACKAGE_shadow-groups=y
+CONFIG_PACKAGE_shadow-grpck=y
+CONFIG_PACKAGE_shadow-grpconv=y
+CONFIG_PACKAGE_shadow-grpunconv=y
+CONFIG_PACKAGE_shadow-lastlog=y
+CONFIG_PACKAGE_shadow-login=y
+CONFIG_PACKAGE_shadow-logoutd=y
+CONFIG_PACKAGE_shadow-newgidmap=y
+CONFIG_PACKAGE_shadow-newgrp=y
+CONFIG_PACKAGE_shadow-newuidmap=y
+CONFIG_PACKAGE_shadow-newusers=y
+CONFIG_PACKAGE_shadow-nologin=y
+CONFIG_PACKAGE_shadow-passwd=y
+CONFIG_PACKAGE_shadow-pwck=y
+CONFIG_PACKAGE_shadow-pwconv=y
+CONFIG_PACKAGE_shadow-pwunconv=y
+CONFIG_PACKAGE_shadow-su=y
+CONFIG_PACKAGE_shadow-useradd=y
+CONFIG_PACKAGE_shadow-userdel=y
+CONFIG_PACKAGE_shadow-usermod=y
+CONFIG_PACKAGE_shadow-utils=y
+CONFIG_PACKAGE_shadow-vipw=y
+CONFIG_PACKAGE_smartmontools=y
+CONFIG_PACKAGE_smartmontools-drivedb=y
+CONFIG_PACKAGE_sqm-scripts=y
+CONFIG_PACKAGE_sqm-scripts-extra=y
+CONFIG_PACKAGE_squashfs-tools-mksquashfs=y
+CONFIG_PACKAGE_squashfs-tools-unsquashfs=y
+CONFIG_PACKAGE_sysfsutils=y
+CONFIG_PACKAGE_tar=y
+CONFIG_PACKAGE_tc-full=y
+CONFIG_PACKAGE_tc-mod-iptables=y
+CONFIG_PACKAGE_tc-tiny=y
+CONFIG_PACKAGE_tcpdump-mini=y
+CONFIG_PACKAGE_terminfo=y
+CONFIG_PACKAGE_tini=y
+CONFIG_PACKAGE_ttyd=y
+CONFIG_PACKAGE_ucert-full=y
+CONFIG_PACKAGE_ucode-mod-html=y
+CONFIG_PACKAGE_ucode-mod-lua=y
+CONFIG_PACKAGE_ucode-mod-math=y
+CONFIG_PACKAGE_uencrypt-openssl=y
+CONFIG_PACKAGE_uhttpd=y
+CONFIG_PACKAGE_uhttpd-mod-ubus=y
+CONFIG_PACKAGE_usb-modeswitch=y
+CONFIG_PACKAGE_usbutils=y
+CONFIG_PACKAGE_uuidd=y
+CONFIG_PACKAGE_uuidgen=y
+CONFIG_PACKAGE_vsftpd-tls=y
+CONFIG_PACKAGE_vxlan=y
+CONFIG_PACKAGE_wget-ssl=y
+CONFIG_PACKAGE_wireguard-tools=y
+CONFIG_PACKAGE_wireless-regdb=y
+CONFIG_PACKAGE_wireless-tools=y
+CONFIG_PACKAGE_wsdd2=y
+CONFIG_PACKAGE_xdp-filter=m
+CONFIG_PACKAGE_xdp-loader=m
+CONFIG_PACKAGE_xdpdump=m
+CONFIG_PACKAGE_xl2tpd=y
+CONFIG_PACKAGE_xtables-nft=y
+CONFIG_PACKAGE_xz=y
+CONFIG_PACKAGE_xz-utils=y
+CONFIG_PACKAGE_xzdec=y
+CONFIG_PACKAGE_xzdiff=y
+CONFIG_PACKAGE_xzgrep=y
+CONFIG_PACKAGE_xzless=y
+CONFIG_PACKAGE_xzmore=y
+CONFIG_PACKAGE_zlib=y
+CONFIG_PARTED_READLINE=y
+CONFIG_REPRODUCIBLE_DEBUG_INFO=y
+CONFIG_SDK_LLVM_BPF=y
+CONFIG_SQUASHFS_TOOLS_XZ_SUPPORT=y
+CONFIG_SQUASHFS_TOOLS_ZSTD_SUPPORT=y
+CONFIG_TARGET_ALL_PROFILES=y
+CONFIG_TARGET_OPTIONS=y
+CONFIG_USE_LLVM_BUILD=y
+CONFIG_ZSTD_OPTIMIZE_O3=y
+CONFIG_shadow-all=y
+# CONFIG_COLLECT_KERNEL_DEBUG is not set
+# CONFIG_IB is not set
+# CONFIG_MAKE_TOOLCHAIN is not set
+# CONFIG_OPENVPN_openssl_ENABLE_SMALL is not set
+# CONFIG_SDK is not set
diff --git a/.github/workflows/coverity.yml b/.github/workflows/coverityyml
similarity index 100%
rename from .github/workflows/coverity.yml
rename to .github/workflows/coverityyml
diff --git a/.github/workflows/formal.yml b/.github/workflows/formalyml
similarity index 100%
rename from .github/workflows/formal.yml
rename to .github/workflows/formalyml
diff --git a/.github/workflows/github-release.yml b/.github/workflows/github-releaseyml
similarity index 100%
rename from .github/workflows/github-release.yml
rename to .github/workflows/github-releaseyml
diff --git a/.github/workflows/kernel.yml b/.github/workflows/kernelyml
similarity index 100%
rename from .github/workflows/kernel.yml
rename to .github/workflows/kernelyml
diff --git a/.github/workflows/label-kernel.yml b/.github/workflows/label-kernelyml
similarity index 100%
rename from .github/workflows/label-kernel.yml
rename to .github/workflows/label-kernelyml
diff --git a/.github/workflows/label-target.yml b/.github/workflows/label-targetyml
similarity index 100%
rename from .github/workflows/label-target.yml
rename to .github/workflows/label-targetyml
diff --git a/.github/workflows/labeler.yml b/.github/workflows/labeleryml
similarity index 100%
rename from .github/workflows/labeler.yml
rename to .github/workflows/labeleryml
diff --git a/.github/workflows/packages.yml b/.github/workflows/packagesyml
similarity index 100%
rename from .github/workflows/packages.yml
rename to .github/workflows/packagesyml
diff --git a/.github/workflows/push-containers.yml b/.github/workflows/push-containersyml
similarity index 100%
rename from .github/workflows/push-containers.yml
rename to .github/workflows/push-containersyml
diff --git a/.github/workflows/toolchain.yml b/.github/workflows/toolchainyml
similarity index 100%
rename from .github/workflows/toolchain.yml
rename to .github/workflows/toolchainyml
diff --git a/.github/workflows/tools.yml b/.github/workflows/toolsyml
similarity index 100%
rename from .github/workflows/tools.yml
rename to .github/workflows/toolsyml
diff --git a/config/Config-images.in b/config/Config-images.in
index c2d7af7a80..7ed5eb1043 100644
--- a/config/Config-images.in
+++ b/config/Config-images.in
@@ -299,7 +299,7 @@ menu "Target Images"
 	config TARGET_ROOTFS_PARTSIZE
 		int "Root filesystem partition size (in MiB)"
 		depends on USES_ROOTFS_PART || TARGET_ROOTFS_EXT4FS
-		default 104
+		default 1040
 		help
 		  Select the root filesystem partition size.
 
diff --git a/target/linux/bcm27xx/base-files/etc/board.d/02_network b/target/linux/bcm27xx/base-files/etc/board.d/02_network
index 23bc9afdb9..3ab19f12c2 100644
--- a/target/linux/bcm27xx/base-files/etc/board.d/02_network
+++ b/target/linux/bcm27xx/base-files/etc/board.d/02_network
@@ -20,7 +20,7 @@ raspberrypi,4-model-b |\
 raspberrypi,model-b |\
 raspberrypi,model-b-plus |\
 raspberrypi,model-b-rev2)
-	ucidef_set_interface_lan "eth0"
+	ucidef_set_interfaces_lan_wan "eth0 eth2" "eth1"
 	;;
 
 raspberrypi,model-zero-2 |\
-- 
2.40.1


From 822f4c4132b5827ed0b11ba0c8d73e3ab9dca182 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Tue, 16 Jan 2024 20:25:33 -0500
Subject: [PATCH 02/24] CI: build bcm2712 RPi 5B

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 .github/workflows/bcm2712.yaml      |  89 ++++
 .github/workflows/config.buildinfo1 | 691 ++++++++++++++++++++++++++++
 2 files changed, 780 insertions(+)
 create mode 100755 .github/workflows/bcm2712.yaml
 create mode 100644 .github/workflows/config.buildinfo1

diff --git a/.github/workflows/bcm2712.yaml b/.github/workflows/bcm2712.yaml
new file mode 100755
index 0000000000..2c2b82a8e8
--- /dev/null
+++ b/.github/workflows/bcm2712.yaml
@@ -0,0 +1,89 @@
+name: Build bcm2712 RPi 5B
+on: [push]
+
+jobs:
+    build:
+        name: Build Raspberry Pi 5 images
+        runs-on: ubuntu-latest
+
+        steps:
+            - name: Setup Ubuntu
+              run: |
+                sudo apt update
+                sudo apt install -y python3 python3-pip python3-ply python3-distutils python3-pyelftools libpython3-dev swig
+            - name: Maximize build space
+              uses: AdityaGarg8/remove-unwanted-software@v1
+              with:
+                remove-android: 'true'
+                remove-dotnet: 'true'
+            - name: Checkout
+              uses: actions/checkout@v3
+
+            - name: Build
+              run: |
+                ./scripts/feeds update -a
+                ./scripts/feeds install -a
+                cd feeds/luci
+                wget https://gist.githubusercontent.com/mj22226/f6db007367a22a31f9cb1c109a032b45/raw/be368c4f1605f652a001d81548c3a3e14adf6cb7/luci-app-diskman.patch
+                git apply luci-app-diskman.patch
+                cd -
+                cd  feeds/packages
+                wget https://gist.githubusercontent.com/mj22226/351f11e66f08f06e37a985719a31ddb4/raw/b35ba7a3aac1949bd6bbeaad065a0a93dc3c34f0/01-cpu.patch
+                wget https://gist.githubusercontent.com/mj22226/b66f5c1bd5fc7e1cb3cf2c690b5dbd5a/raw/b955e726cbb0948d932c8d6143229ad604320149/20-lxc.patch
+                wget https://patch-diff.githubusercontent.com/raw/openwrt/packages/pull/23113.patch
+                git apply  01-cpu.patch
+                git apply 20-lxc.patch
+                git apply 23113.patch
+                cd -
+                sed -i "70s/'0'/'1'/" feeds/luci/applications/luci-app-statistics/root/etc/config/luci_statistics
+                sed -i "83s/'0'/'1'/" feeds/luci/applications/luci-app-statistics/root/etc/config/luci_statistics
+                sed -i "194s/'0'/'1'/" feeds/luci/applications/luci-app-statistics/root/etc/config/luci_statistics
+                sed -i "211s/'0'/'1'/" feeds/luci/applications/luci-app-statistics/root/etc/config/luci_statistics
+                sed -i "13s/'1'/'0'/" feeds/packages/utils/dockerd/files/etc/config/dockerd
+                sed -i 's/default n/default y/g' feeds/packages/utils/dockerd/Config.in
+                ./scripts/feeds update -a
+                ./scripts/feeds install -a -f
+                cp .github/workflows/config.buildinfo1 .config
+                make defconfig
+                wget https://gist.githubusercontent.com/mj22226/23edc25efeb65ef69d8eb6598f4f8179/raw/29c862e3e2558852523f4e8edd5f3d0cc145067e/01-key.patch
+                git apply 01-key.patch
+                make download -j32
+                rm 01-key.patch
+                sed -i '129d' package/base-files/Makefile
+                sed -i '135d' package/base-files/Makefile
+                mkdir -p files/www/repo
+                wget https://gist.githubusercontent.com/mj22226/681178b344f588b4625a7f83febd9131/raw/73ff0c720a0eefb99fe086ec2d715e0052976df0/03.patch
+                git apply 03.patch
+                make -j$(nproc) 'IGNORE_ERRORS=n m'
+                cp -R bin/targets/bcm27xx/bcm2712/packages/ files/www/repo/
+                make -j$(nproc) 'IGNORE_ERRORS=n m'
+                tar -cvf bcm27xx-images.tar bin/targets/bcm27xx/bcm2712
+
+            - name: Upload artifacts
+              uses: actions/upload-artifact@v3
+              with:
+                name: bcm27xx-images
+                path: bcm27xx-images.tar
+
+    release:
+          name: Make a release
+          runs-on: ubuntu-latest
+          needs: build
+
+          steps:
+            - name: Download the image artifacts
+              uses: actions/download-artifact@v3
+              with:
+                name: bcm27xx-images
+
+            - name: Extract the image artifacts
+              run: tar xf bcm27xx-images.tar
+
+            - name: Create a release
+              uses: "marvinpinto/action-automatic-releases@latest"
+              with:
+                repo_token: "${{ secrets.GITHUB_TOKEN }}"
+                prerelease: true
+                title: "Raspberry Pi 5 Firmware Images"
+                automatic_release_tag: "bcm2712-6.1"
+                files: bin/targets/bcm27xx/bcm2712/*
diff --git a/.github/workflows/config.buildinfo1 b/.github/workflows/config.buildinfo1
new file mode 100644
index 0000000000..4d6237dc2b
--- /dev/null
+++ b/.github/workflows/config.buildinfo1
@@ -0,0 +1,691 @@
+CONFIG_TARGET_bcm27xx=y
+CONFIG_TARGET_bcm27xx_bcm2712=y
+CONFIG_TARGET_MULTI_PROFILE=y
+CONFIG_TARGET_DEVICE_bcm27xx_bcm2712_DEVICE_rpi-5=y
+CONFIG_TARGET_DEVICE_PACKAGES_bcm27xx_bcm2712_DEVICE_rpi-5=""
+CONFIG_ALL_KMODS=y
+CONFIG_ALL_NONSHARED=y
+CONFIG_DEVEL=y
+CONFIG_BUSYBOX_CUSTOM=y
+CONFIG_TARGET_PER_DEVICE_ROOTFS=y
+CONFIG_BPF_TOOLCHAIN_BUILD_LLVM=y
+# CONFIG_BPF_TOOLCHAIN_NONE is not set
+CONFIG_BUILDBOT=y
+CONFIG_BUILD_LOG=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_GETOPT_LONG=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_SEAMLESS_XZ=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_TAR_LONG_OPTIONS=y
+CONFIG_BUSYBOX_CONFIG_GETOPT=y
+CONFIG_BUSYBOX_CONFIG_MOUNTPOINT=y
+CONFIG_BUSYBOX_CONFIG_UNXZ=y
+CONFIG_BUSYBOX_CONFIG_XZ=y
+CONFIG_CGROUPFS_MOUNT_KERNEL_CGROUPS=y
+CONFIG_DOCKER_CGROUP_OPTIONS=y
+CONFIG_DOCKER_CHECK_CONFIG=y
+CONFIG_DOCKER_NET_ENCRYPT=y
+CONFIG_DOCKER_NET_MACVLAN=y
+CONFIG_DOCKER_NET_OVERLAY=y
+CONFIG_DOCKER_NET_TFTP=y
+CONFIG_DOCKER_OPTIONAL_FEATURES=y
+CONFIG_DOCKER_STO_BTRFS=y
+CONFIG_DOCKER_STO_DEVMAPPER=y
+CONFIG_DOCKER_STO_EXT4=y
+CONFIG_GNUTLS_ALPN=y
+CONFIG_GNUTLS_ANON=y
+CONFIG_GNUTLS_DTLS_SRTP=y
+CONFIG_GNUTLS_HEARTBEAT=y
+CONFIG_GNUTLS_OCSP=y
+CONFIG_GNUTLS_PSK=y
+CONFIG_HAS_BPF_TOOLCHAIN=y
+CONFIG_HTOP_LMSENSORS=y
+CONFIG_JSON_CYCLONEDX_SBOM=y
+CONFIG_KERNEL_ARM_PMU=y
+CONFIG_KERNEL_BTRFS_FS_POSIX_ACL=y
+CONFIG_KERNEL_BUILD_DOMAIN="buildhost"
+CONFIG_KERNEL_BUILD_USER="builder"
+CONFIG_KERNEL_CFQ_GROUP_IOSCHED=y
+CONFIG_KERNEL_CGROUP_DEVICE=y
+CONFIG_KERNEL_CGROUP_FREEZER=y
+CONFIG_KERNEL_CGROUP_HUGETLB=y
+CONFIG_KERNEL_CGROUP_NET_PRIO=y
+CONFIG_KERNEL_CGROUP_PERF=y
+CONFIG_KERNEL_EXT4_FS_POSIX_ACL=y
+CONFIG_KERNEL_EXT4_FS_SECURITY=y
+CONFIG_KERNEL_FS_POSIX_ACL=y
+CONFIG_KERNEL_HUGETLBFS=y
+CONFIG_KERNEL_HUGETLB_PAGE=y
+CONFIG_KERNEL_MEMCG_SWAP_ENABLED=y
+CONFIG_KERNEL_NET_CLS_CGROUP=y
+CONFIG_KERNEL_PERF_EVENTS=y
+CONFIG_KERNEL_RPI_AXIPERF=y
+CONFIG_KERNEL_TRANSPARENT_HUGEPAGE=y
+CONFIG_KERNEL_TRANSPARENT_HUGEPAGE_ALWAYS=y
+CONFIG_KERNEL_WERROR=y
+CONFIG_LIBCURL_COOKIES=y
+CONFIG_LIBCURL_FILE=y
+CONFIG_LIBCURL_FTP=y
+CONFIG_LIBCURL_HTTP=y
+CONFIG_LIBCURL_MBEDTLS=y
+CONFIG_LIBCURL_NGHTTP2=y
+CONFIG_LIBCURL_NO_SMB="!"
+CONFIG_LIBCURL_PROXY=y
+CONFIG_LIBCURL_UNIX_SOCKETS=y
+CONFIG_LXC_BUSYBOX_OPTIONS=y
+CONFIG_LXC_KERNEL_OPTIONS=y
+CONFIG_LXC_NETWORKING=y
+CONFIG_LXC_SECCOMP=y
+CONFIG_OPENSSL_ENGINE=y
+CONFIG_OPENSSL_ENGINE_BUILTIN=y
+CONFIG_OPENSSL_ENGINE_BUILTIN_DEVCRYPTO=y
+CONFIG_OPENSSL_OPTIMIZE_SPEED=y
+CONFIG_OPENSSL_WITH_ASM=y
+CONFIG_OPENSSL_WITH_CHACHA_POLY1305=y
+CONFIG_OPENSSL_WITH_CMS=y
+CONFIG_OPENSSL_WITH_DEPRECATED=y
+CONFIG_OPENSSL_WITH_ERROR_MESSAGES=y
+CONFIG_OPENSSL_WITH_IDEA=y
+CONFIG_OPENSSL_WITH_MDC2=y
+CONFIG_OPENSSL_WITH_PSK=y
+CONFIG_OPENSSL_WITH_SEED=y
+CONFIG_OPENSSL_WITH_SRP=y
+CONFIG_OPENSSL_WITH_TLS13=y
+CONFIG_OPENSSL_WITH_WHIRLPOOL=y
+CONFIG_OPENVPN_openssl_ENABLE_FRAGMENT=y
+CONFIG_OPENVPN_openssl_ENABLE_LZ4=y
+CONFIG_OPENVPN_openssl_ENABLE_LZO=y
+CONFIG_OPENVPN_openssl_ENABLE_PORT_SHARE=y
+CONFIG_OPENVPN_openssl_ENABLE_X509_ALT_USERNAME=y
+CONFIG_PACKAGE_TAR_BZIP2=y
+CONFIG_PACKAGE_TAR_GZIP=y
+CONFIG_PACKAGE_TAR_POSIX_ACL=y
+CONFIG_PACKAGE_TAR_XATTR=y
+CONFIG_PACKAGE_TAR_XZ=y
+CONFIG_PACKAGE_TAR_ZSTD=y
+CONFIG_PACKAGE_adb=y
+CONFIG_PACKAGE_adblock=y
+CONFIG_PACKAGE_arp-scan=y
+CONFIG_PACKAGE_arp-scan-database=y
+CONFIG_PACKAGE_atop=y
+CONFIG_PACKAGE_bash=y
+CONFIG_PACKAGE_bcm2712-eeprom=y
+CONFIG_PACKAGE_bcm27xx-eeprom=y
+# CONFIG_PACKAGE_bcm27xx-userland is not set
+CONFIG_PACKAGE_bcm27xx-utils=y
+CONFIG_PACKAGE_blkdiscard=y
+CONFIG_PACKAGE_blkid=y
+CONFIG_PACKAGE_block-mount=y
+CONFIG_PACKAGE_blockd=y
+CONFIG_PACKAGE_blockdev=y
+CONFIG_PACKAGE_bluez-daemon=y
+CONFIG_PACKAGE_bluez-libs=y
+CONFIG_PACKAGE_bluez-tools=y
+CONFIG_PACKAGE_bluez-utils=y
+CONFIG_PACKAGE_bluez-utils-extra=y
+CONFIG_PACKAGE_btop=y
+CONFIG_PACKAGE_btrfs-progs=y
+CONFIG_PACKAGE_bzip2=y
+CONFIG_PACKAGE_ca-certificates=y
+CONFIG_PACKAGE_ccrypt=y
+CONFIG_PACKAGE_certtool=y
+CONFIG_PACKAGE_cfdisk=y
+CONFIG_PACKAGE_cgdisk=y
+CONFIG_PACKAGE_cgi-io=y
+CONFIG_PACKAGE_cgroup-tools=y
+CONFIG_PACKAGE_cgroupfs-mount=y
+CONFIG_PACKAGE_collectd=y
+CONFIG_PACKAGE_collectd-mod-conntrack=y
+CONFIG_PACKAGE_collectd-mod-cpu=y
+CONFIG_PACKAGE_collectd-mod-cpufreq=y
+CONFIG_PACKAGE_collectd-mod-interface=y
+CONFIG_PACKAGE_collectd-mod-irq=y
+CONFIG_PACKAGE_collectd-mod-iwinfo=y
+CONFIG_PACKAGE_collectd-mod-load=y
+CONFIG_PACKAGE_collectd-mod-memory=y
+CONFIG_PACKAGE_collectd-mod-network=y
+CONFIG_PACKAGE_collectd-mod-rrdtool=y
+CONFIG_PACKAGE_collectd-mod-sensors=y
+CONFIG_PACKAGE_collectd-mod-thermal=y
+CONFIG_PACKAGE_containerd=y
+CONFIG_PACKAGE_coreutils=y
+CONFIG_PACKAGE_coreutils-od=y
+CONFIG_PACKAGE_coreutils-sort=y
+CONFIG_PACKAGE_cryptsetup=y
+CONFIG_PACKAGE_cryptsetup-ssh=y
+CONFIG_PACKAGE_dbus=y
+CONFIG_PACKAGE_debugfs=y
+CONFIG_PACKAGE_dnsmasq=m
+CONFIG_PACKAGE_dnsmasq-full=y
+CONFIG_PACKAGE_dnsmasq_full_auth=y
+CONFIG_PACKAGE_dnsmasq_full_conntrack=y
+CONFIG_PACKAGE_dnsmasq_full_dhcp=y
+CONFIG_PACKAGE_dnsmasq_full_dhcpv6=y
+CONFIG_PACKAGE_dnsmasq_full_dnssec=y
+CONFIG_PACKAGE_dnsmasq_full_nftset=y
+CONFIG_PACKAGE_dnsmasq_full_noid=y
+CONFIG_PACKAGE_dnsmasq_full_tftp=y
+CONFIG_PACKAGE_docker=y
+CONFIG_PACKAGE_docker-compose=y
+CONFIG_PACKAGE_dockerd=y
+CONFIG_PACKAGE_dosfstools=y
+CONFIG_PACKAGE_dumpe2fs=y
+CONFIG_PACKAGE_e2freefrag=y
+CONFIG_PACKAGE_e4crypt=y
+CONFIG_PACKAGE_eject=y
+CONFIG_PACKAGE_ethtool-full=y
+CONFIG_PACKAGE_exfat-fsck=y
+CONFIG_PACKAGE_exfat-mkfs=y
+CONFIG_PACKAGE_f2fs-tools=m
+CONFIG_PACKAGE_f2fs-tools-selinux=y
+CONFIG_PACKAGE_f2fsck=m
+CONFIG_PACKAGE_f2fsck-selinux=y
+CONFIG_PACKAGE_fdisk=y
+CONFIG_PACKAGE_findfs=y
+CONFIG_PACKAGE_fixparts=y
+CONFIG_PACKAGE_flock=y
+CONFIG_PACKAGE_fuse-utils=y
+CONFIG_PACKAGE_gdisk=y
+CONFIG_PACKAGE_getopt=y
+CONFIG_PACKAGE_glib2=y
+CONFIG_PACKAGE_gnupg=y
+CONFIG_PACKAGE_gnupg-utils=y
+CONFIG_PACKAGE_gnupg2=y
+CONFIG_PACKAGE_gnupg2-utils=y
+CONFIG_PACKAGE_gzip=y
+CONFIG_PACKAGE_hdparm=y
+CONFIG_PACKAGE_hostapd-common=y
+CONFIG_PACKAGE_htop=y
+CONFIG_PACKAGE_hwclock=y
+CONFIG_PACKAGE_ip-full=y
+CONFIG_PACKAGE_ip6tables-nft=y
+CONFIG_PACKAGE_iperf3-ssl=y
+CONFIG_PACKAGE_ipset=y
+CONFIG_PACKAGE_iptables-mod-extra=y
+CONFIG_PACKAGE_iptables-mod-ipopt=y
+CONFIG_PACKAGE_iptables-nft=y
+CONFIG_PACKAGE_irqbalance=y
+CONFIG_PACKAGE_iw=y
+CONFIG_PACKAGE_iwinfo=y
+CONFIG_PACKAGE_kmod-asn1-decoder=y
+CONFIG_PACKAGE_kmod-asn1-encoder=y
+CONFIG_PACKAGE_kmod-ata-ahci=y
+CONFIG_PACKAGE_kmod-ata-core=y
+CONFIG_PACKAGE_kmod-atm=y
+CONFIG_PACKAGE_kmod-bluetooth=y
+CONFIG_PACKAGE_kmod-br-netfilter=y
+CONFIG_PACKAGE_kmod-cdrom=y
+CONFIG_PACKAGE_kmod-cfg80211=y
+CONFIG_PACKAGE_kmod-crypto-aead=y
+CONFIG_PACKAGE_kmod-crypto-arc4=y
+CONFIG_PACKAGE_kmod-crypto-authenc=y
+CONFIG_PACKAGE_kmod-crypto-cbc=y
+CONFIG_PACKAGE_kmod-crypto-ccm=y
+CONFIG_PACKAGE_kmod-crypto-chacha20poly1305=y
+CONFIG_PACKAGE_kmod-crypto-cmac=y
+CONFIG_PACKAGE_kmod-crypto-crc32=y
+CONFIG_PACKAGE_kmod-crypto-ctr=y
+CONFIG_PACKAGE_kmod-crypto-cts=y
+CONFIG_PACKAGE_kmod-crypto-deflate=y
+CONFIG_PACKAGE_kmod-crypto-des=y
+CONFIG_PACKAGE_kmod-crypto-ecb=y
+CONFIG_PACKAGE_kmod-crypto-ecdh=y
+CONFIG_PACKAGE_kmod-crypto-echainiv=y
+CONFIG_PACKAGE_kmod-crypto-essiv=y
+CONFIG_PACKAGE_kmod-crypto-fcrypt=y
+CONFIG_PACKAGE_kmod-crypto-gcm=y
+CONFIG_PACKAGE_kmod-crypto-gf128=y
+CONFIG_PACKAGE_kmod-crypto-ghash=y
+CONFIG_PACKAGE_kmod-crypto-hmac=y
+CONFIG_PACKAGE_kmod-crypto-kpp=y
+CONFIG_PACKAGE_kmod-crypto-lib-chacha20=y
+CONFIG_PACKAGE_kmod-crypto-lib-chacha20poly1305=y
+CONFIG_PACKAGE_kmod-crypto-lib-curve25519=y
+CONFIG_PACKAGE_kmod-crypto-lib-poly1305=y
+CONFIG_PACKAGE_kmod-crypto-manager=y
+CONFIG_PACKAGE_kmod-crypto-md4=y
+CONFIG_PACKAGE_kmod-crypto-md5=y
+CONFIG_PACKAGE_kmod-crypto-michael-mic=y
+CONFIG_PACKAGE_kmod-crypto-misc=y
+CONFIG_PACKAGE_kmod-crypto-null=y
+CONFIG_PACKAGE_kmod-crypto-pcbc=y
+CONFIG_PACKAGE_kmod-crypto-rmd160=y
+CONFIG_PACKAGE_kmod-crypto-rng=y
+CONFIG_PACKAGE_kmod-crypto-seqiv=y
+CONFIG_PACKAGE_kmod-crypto-sha1=y
+CONFIG_PACKAGE_kmod-crypto-sha256=y
+CONFIG_PACKAGE_kmod-crypto-sha512=y
+CONFIG_PACKAGE_kmod-crypto-test=y
+CONFIG_PACKAGE_kmod-crypto-user=y
+CONFIG_PACKAGE_kmod-crypto-xcbc=y
+CONFIG_PACKAGE_kmod-crypto-xts=y
+CONFIG_PACKAGE_kmod-cryptodev=y
+CONFIG_PACKAGE_kmod-dax=y
+CONFIG_PACKAGE_kmod-dm=y
+CONFIG_PACKAGE_kmod-dummy=y
+CONFIG_PACKAGE_kmod-fs-autofs4=y
+CONFIG_PACKAGE_kmod-fs-btrfs=y
+CONFIG_PACKAGE_kmod-fs-configfs=y
+CONFIG_PACKAGE_kmod-fs-exfat=y
+CONFIG_PACKAGE_kmod-fs-exportfs=y
+CONFIG_PACKAGE_kmod-fs-ext4=y
+CONFIG_PACKAGE_kmod-fs-f2fs=y
+CONFIG_PACKAGE_kmod-fs-hfs=y
+CONFIG_PACKAGE_kmod-fs-hfsplus=y
+CONFIG_PACKAGE_kmod-fs-ksmbd=y
+CONFIG_PACKAGE_kmod-fs-ntfs3=y
+CONFIG_PACKAGE_kmod-fs-smbfs-common=y
+CONFIG_PACKAGE_kmod-fs-squashfs=y
+CONFIG_PACKAGE_kmod-fs-xfs=y
+CONFIG_PACKAGE_kmod-fuse=y
+CONFIG_PACKAGE_kmod-gre=y
+CONFIG_PACKAGE_kmod-hwmon-core=y
+CONFIG_PACKAGE_kmod-i2c-bcm2835=y
+CONFIG_PACKAGE_kmod-i2c-core=y
+CONFIG_PACKAGE_kmod-ifb=y
+CONFIG_PACKAGE_kmod-ikconfig=y
+CONFIG_PACKAGE_kmod-ip6tables=y
+CONFIG_PACKAGE_kmod-ipsec=y
+CONFIG_PACKAGE_kmod-ipt-conntrack=y
+CONFIG_PACKAGE_kmod-ipt-core=y
+CONFIG_PACKAGE_kmod-ipt-extra=y
+CONFIG_PACKAGE_kmod-ipt-ipopt=y
+CONFIG_PACKAGE_kmod-ipt-ipset=y
+CONFIG_PACKAGE_kmod-ipt-nat=y
+CONFIG_PACKAGE_kmod-ipt-nat6=y
+CONFIG_PACKAGE_kmod-ipt-physdev=y
+CONFIG_PACKAGE_kmod-iptunnel=y
+CONFIG_PACKAGE_kmod-keys-encrypted=y
+CONFIG_PACKAGE_kmod-keys-trusted=y
+CONFIG_PACKAGE_kmod-l2tp=y
+CONFIG_PACKAGE_kmod-lib-crc16=y
+CONFIG_PACKAGE_kmod-lib-raid6=y
+CONFIG_PACKAGE_kmod-lib-textsearch=y
+CONFIG_PACKAGE_kmod-lib-xor=y
+CONFIG_PACKAGE_kmod-lib-zlib-deflate=y
+CONFIG_PACKAGE_kmod-lib-zlib-inflate=y
+CONFIG_PACKAGE_kmod-lib-zstd=y
+CONFIG_PACKAGE_kmod-libphy=y
+CONFIG_PACKAGE_kmod-mac80211=y
+CONFIG_PACKAGE_kmod-macvlan=y
+CONFIG_PACKAGE_kmod-md-mod=y
+CONFIG_PACKAGE_kmod-md-raid0=y
+CONFIG_PACKAGE_kmod-md-raid1=y
+CONFIG_PACKAGE_kmod-md-raid10=y
+CONFIG_PACKAGE_kmod-mdio-devres=y
+CONFIG_PACKAGE_kmod-mii=y
+CONFIG_PACKAGE_kmod-mppe=y
+CONFIG_PACKAGE_kmod-mt76-connac=y
+CONFIG_PACKAGE_kmod-mt76-core=y
+CONFIG_PACKAGE_kmod-mt76-usb=y
+CONFIG_PACKAGE_kmod-mt76x02-common=y
+CONFIG_PACKAGE_kmod-mt76x02-usb=y
+CONFIG_PACKAGE_kmod-mt76x2-common=y
+CONFIG_PACKAGE_kmod-mt76x2u=y
+CONFIG_PACKAGE_kmod-mt7921-common=y
+CONFIG_PACKAGE_kmod-mt7921-firmware=y
+CONFIG_PACKAGE_kmod-mt7921u=y
+CONFIG_PACKAGE_kmod-mt792x-common=y
+CONFIG_PACKAGE_kmod-mt792x-usb=y
+CONFIG_PACKAGE_kmod-net-selftests=y
+CONFIG_PACKAGE_kmod-nf-conntrack-netlink=y
+CONFIG_PACKAGE_kmod-nf-ipt=y
+CONFIG_PACKAGE_kmod-nf-ipt6=y
+CONFIG_PACKAGE_kmod-nf-ipvs=y
+CONFIG_PACKAGE_kmod-nf-nat6=y
+CONFIG_PACKAGE_kmod-nf-nathelper=y
+CONFIG_PACKAGE_kmod-nf-nathelper-extra=y
+CONFIG_PACKAGE_kmod-nft-compat=y
+CONFIG_PACKAGE_kmod-nvme=y
+CONFIG_PACKAGE_kmod-oid-registry=y
+CONFIG_PACKAGE_kmod-phy-ax88796b=y
+CONFIG_PACKAGE_kmod-phy-realtek=y
+CONFIG_PACKAGE_kmod-phylink=y
+CONFIG_PACKAGE_kmod-pppoa=y
+CONFIG_PACKAGE_kmod-pppol2tp=y
+CONFIG_PACKAGE_kmod-pptp=y
+CONFIG_PACKAGE_kmod-r8169=y
+CONFIG_PACKAGE_kmod-random-core=y
+CONFIG_PACKAGE_kmod-regmap-core=y
+CONFIG_PACKAGE_kmod-rtl8812au-ac=y
+CONFIG_PACKAGE_kmod-rtw88=y
+CONFIG_PACKAGE_kmod-rtw88-8821c=y
+CONFIG_PACKAGE_kmod-rtw88-8821cu=y
+CONFIG_PACKAGE_kmod-rtw88-8822b=y
+CONFIG_PACKAGE_kmod-rtw88-8822bu=y
+CONFIG_PACKAGE_kmod-rtw88-8822c=y
+CONFIG_PACKAGE_kmod-rtw88-8822cu=y
+CONFIG_PACKAGE_kmod-rtw88-usb=y
+CONFIG_PACKAGE_kmod-sched-bpf=y
+CONFIG_PACKAGE_kmod-sched-cake=y
+CONFIG_PACKAGE_kmod-sched-core=y
+CONFIG_PACKAGE_kmod-scsi-core=y
+CONFIG_PACKAGE_kmod-tpm=y
+CONFIG_PACKAGE_kmod-tun=y
+CONFIG_PACKAGE_kmod-udptunnel4=y
+CONFIG_PACKAGE_kmod-udptunnel6=y
+CONFIG_PACKAGE_kmod-usb-net=y
+CONFIG_PACKAGE_kmod-usb-net-aqc111=y
+CONFIG_PACKAGE_kmod-usb-net-asix=y
+CONFIG_PACKAGE_kmod-usb-net-asix-ax88179=y
+CONFIG_PACKAGE_kmod-usb-net-cdc-ether=y
+CONFIG_PACKAGE_kmod-usb-net-cdc-ncm=y
+CONFIG_PACKAGE_kmod-usb-net-ipheth=y
+CONFIG_PACKAGE_kmod-usb-net-rndis=y
+CONFIG_PACKAGE_kmod-usb-net-rtl8150=y
+CONFIG_PACKAGE_kmod-usb-net-rtl8152=y
+CONFIG_PACKAGE_kmod-usb-ohci=y
+CONFIG_PACKAGE_kmod-usb-storage=y
+CONFIG_PACKAGE_kmod-usb-storage-extras=y
+CONFIG_PACKAGE_kmod-usb-storage-uas=y
+CONFIG_PACKAGE_kmod-usb-wdm=y
+CONFIG_PACKAGE_kmod-veth=y
+CONFIG_PACKAGE_kmod-vxlan=y
+CONFIG_PACKAGE_kmod-wireguard=y
+CONFIG_PACKAGE_ksmbd-server=y
+CONFIG_PACKAGE_libacl=y
+CONFIG_PACKAGE_libaio=y
+CONFIG_PACKAGE_libassuan=y
+CONFIG_PACKAGE_libatomic=y
+CONFIG_PACKAGE_libattr=y
+CONFIG_PACKAGE_libbfd=m
+CONFIG_PACKAGE_libbpf=y
+CONFIG_PACKAGE_libbz2=y
+CONFIG_PACKAGE_libcap=y
+CONFIG_PACKAGE_libcap-ng=y
+CONFIG_PACKAGE_libcgroup=y
+CONFIG_PACKAGE_libctf=m
+CONFIG_PACKAGE_libcurl=y
+CONFIG_PACKAGE_libdbus=y
+CONFIG_PACKAGE_libdevmapper=y
+CONFIG_PACKAGE_libdw=m
+CONFIG_PACKAGE_libelf=y
+CONFIG_PACKAGE_libevdev=y
+CONFIG_PACKAGE_libexpat=y
+CONFIG_PACKAGE_libf2fs=m
+CONFIG_PACKAGE_libf2fs-selinux=y
+CONFIG_PACKAGE_libfdisk=y
+CONFIG_PACKAGE_libfdt=y
+CONFIG_PACKAGE_libffi=y
+CONFIG_PACKAGE_libfuse=y
+CONFIG_PACKAGE_libgcrypt=y
+CONFIG_PACKAGE_libgmp=y
+CONFIG_PACKAGE_libgnutls=y
+CONFIG_PACKAGE_libgpg-error=y
+CONFIG_PACKAGE_libical=y
+CONFIG_PACKAGE_libipset=y
+CONFIG_PACKAGE_libiptext=y
+CONFIG_PACKAGE_libiptext-nft=y
+CONFIG_PACKAGE_libiptext6=y
+CONFIG_PACKAGE_libiwinfo=y
+CONFIG_PACKAGE_libiwinfo-data=y
+CONFIG_PACKAGE_libkmod=y
+CONFIG_PACKAGE_libksba=y
+CONFIG_PACKAGE_libltdl=y
+CONFIG_PACKAGE_liblua=y
+CONFIG_PACKAGE_liblucihttp=y
+CONFIG_PACKAGE_liblucihttp-lua=y
+CONFIG_PACKAGE_liblucihttp-ucode=y
+CONFIG_PACKAGE_liblxc=y
+CONFIG_PACKAGE_liblz4=y
+CONFIG_PACKAGE_liblzma=y
+CONFIG_PACKAGE_liblzo=y
+CONFIG_PACKAGE_libmount=y
+CONFIG_PACKAGE_libncurses=y
+CONFIG_PACKAGE_libnetfilter-conntrack=y
+CONFIG_PACKAGE_libnettle=y
+CONFIG_PACKAGE_libnfnetlink=y
+CONFIG_PACKAGE_libnghttp2=y
+CONFIG_PACKAGE_libnl-core=y
+CONFIG_PACKAGE_libnl-genl=y
+CONFIG_PACKAGE_libnpth=y
+CONFIG_PACKAGE_libopcodes=m
+CONFIG_PACKAGE_libopenssl=y
+CONFIG_PACKAGE_libopenssl-conf=y
+CONFIG_PACKAGE_libparted=y
+CONFIG_PACKAGE_libpcap=y
+CONFIG_PACKAGE_libpci=y
+CONFIG_PACKAGE_libpcre2=y
+CONFIG_PACKAGE_libpopt=y
+CONFIG_PACKAGE_libpython3=y
+CONFIG_PACKAGE_libqrencode=y
+CONFIG_PACKAGE_libreadline=y
+CONFIG_PACKAGE_librrd1=y
+CONFIG_PACKAGE_libseccomp=y
+CONFIG_PACKAGE_libselinux=y
+CONFIG_PACKAGE_libsensors=y
+CONFIG_PACKAGE_libsepol=y
+CONFIG_PACKAGE_libssh=y
+CONFIG_PACKAGE_libstdcpp=y
+CONFIG_PACKAGE_libsysfs=y
+CONFIG_PACKAGE_libtirpc=y
+CONFIG_PACKAGE_libubus-lua=y
+CONFIG_PACKAGE_libudev-zero=y
+CONFIG_PACKAGE_libusb-1.0=y
+CONFIG_PACKAGE_libuv=y
+CONFIG_PACKAGE_libwebsockets-full=y
+CONFIG_PACKAGE_libxdp=m
+CONFIG_PACKAGE_libxtables=y
+CONFIG_PACKAGE_libzstd=y
+CONFIG_PACKAGE_linux-atm=y
+CONFIG_PACKAGE_lm-sensors=y
+CONFIG_PACKAGE_losetup=y
+CONFIG_PACKAGE_lsblk=y
+CONFIG_PACKAGE_lscpu=y
+CONFIG_PACKAGE_lua=y
+CONFIG_PACKAGE_luci=y
+CONFIG_PACKAGE_luci-app-adblock=y
+CONFIG_PACKAGE_luci-app-commands=y
+CONFIG_PACKAGE_luci-app-diskman=y
+CONFIG_PACKAGE_luci-app-diskman_INCLUDE_btrfs_progs=y
+CONFIG_PACKAGE_luci-app-diskman_INCLUDE_lsblk=y
+CONFIG_PACKAGE_luci-app-dockerman=y
+CONFIG_PACKAGE_luci-app-firewall=y
+CONFIG_PACKAGE_luci-app-ksmbd=y
+CONFIG_PACKAGE_luci-app-lxc=y
+CONFIG_PACKAGE_luci-app-nlbwmon=y
+CONFIG_PACKAGE_luci-app-openvpn=y
+CONFIG_PACKAGE_luci-app-opkg=y
+CONFIG_PACKAGE_luci-app-pbr=y
+CONFIG_PACKAGE_luci-app-sqm=y
+CONFIG_PACKAGE_luci-app-statistics=y
+CONFIG_PACKAGE_luci-app-ttyd=y
+CONFIG_PACKAGE_luci-base=y
+CONFIG_PACKAGE_luci-compat=y
+CONFIG_PACKAGE_luci-lib-base=y
+CONFIG_PACKAGE_luci-lib-docker=y
+CONFIG_PACKAGE_luci-lib-ip=y
+CONFIG_PACKAGE_luci-lib-jsonc=y
+CONFIG_PACKAGE_luci-lib-nixio=y
+CONFIG_PACKAGE_luci-light=y
+CONFIG_PACKAGE_luci-lua-runtime=y
+CONFIG_PACKAGE_luci-mod-admin-full=y
+CONFIG_PACKAGE_luci-mod-network=y
+CONFIG_PACKAGE_luci-mod-status=y
+CONFIG_PACKAGE_luci-mod-system=y
+CONFIG_PACKAGE_luci-proto-ipv6=y
+CONFIG_PACKAGE_luci-proto-ppp=y
+CONFIG_PACKAGE_luci-proto-vxlan=y
+CONFIG_PACKAGE_luci-proto-wireguard=y
+CONFIG_PACKAGE_luci-theme-bootstrap=y
+CONFIG_PACKAGE_lvm2=y
+CONFIG_PACKAGE_lxc=y
+CONFIG_PACKAGE_lxc-attach=y
+CONFIG_PACKAGE_lxc-auto=y
+CONFIG_PACKAGE_lxc-autostart=y
+CONFIG_PACKAGE_lxc-cgroup=y
+CONFIG_PACKAGE_lxc-checkconfig=y
+CONFIG_PACKAGE_lxc-common=y
+CONFIG_PACKAGE_lxc-config=y
+CONFIG_PACKAGE_lxc-configs=y
+CONFIG_PACKAGE_lxc-console=y
+CONFIG_PACKAGE_lxc-copy=y
+CONFIG_PACKAGE_lxc-create=y
+CONFIG_PACKAGE_lxc-destroy=y
+CONFIG_PACKAGE_lxc-device=y
+CONFIG_PACKAGE_lxc-execute=y
+CONFIG_PACKAGE_lxc-freeze=y
+CONFIG_PACKAGE_lxc-hooks=y
+CONFIG_PACKAGE_lxc-info=y
+CONFIG_PACKAGE_lxc-init=y
+CONFIG_PACKAGE_lxc-ls=y
+CONFIG_PACKAGE_lxc-monitor=y
+CONFIG_PACKAGE_lxc-monitord=y
+CONFIG_PACKAGE_lxc-snapshot=y
+CONFIG_PACKAGE_lxc-start=y
+CONFIG_PACKAGE_lxc-stop=y
+CONFIG_PACKAGE_lxc-templates=y
+CONFIG_PACKAGE_lxc-top=y
+CONFIG_PACKAGE_lxc-unfreeze=y
+CONFIG_PACKAGE_lxc-unprivileged=y
+CONFIG_PACKAGE_lxc-unshare=y
+CONFIG_PACKAGE_lxc-user-nic=y
+CONFIG_PACKAGE_lxc-usernsexec=y
+CONFIG_PACKAGE_lxc-wait=y
+CONFIG_PACKAGE_lz4=y
+CONFIG_PACKAGE_lzmadec=y
+CONFIG_PACKAGE_lzmainfo=y
+CONFIG_PACKAGE_mdadm=y
+CONFIG_PACKAGE_mkf2fs=m
+CONFIG_PACKAGE_mkf2fs-selinux=y
+CONFIG_PACKAGE_mmc-utils=y
+CONFIG_PACKAGE_mount-utils=y
+CONFIG_PACKAGE_mtools=y
+CONFIG_PACKAGE_musl-fts=y
+CONFIG_PACKAGE_nano=y
+CONFIG_PACKAGE_nfs-utils=y
+CONFIG_PACKAGE_nlbwmon=y
+CONFIG_PACKAGE_objdump=m
+CONFIG_PACKAGE_openssl-util=y
+CONFIG_PACKAGE_openvpn-easy-rsa=y
+CONFIG_PACKAGE_openvpn-openssl=y
+CONFIG_PACKAGE_parted=y
+CONFIG_PACKAGE_pbr=y
+CONFIG_PACKAGE_pciids=y
+CONFIG_PACKAGE_pciutils=y
+CONFIG_PACKAGE_perf=m
+CONFIG_PACKAGE_ppp-mod-passwordfd=y
+CONFIG_PACKAGE_ppp-mod-pppoa=y
+CONFIG_PACKAGE_ppp-mod-pppol2tp=y
+CONFIG_PACKAGE_ppp-mod-pptp=y
+CONFIG_PACKAGE_ppp-mod-radius=y
+CONFIG_PACKAGE_pppdump=y
+CONFIG_PACKAGE_pppoe-discovery=y
+CONFIG_PACKAGE_pptpd=y
+CONFIG_PACKAGE_python3-base=y
+CONFIG_PACKAGE_python3-light=y
+CONFIG_PACKAGE_qosify=y
+CONFIG_PACKAGE_qrencode=y
+CONFIG_PACKAGE_r8152-firmware=y
+CONFIG_PACKAGE_r8169-firmware=y
+CONFIG_PACKAGE_resize2fs=y
+CONFIG_PACKAGE_resolveip=y
+CONFIG_PACKAGE_rpcd=y
+CONFIG_PACKAGE_rpcd-mod-file=y
+CONFIG_PACKAGE_rpcd-mod-iwinfo=y
+CONFIG_PACKAGE_rpcd-mod-luci=y
+CONFIG_PACKAGE_rpcd-mod-lxc=y
+CONFIG_PACKAGE_rpcd-mod-rrdns=y
+CONFIG_PACKAGE_rpcd-mod-ucode=y
+CONFIG_PACKAGE_rrdtool1=y
+CONFIG_PACKAGE_rtl8821ce-firmware=y
+CONFIG_PACKAGE_rtl8822be-firmware=y
+CONFIG_PACKAGE_rtl8822ce-firmware=y
+CONFIG_PACKAGE_runc=y
+CONFIG_PACKAGE_sfdisk=y
+CONFIG_PACKAGE_sgdisk=y
+CONFIG_PACKAGE_shadow=y
+CONFIG_PACKAGE_shadow-chage=y
+CONFIG_PACKAGE_shadow-chfn=y
+CONFIG_PACKAGE_shadow-chgpasswd=y
+CONFIG_PACKAGE_shadow-chpasswd=y
+CONFIG_PACKAGE_shadow-chsh=y
+CONFIG_PACKAGE_shadow-common=y
+CONFIG_PACKAGE_shadow-expiry=y
+CONFIG_PACKAGE_shadow-faillog=y
+CONFIG_PACKAGE_shadow-gpasswd=y
+CONFIG_PACKAGE_shadow-groupadd=y
+CONFIG_PACKAGE_shadow-groupdel=y
+CONFIG_PACKAGE_shadow-groupmems=y
+CONFIG_PACKAGE_shadow-groupmod=y
+CONFIG_PACKAGE_shadow-groups=y
+CONFIG_PACKAGE_shadow-grpck=y
+CONFIG_PACKAGE_shadow-grpconv=y
+CONFIG_PACKAGE_shadow-grpunconv=y
+CONFIG_PACKAGE_shadow-lastlog=y
+CONFIG_PACKAGE_shadow-login=y
+CONFIG_PACKAGE_shadow-logoutd=y
+CONFIG_PACKAGE_shadow-newgidmap=y
+CONFIG_PACKAGE_shadow-newgrp=y
+CONFIG_PACKAGE_shadow-newuidmap=y
+CONFIG_PACKAGE_shadow-newusers=y
+CONFIG_PACKAGE_shadow-nologin=y
+CONFIG_PACKAGE_shadow-passwd=y
+CONFIG_PACKAGE_shadow-pwck=y
+CONFIG_PACKAGE_shadow-pwconv=y
+CONFIG_PACKAGE_shadow-pwunconv=y
+CONFIG_PACKAGE_shadow-su=y
+CONFIG_PACKAGE_shadow-useradd=y
+CONFIG_PACKAGE_shadow-userdel=y
+CONFIG_PACKAGE_shadow-usermod=y
+CONFIG_PACKAGE_shadow-utils=y
+CONFIG_PACKAGE_shadow-vipw=y
+CONFIG_PACKAGE_smartmontools=y
+CONFIG_PACKAGE_smartmontools-drivedb=y
+CONFIG_PACKAGE_sqm-scripts=y
+CONFIG_PACKAGE_sqm-scripts-extra=y
+CONFIG_PACKAGE_squashfs-tools-mksquashfs=y
+CONFIG_PACKAGE_squashfs-tools-unsquashfs=y
+CONFIG_PACKAGE_sysfsutils=y
+CONFIG_PACKAGE_tar=y
+CONFIG_PACKAGE_tc-full=y
+CONFIG_PACKAGE_tc-mod-iptables=y
+CONFIG_PACKAGE_tc-tiny=y
+CONFIG_PACKAGE_tcpdump-mini=y
+CONFIG_PACKAGE_terminfo=y
+CONFIG_PACKAGE_tini=y
+CONFIG_PACKAGE_ttyd=y
+CONFIG_PACKAGE_ucert-full=y
+CONFIG_PACKAGE_ucode-mod-html=y
+CONFIG_PACKAGE_ucode-mod-lua=y
+CONFIG_PACKAGE_ucode-mod-math=y
+CONFIG_PACKAGE_uencrypt-openssl=y
+CONFIG_PACKAGE_uhttpd=y
+CONFIG_PACKAGE_uhttpd-mod-ubus=y
+CONFIG_PACKAGE_usb-modeswitch=y
+CONFIG_PACKAGE_usbutils=y
+CONFIG_PACKAGE_uuidd=y
+CONFIG_PACKAGE_uuidgen=y
+CONFIG_PACKAGE_vsftpd-tls=y
+CONFIG_PACKAGE_vxlan=y
+CONFIG_PACKAGE_wget-ssl=y
+CONFIG_PACKAGE_wireguard-tools=y
+CONFIG_PACKAGE_wireless-regdb=y
+CONFIG_PACKAGE_wireless-tools=y
+CONFIG_PACKAGE_wsdd2=y
+CONFIG_PACKAGE_xdp-filter=m
+CONFIG_PACKAGE_xdp-loader=m
+CONFIG_PACKAGE_xdpdump=m
+CONFIG_PACKAGE_xl2tpd=y
+CONFIG_PACKAGE_xtables-nft=y
+CONFIG_PACKAGE_xz=y
+CONFIG_PACKAGE_xz-utils=y
+CONFIG_PACKAGE_xzdec=y
+CONFIG_PACKAGE_xzdiff=y
+CONFIG_PACKAGE_xzgrep=y
+CONFIG_PACKAGE_xzless=y
+CONFIG_PACKAGE_xzmore=y
+CONFIG_PACKAGE_zlib=y
+CONFIG_PARTED_READLINE=y
+CONFIG_REPRODUCIBLE_DEBUG_INFO=y
+CONFIG_SDK_LLVM_BPF=y
+CONFIG_SQUASHFS_TOOLS_XZ_SUPPORT=y
+CONFIG_SQUASHFS_TOOLS_ZSTD_SUPPORT=y
+CONFIG_TARGET_ALL_PROFILES=y
+CONFIG_TARGET_OPTIONS=y
+CONFIG_USE_LLVM_BUILD=y
+CONFIG_ZSTD_OPTIMIZE_O3=y
+CONFIG_shadow-all=y
+# CONFIG_COLLECT_KERNEL_DEBUG is not set
+# CONFIG_IB is not set
+# CONFIG_MAKE_TOOLCHAIN is not set
+# CONFIG_OPENVPN_openssl_ENABLE_SMALL is not set
+# CONFIG_SDK is not set
-- 
2.40.1


From 77df489cd25e9467cbc9051af414b15eb6108bf6 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Fri, 18 Aug 2023 21:42:50 -0400
Subject: [PATCH 03/24] bcm27xx: auto rezise ext4

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 .../base-files/etc/init.d/resize-rootfs       |  9 +++++
 .../base-files/etc/rc.d/S22resize-rootfs      |  1 +
 .../base-files/usr/bin/resize-rootfs.sh       | 39 +++++++++++++++++++
 3 files changed, 49 insertions(+)
 create mode 100755 target/linux/bcm27xx/base-files/etc/init.d/resize-rootfs
 create mode 100755 target/linux/bcm27xx/base-files/etc/rc.d/S22resize-rootfs
 create mode 100755 target/linux/bcm27xx/base-files/usr/bin/resize-rootfs.sh

diff --git a/target/linux/bcm27xx/base-files/etc/init.d/resize-rootfs b/target/linux/bcm27xx/base-files/etc/init.d/resize-rootfs
new file mode 100755
index 0000000000..740b751499
--- /dev/null
+++ b/target/linux/bcm27xx/base-files/etc/init.d/resize-rootfs
@@ -0,0 +1,9 @@
+#!/bin/sh /etc/rc.common
+
+START=22
+start() {
+	rm -rf /etc/rc.d/S22resize-rootfs
+	#service resize-rootfs disable
+	/usr/bin/resize-rootfs.sh
+}
+
diff --git a/target/linux/bcm27xx/base-files/etc/rc.d/S22resize-rootfs b/target/linux/bcm27xx/base-files/etc/rc.d/S22resize-rootfs
new file mode 100755
index 0000000000..051d001b6c
--- /dev/null
+++ b/target/linux/bcm27xx/base-files/etc/rc.d/S22resize-rootfs
@@ -0,0 +1 @@
+../init.d/resize-rootfs
diff --git a/target/linux/bcm27xx/base-files/usr/bin/resize-rootfs.sh b/target/linux/bcm27xx/base-files/usr/bin/resize-rootfs.sh
new file mode 100755
index 0000000000..170c999ac0
--- /dev/null
+++ b/target/linux/bcm27xx/base-files/usr/bin/resize-rootfs.sh
@@ -0,0 +1,39 @@
+#!/bin/bash
+
+FDISK=$(which fdisk) || { echo "E: You must have fdisk" && exit 1; }
+LOSETUP=$(which losetup) || { echo "E: You must have losetup" && exit 1; }
+roottype=$(findmnt -n -o SOURCE / -o FSTYPE)
+case ${roottype} in
+	overlay)
+		FSCKEXT4=$(which fsck.ext4) || { echo "E: You must have fsck.ext4" && exit 1; }
+		RESIZE2FS=$(which resize2fs) || { echo "E: You must have resize2fs" && exit 1; }
+		rootsource=$(findmnt -n -o SOURCE / | sed 's~\[.*\]~~')		# i.e. /dev/mmcblk0p2
+		rootdevice=${rootsource%p*}				# i.e. /dev/mmcblk0
+		partitions=${rootsource##*p}
+		;;
+	ext4)
+		FSCKEXT4=$(which fsck.ext4) || { echo "E: You must have fsck.ext4" && exit 1; }
+		RESIZE2FS=$(which resize2fs) || { echo "E: You must have resize2fs" && exit 1; }
+		rootsource=$(findmnt -n -o SOURCE / | sed 's~\[.*\]~~')		# i.e. /dev/mmcblk0p2
+		rootdevice=${rootsource%p*}					# i.e. /dev/mmcblk0
+		partitions=${rootsource##*p}
+
+		# Resizing partitions
+		lastsector=$(${FDISK} -l ${rootdevice} |grep "Disk ${rootdevice}" |awk '{print $7}')
+		lastsector=$(( $lastsector - 1 ))
+		startfrom=$(${FDISK} -l ${rootdevice} |grep ${rootsource} |awk '{print $2}')
+		partend=$(${FDISK} -l ${rootdevice} |grep ${rootsource} |awk '{print $3}')
+		[[ $lastsector -eq $partend ]] && exit 0
+		(echo d; echo $partitions; echo n; echo p; echo ; echo $startfrom; echo $lastsector ; echo w;) | fdisk $rootdevice
+
+		# Start resizing filesystem
+		LOOP="$(losetup -f)"
+		${LOSETUP} ${LOOP} ${rootsource}
+		${FSCKEXT4} -y ${LOOP}
+		${RESIZE2FS} ${LOOP}
+		reboot
+		;;
+esac
+
+exit 0
+
-- 
2.40.1


From 2c4b50b7805c2aa47b549b67907d8367c21a9f4f Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Fri, 15 Sep 2023 01:24:29 -0400
Subject: [PATCH 04/24] kernel: add rtl8812au-ac driver

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 package/kernel/rtl8812au-ac/Makefile         |  64 ++++++++
 package/kernel/rtl8812au-ac/patches/01.patch | 145 +++++++++++++++++++
 2 files changed, 209 insertions(+)
 create mode 100644 package/kernel/rtl8812au-ac/Makefile
 create mode 100644 package/kernel/rtl8812au-ac/patches/01.patch

diff --git a/package/kernel/rtl8812au-ac/Makefile b/package/kernel/rtl8812au-ac/Makefile
new file mode 100644
index 0000000000..3faa423a5d
--- /dev/null
+++ b/package/kernel/rtl8812au-ac/Makefile
@@ -0,0 +1,64 @@
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=rtl8812au-ac
+PKG_RELEASE:=1
+
+PKG_LICENSE:=GPLv2
+PKG_LICENSE_FILES:=
+
+PKG_SOURCE_URL:=https://github.com/aircrack-ng/rtl8812au.git
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_DATE:=2023-07-23
+PKG_SOURCE_VERSION:=04f600ee54a414b871aea509fcd4709838c8c522
+PKG_MIRROR_HASH:=df8aa45fb2bc2bc706b8fe49b4b7c4216b64232286845bb7dc231d0be309ccac
+
+# PKG_MAINTAINER:=
+PKG_BUILD_PARALLEL:=1
+
+STAMP_CONFIGURED_DEPENDS := $(STAGING_DIR)/usr/include/mac80211-backport/backport/autoconf.h
+
+include $(INCLUDE_DIR)/kernel.mk
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/rtl8812au-ac
+  SUBMENU:=Wireless Drivers
+  TITLE:=Realtek RTL8812AU/21AU wireless drivers
+  DEPENDS:=+kmod-cfg80211 +kmod-usb-core +@DRIVER_11AC_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/rtl8812au.ko
+  AUTOLOAD:=$(call AutoProbe,rtl8812au)
+  CONFLICTS:=kmod-rtl8812au-ct
+endef
+
+NOSTDINC_FLAGS:= \
+	$(KERNEL_NOSTDINC_FLAGS) \
+	-I$(PKG_BUILD_DIR) \
+	-I$(PKG_BUILD_DIR)/include \
+	-I$(STAGING_DIR)/usr/include/mac80211-backport \
+	-I$(STAGING_DIR)/usr/include/mac80211-backport/uapi \
+	-I$(STAGING_DIR)/usr/include/mac80211 \
+	-I$(STAGING_DIR)/usr/include/mac80211/uapi \
+	-include backport/autoconf.h \
+	-include backport/backport.h
+
+NOSTDINC_FLAGS+= \
+	-DRTW_SINGLE_WIPHY \
+	-DRTW_USE_CFG80211_STA_EVENT \
+	-DCONFIG_IOCTL_CFG80211 \
+	-DBUILD_OPENWRT
+
+ifeq ($(CONFIG_BIG_ENDIAN),y)
+NOSTDINC_FLAGS+= -DCONFIG_BIG_ENDIAN
+else
+NOSTDINC_FLAGS+= -DCONFIG_LITTLE_ENDIAN
+endif
+
+define Build/Compile
+	+$(KERNEL_MAKE) $(PKG_JOBS) \
+		M="$(PKG_BUILD_DIR)" \
+		NOSTDINC_FLAGS="$(NOSTDINC_FLAGS)" \
+		CONFIG_88XXAU=m \
+		USER_MODULE_NAME=rtl8812au \
+		modules
+endef
+
+$(eval $(call KernelPackage,rtl8812au-ac))
diff --git a/package/kernel/rtl8812au-ac/patches/01.patch b/package/kernel/rtl8812au-ac/patches/01.patch
new file mode 100644
index 0000000000..9cd30a061e
--- /dev/null
+++ b/package/kernel/rtl8812au-ac/patches/01.patch
@@ -0,0 +1,145 @@
+--- a/include/drv_types.h
++++ b/include/drv_types.h
+@@ -24,7 +24,7 @@
+ #include <drv_conf.h>
+ #include <basic_types.h>
+ #include <osdep_service.h>
+-#include <rtw_byteorder.h>
++#include <asm/byteorder.h>
+ #include <wlan_bssdef.h>
+ #include <wifi.h>
+ #include <ieee80211.h>
+--- a/os_dep/linux/os_intfs.c
++++ b/os_dep/linux/os_intfs.c
+@@ -1737,7 +1737,7 @@ int rtw_os_ndev_register(_adapter *adapt
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+ 	netif_napi_add_weight(ndev, &adapter->napi, rtw_recv_napi_poll, RTL_NAPI_WEIGHT);
+ #else
+-	netif_napi_add(ndev, &adapter->napi, rtw_recv_napi_poll, RTL_NAPI_WEIGHT);
++	netif_napi_add(ndev, &adapter->napi, rtw_recv_napi_poll);
+ #endif
+ #endif /* CONFIG_RTW_NAPI */
+ 
+@@ -2778,6 +2778,7 @@ static int netdev_vir_if_close(struct ne
+ {
+ 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+ 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
++	struct wireless_dev *wdev = padapter->rtw_wdev;
+ 
+ 	RTW_INFO(FUNC_NDEV_FMT" , bup=%d\n", FUNC_NDEV_ARG(pnetdev), padapter->bup);
+ 	padapter->net_closed = _TRUE;
+@@ -2793,7 +2794,13 @@ static int netdev_vir_if_close(struct ne
+ 
+ #ifdef CONFIG_IOCTL_CFG80211
+ 	wdev->iftype = NL80211_IFTYPE_MONITOR;
++	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0) || defined(BUILD_OPENWRT))
++	wdev->links[0].client.current_bss = NULL;
++	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
++	wdev->connected = NULL;
++	#else
+ 	wdev->current_bss = NULL;
++	#endif
+ 	rtw_scan_abort(padapter);
+ 	rtw_cfg80211_wait_scan_req_empty(padapter, 200);
+ 	adapter_wdev_data(padapter)->bandroid_scan = _FALSE;
+--- a/os_dep/linux/ioctl_cfg80211.c
++++ b/os_dep/linux/ioctl_cfg80211.c
+@@ -460,11 +460,11 @@ u8 rtw_cfg80211_ch_switch_notify(_adapte
+ 
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0))
+ 	if (started) {
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0) || defined(BUILD_OPENWRT))
+ 		cfg80211_ch_switch_started_notify(adapter->pnetdev, &chdef, 0, 0, false, 0);
+-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
++#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) || defined(BUILD_OPENWRT))
+ 		cfg80211_ch_switch_started_notify(adapter->pnetdev, &chdef, 0, 0, false);
+-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)) || (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,0))
++#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0) || defined(BUILD_OPENWRT))
+ 		cfg80211_ch_switch_started_notify(adapter->pnetdev, &chdef, 0, false);
+ #else
+ 		cfg80211_ch_switch_started_notify(adapter->pnetdev, &chdef, 0);
+@@ -476,7 +476,7 @@ u8 rtw_cfg80211_ch_switch_notify(_adapte
+ 	if (!rtw_cfg80211_allow_ch_switch_notify(adapter))
+ 		goto exit;
+ 
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0) || defined(BUILD_OPENWRT))
+ 	cfg80211_ch_switch_notify(adapter->pnetdev, &chdef, 0, 0);
+ #elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5,19, 2))
+ 	cfg80211_ch_switch_notify(adapter->pnetdev, &chdef, 0);
+@@ -1738,7 +1738,7 @@ exit:
+ }
+ 
+ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) || defined(BUILD_OPENWRT))
+ 	, int link_id
+ #endif
+ 	, u8 key_index
+@@ -1885,7 +1885,7 @@ addkey_end:
+ }
+ 
+ static int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) || defined(BUILD_OPENWRT))
+ 	, int link_id
+ #endif
+ 	, u8 keyid
+@@ -2053,7 +2053,7 @@ exit:
+ }
+ 
+ static int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) || defined(BUILD_OPENWRT))
+ 	int link_id,
+ #endif
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE)
+@@ -2077,7 +2077,7 @@ static int cfg80211_rtw_del_key(struct w
+ 
+ static int cfg80211_rtw_set_default_key(struct wiphy *wiphy,
+ 	struct net_device *ndev,
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) || defined(BUILD_OPENWRT))
+ 	int link_id,
+ #endif
+ 	u8 key_index
+@@ -2129,7 +2129,7 @@ static int cfg80211_rtw_set_default_key(
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30))
+ int cfg80211_rtw_set_default_mgmt_key(struct wiphy *wiphy,
+ 	struct net_device *ndev,
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) || defined(BUILD_OPENWRT))
+ 	int link_id,
+ #endif
+ 	u8 key_index)
+@@ -5267,7 +5267,7 @@ static int cfg80211_rtw_change_beacon(st
+ 	return ret;
+ }
+ 
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2) || defined(BUILD_OPENWRT))
+ static int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev, unsigned int link_id)
+ #else
+ static int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
+@@ -6143,7 +6143,7 @@ static int	cfg80211_rtw_set_channel(stru
+ 	return 0;
+ }
+ 
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2) || defined(BUILD_OPENWRT))
+ static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, unsigned int link_id, struct cfg80211_chan_def *chandef){
+ #else
+ static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_chan_def *chandef){
+@@ -10432,9 +10432,9 @@ void rtw_wdev_unregister(struct wireless
+ 	rtw_cfg80211_indicate_scan_done(adapter, _TRUE);
+ 
+ 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)) || defined(COMPAT_KERNEL_RELEASE)
+-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
++	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0) || defined(BUILD_OPENWRT))
+ 	if (wdev->links[0].client.current_bss) {
+-	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2))
++	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 2) || defined(BUILD_OPENWRT))
+ 	if (wdev->connected) {
+ 	#else
+ 	if (wdev->current_bss) {
-- 
2.40.1


From 3869f5e22f00f0b237e0b13966bd689129653a04 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Sat, 28 Jan 2023 23:41:44 -0500
Subject: [PATCH 05/24] iwinfo: add rtl8812/14/21au devices

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 .../patches/0004-add-rtl8812au-devices.patch  | 86 +++++++++++++++++++
 1 file changed, 86 insertions(+)
 create mode 100644 package/network/utils/iwinfo/patches/0004-add-rtl8812au-devices.patch

diff --git a/package/network/utils/iwinfo/patches/0004-add-rtl8812au-devices.patch b/package/network/utils/iwinfo/patches/0004-add-rtl8812au-devices.patch
new file mode 100644
index 0000000000..43feb6412b
--- /dev/null
+++ b/package/network/utils/iwinfo/patches/0004-add-rtl8812au-devices.patch
@@ -0,0 +1,86 @@
+diff --git a/devices.txt b/devices.txt
+index 82d8421..f4408c2 100644
+--- a/devices.txt
++++ b/devices.txt
+@@ -192,6 +192,7 @@
+ 0x14e4 0xaa52 0x14e4 0xaa52    0      0  "Broadcom" "BCM43602"
+ 0x02d0 0xa9a6 0x0000 0x0000    0      0  "Cypress"  "CYW43455"
+ 0x1ae9 0x0310 0x1ae9 0x0000    0      0  "Wilocity" "Wil6210"
++0x02d0 0xa9bf 0x0000 0x0000    0      0  "Broadcom" "BCM43456"
+ 
+ # USB devices
+ # 0x0000 | 0x0000 | vendor id | product id | ...
+@@ -236,7 +237,72 @@
+ # mt7615/usb.c
+ 0x0000 0x0000 0x0e8d 0x7663    0      0  "MediaTek" "MT7663U"
+ 0x0000 0x0000 0x043e 0x310c    0      0  "LG" "LGSBWAC02"
+-
++# RTL8812A
++0x0000 0x0000 0x0409 0x0408    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x0411 0x025D    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x04BB 0x0952    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x050D 0x1106    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x050D 0x1109    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x0586 0x3426    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x0789 0x016E    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x07B8 0x8812    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x0846 0x9051    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x0B05 0x17D2    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x0DF6 0x0074    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x0E66 0x0022    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x1058 0x0632    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x13B1 0x003F    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x148F 0x9097    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x1740 0x0100    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2001 0x330E    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2001 0x3313    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2001 0x3315    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2001 0x3316    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2019 0xAB30    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x20F4 0x805B    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2357 0x0101    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2357 0x0103    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2357 0x010D    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2357 0x010E    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2357 0x010F    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2357 0x0122    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x2604 0x0012    0      0  "Realtek" "RTL8812"
++0x0000 0x0000 0x7392 0xA822    0      0  "Realtek" "RTL8812"
++# RTL8814A
++0x0000 0x0000 0x0B05 0x1817    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x0B05 0x1852    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x0B05 0x1853    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x056E 0x400B    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x056E 0x400D    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x0846 0x9054    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x0E66 0x0026    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x2001 0x331A    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x20F4 0x809A    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x20F4 0x809B    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x2357 0x0106    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x7392 0xA834    0      0  "Realtek" "RTL8814A"
++0x0000 0x0000 0x7392 0xA833    0      0  "Realtek" "RTL8814A"
++# RTL8821A
++0x0000 0x0000 0x0bda 0x0811    0      0  "Realtek" "RTL8821" /* Alfa AWUS036ACS */
++0x0000 0x0000 0x0411 0x0242    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x0411 0x029B    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x04BB 0x0953    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x056E 0x4007    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x056E 0x400E    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x056E 0x400F    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x0846 0x9052    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x0E66 0x0023    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x2001 0x3314    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x2001 0x3318    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x2019 0xAB32    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x2357 0x011E    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x2357 0x011F    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x2357 0x0120    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x3823 0x6249    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x7392 0xA811    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x7392 0xA812    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x7392 0xA813    0      0  "Realtek" "RTL8821"
++0x0000 0x0000 0x7392 0xB611    0      0  "Realtek" "RTL8821"
+ # FDT compatible strings
+ # "compatible" | txpower offset | frequency offset | ...
+ "qca,ar9130-wmac"       0      0  "Atheros"  "AR9130"
-- 
2.40.1


From f7c29d6d1e03130c05f6a12bfeb3f587d33cdcff Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Thu, 23 Feb 2023 19:04:52 -0500
Subject: [PATCH 06/24] linux-firmware: add realtek bluetooth

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 package/firmware/linux-firmware/realtek.mk | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/package/firmware/linux-firmware/realtek.mk b/package/firmware/linux-firmware/realtek.mk
index b4880b6a7f..8329f36f91 100644
--- a/package/firmware/linux-firmware/realtek.mk
+++ b/package/firmware/linux-firmware/realtek.mk
@@ -116,6 +116,16 @@ define Package/rtl8761bu-firmware/install
 endef
 $(eval $(call BuildPackage,rtl8761bu-firmware))
 
+Package/realtek-bluetooth-firmware = $(call Package/firmware-default,RealTek bluetooth firmware)
+define Package/realtek-bluetooth-firmware/install
+	$(INSTALL_DIR) $(1)/lib/firmware/rtl_bt
+	$(CP) \
+		$(PKG_BUILD_DIR)/rtl_bt/* \
+		$(1)/lib/firmware/rtl_bt
+endef
+$(eval $(call BuildPackage,realtek-bluetooth-firmware))
+
+
 Package/rtl8821ae-firmware = $(call Package/firmware-default,RealTek RTL8821AE firmware)
 define Package/rtl8821ae-firmware/install
 	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
-- 
2.40.1


From cb3921a53acb575af9492ceac1ba852d1e6f086a Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Fri, 13 Oct 2023 11:57:15 -0400
Subject: [PATCH 07/24] iwinfo:devices: add device id for TP-Link T3u Plus

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 ...s-add-device-id-for-TP-Link-T3u-Plus.patch | 27 +++++++++++++++++++
 1 file changed, 27 insertions(+)
 create mode 100644 package/network/utils/iwinfo/patches/0006-devices-add-device-id-for-TP-Link-T3u-Plus.patch

diff --git a/package/network/utils/iwinfo/patches/0006-devices-add-device-id-for-TP-Link-T3u-Plus.patch b/package/network/utils/iwinfo/patches/0006-devices-add-device-id-for-TP-Link-T3u-Plus.patch
new file mode 100644
index 0000000000..bc873e5d07
--- /dev/null
+++ b/package/network/utils/iwinfo/patches/0006-devices-add-device-id-for-TP-Link-T3u-Plus.patch
@@ -0,0 +1,27 @@
+From 691245771477ed8ad9b7aa0bcff019b6dec01384 Mon Sep 17 00:00:00 2001
+From: Marty Jones <mj8263788@gmail.com>
+Date: Fri, 13 Oct 2023 11:43:06 -0400
+Subject: [PATCH 4/4] devices: add device id for TP-Link T3u Plus
+
+---
+ devices.txt | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/devices.txt b/devices.txt
+index 0e6f8b6..5c5a5b8 100644
+--- a/devices.txt
++++ b/devices.txt
+@@ -303,6 +303,10 @@
+ 0x0000 0x0000 0x7392 0xA812    0      0  "Realtek" "RTL8821"
+ 0x0000 0x0000 0x7392 0xA813    0      0  "Realtek" "RTL8821"
+ 0x0000 0x0000 0x7392 0xB611    0      0  "Realtek" "RTL8821"
++# RTW88 USB
++0x0000 0x0000 0x2357 0x0138    0      0  "Realtek" "RTW88" /* TP-Link T3u Plus */
++0x0000 0x0000 0x0BDA 0xC811    0      0  "Realtek" "RTW88"
++0x0000 0x0000 0x0BDA 0xC820    0      0  "Realtek" "RTW88"
+ # FDT compatible strings
+ # "compatible" | txpower offset | frequency offset | ...
+ "qca,ar9130-wmac"       0      0  "Atheros"  "AR9130"
+-- 
+2.39.2
+
-- 
2.40.1


From 11f73115adce03e741b366dd7b2a2b732e81bf57 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Sat, 4 Nov 2023 19:51:14 -0400
Subject: [PATCH 08/24] iwinfo: devices: CYW43455: add rpi 5

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 ...ess-CYW43455-variant-found-on-the-Ra.patch | 28 +++++++++++++++++++
 1 file changed, 28 insertions(+)
 create mode 100644 package/network/utils/iwinfo/patches/0007-devices-add-Cypress-CYW43455-variant-found-on-the-Ra.patch

diff --git a/package/network/utils/iwinfo/patches/0007-devices-add-Cypress-CYW43455-variant-found-on-the-Ra.patch b/package/network/utils/iwinfo/patches/0007-devices-add-Cypress-CYW43455-variant-found-on-the-Ra.patch
new file mode 100644
index 0000000000..edb35831f6
--- /dev/null
+++ b/package/network/utils/iwinfo/patches/0007-devices-add-Cypress-CYW43455-variant-found-on-the-Ra.patch
@@ -0,0 +1,28 @@
+From 265ffcf908ac2e842eff8106064b41cad070c242 Mon Sep 17 00:00:00 2001
+From: Marty Jones <mj8263788@gmail.com>
+Date: Sat, 4 Nov 2023 19:42:32 -0400
+Subject: [PATCH] devices: add Cypress CYW43455 variant found on the Raspberry
+ Pi 5
+
+This adds a Cypress CYW43455 variant found on the Raspberry Pi 5 .
+
+Signed-off-by: Marty Jones <mj8263788@gmail.com>
+---
+ devices.txt | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/devices.txt b/devices.txt
+index 3f28446..e1b6215 100644
+--- a/devices.txt
++++ b/devices.txt
+@@ -188,6 +188,7 @@
+ 0x14c3 0x7915 0x14c3 0x7915    0      0  "MediaTek" "MT7915E"
+ 0x14e4 0xaa52 0x14e4 0xaa52    0      0  "Broadcom" "BCM43602"
+ 0x02d0 0xa9a6 0x0000 0x0000    0      0  "Cypress"  "CYW43455"
++0x02d0 0x4345 0x0000 0x0000    0      0  "Cypress"  "CYW43455"
+ 0x1ae9 0x0310 0x1ae9 0x0000    0      0  "Wilocity" "Wil6210"
+ 
+ # USB devices
+-- 
+2.39.2
+
-- 
2.40.1


From 9d1d557571daedd87531797b75b7f20d1b85edd9 Mon Sep 17 00:00:00 2001
From: Florian Fainelli <f.fainelli@gmail.com>
Date: Mon, 25 Jul 2022 13:36:44 -0700
Subject: [PATCH 09/24] kernel: Enable Broadcom BT support

Generate kmod-bluetooth with support for Broadcom chips over HCI UARTs,
required to interface with the Raspberry Pi 4B BT chip.

Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
---
 package/kernel/linux/modules/other.mk | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/package/kernel/linux/modules/other.mk b/package/kernel/linux/modules/other.mk
index face579472..d52cc10f85 100644
--- a/package/kernel/linux/modules/other.mk
+++ b/package/kernel/linux/modules/other.mk
@@ -43,7 +43,7 @@ define KernelPackage/bluetooth
 	CONFIG_BT_HCIBTUSB_MTK=y \
 	CONFIG_BT_HCIBTUSB_RTL=y \
 	CONFIG_BT_HCIUART \
-	CONFIG_BT_HCIUART_BCM=n \
+	CONFIG_BT_HCIUART_BCM=y \
 	CONFIG_BT_HCIUART_INTEL=n \
 	CONFIG_BT_HCIUART_H4 \
 	CONFIG_BT_HCIUART_NOKIA=n \
@@ -58,6 +58,7 @@ define KernelPackage/bluetooth
 	$(LINUX_DIR)/drivers/bluetooth/btusb.ko \
 	$(LINUX_DIR)/drivers/bluetooth/btintel.ko \
 	$(LINUX_DIR)/drivers/bluetooth/btrtl.ko \
+	$(LINUX_DIR)/drivers/bluetooth/btbcm.ko \
 	$(LINUX_DIR)/drivers/bluetooth/btmtk.ko@ge5.17
   AUTOLOAD:=$(call AutoProbe,bluetooth rfcomm bnep hidp hci_uart btusb)
 endef
-- 
2.40.1


From 96ceb996d64e26717d363b178338d7d1983ceb73 Mon Sep 17 00:00:00 2001
From: Florian Fainelli <f.fainelli@gmail.com>
Date: Tue, 26 Jul 2022 11:17:07 -0700
Subject: [PATCH 10/24] bcm2711: Enable CONFIG_SERIAL_DEV_CTRL_TTYPORT

In order for bluetooth chips to be automatically initialized and
attached by the serial bus, enable CONFIG_SERIAL_DEV_CTRL_TTYPORT.

This is necessary for the serial bus to pick up the Bluetooth adapter
and register it automatically with the device model.

Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
---
 target/linux/bcm27xx/bcm2711/config-6.1 | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/target/linux/bcm27xx/bcm2711/config-6.1 b/target/linux/bcm27xx/bcm2711/config-6.1
index 1912b653e5..205e91a8b9 100644
--- a/target/linux/bcm27xx/bcm2711/config-6.1
+++ b/target/linux/bcm27xx/bcm2711/config-6.1
@@ -420,7 +420,7 @@ CONFIG_SERIAL_8250_SHARE_IRQ=y
 CONFIG_SERIAL_AMBA_PL011=y
 CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
 CONFIG_SERIAL_DEV_BUS=y
-# CONFIG_SERIAL_DEV_CTRL_TTYPORT is not set
+CONFIG_SERIAL_DEV_CTRL_TTYPORT=y
 CONFIG_SERIAL_MCTRL_GPIO=y
 CONFIG_SERIAL_OF_PLATFORM=y
 CONFIG_SG_POOL=y
-- 
2.40.1


From 785c48fe25976ff50ca32038666213d23fd5a2a0 Mon Sep 17 00:00:00 2001
From: Florian Fainelli <f.fainelli@gmail.com>
Date: Mon, 1 Aug 2022 10:53:00 -0700
Subject: [PATCH 11/24] LICENSES: Import Broadcom BCM43xx license

Import the license from:

https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/tree/LICENCE.broadcom_bcm43xx

describing the redistribution rules for Broadcom proprietary
firmware(s).

Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
---
 LICENSES/LICENCE.broadcom_bcm43xx | 65 +++++++++++++++++++++++++++++++
 1 file changed, 65 insertions(+)
 create mode 100644 LICENSES/LICENCE.broadcom_bcm43xx

diff --git a/LICENSES/LICENCE.broadcom_bcm43xx b/LICENSES/LICENCE.broadcom_bcm43xx
new file mode 100644
index 0000000000..ff26fdd72f
--- /dev/null
+++ b/LICENSES/LICENCE.broadcom_bcm43xx
@@ -0,0 +1,65 @@
+SOFTWARE LICENSE AGREEMENT
+
+The accompanying software in binary code form (Software), is licensed to you,
+or, if you are accepting on behalf of an entity, the entity and its affiliates
+exercising rights hereunder (Licensee) subject to the terms of this software
+license agreement (Agreement), unless Licensee and Broadcom Corporation
+(Broadcom) execute a separate written software license agreement governing
+use of the Software. ANY USE, REPRODUCTION, OR DISTRIBUTION OF THE SOFTWARE
+CONSTITUTES LICENSEES ACCEPTANCE OF THIS AGREEMENT.
+
+1.	License. Subject to the terms and conditions of this Agreement,
+Broadcom hereby grants to Licensee a limited, non-exclusive, non-transferable,
+royalty-free license: (i) to use and integrate the Software with any other
+software; and (ii) to reproduce and distribute the Software complete,
+unmodified, and as provided by Broadcom, solely for use with Broadcom
+proprietary integrated circuit product(s) sold by Broadcom with which the
+Software was designed to be used, or their successors.
+
+2.	Restrictions. Licensee shall distribute Software with a copy of this
+Agreement. Licensee shall not remove, efface or obscure any copyright or
+trademark notices from the Software. Reproductions of the Broadcom copyright
+notice shall be included with each copy of the Software, except where such
+Software is embedded in a manner not readily accessible to the end user.
+Licensee shall not: (i) use, license, sell or otherwise distribute the Software
+except as provided in this Agreement; (ii) attempt to modify in any way,
+reverse engineer, decompile or disassemble any portion of the Software; or
+(iii) use the Software or other material in violation of any applicable law or
+regulation, including but not limited to any regulatory agency. This Agreement
+shall automatically terminate upon Licensees failure to comply with any of the
+terms of this Agreement. In such event, Licensee will destroy all copies of the
+Software and its component parts.
+
+3.	Ownership. The Software is licensed and not sold.  Title to and
+ownership of the Software, including all intellectual property rights thereto,
+and any portion thereof remain with Broadcom or its licensors. Licensee hereby
+covenants that it will not assert any claim that the Software created by or for
+Broadcom infringe any intellectual property right owned or controlled by
+Licensee.
+
+4.     	Disclaimer. THE SOFTWARE IS OFFERED AS IS, AND BROADCOM PROVIDES AND
+GRANTS AND LICENSEE RECEIVES NO SUPPORT AND NO WARRANTIES OF ANY KIND, EXPRESS
+OR IMPLIED, BY STATUTE, COMMUNICATION OR CONDUCT WITH LICENSEE, OR OTHERWISE.
+BROADCOM SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A SPECIFIC PURPOSE, OR NONINFRINGEMENT CONCERNING THE SOFTWARE OR
+ANY UPGRADES TO OR DOCUMENTATION FOR THE SOFTWARE. WITHOUT LIMITATION OF THE
+ABOVE, BROADCOM GRANTS NO WARRANTY THAT THE SOFTWARE IS ERROR-FREE OR WILL
+OPERATE WITHOUT INTERRUPTION, AND GRANTS NO WARRANTY REGARDING ITS USE OR THE
+RESULTS THEREFROM INCLUDING, WITHOUT LIMITATION, ITS CORRECTNESS, ACCURACY, OR
+RELIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM
+OR ANY OF ITS LICENSORS HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND ON ANY THEORY
+OF LIABILITY, WHETHER FOR BREACH OF CONTRACT, TORT (INCLUDING NEGLIGENCE) OR
+OTHERWISE, ARISING OUT OF THIS AGREEMENT OR USE, REPRODUCTION, OR DISTRIBUTION
+OF THE SOFTWARE, INCLUDING BUT NOT LIMITED TO LOSS OF DATA AND LOSS OF PROFITS,
+EVEN IF SUCH PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. THESE
+LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY
+LIMITED REMEDY.
+
+5. 	Export Laws.  LICENSEE UNDERSTANDS AND AGREES THAT THE SOFTWARE IS
+SUBJECT TO UNITED STATES AND OTHER APPLICABLE EXPORT-RELATED LAWS AND
+REGULATIONS AND THAT LICENSEE MAY NOT EXPORT, RE-EXPORT OR TRANSFER THE
+SOFTWARE OR ANY DIRECT PRODUCT OF THE SOFTWARE EXCEPT AS PERMITTED UNDER THOSE
+LAWS. WITHOUT LIMITING THE FOREGOING, EXPORT, RE-EXPORT, OR TRANSFER OF THE
+SOFTWARE TO CUBA, IRAN, NORTH KOREA, SUDAN, AND SYRIA IS PROHIBITED.
+
-- 
2.40.1


From b43a343567da2b4a9935dc608d0bf5b4e2e4ea4b Mon Sep 17 00:00:00 2001
From: Florian Fainelli <f.fainelli@gmail.com>
Date: Wed, 27 Jul 2022 15:20:52 -0700
Subject: [PATCH 12/24] brcmfmac-sdio-firmware: Add Broadcom Bluetooth
 firmware/patch RAMs

Utilize the LibreELEC brcmfmac_sdio_firmware repository to add support
for the Bluetooth firmware and patch RAM which are necessary for the
Bluetooth adapter to work reliably and operate with the proper MAC
address.

Packages for the two most common BT adapters are created and more can be
added a long the way.

Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
---
 .../firmware/brcmfmac-sdio-firmware/Makefile  | 61 +++++++++++++++++++
 1 file changed, 61 insertions(+)
 create mode 100644 package/firmware/brcmfmac-sdio-firmware/Makefile

diff --git a/package/firmware/brcmfmac-sdio-firmware/Makefile b/package/firmware/brcmfmac-sdio-firmware/Makefile
new file mode 100644
index 0000000000..651ef36e22
--- /dev/null
+++ b/package/firmware/brcmfmac-sdio-firmware/Makefile
@@ -0,0 +1,61 @@
+#
+# Copyright (C) 2019-2020 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=brcmfmac-sdio-firmware
+PKG_SOURCE_DATE:=2022-07-06
+PKG_SOURCE_VERSION:=afc477e807c407736cfaff6a6188d09197dfbceb
+PKG_MIRROR_HASH:=1afabfe429163bd87a03d8305352a8df9a25d59ae6ba600f1955bbd58e17f9a5
+PKG_RELEASE:=1
+
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_URL:=https://github.com/LibreELEC/brcmfmac_sdio-firmware
+
+PKG_MAINTAINER:=Florian Fainelli <f.fainelli@gmail.com>
+PKG_LICENSE:=Proprietary
+PKG_LICENSE_FILES:=LICENCE.broadcom_bcm43xx
+
+include $(INCLUDE_DIR)/package.mk
+
+define Package/brcmfmac-sdio-firmware-default
+  SECTION:=firmware
+  CATEGORY:=Firmware
+  URL:=https://github.com/LibreELEC/brcmfmac_sdio-firmware
+endef
+
+define Build/Compile
+	true
+endef
+
+define Package/brcmfmac-sdio-firmware-43430-bt
+  $(Package/brcmfmac-sdio-firmware-default)
+  TITLE:=CYW43430 BT firmware and patch RAM
+endef
+
+define Package/brcmfmac-sdio-firmware-43430-bt/install
+	$(INSTALL_DIR) $(1)/lib/firmware/brcm
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/BCM43430*.hcd \
+		$(1)/lib/firmware/brcm/
+endef
+
+$(eval $(call BuildPackage,brcmfmac-sdio-firmware-43430-bt))
+
+define Package/brcmfmac-sdio-firmware-4345-bt
+  $(Package/brcmfmac-sdio-firmware-default)
+  TITLE:=CYW4345 BT firmware and patch RAM
+endef
+
+define Package/brcmfmac-sdio-firmware-4345-bt/install
+	$(INSTALL_DIR) $(1)/lib/firmware/brcm
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/BCM4345*.hcd \
+		$(1)/lib/firmware/brcm/
+endef
+
+$(eval $(call BuildPackage,brcmfmac-sdio-firmware-4345-bt))
-- 
2.40.1


From 2834c035a842628b23896d8f2f7caad0c699dcba Mon Sep 17 00:00:00 2001
From: Florian Fainelli <f.fainelli@gmail.com>
Date: Thu, 28 Jul 2022 15:19:20 -0700
Subject: [PATCH 13/24] bcm27xx: Include brcmfmac-sdio-firmware-4345-bt for Pi4
 profiles

Enable brcmfmac-sdio-firmware-4345-bt by default to provide the
appropriate Bluetooth firmware/patch RAM for the Bluetooth controller on
Pi4 and derivatives.

Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
---
 target/linux/bcm27xx/image/Makefile | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/target/linux/bcm27xx/image/Makefile b/target/linux/bcm27xx/image/Makefile
index ad79ac7d0c..cc1ac0c3f5 100644
--- a/target/linux/bcm27xx/image/Makefile
+++ b/target/linux/bcm27xx/image/Makefile
@@ -106,6 +106,7 @@ define Device/rpi-2
 	raspberrypi,400 raspberrypi,4-compute-module raspberrypi,4-model-b \
 	raspberrypi,model-zero-2
   DEVICE_PACKAGES := \
+	brcmfmac-sdio-firmware-4345-bt \
 	cypress-firmware-43430-sdio \
 	brcmfmac-nvram-43430-sdio \
 	cypress-firmware-43455-sdio \
@@ -160,6 +161,7 @@ define Device/rpi-4
 	raspberrypi,4-compute-module \
 	raspberrypi,4-model-b
   DEVICE_PACKAGES := \
+	brcmfmac-sdio-firmware-4345-bt \
 	cypress-firmware-43455-sdio \
 	brcmfmac-nvram-43455-sdio \
 	kmod-brcmfmac wpad-basic-mbedtls \
-- 
2.40.1


From e422a23ef65585f4118afe30a43cb45ef23d4af8 Mon Sep 17 00:00:00 2001
From: Florian Fainelli <f.fainelli@gmail.com>
Date: Tue, 26 Jul 2022 11:18:08 -0700
Subject: [PATCH 14/24] bcm27xx: Enable Bluetooth adapter for the Raspberry Pi
 4B

Configure the mini-UART (ttyS0) to be the main console and allow the
PL011 UART to be used for Bluetooth. Since we already set arm_boost=1
this should have no adverse affect.

Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
---
 target/linux/bcm27xx/image/distroconfig.txt | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/target/linux/bcm27xx/image/distroconfig.txt b/target/linux/bcm27xx/image/distroconfig.txt
index 103c5d2e82..7a2140a70d 100644
--- a/target/linux/bcm27xx/image/distroconfig.txt
+++ b/target/linux/bcm27xx/image/distroconfig.txt
@@ -12,5 +12,9 @@ dtoverlay=disable-bt
 dtoverlay=disable-bt
 [pi4]
 dtoverlay=disable-bt
+# Enable the Mini UART (ttyS0) as the console
+# enable_uart=1
+# Enable Bluetooth over the PL011 (ttyAMA0) using the serial bus (serdev)
+# dtparam=krnbt=on
 # Run as fast as firmware / board allows
 arm_boost=1
-- 
2.40.1


From 6ddb0b9cfcbd154c90d096e726d14d8d568d2e91 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Sat, 13 Jan 2024 16:47:21 -0500
Subject: [PATCH 15/24] bcm27xx: update 6.1 patches to latest version

Add support for BCM2712, Raspberry Pi 5
https://github.com/raspberrypi/linux/commit/5e339e1502c9be0f624398cf774e5880a6d1a677
Patches were generated from the diff between linux kernel branch linux-6.1.y
and rpi-6.1.y from raspberry pi kernel source:
- git format-patch linux-6.1.y...rpi-6.1.y

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 ...-fix-binning-and-rate_factor-for-480.patch |  306 +
 ...7xx-Read-modem-line-state-at-startup.patch |   28 +
 ...m2835_unicam-Improve-frame-sequence-.patch |   79 +
 ...itft-28-35-overlays-for-6.1-driver-c.patch |   41 +
 ...-imx477-Re-enable-temperature-sensor.patch |   23 +
 ...lo-katana-dac-audio-Reduce-I2C-clock.patch |   25 +
 ...ys-jedec-spi-nor-Add-speed-parameter.patch |  308 +
 ...-constraints-for-E-AC3-DTS-HD-and-ML.patch |  137 +
 ...fix-channel-info-for-compressed-form.patch |   86 +
 ...m_64mp-Modify-the-line-length-of-128.patch |   44 +
 ...rducam_64mp-Add-8000x6000-resolution.patch |  105 +
 ...ia-i2c-arducam_64mp-Add-PDAF-support.patch |  163 +
 ...remap-Document-CM4-40-41-restriction.patch |   24 +
 ...ow-mac-address-to-be-set-in-smsc95xx.patch |  120 +
 ...hip-debian-certificates-as-hex-files.patch | 1455 ++++
 ...t-for-all-the-downstream-rpi-sound-c.patch |  329 +
 ...62-Set-the-pre_enable_upstream_first.patch |   21 +
 ...-cards-Fix-Codec-Zero-rate-switching.patch |   48 +
 ...trickle-voltage-mv-parameter-to-RTCs.patch |   68 +
 ...mx296-Add-standby-delay-during-probe.patch |   25 +
 ...ays-Add-bmp380-to-i2c-sensor-overlay.patch |   78 +
 ...odule-parameter-for-maximum-pdu-size.patch |  162 +
 ...x296-Updated-imx296-driver-for-exter.patch |   40 +
 ...s-imx258-Fix-alternate-compatible-st.patch |   26 +
 ...-vc_mem-Fix-preprocessor-conditional.patch |   21 +
 ...ers-dwc_otg-Fix-fallthrough-warnings.patch |   32 +
 ...-sm-cma-Switch-one-bit-bitfields-to-.patch |   61 +
 ...311-Fix-uninitialized-variable-usage.patch |   21 +
 ...fault-values-for-Waveshare-7.9-inch-.patch |   29 +
 ...2c-bus-overrides-to-edt-ft5406-overl.patch |  102 +
 ...overlays-Fix-README-text-for-i2c-fan.patch |   25 +
 ...-irqchip-irq-bcm2835-Concurrency-fix.patch |   50 +
 ...s-Add-drm-option-to-piscreen-overlay.patch |   58 +
 ...Resolve-clash-in-spi_device_id-names.patch |   36 +
 ...46-Add-missing-spi_device_id-strings.patch |   50 +
 ...codec-Downgrade-the-level-for-a-debu.patch |   27 +
 ...-functions-into-a-more-logical-order.patch |  286 +
 ...ework-the-atomic-vs-non-atomic-split.patch |  192 +
 ...d-NULL-pointer-dereference-in-f2fs_i.patch |   63 +
 ...dec-Fix-broken-channel-map-reporting.patch |   47 +
 ...rng-iproc-rng200-Add-BCM2838-support.patch |  142 +
 ...rng-iproc-rng200-Add-BCM2838-support.patch |  161 +
 ...t-for-100ms-following-PERST-deassert.patch |   39 +
 ...ion-to-report-basic-audio-support-wi.patch |  128 +
 ...Add-option-to-report-basic-audio-sup.patch |  119 +
 ...0-0850-overlays-Add-a-sample-hat_map.patch |   47 +
 ...-usb-phy-generic-Get-the-vbus-supply.patch |   26 +
 ...0853-dts-2712-Update-for-device-tree.patch | 7672 +++++++++++++++++
 ...0854-bcm2708_fb-Hack-out-dma-support.patch |   37 +
 ...mstb-Allow-to-build-for-ARCH_BCM2835.patch |  282 +
 ...-Allow-RESET_BRCMSTB-on-ARCH_BCM2835.patch |   20 +
 ...nctrl-bcm2712-pinctrl-pinconf-driver.patch | 1324 +++
 ...c4-fkms-Remove-use-of-SMI-peripheral.patch |   76 +
 ...-mmc-brcmstb-add-support-for-BCM2712.patch |  498 ++
 .../950-0860-sdhci-Add-SD-Express-hook.patch  |   90 +
 ...river-though-not-yet-the-Makesfiles-.patch | 3788 ++++++++
 ...q-bcm2712-mip-Support-for-2712-s-MIP.patch |  386 +
 ...et-brcmstb-rescal-Support-shared-use.patch |   47 +
 ...-net-macb-Also-set-DMA-coherent-mask.patch |  418 +
 ...wc3-Set-DMA-and-coherent-masks-early.patch |  384 +
 ...rrypi-touchscreen-Insert-more-delays.patch |   37 +
 ...0867-PCI-brcmstb-Add-BCM2712-support.patch | 1108 +++
 ...V4L2-Add-PiSP-opaque-formats-to-V4L2.patch |   42 +
 ...-Add-PiSP-compressed-formats-to-V4L2.patch |   39 +
 ...0-bcm2708_fb-Fix-more-build-warnings.patch |   43 +
 ...mfd-Add-binding-for-Raspberry-Pi-RP1.patch |  249 +
 .../950-0872-mfd-Add-rp1-driver.patch         |  442 +
 ...ck-Add-bindings-for-Raspberry-Pi-RP1.patch |   65 +
 .../950-0874-clk-Add-rp1-clock-driver.patch   | 2208 +++++
 ...trl-Add-bindings-for-Raspberry-Pi-RP.patch |   60 +
 .../950-0876-pinctrl-Add-rp1-driver.patch     | 1666 ++++
 ...0-0877-serial-pl011-rp1-uart-support.patch |  129 +
 ...f-dwcmshc-define-sdio-timeout-clocks.patch |   83 +
 ...mc-sdhci-of-dwcmshc-rp1-sdio-changes.patch |   83 +
 ...950-0880-clk-rp1-Add-sdio-clk-driver.patch |  641 ++
 ...ware-Add-SMBUS-quick-command-support.patch |   76 +
 ...-dmaengine-dw-axi-dmac-Fixes-for-RP1.patch |  355 +
 ...w-Handle-combined-tx-and-rx-messages.patch |   64 +
 ...950-0884-pwm-Add-support-for-RP1-PWM.patch |  292 +
 .../950-0885-drm-Add-RP1-DSI-driver.patch     | 2678 ++++++
 .../950-0886-drm-Add-RP1-DPI-driver.patch     | 1552 ++++
 .../950-0887-drm-Add-RP1-VEC-driver.patch     | 3078 +++++++
 ...p-compression-format-support-to-v4l2.patch |   75 +
 ...rp1-Add-CFE-Camera-Front-End-support.patch | 4527 ++++++++++
 ...-net-cdns-macb-AXI-tuning-properties.patch |   38 +
 ...-dwc-list-all-supported-sample-sizes.patch |   29 +
 ...0892-ASoC-dwc-Support-set_bclk_ratio.patch |   59 +
 ...950-0893-ASoC-dwc-Add-DMACR-handling.patch |   81 +
 ...0-0894-ASOC-dwc-Improve-DMA-shutdown.patch |  128 +
 ...5-ASOC-dwc-Fix-16-bit-audio-handling.patch |   88 +
 ...bcm-Remove-dependency-on-BCM2835-I2S.patch |  304 +
 ...n-Add-RP1-ADC-and-temperature-driver.patch |  343 +
 ...d-bcm2835-pm-Add-support-for-BCM2712.patch |   69 +
 ...cm2835-power-Add-support-for-BCM2712.patch |   76 +
 ...spi-gpio-to-correctly-implement-sck-.patch |  150 +
 ...lement-spidelay-when-requested-bit-r.patch |   55 +
 ...ix-up-register-addresses-for-V3D-7.x.patch |  672 ++
 ...UAPI-to-match-user-space-for-V3D-7.x.patch |   24 +
 ...-2712-v3d-as-a-compatible-V3D-device.patch |   19 +
 ...Improve-MMU-support-for-larger-pages.patch |   64 +
 ...v3d-Add-BCM2712-to-compatibility-lis.patch |   19 +
 ...vers-char-add-generic-gpiomem-driver.patch |  328 +
 ...-drivers-char-delete-bcm2835-gpiomem.patch |  301 +
 ...1-adc-check-conversion-validity-befo.patch |   34 +
 ...maengine-bcm2835-Add-BCM2712-support.patch |   36 +
 ...m2835-HACK-Support-DMA-Lite-channels.patch |   57 +
 .../950-0913-clk-bcm-rpi-Add-disp-clock.patch |   46 +
 ...-optionally-enable-link-down-powersa.patch |   26 +
 ...5-Rename-to_bcm2711_cbaddr-to-to_40b.patch |   75 +
 ...cm2835-Fix-dma-driver-for-BCM2835-38.patch |   77 +
 ...0917-drivers-iommu-Add-BCM2712-IOMMU.patch |  855 ++
 ...stb-l2-Add-config-for-2711-controlle.patch |   73 +
 ...d-simple-RTC-driver-for-Raspberry-Pi.patch |  237 +
 ...new-binding-for-Raspberry-Pi-RTC-dri.patch |   35 +
 ...m-fan-Add-fan-speed-register-support.patch |  164 +
 ...-Add-2ms-delay-after-releasing-stand.patch |   23 +
 ...t-Add-bindings-for-raspberrypi-butto.patch |   63 +
 ...t-Add-bindings-for-raspberrypi-butto.patch |   27 +
 ...d-raspberrypi-button-firmware-driver.patch |  197 +
 ...6-dt-bindings-update-rpi-rtc-binding.patch |   29 +
 ...add-battery-charge-circuit-control-a.patch |  153 +
 ...-Avoid-panic-when-booted-with-no-kms.patch |   29 +
 ...ero-sized-destination-as-full-screen.patch |   28 +
 ...-for-when-the-YUV-chroma-planes-are-.patch |   50 +
 ...-drm-vc4-hdmi-Enable-the-audio-clock.patch |   39 +
 ...n-if-writing-to-an-unknown-HDMI-regi.patch |   31 +
 ...vs-More-logging-for-dlist-generation.patch |   41 +
 ...Print-error-if-we-fail-an-allocation.patch |   66 +
 ...dd-more-debugging-for-LBM-allocation.patch |   36 +
 ...-Use-return-variable-in-atomic_check.patch |   31 +
 ...-Move-assigned_channel-to-a-variable.patch |   47 +
 ...vc4-Introduce-generation-number-enum.patch | 1029 +++
 ...-paths-unavailable-on-any-generation.patch |  577 ++
 ...switch-statement-to-simplify-vc4_hvs.patch |  125 +
 ...switch-statement-to-simplify-enablin.patch |   74 +
 ...st-if-the-EOF-interrupts-are-enabled.patch |  100 +
 ...-drm-vc4-hvs-Create-hw_init-function.patch |  188 +
 ...drm-vc4-hvs-Create-cob_init-function.patch |  167 +
 ...945-drm-vc4-hvs-Rename-hvs_regs-list.patch |   38 +
 ...plane-Change-ptr0_offset-to-an-array.patch |  103 +
 ...947-drm-vc4-hvs-Rework-LBM-alignment.patch |   45 +
 ...ge-prototype-of-__vc4_hvs_alloc-to-p.patch |   93 +
 ...s-vertical-scaling-must-always-be-en.patch |   30 +
 ...id-hang-with-debug-registers-when-su.patch |   39 +
 ...-buffer-offset-out-of-the-vc4_plane_.patch |  154 +
 ...t-debug-not-resetting-the-next-entry.patch |   33 +
 ...ncorrect-limit-from-hvs_dlist-debugf.patch |   57 +
 ...m-vc4-hvs-Remove-ABORT_ON_EMPTY-flag.patch |   50 +
 ...ble-SCALER_CONTROL-early-in-HVS-init.patch |   59 +
 ...gs-display-Add-BCM2712-HDMI-bindings.patch |   26 +
 ...ngs-display-Add-BCM2712-HVS-bindings.patch |   34 +
 ...play-Add-BCM2712-PixelValve-bindings.patch |   28 +
 ...ngs-display-Add-BCM2712-MOP-bindings.patch |   28 +
 ...-display-Add-BCM2712-MOPLET-bindings.patch |   25 +
 ...play-Add-BCM2712-KMS-driver-bindings.patch |   23 +
 ...950-0962-drm-vc4-drv-Support-BCM2712.patch |   47 +
 ...0963-drm-vc4-hvs-Support-BCM2712-HVS.patch | 2139 +++++
 ...-Add-support-for-BCM2712-PixelValves.patch |  144 +
 ...-support-for-BCM2712-HDMI-controller.patch | 1057 +++
 ...oduce-structure-to-deal-with-revisio.patch |  117 +
 ...rm-vc4-txp-Rename-TXP-data-structure.patch |   66 +
 ...m-vc4-txp-Add-byte-enable-toggle-bit.patch |   56 +
 ...horizontal-and-vertical-size-offset-.patch |   59 +
 ...vc4-txp-Handle-40-bits-DMA-Addresses.patch |   59 +
 ...-the-encoder-type-in-the-variant-str.patch |   44 +
 ...m-vc4-txp-Add-a-new-TXP-encoder-type.patch |  475 +
 ...-vc4-txp-Add-support-for-BCM2712-MOP.patch |   64 +
 ...m-vc4-txp-Add-BCM2712-MOPLET-support.patch |   42 +
 ...-0975-drm-vc4-Add-additional-warn_on.patch |  240 +
 ...Switch-generation-mockup-to-a-switch.patch |   47 +
 ...op-drm-parameter-for-vc4_find_crtc_f.patch |   63 +
 ...c4-tests-Return-the-allocated-output.patch |  174 +
 ...rm-vc4-tests-Add-BCM2712-mock-driver.patch |   87 +
 ...d-tests-for-BCM2712-PixelValve-Muxin.patch |  138 +
 ...-fkms-Rename-plane-related-functions.patch |   64 +
 ...ests-Use-custom-plane-state-for-mock.patch |   95 +
 ...d-function-to-lookup-a-plane-for-a-C.patch |   36 +
 ...d-helper-to-add-a-new-plane-to-a-sta.patch |   62 +
 ...sts-Support-a-few-more-plane-formats.patch |   26 +
 ...Introduce-a-test-for-LBM-buffer-size.patch |  358 +
 ...d-setting-core-and-disp-clocks-for-h.patch |   40 +
 ...ssign-LBM-memory-during-atomic_flush.patch |  240 +
 ...-Alter-the-timing-for-the-Pi-7-DSI-d.patch |   33 +
 ...eshare-Fix-up-timings-for-10.1-panel.patch |   33 +
 ...-Fix-locking-in-imx477_init_controls.patch |   34 +
 ...-0994-overlays-Fix-vc4-kms-dsi-7inch.patch |   57 +
 ...-codec-Fix-broken-channel-map-report.patch |   21 +
 ...dec-Fix-broken-channel-map-reporting.patch |   56 +
 ...fe-Fix-use-of-freed-memory-on-errors.patch |   48 +
 ...ix-width-height-in-cfe_start_channel.patch |   88 +
 ...edia-rp1-csi2-Fix-missing-reg-writes.patch |   36 +
 ...-0-not-1-when-working-with-unsigned-.patch |   33 +
 ...edia-rp1-cfe-Fix-verbose-debug-print.patch |   26 +
 ...ename-xxx_dbg_irq-to-xxx_dbg_verbose.patch |  227 +
 ...-rp1-Add-back-reg-write-debug-prints.patch |   41 +
 ...e-Add-verbose-debug-module-parameter.patch |   23 +
 ...05-media-rp1-csi2-Track-CSI-2-errors.patch |  245 +
 ...1006-media-rp1-cfe-Drop-unused-field.patch |   31 +
 ...1-csi2-Set-values-for-enum-csi2_mode.patch |   30 +
 ...8-media-rp1-fe-Fix-default-mbus-code.patch |   27 +
 ...-cfe-Fix-default-meta-format-s-field.patch |   25 +
 ...il-streaming-if-FE_CONFIG-node-is-no.patch |   31 +
 ...config-entry-for-IMX477-to-the-camer.patch |   51 +
 ...alias-for-the-displays-to-use-as-the.patch |  109 +
 ...dt-Add-DSI1-and-DSI2-aliases-to-2712.patch |   24 +
 ...e-the-clear-of-SCALER_DISPBKGND_FILL.patch |   64 +
 ...rcmstb-Use-dynamic-GPIO-base-numbers.patch |  117 +
 ...-rpivid-Allow-use-of-iommu-in-rpivid.patch |   57 +
 ...1019-dts-bcm2712-Add-iommu-to-rpivid.patch |   22 +
 ...1_cfe-Remove-PISP-specific-MBUS-form.patch |  117 +
 ...m2835-codec-Correct-alignment-requir.patch |   53 +
 ...n-edt-ft5x06-Suppress-bogus-data-on-.patch |   96 +
 ...t-bcm2708_fb-Fix-more-build-warnings.patch |   44 +
 ...vert-bcm2708_fb-Hack-out-dma-support.patch |   38 +
 ...7-allow-specification-of-the-i2c-bus.patch |   97 +
 ...-Set-default-I2C-baudrates-to-100kHz.patch |   46 +
 ...e-DMA-memcpy-support-from-bcm2708_fb.patch |  345 +
 ...address-offset-for-planes-with-src_-.patch |   48 +
 ...1_cfe-Fix-link-validate-test-for-pix.patch |   69 +
 ...4-dts-bcm2712-Use-the-new-model-name.patch |   23 +
 ...nt-to-request-a-particular-dev-fbN-n.patch |   93 +
 ...ok-up-preferred-fbdev-node-number-fr.patch |   41 +
 ...-for-drm-framebuffer-allocations-on-.patch |   72 +
 ...ange-DRM-card-alias-from-underscore-.patch |   26 +
 ...r-alias-names-from-_-to-for-drm_dsiN.patch |   24 +
 ...ange-query-for-FB-designation-from-d.patch |   28 +
 ...ames-from-_-to-for-drm_fbN_-override.patch |   43 +
 .../950-1044-Typo-in-overlays-README.patch    |   21 +
 ...-dts-bcm2712-Add-the-krnbt-parameter.patch |   23 +
 ...c4-fkms-Remove-use-of-SMI-peripheral.patch |   77 +
 ...-up-interrupt-handler-for-both-2835-.patch |  109 +
 ...2-firmware-kms-node-to-using-the-271.patch |   25 +
 ...vers-media-imx477-Disable-the-scaler.patch |   35 +
 ...-Add-drm_fbN_vc4-overrides-for-Pi0-4.patch |   37 +
 ...cp23017-allow-specification-of-the-i.patch |   95 +
 ...sp_be-Add-back-V4L2_PIX_FMT_RPI_BE-f.patch |   54 +
 ...brcmstb-add-optional-property-brcm-t.patch |   32 +
 ...stb-optionally-extend-Tperst_clk-tim.patch |   71 +
 ...arams-for-PCIe-reset-timing-override.patch |   59 +
 ...on-t-unconditionally-enable-MPS-read.patch |   35 +
 ...x477-Set-horizontal-binning-when-dis.patch |   39 +
 ...-Add-Revision-Serial-Model-to-cpuinf.patch |   25 +
 ...0-rpi-zero-2-w-Remove-WLAN-firmwares.patch |   35 +
 ...e-Set-the-CSI-2-link-frequency-corre.patch |  111 +
 ...2712-rpi-5-b-Create-some-dummy-nodes.patch |   42 +
 ...-rp1-Add-spi6-fix-spi1-address-cells.patch |   49 +
 ...art-n-pi5-Add-the-pinctrl-0-property.patch |   67 +
 ...mx477-Add-V4L2_CID_LINK_FREQ-control.patch |   51 +
 ...x477-Correctly-set-IMX477_PIXEL_RATE.patch |   24 +
 ...ect-logic-on-stopping-an-HVS-channel.patch |   52 +
 ...p-WARN-for-HVS-FIFOs-not-being-empty.patch |   30 +
 ...-stale-dlists-if-channel-is-disabled.patch |   85 +
 ...dd-hvs_dlist_allocs-debugfs-function.patch |   64 +
 ...size-of-the-dlist-allocation-that-wa.patch |   23 +
 ...port-odd-horizontal-timings-on-BCM27.patch |  104 +
 ...t-the-last-DMA-scoop-out-of-the-FIFO.patch |   41 +
 ...mc-sdhci-add-SPURIOUS_INT_RESP-quirk.patch |   62 +
 ...sdhci-of-dwcmhsc-Add-Raspberry-Pi-RP.patch |   42 +
 ...i-of-dwcmshc-add-RP1-dt-ID-and-quirk.patch |   41 +
 ...P1-SDHCI-controller-compatible-strin.patch |  104 +
 ...dioinjector_octo-Add-soundcard-owner.patch |   22 +
 ...x708-Adjust-broken-line-correction-p.patch |  139 +
 ...-imx296-Add-2ms-delay-after-releasin.patch |   24 +
 ...media-cfe-Don-t-confuse-MHz-and-Mbps.patch |   96 +
 ...Fix-cam-port-override-for-regulators.patch |   25 +
 ...v5647-Regularise-vcm-node-label-name.patch |   32 +
 ...ov5647-cam0-mode-should-use-cam0_reg.patch |   27 +
 .../950-1150-w1-Disable-kernel-log-spam.patch |   25 +
 ...s-Add-a-media-bus-format-enum-for-16.patch |   21 +
 ...2-Add-additional-pixel-formats-for-u.patch |   73 +
 ...e-Add-16-bit-and-compressed-mono-for.patch |   52 +
 ...sp_be-Add-mono-and-48-bit-RGB-pixel-.patch |   72 +
 ...ove-check-in-set_bclk_ratio-handling.patch |   32 +
 ...lays-README-Fix-cut-and-paste-errors.patch |   39 +
 ...-Switch-from-V4L2_CID_GAIN-to-V4L2_C.patch |   38 +
 ...lanes-that-are-completely-off-screen.patch |   63 +
 ...play-connector-Select-DRM_KMS_HELPER.patch |   29 +
 ...-dlist-alloc-immediately-if-it-never.patch |   56 +
 ...-Include-I2C-details-in-names-for-th.patch |   48 +
 ...lude-I2C-details-in-names-for-the-de.patch |   52 +
 ...iotlb-bounce-buffers-being-imported-.patch |   84 +
 ...rlays-i2c-sensor-Add-adt7410-support.patch |   75 +
 ...overlays-hat_map-Add-pisound-mapping.patch |   26 +
 ...argins-on-the-composite-connector-st.patch |   47 +
 ...070me05000-Add-prepare_upstream_firs.patch |   26 +
 ...e-Find-the-source-pads-on-the-sensor.patch |   55 +
 ...ption-for-cam0-to-camera-mux-Nport-o.patch |  101 +
 ...dwc-Permit-sample-rates-up-to-384kHz.patch |   26 +
 ...0-1176-ASoC-dwc-Fix-full-duplex-mode.patch |   63 +
 ...2x-Adds-bindings-for-TAS575x-devices.patch |   45 +
 ...rt-for-TAS575x-to-the-pcm512x-driver.patch |  102 +
 .../950-1182-drm-panel-add-panel-dsi.patch    |  176 +
 ...-bindings-display-panel-dsi-bindings.patch |  136 +
 ...e-overlay-for-using-panel-dsi-on-RPi.patch |  176 +
 ...5-allow-specification-of-the-i2c-bus.patch |  159 +
 ...ts-bcm2712-put-usb-under-axi-not-soc.patch |   59 +
 ...rect-HVS-muxing-setup-for-the-moplet.patch |   26 +
 ...moplet-have-different-register-offse.patch |   68 +
 ...orrect-the-size-of-the-register-rang.patch |   25 +
 ...CCI-register-access-helper-functions.patch |  388 +
 ...a-dt-bindings-Add-OmniVision-OV64A40.patch |  114 +
 ...ndings-i2c-Add-Rohm-BU64754-bindings.patch |   83 +
 ...2c-Add-driver-for-OmniVision-OV64A40.patch | 3763 ++++++++
 ...HM-BU64754-Camera-Autofocus-Actuator.patch |  368 +
 ...rlay-for-the-OV64A40-Arducam-Camera-.patch |  426 +
 ...edia-rp1-cfe-Fix-verbose-debug-print.patch |   26 +
 ...ia-rp1-cfe-Expose-find_format_by_pix.patch |   33 +
 ...201-media-rp1-cfe-Add-missing-remaps.patch |   43 +
 ...p1-cfe-Add-missing-compressed-remaps.patch |   43 +
 ...d-cfe_find_16bit_code-and-cfe_find_c.patch |   74 +
 ...-media-rp1-csi2-Fix-csi2_pad_set_fmt.patch |   95 +
 ...media-rp1-fe-Fix-pisp_fe_pad_set_fmt.patch |  104 +
 ...se-get_frame_desc-to-get-CSI-2-VC-an.patch |  146 +
 ...1207-media-rp1-cfe-Add-is_image_node.patch |   91 +
 ...dia-rp1-cfe-Dual-purpose-video-nodes.patch |  621 ++
 .../950-1209-media-rp1-Drop-LE-handling.patch |  127 +
 ...-rp1-csi2-Use-standard-link_validate.patch |   75 +
 ...ia-rp1-fe-Use-standard-link_validate.patch |   70 +
 ...Improve-link-validation-for-metadata.patch |   61 +
 ...pinctrl-bcm-Kconfig-Fix-BCM2712-help.patch |   24 +
 ...panel-fix-waveshare-panel-software-r.patch |   41 +
 ...-Pass-given-partition-number-through.patch |   33 +
 ...2712-rpi-5-b-Enable-warm-reboot-mode.patch |   23 +
 ...c-imx296-imx477-Configure-tigger_mod.patch |   85 +
 ...ays-on-parameter-to-imx477-and-imx29.patch |   99 +
 ...06-Correct-prefix-length-in-snprintf.patch |   29 +
 ...712-rpi-5-b-Allow-RTC-to-be-disabled.patch |   38 +
 ...designware-Look-for-CNT-values-in-DT.patch |   57 +
 .../950-1227-dts-rp1-Add-I2C-timings.patch    |  103 +
 ...sp_be-pisp_fe-Update-UAPI-header-lic.patch |   58 +
 ...dia-cfe-Add-more-robust-ISR-handlers.patch |  207 +
 ...fer-bclk_ratio-handling-to-hw_params.patch |   89 +
 ...x-reading-of-frame-count-on-GEN5-Pi4.patch |   79 +
 ...2712-rpi-5-b-Add-eth_ledx-parameters.patch |   56 +
 ...m2712-rpi-5-b-Add-fan-speed-dtparams.patch |   71 +
 ...n-t-check-if-plane-state-fb-state-fb.patch |   93 +
 ...-Support-spi0-0cs-and-SPI_NO_CS-mode.patch |   42 +
 ...mx519-Add-V4L2_CID_LINK_FREQ-control.patch |   51 +
 ...ducam_64mp-Add-V4L2_CID_LINK_FREQ-co.patch |   56 +
 .../960-hwrng-iproc-set-quality-to-1000.patch |    2 +-
 340 files changed, 69915 insertions(+), 1 deletion(-)
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0790-media-i2c-imx219-fix-binning-and-rate_factor-for-480.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0791-serial-sc16is7xx-Read-modem-line-state-at-startup.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0792-drivers-media-bcm2835_unicam-Improve-frame-sequence-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0793-dtoverlays-Fix-pitft-28-35-overlays-for-6.1-driver-c.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0795-driver-media-i2c-imx477-Re-enable-temperature-sensor.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0796-overlays-allo-katana-dac-audio-Reduce-I2C-clock.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0797-overlays-jedec-spi-nor-Add-speed-parameter.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0798-ALSA-pcm-fix-ELD-constraints-for-E-AC3-DTS-HD-and-ML.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0799-ASoC-hdmi-codec-fix-channel-info-for-compressed-form.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0800-media-i2c-arducam_64mp-Modify-the-line-length-of-128.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0801-media-i2c-arducam_64mp-Add-8000x6000-resolution.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0802-media-i2c-arducam_64mp-Add-PDAF-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0803-overlays-audremap-Document-CM4-40-41-restriction.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0804-fixup-Allow-mac-address-to-be-set-in-smsc95xx.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0809-cfg80211-ship-debian-certificates-as-hex-files.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0810-fixup-Add-support-for-all-the-downstream-rpi-sound-c.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0815-fixup-drm-tc358762-Set-the-pre_enable_upstream_first.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0816-rpi-sound-cards-Fix-Codec-Zero-rate-switching.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0818-overlays-Add-trickle-voltage-mv-parameter-to-RTCs.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0819-drivers-media-imx296-Add-standby-delay-during-probe.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0820-overlays-Add-bmp380-to-i2c-sensor-overlay.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0821-can-isotp-add-module-parameter-for-maximum-pdu-size.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0822-drivers-media-imx296-Updated-imx296-driver-for-exter.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0823-media-dt-bindings-imx258-Fix-alternate-compatible-st.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0825-char-broadcom-vc_mem-Fix-preprocessor-conditional.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0826-drivers-dwc_otg-Fix-fallthrough-warnings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0827-vc04_services-vc-sm-cma-Switch-one-bit-bitfields-to-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0828-media-i2c-ov2311-Fix-uninitialized-variable-usage.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0830-drm-panel-Fix-default-values-for-Waveshare-7.9-inch-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0831-dtoverlays-Add-i2c-bus-overrides-to-edt-ft5406-overl.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0832-dtoverlays-Fix-README-text-for-i2c-fan.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0833-drivers-irqchip-irq-bcm2835-Concurrency-fix.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0835-dtoverlays-Add-drm-option-to-piscreen-overlay.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0836-drm-ili9486-Resolve-clash-in-spi_device_id-names.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0837-input-ads7846-Add-missing-spi_device_id-strings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0838-staging-bcm2835-codec-Downgrade-the-level-for-a-debu.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0840-gpio-fsm-Sort-functions-into-a-more-logical-order.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0841-gpio_fsm-Rework-the-atomic-vs-non-atomic-split.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0842-f2fs-fix-to-avoid-NULL-pointer-dereference-in-f2fs_i.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0843-ASoC-hdmi-codec-Fix-broken-channel-map-reporting.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0845-Revert-hwrng-iproc-rng200-Add-BCM2838-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0846-hwrng-iproc-rng200-Add-BCM2838-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0847-PCI-brcmstb-Wait-for-100ms-following-PERST-deassert.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0848-drm-edid-Add-option-to-report-basic-audio-support-wi.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0849-Revert-drm-edid-Add-option-to-report-basic-audio-sup.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0850-overlays-Add-a-sample-hat_map.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0851-Revert-usb-phy-generic-Get-the-vbus-supply.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0853-dts-2712-Update-for-device-tree.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0854-bcm2708_fb-Hack-out-dma-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0855-gpio_brcmstb-Allow-to-build-for-ARCH_BCM2835.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0856-Allow-RESET_BRCMSTB-on-ARCH_BCM2835.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0857-pinctrl-bcm2712-pinctrl-pinconf-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0858-vc4-fkms-Remove-use-of-SMI-peripheral.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0859-mmc-brcmstb-add-support-for-BCM2712.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0860-sdhci-Add-SD-Express-hook.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0861-Add-new-pispbe-driver-though-not-yet-the-Makesfiles-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0862-irqchip-irq-bcm2712-mip-Support-for-2712-s-MIP.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0863-reset-reset-brcmstb-rescal-Support-shared-use.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0864-net-macb-Also-set-DMA-coherent-mask.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0865-usb-dwc3-Set-DMA-and-coherent-masks-early.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0866-drm-panel-raspberrypi-touchscreen-Insert-more-delays.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0867-PCI-brcmstb-Add-BCM2712-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0868-V4L2-Add-PiSP-opaque-formats-to-V4L2.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0869-V4L2-Add-PiSP-compressed-formats-to-V4L2.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0870-bcm2708_fb-Fix-more-build-warnings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0871-dt-binding-mfd-Add-binding-for-Raspberry-Pi-RP1.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0872-mfd-Add-rp1-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0873-dt-bindings-clock-Add-bindings-for-Raspberry-Pi-RP1.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0874-clk-Add-rp1-clock-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0875-dt-bindings-pinctrl-Add-bindings-for-Raspberry-Pi-RP.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0876-pinctrl-Add-rp1-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0877-serial-pl011-rp1-uart-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0878-mmc-sdhci-of-dwcmshc-define-sdio-timeout-clocks.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0879-mmc-sdhci-of-dwcmshc-rp1-sdio-changes.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0880-clk-rp1-Add-sdio-clk-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0881-i2c-designware-Add-SMBUS-quick-command-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0882-dmaengine-dw-axi-dmac-Fixes-for-RP1.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0883-spi-dw-Handle-combined-tx-and-rx-messages.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0884-pwm-Add-support-for-RP1-PWM.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0885-drm-Add-RP1-DSI-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0886-drm-Add-RP1-DPI-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0887-drm-Add-RP1-VEC-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0888-v4l2-Add-pisp-compression-format-support-to-v4l2.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0889-media-rp1-Add-CFE-Camera-Front-End-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0890-dt-bindings-net-cdns-macb-AXI-tuning-properties.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0891-ASoC-dwc-list-all-supported-sample-sizes.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0892-ASoC-dwc-Support-set_bclk_ratio.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0893-ASoC-dwc-Add-DMACR-handling.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0894-ASOC-dwc-Improve-DMA-shutdown.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0895-ASOC-dwc-Fix-16-bit-audio-handling.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0896-ASoC-bcm-Remove-dependency-on-BCM2835-I2S.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0897-hwmon-Add-RP1-ADC-and-temperature-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0898-mfd-bcm2835-pm-Add-support-for-BCM2712.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0899-soc-bcm-bcm2835-power-Add-support-for-BCM2712.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0900-drivers-spi-Fix-spi-gpio-to-correctly-implement-sck-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0901-spi-spi-gpio-Implement-spidelay-when-requested-bit-r.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0902-drm-v3d-fix-up-register-addresses-for-V3D-7.x.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0903-drm-v3d-update-UAPI-to-match-user-space-for-V3D-7.x.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0904-drm-v3d-add-brcm-2712-v3d-as-a-compatible-V3D-device.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0905-drm-v3d-Improve-MMU-support-for-larger-pages.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0906-dt-bindings-gpu-v3d-Add-BCM2712-to-compatibility-lis.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0907-drivers-char-add-generic-gpiomem-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0909-drivers-char-delete-bcm2835-gpiomem.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0910-drivers-hwmon-rp1-adc-check-conversion-validity-befo.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0911-dmaengine-bcm2835-Add-BCM2712-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0912-dmaengine-bcm2835-HACK-Support-DMA-Lite-channels.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0913-clk-bcm-rpi-Add-disp-clock.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0914-net-phy-broadcom-optionally-enable-link-down-powersa.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0915-dmaengine-bcm2835-Rename-to_bcm2711_cbaddr-to-to_40b.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0916-dmaengine-bcm2835-Fix-dma-driver-for-BCM2835-38.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0917-drivers-iommu-Add-BCM2712-IOMMU.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0918-irqchip-irq-brcmstb-l2-Add-config-for-2711-controlle.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0919-rtc-rtc-rpi-Add-simple-RTC-driver-for-Raspberry-Pi.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0920-dt-bindings-rtc-new-binding-for-Raspberry-Pi-RTC-dri.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0921-hwmon-pwm-fan-Add-fan-speed-register-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0922-media-i2c-imx296-Add-2ms-delay-after-releasing-stand.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0923-dt-bindings-input-Add-bindings-for-raspberrypi-butto.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0924-dt-bindings-input-Add-bindings-for-raspberrypi-butto.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0925-Input-Add-raspberrypi-button-firmware-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0926-dt-bindings-update-rpi-rtc-binding.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0927-drivers-rtc-rpi-add-battery-charge-circuit-control-a.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0928-vc4_drv-Avoid-panic-when-booted-with-no-kms.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0929-drm-vc4-Treat-zero-sized-destination-as-full-screen.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0930-drm-vc4-Fix-FKMS-for-when-the-YUV-chroma-planes-are-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0931-drm-vc4-hdmi-Enable-the-audio-clock.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0932-drm-vc4-hdmi-Warn-if-writing-to-an-unknown-HDMI-regi.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0933-drm-vc4-hvs-More-logging-for-dlist-generation.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0934-drm-vc4-hvs-Print-error-if-we-fail-an-allocation.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0935-drm-vc4-plane-Add-more-debugging-for-LBM-allocation.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0936-drm-vc4-plane-Use-return-variable-in-atomic_check.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0937-drm-vc4-crtc-Move-assigned_channel-to-a-variable.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0938-drm-vc4-Introduce-generation-number-enum.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0939-drm-vc4-Make-v3d-paths-unavailable-on-any-generation.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0940-drm-vc4-hvs-Use-switch-statement-to-simplify-vc4_hvs.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0941-drm-vc4-hvs-Use-switch-statement-to-simplify-enablin.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0942-drm-vc4-hvs-Test-if-the-EOF-interrupts-are-enabled.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0943-drm-vc4-hvs-Create-hw_init-function.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0944-drm-vc4-hvs-Create-cob_init-function.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0945-drm-vc4-hvs-Rename-hvs_regs-list.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0946-drm-vc4-plane-Change-ptr0_offset-to-an-array.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0947-drm-vc4-hvs-Rework-LBM-alignment.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0948-drm-vc4-hvs-Change-prototype-of-__vc4_hvs_alloc-to-p.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0949-drm-vc4-UV-planes-vertical-scaling-must-always-be-en.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0950-drm-vc4-hdmi-Avoid-hang-with-debug-registers-when-su.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0951-drm-vc4-Move-the-buffer-offset-out-of-the-vc4_plane_.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0952-drm-vc4-Fix-dlist-debug-not-resetting-the-next-entry.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0953-drm-vc4-Remove-incorrect-limit-from-hvs_dlist-debugf.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0954-drm-vc4-hvs-Remove-ABORT_ON_EMPTY-flag.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0955-drm-vc4-Enable-SCALER_CONTROL-early-in-HVS-init.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0956-dt-bindings-display-Add-BCM2712-HDMI-bindings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0957-dt-bindings-display-Add-BCM2712-HVS-bindings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0958-dt-bindings-display-Add-BCM2712-PixelValve-bindings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0959-dt-bindings-display-Add-BCM2712-MOP-bindings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0960-dt-bindings-display-Add-BCM2712-MOPLET-bindings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0961-dt-bindings-display-Add-BCM2712-KMS-driver-bindings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0962-drm-vc4-drv-Support-BCM2712.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0963-drm-vc4-hvs-Support-BCM2712-HVS.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0964-drm-vc4-crtc-Add-support-for-BCM2712-PixelValves.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0965-drm-vc4-hdmi-Add-support-for-BCM2712-HDMI-controller.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0966-drm-vc4-txp-Introduce-structure-to-deal-with-revisio.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0967-drm-vc4-txp-Rename-TXP-data-structure.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0968-drm-vc4-txp-Add-byte-enable-toggle-bit.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0969-drm-vc4-txp-Add-horizontal-and-vertical-size-offset-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0970-drm-vc4-txp-Handle-40-bits-DMA-Addresses.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0971-drm-vc4-txp-Move-the-encoder-type-in-the-variant-str.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0972-drm-vc4-txp-Add-a-new-TXP-encoder-type.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0973-drm-vc4-txp-Add-support-for-BCM2712-MOP.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0974-drm-vc4-txp-Add-BCM2712-MOPLET-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0975-drm-vc4-Add-additional-warn_on.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0976-drm-vc4-tests-Switch-generation-mockup-to-a-switch.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0977-drm-vc4-tests-Drop-drm-parameter-for-vc4_find_crtc_f.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0978-drm-vc4-tests-Return-the-allocated-output.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0979-drm-vc4-tests-Add-BCM2712-mock-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0980-drm-vc4-tests-Add-tests-for-BCM2712-PixelValve-Muxin.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0981-drm-vc4-fkms-Rename-plane-related-functions.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0982-drm-vc4-tests-Use-custom-plane-state-for-mock.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0983-drm-vc4-tests-Add-function-to-lookup-a-plane-for-a-C.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0984-drm-vc4-tests-Add-helper-to-add-a-new-plane-to-a-sta.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0985-drm-vc4-tests-Support-a-few-more-plane-formats.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0986-drm-vc4-tests-Introduce-a-test-for-LBM-buffer-size.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0987-drm-vc4-kms-Avoid-setting-core-and-disp-clocks-for-h.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0988-drm-vc4-Assign-LBM-memory-during-atomic_flush.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0989-drm-panel-simple-Alter-the-timing-for-the-Pi-7-DSI-d.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0990-drm-panel-waveshare-Fix-up-timings-for-10.1-panel.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0991-media-i2c-imx477-Fix-locking-in-imx477_init_controls.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0994-overlays-Fix-vc4-kms-dsi-7inch.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0995-Revert-ASoC-hdmi-codec-Fix-broken-channel-map-report.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0996-ASoC-hdmi-codec-Fix-broken-channel-map-reporting.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0997-media-rp1-cfe-Fix-use-of-freed-memory-on-errors.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0998-media-rp1-cfe-Fix-width-height-in-cfe_start_channel.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-0999-media-rp1-csi2-Fix-missing-reg-writes.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1000-media-rp1-fe-Use-0-not-1-when-working-with-unsigned-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1001-media-rp1-cfe-Fix-verbose-debug-print.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1002-media-rp1-cfe-Rename-xxx_dbg_irq-to-xxx_dbg_verbose.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1003-media-rp1-Add-back-reg-write-debug-prints.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1004-media-rp1-cfe-Add-verbose-debug-module-parameter.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1005-media-rp1-csi2-Track-CSI-2-errors.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1006-media-rp1-cfe-Drop-unused-field.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1007-media-rp1-csi2-Set-values-for-enum-csi2_mode.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1008-media-rp1-fe-Fix-default-mbus-code.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1009-media-rp1-cfe-Fix-default-meta-format-s-field.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1010-media-rp1-cfe-Fail-streaming-if-FE_CONFIG-node-is-no.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1011-media-i2c-Move-Kconfig-entry-for-IMX477-to-the-camer.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1013-drm-Look-for-an-alias-for-the-displays-to-use-as-the.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1014-dt-Add-DSI1-and-DSI2-aliases-to-2712.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1015-vc4-drm-Remove-the-clear-of-SCALER_DISPBKGND_FILL.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1017-gpio-brcmstb-Use-dynamic-GPIO-base-numbers.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1018-media-rpivid-Allow-use-of-iommu-in-rpivid.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1019-dts-bcm2712-Add-iommu-to-rpivid.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1020-drivers-media-rp1_cfe-Remove-PISP-specific-MBUS-form.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1022-vc04_services-bcm2835-codec-Correct-alignment-requir.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1025-input-touchscreen-edt-ft5x06-Suppress-bogus-data-on-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1027-Revert-bcm2708_fb-Fix-more-build-warnings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1028-Revert-bcm2708_fb-Hack-out-dma-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1029-overlays-mcp23017-allow-specification-of-the-i2c-bus.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1030-dts-bcm2712-Set-default-I2C-baudrates-to-100kHz.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1031-vc_mem-Add-the-DMA-memcpy-support-from-bcm2708_fb.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1032-drm-vc4-Correct-address-offset-for-planes-with-src_-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1033-drivers-media-rp1_cfe-Fix-link-validate-test-for-pix.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1034-dts-bcm2712-Use-the-new-model-name.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1035-fbdev-Allow-client-to-request-a-particular-dev-fbN-n.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1036-drm-fb-helper-Look-up-preferred-fbdev-node-number-fr.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1037-dt-Add-overrides-for-drm-framebuffer-allocations-on-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1039-drm-connector-Change-DRM-card-alias-from-underscore-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1040-dt-Alter-alias-names-from-_-to-for-drm_dsiN.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1041-drm-fb_helper-Change-query-for-FB-designation-from-d.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1042-dt-Alter-alias-names-from-_-to-for-drm_fbN_-override.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1044-Typo-in-overlays-README.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1045-dts-bcm2712-Add-the-krnbt-parameter.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1046-Revert-vc4-fkms-Remove-use-of-SMI-peripheral.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1047-drm-vc4_fkms-Fix-up-interrupt-handler-for-both-2835-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1048-dt-Switch-bcm2712-firmware-kms-node-to-using-the-271.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1049-drivers-media-imx477-Disable-the-scaler.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1050-dt-Add-drm_fbN_vc4-overrides-for-Pi0-4.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1051-fixup-overlays-mcp23017-allow-specification-of-the-i.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1052-drivers-media-pisp_be-Add-back-V4L2_PIX_FMT_RPI_BE-f.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1053-dt-bindings-PCI-brcmstb-add-optional-property-brcm-t.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1054-drivers-pci-brcmstb-optionally-extend-Tperst_clk-tim.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1055-arm-dt-add-dtparams-for-PCIe-reset-timing-override.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1056-arm-dt-bcm2712-don-t-unconditionally-enable-MPS-read.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1057-drivers-media-imx477-Set-horizontal-binning-when-dis.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1058-fixup-arch-arm64-Add-Revision-Serial-Model-to-cpuinf.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1060-dts-bcm2710-rpi-zero-2-w-Remove-WLAN-firmwares.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1061-drivers-media-cfe-Set-the-CSI-2-link-frequency-corre.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1062-dts-bcm2712-rpi-5-b-Create-some-dummy-nodes.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1063-dts-rp1-Add-spi6-fix-spi1-address-cells.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1064-overlays-uart-n-pi5-Add-the-pinctrl-0-property.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1065-drivers-media-imx477-Add-V4L2_CID_LINK_FREQ-control.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1066-drivers-media-imx477-Correctly-set-IMX477_PIXEL_RATE.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1067-drm-vc4-Correct-logic-on-stopping-an-HVS-channel.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1068-drm-vc4-Drop-WARN-for-HVS-FIFOs-not-being-empty.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1069-drm-vc4-Free-all-stale-dlists-if-channel-is-disabled.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1070-drm-vc4-Add-hvs_dlist_allocs-debugfs-function.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1071-drm-vc4-Log-the-size-of-the-dlist-allocation-that-wa.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1072-drm-vc4-crtc-Support-odd-horizontal-timings-on-BCM27.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1073-spi-dw-dma-Get-the-last-DMA-scoop-out-of-the-FIFO.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1075-drivers-mmc-sdhci-add-SPURIOUS_INT_RESP-quirk.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1076-dt-bindings-mmc-sdhci-of-dwcmhsc-Add-Raspberry-Pi-RP.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1077-drivers-mmc-sdhci-of-dwcmshc-add-RP1-dt-ID-and-quirk.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1078-arm-dts-change-RP1-SDHCI-controller-compatible-strin.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1079-ASoC-bcm-audioinjector_octo-Add-soundcard-owner.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1080-drivers-media-imx708-Adjust-broken-line-correction-p.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1081-Revert-media-i2c-imx296-Add-2ms-delay-after-releasin.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1082-drivers-media-cfe-Don-t-confuse-MHz-and-Mbps.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1083-overlays-imx296-Fix-cam-port-override-for-regulators.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1148-overlays-ov5647-Regularise-vcm-node-label-name.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1149-overlays-ov5647-cam0-mode-should-use-cam0_reg.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1150-w1-Disable-kernel-log-spam.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1151-include-uapi-mbus-Add-a-media-bus-format-enum-for-16.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1152-include-uapi-v4l2-Add-additional-pixel-formats-for-u.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1153-drivers-media-cfe-Add-16-bit-and-compressed-mono-for.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1154-drivers-media-pisp_be-Add-mono-and-48-bit-RGB-pixel-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1155-ASoC-dwc-Remove-check-in-set_bclk_ratio-handling.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1159-overlays-README-Fix-cut-and-paste-errors.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1160-media-i2c-ov7251-Switch-from-V4L2_CID_GAIN-to-V4L2_C.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1161-drm-vc4-Drop-planes-that-are-completely-off-screen.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1162-drm-bridge-display-connector-Select-DRM_KMS_HELPER.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1163-drm-vc4-Free-the-dlist-alloc-immediately-if-it-never.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1164-input-edt-ft5x06-Include-I2C-details-in-names-for-th.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1165-input-goodix-Include-I2C-details-in-names-for-the-de.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1166-drm-vc4-Block-swiotlb-bounce-buffers-being-imported-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1167-overlays-i2c-sensor-Add-adt7410-support.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1168-overlays-hat_map-Add-pisound-mapping.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1169-drm-vc4-Set-TV-margins-on-the-composite-connector-st.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1170-drm-panel-jdi-lt070me05000-Add-prepare_upstream_firs.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1172-drivers-media-cfe-Find-the-source-pads-on-the-sensor.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1173-dtoverlays-Add-option-for-cam0-to-camera-mux-Nport-o.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1174-ASoC-dwc-Permit-sample-rates-up-to-384kHz.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1176-ASoC-dwc-Fix-full-duplex-mode.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1179-ASoC-pcm512x-Adds-bindings-for-TAS575x-devices.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1180-ASoC-Adds-support-for-TAS575x-to-the-pcm512x-driver.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1182-drm-panel-add-panel-dsi.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1183-dt-bindings-display-panel-dsi-bindings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1184-overlays-example-overlay-for-using-panel-dsi-on-RPi.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1185-overlays-ADS1115-allow-specification-of-the-i2c-bus.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1186-dts-bcm2712-put-usb-under-axi-not-soc.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1187-drm-vc4-Correct-HVS-muxing-setup-for-the-moplet.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1188-drm-vc4-Mop-and-moplet-have-different-register-offse.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1189-arm-dt-bcm2712-Correct-the-size-of-the-register-rang.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1192-media-Add-MIPI-CCI-register-access-helper-functions.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1193-media-dt-bindings-Add-OmniVision-OV64A40.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1194-media-dt-bindings-i2c-Add-Rohm-BU64754-bindings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1195-media-i2c-Add-driver-for-OmniVision-OV64A40.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1196-media-i2c-Add-ROHM-BU64754-Camera-Autofocus-Actuator.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1197-overlays-Add-overlay-for-the-OV64A40-Arducam-Camera-.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1199-media-rp1-cfe-Fix-verbose-debug-print.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1200-media-rp1-cfe-Expose-find_format_by_pix.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1201-media-rp1-cfe-Add-missing-remaps.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1202-media-rp1-cfe-Add-missing-compressed-remaps.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1203-media-rp1-cfe-Add-cfe_find_16bit_code-and-cfe_find_c.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1204-media-rp1-csi2-Fix-csi2_pad_set_fmt.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1205-media-rp1-fe-Fix-pisp_fe_pad_set_fmt.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1206-media-rp1-csi2-Use-get_frame_desc-to-get-CSI-2-VC-an.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1207-media-rp1-cfe-Add-is_image_node.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1208-media-rp1-cfe-Dual-purpose-video-nodes.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1209-media-rp1-Drop-LE-handling.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1210-media-rp1-csi2-Use-standard-link_validate.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1211-media-rp1-fe-Use-standard-link_validate.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1212-media-rp1-cfe-Improve-link-validation-for-metadata.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1214-drivers-pinctrl-bcm-Kconfig-Fix-BCM2712-help.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1216-drivers-gpu-drm-panel-fix-waveshare-panel-software-r.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1217-firmware-psci-Pass-given-partition-number-through.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1218-dts-bcm2712-rpi-5-b-Enable-warm-reboot-mode.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1222-drivers-media-i2c-imx296-imx477-Configure-tigger_mod.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1223-overlays-Add-always-on-parameter-to-imx477-and-imx29.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1224-input-edt-ft5x06-Correct-prefix-length-in-snprintf.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1225-ARM-dts-bcm2712-rpi-5-b-Allow-RTC-to-be-disabled.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1226-i2c-designware-Look-for-CNT-values-in-DT.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1227-dts-rp1-Add-I2C-timings.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1228-drivers-media-pisp_be-pisp_fe-Update-UAPI-header-lic.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1229-drivers-media-cfe-Add-more-robust-ISR-handlers.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1231-ASoC-dwc-Defer-bclk_ratio-handling-to-hw_params.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1232-drm-vc4-Fix-reading-of-frame-count-on-GEN5-Pi4.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1233-ARM-dts-bcm2712-rpi-5-b-Add-eth_ledx-parameters.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1234-ARM-dts-bcm2712-rpi-5-b-Add-fan-speed-dtparams.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1235-drm-vc4-don-t-check-if-plane-state-fb-state-fb.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1236-spi-bcm2835-Support-spi0-0cs-and-SPI_NO_CS-mode.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1237-drivers-media-imx519-Add-V4L2_CID_LINK_FREQ-control.patch
 create mode 100644 target/linux/bcm27xx/patches-6.1/950-1238-drivers-media-arducam_64mp-Add-V4L2_CID_LINK_FREQ-co.patch

diff --git a/target/linux/bcm27xx/patches-6.1/950-0790-media-i2c-imx219-fix-binning-and-rate_factor-for-480.patch b/target/linux/bcm27xx/patches-6.1/950-0790-media-i2c-imx219-fix-binning-and-rate_factor-for-480.patch
new file mode 100644
index 0000000000..276e51d2d9
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0790-media-i2c-imx219-fix-binning-and-rate_factor-for-480.patch
@@ -0,0 +1,306 @@
+From 3ad8e28669e0058e3cec482a47215e50e33f2574 Mon Sep 17 00:00:00 2001
+From: Vinay Varma <varmavinaym@gmail.com>
+Date: Sun, 11 Jun 2023 23:45:03 +0800
+Subject: [PATCH] media: i2c: imx219: fix binning and rate_factor for 480p and
+ 1232p
+
+At a high FPS with RAW10, there is frame corruption for 480p because the
+rate_factor of 2 is used with the normal 2x2 bining [1]. This commit
+ties the rate_factor to the selected binning mode. For the 480p mode,
+analog 2x2 binning mode with a rate_factor of 2 is always used. For the
+1232p mode the normal 2x2 binning mode is used for RAW10 while analog
+2x2 binning mode is used for RAW8.
+
+[1] https://github.com/raspberrypi/linux/issues/5493
+
+Signed-off-by: Vinay Varma <varmavinaym@gmail.com>
+---
+ drivers/media/i2c/imx219.c | 143 ++++++++++++++++++++++++++-----------
+ 1 file changed, 100 insertions(+), 43 deletions(-)
+
+--- a/drivers/media/i2c/imx219.c
++++ b/drivers/media/i2c/imx219.c
+@@ -136,6 +136,18 @@ enum pad_types {
+ 	NUM_PADS
+ };
+ 
++enum binning_mode {
++	BINNING_NONE,
++	BINNING_DIGITAL_2x2,
++	BINNING_ANALOG_2x2,
++};
++
++enum binning_bit_depths {
++	BINNING_IDX_8_BIT,
++	BINNING_IDX_10_BIT,
++	BINNING_IDX_MAX
++};
++
+ struct imx219_reg {
+ 	u16 address;
+ 	u8 val;
+@@ -162,11 +174,8 @@ struct imx219_mode {
+ 	/* Default register values */
+ 	struct imx219_reg_list reg_list;
+ 
+-	/* 2x2 binning is used */
+-	bool binning;
+-
+-	/* Relative pixel clock rate factor for the mode. */
+-	unsigned int rate_factor;
++	/* binning mode based on format code */
++	enum binning_mode binning[BINNING_IDX_MAX];
+ };
+ 
+ static const struct imx219_reg imx219_common_regs[] = {
+@@ -404,8 +413,10 @@ static const struct imx219_mode supporte
+ 			.num_of_regs = ARRAY_SIZE(mode_3280x2464_regs),
+ 			.regs = mode_3280x2464_regs,
+ 		},
+-		.binning = false,
+-		.rate_factor = 1,
++		.binning = {
++			[BINNING_IDX_8_BIT] = BINNING_NONE,
++			[BINNING_IDX_10_BIT] = BINNING_NONE,
++		},
+ 	},
+ 	{
+ 		/* 1080P 30fps cropped */
+@@ -422,8 +433,10 @@ static const struct imx219_mode supporte
+ 			.num_of_regs = ARRAY_SIZE(mode_1920_1080_regs),
+ 			.regs = mode_1920_1080_regs,
+ 		},
+-		.binning = false,
+-		.rate_factor = 1,
++		.binning = {
++			[BINNING_IDX_8_BIT] = BINNING_NONE,
++			[BINNING_IDX_10_BIT] = BINNING_NONE,
++		},
+ 	},
+ 	{
+ 		/* 2x2 binned 30fps mode */
+@@ -440,8 +453,10 @@ static const struct imx219_mode supporte
+ 			.num_of_regs = ARRAY_SIZE(mode_1640_1232_regs),
+ 			.regs = mode_1640_1232_regs,
+ 		},
+-		.binning = true,
+-		.rate_factor = 1,
++		.binning = {
++			[BINNING_IDX_8_BIT] = BINNING_ANALOG_2x2,
++			[BINNING_IDX_10_BIT] = BINNING_DIGITAL_2x2,
++		},
+ 	},
+ 	{
+ 		/* 640x480 30fps mode */
+@@ -458,12 +473,10 @@ static const struct imx219_mode supporte
+ 			.num_of_regs = ARRAY_SIZE(mode_640_480_regs),
+ 			.regs = mode_640_480_regs,
+ 		},
+-		.binning = true,
+-		/*
+-		 * This mode uses a special 2x2 binning that doubles the
+-		 * internal pixel clock rate.
+-		 */
+-		.rate_factor = 2,
++		.binning = {
++			[BINNING_IDX_8_BIT] = BINNING_ANALOG_2x2,
++			[BINNING_IDX_10_BIT] = BINNING_ANALOG_2x2,
++		},
+ 	},
+ };
+ 
+@@ -652,12 +665,51 @@ static int imx219_open(struct v4l2_subde
+ 	return 0;
+ }
+ 
++static int imx219_resolve_binning(struct imx219 *imx219,
++				  enum binning_mode *binning)
++{
++	switch (imx219->fmt.code) {
++	case MEDIA_BUS_FMT_SRGGB8_1X8:
++	case MEDIA_BUS_FMT_SGRBG8_1X8:
++	case MEDIA_BUS_FMT_SGBRG8_1X8:
++	case MEDIA_BUS_FMT_SBGGR8_1X8:
++		*binning = imx219->mode->binning[BINNING_IDX_8_BIT];
++		return 0;
++
++	case MEDIA_BUS_FMT_SRGGB10_1X10:
++	case MEDIA_BUS_FMT_SGRBG10_1X10:
++	case MEDIA_BUS_FMT_SGBRG10_1X10:
++	case MEDIA_BUS_FMT_SBGGR10_1X10:
++		*binning = imx219->mode->binning[BINNING_IDX_10_BIT];
++		return 0;
++	}
++	return -EINVAL;
++}
++
++static int imx219_get_rate_factor(struct imx219 *imx219)
++{
++	enum binning_mode binning = BINNING_NONE;
++	int ret = imx219_resolve_binning(imx219, &binning);
++
++	if (ret < 0)
++		return ret;
++	switch (binning) {
++	case BINNING_NONE:
++	case BINNING_DIGITAL_2x2:
++		return 1;
++	case BINNING_ANALOG_2x2:
++		return 2;
++	}
++	return -EINVAL;
++}
++
+ static int imx219_set_ctrl(struct v4l2_ctrl *ctrl)
+ {
+ 	struct imx219 *imx219 =
+ 		container_of(ctrl->handler, struct imx219, ctrl_handler);
+ 	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+ 	int ret;
++	int rate_factor;
+ 
+ 	if (ctrl->id == V4L2_CID_VBLANK) {
+ 		int exposure_max, exposure_def;
+@@ -679,6 +731,10 @@ static int imx219_set_ctrl(struct v4l2_c
+ 	if (pm_runtime_get_if_in_use(&client->dev) == 0)
+ 		return 0;
+ 
++	rate_factor = imx219_get_rate_factor(imx219);
++	if (rate_factor < 0)
++		return rate_factor;
++
+ 	switch (ctrl->id) {
+ 	case V4L2_CID_ANALOGUE_GAIN:
+ 		ret = imx219_write_reg(imx219, IMX219_REG_ANALOG_GAIN,
+@@ -687,7 +743,7 @@ static int imx219_set_ctrl(struct v4l2_c
+ 	case V4L2_CID_EXPOSURE:
+ 		ret = imx219_write_reg(imx219, IMX219_REG_EXPOSURE,
+ 				       IMX219_REG_VALUE_16BIT,
+-				       ctrl->val / imx219->mode->rate_factor);
++				       ctrl->val / rate_factor);
+ 		break;
+ 	case V4L2_CID_DIGITAL_GAIN:
+ 		ret = imx219_write_reg(imx219, IMX219_REG_DIGITAL_GAIN,
+@@ -708,7 +764,7 @@ static int imx219_set_ctrl(struct v4l2_c
+ 		ret = imx219_write_reg(imx219, IMX219_REG_VTS,
+ 				       IMX219_REG_VALUE_16BIT,
+ 				       (imx219->mode->height + ctrl->val) /
+-						imx219->mode->rate_factor);
++						rate_factor);
+ 		break;
+ 	case V4L2_CID_HBLANK:
+ 		ret = imx219_write_reg(imx219, IMX219_REG_HTS,
+@@ -890,7 +946,7 @@ static int imx219_set_pad_format(struct
+ 	struct imx219 *imx219 = to_imx219(sd);
+ 	const struct imx219_mode *mode;
+ 	struct v4l2_mbus_framefmt *framefmt;
+-	int exposure_max, exposure_def, hblank, pixel_rate;
++	int exposure_max, exposure_def, hblank, pixel_rate, rate_factor;
+ 	unsigned int i;
+ 
+ 	if (fmt->pad >= NUM_PADS)
+@@ -924,6 +980,9 @@ static int imx219_set_pad_format(struct
+ 
+ 			imx219->fmt = fmt->format;
+ 			imx219->mode = mode;
++			rate_factor = imx219_get_rate_factor(imx219);
++			if (rate_factor < 0)
++				return rate_factor;
+ 			/* Update limits and set FPS to default */
+ 			__v4l2_ctrl_modify_range(imx219->vblank,
+ 						 IMX219_VBLANK_MIN,
+@@ -957,8 +1016,7 @@ static int imx219_set_pad_format(struct
+ 			__v4l2_ctrl_s_ctrl(imx219->hblank, hblank);
+ 
+ 			/* Scale the pixel rate based on the mode specific factor */
+-			pixel_rate =
+-				IMX219_PIXEL_RATE * imx219->mode->rate_factor;
++			pixel_rate = IMX219_PIXEL_RATE * rate_factor;
+ 			__v4l2_ctrl_modify_range(imx219->pixel_rate, pixel_rate,
+ 						 pixel_rate, 1, pixel_rate);
+ 		}
+@@ -1001,30 +1059,25 @@ static int imx219_set_framefmt(struct im
+ 
+ static int imx219_set_binning(struct imx219 *imx219)
+ {
+-	if (!imx219->mode->binning) {
++	enum binning_mode binning = BINNING_NONE;
++	int ret = imx219_resolve_binning(imx219, &binning);
++
++	if (ret < 0)
++		return ret;
++	switch (binning) {
++	case BINNING_NONE:
+ 		return imx219_write_reg(imx219, IMX219_REG_BINNING_MODE,
+ 					IMX219_REG_VALUE_16BIT,
+ 					IMX219_BINNING_NONE);
+-	}
+-
+-	switch (imx219->fmt.code) {
+-	case MEDIA_BUS_FMT_SRGGB8_1X8:
+-	case MEDIA_BUS_FMT_SGRBG8_1X8:
+-	case MEDIA_BUS_FMT_SGBRG8_1X8:
+-	case MEDIA_BUS_FMT_SBGGR8_1X8:
++	case BINNING_DIGITAL_2x2:
+ 		return imx219_write_reg(imx219, IMX219_REG_BINNING_MODE,
+ 					IMX219_REG_VALUE_16BIT,
+-					IMX219_BINNING_2X2_ANALOG);
+-
+-	case MEDIA_BUS_FMT_SRGGB10_1X10:
+-	case MEDIA_BUS_FMT_SGRBG10_1X10:
+-	case MEDIA_BUS_FMT_SGBRG10_1X10:
+-	case MEDIA_BUS_FMT_SBGGR10_1X10:
++					IMX219_BINNING_2X2);
++	case BINNING_ANALOG_2x2:
+ 		return imx219_write_reg(imx219, IMX219_REG_BINNING_MODE,
+ 					IMX219_REG_VALUE_16BIT,
+-					IMX219_BINNING_2X2);
++					IMX219_BINNING_2X2_ANALOG);
+ 	}
+-
+ 	return -EINVAL;
+ }
+ 
+@@ -1342,7 +1395,7 @@ static int imx219_init_controls(struct i
+ 	struct v4l2_ctrl_handler *ctrl_hdlr;
+ 	unsigned int height = imx219->mode->height;
+ 	struct v4l2_fwnode_device_properties props;
+-	int exposure_max, exposure_def, hblank, pixel_rate;
++	int exposure_max, exposure_def, hblank, pixel_rate, rate_factor;
+ 	int i, ret;
+ 
+ 	ctrl_hdlr = &imx219->ctrl_handler;
+@@ -1353,8 +1406,12 @@ static int imx219_init_controls(struct i
+ 	mutex_init(&imx219->mutex);
+ 	ctrl_hdlr->lock = &imx219->mutex;
+ 
++	rate_factor = imx219_get_rate_factor(imx219);
++	if (rate_factor < 0)
++		return rate_factor;
++
+ 	/* By default, PIXEL_RATE is read only */
+-	pixel_rate = IMX219_PIXEL_RATE * imx219->mode->rate_factor;
++	pixel_rate = IMX219_PIXEL_RATE * rate_factor;
+ 	imx219->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,
+ 					       V4L2_CID_PIXEL_RATE,
+ 					       pixel_rate, pixel_rate,
+@@ -1576,6 +1633,9 @@ static int imx219_probe(struct i2c_clien
+ 		goto error_power_off;
+ 	usleep_range(100, 110);
+ 
++	/* Initialize default format */
++	imx219_set_default_format(imx219);
++
+ 	ret = imx219_init_controls(imx219);
+ 	if (ret)
+ 		goto error_power_off;
+@@ -1590,9 +1650,6 @@ static int imx219_probe(struct i2c_clien
+ 	imx219->pad[IMAGE_PAD].flags = MEDIA_PAD_FL_SOURCE;
+ 	imx219->pad[METADATA_PAD].flags = MEDIA_PAD_FL_SOURCE;
+ 
+-	/* Initialize default format */
+-	imx219_set_default_format(imx219);
+-
+ 	ret = media_entity_pads_init(&imx219->sd.entity, NUM_PADS, imx219->pad);
+ 	if (ret) {
+ 		dev_err(dev, "failed to init entity pads: %d\n", ret);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0791-serial-sc16is7xx-Read-modem-line-state-at-startup.patch b/target/linux/bcm27xx/patches-6.1/950-0791-serial-sc16is7xx-Read-modem-line-state-at-startup.patch
new file mode 100644
index 0000000000..c54c4472ed
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0791-serial-sc16is7xx-Read-modem-line-state-at-startup.patch
@@ -0,0 +1,28 @@
+From 52039b6ffb6e78c2f77319b167dceab9aa51d13f Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 13 Jun 2023 16:12:54 +0100
+Subject: [PATCH] serial: sc16is7xx: Read modem line state at startup
+
+This patch sets the driver modem line state to the actual line state
+at driver startup.
+
+See: https://github.com/raspberrypi/linux/issues/5501
+
+Signed-off-by: Earl Schmidt <schmidt.earl.f@gmail.com>
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/tty/serial/sc16is7xx.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/tty/serial/sc16is7xx.c
++++ b/drivers/tty/serial/sc16is7xx.c
+@@ -1223,6 +1223,9 @@ static int sc16is7xx_startup(struct uart
+ 	      SC16IS7XX_IER_MSI_BIT;
+ 	sc16is7xx_port_write(port, SC16IS7XX_IER_REG, val);
+ 
++	/* Initialize the Modem Control signals to current status */
++	one->old_mctrl = sc16is7xx_get_hwmctrl(port);
++
+ 	/* Enable modem status polling */
+ 	spin_lock_irqsave(&port->lock, flags);
+ 	sc16is7xx_enable_ms(port);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0792-drivers-media-bcm2835_unicam-Improve-frame-sequence-.patch b/target/linux/bcm27xx/patches-6.1/950-0792-drivers-media-bcm2835_unicam-Improve-frame-sequence-.patch
new file mode 100644
index 0000000000..6de340c2a9
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0792-drivers-media-bcm2835_unicam-Improve-frame-sequence-.patch
@@ -0,0 +1,79 @@
+From 6ef818eed60db70e9caf6bdf74cc1f9943994226 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Fri, 16 Jun 2023 16:24:19 +0100
+Subject: [PATCH] drivers: media: bcm2835_unicam: Improve frame sequence count
+ handling
+
+Ensure that the frame sequence counter is incremented only if a previous
+frame start interrupt has occurred, or a frame start + frame end has
+occurred simultaneously.
+
+This corresponds the sequence number with the actual number of frames
+produced by the sensor, not the number of frame buffers dequeued back
+to userland.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ .../media/platform/bcm2835/bcm2835-unicam.c   | 19 ++++++++++++++++++-
+ 1 file changed, 18 insertions(+), 1 deletion(-)
+
+--- a/drivers/media/platform/bcm2835/bcm2835-unicam.c
++++ b/drivers/media/platform/bcm2835/bcm2835-unicam.c
+@@ -522,6 +522,7 @@ struct unicam_device {
+ 	/* subdevice async Notifier */
+ 	struct v4l2_async_notifier notifier;
+ 	unsigned int sequence;
++	bool frame_started;
+ 
+ 	/* ptr to  sub device */
+ 	struct v4l2_subdev *sensor;
+@@ -914,6 +915,8 @@ static irqreturn_t unicam_isr(int irq, v
+ 	 * buffer forever.
+ 	 */
+ 	if (fe) {
++		bool inc_seq = unicam->frame_started;
++
+ 		/*
+ 		 * Ensure we have swapped buffers already as we can't
+ 		 * stop the peripheral. If no buffer is available, use a
+@@ -949,11 +952,23 @@ static irqreturn_t unicam_isr(int irq, v
+ 				unicam_process_buffer_complete(node, sequence);
+ 				node->cur_frm = node->next_frm;
+ 				node->next_frm = NULL;
++				inc_seq = true;
+ 			} else {
+ 				node->cur_frm = node->next_frm;
+ 			}
+ 		}
+-		unicam->sequence++;
++
++		/*
++		 * Increment the sequence number conditionally on either a FS
++		 * having already occurred, or in the FE + FS condition as
++		 * caught in the FE handler above. This ensures the sequence
++		 * number corresponds to the frames generated by the sensor, not
++		 * the frames dequeued to userland.
++		 */
++		if (inc_seq) {
++			unicam->sequence++;
++			unicam->frame_started = false;
++		}
+ 	}
+ 
+ 	if (ista & UNICAM_FSI) {
+@@ -996,6 +1011,7 @@ static irqreturn_t unicam_isr(int irq, v
+ 		}
+ 
+ 		unicam_queue_event_sof(unicam);
++		unicam->frame_started = true;
+ 	}
+ 
+ 	/*
+@@ -2600,6 +2616,7 @@ static int unicam_start_streaming(struct
+ 			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+ 	}
+ 
++	dev->frame_started = false;
+ 	unicam_start_rx(dev, buffer_addr);
+ 
+ 	ret = v4l2_subdev_call(dev->sensor, video, s_stream, 1);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0793-dtoverlays-Fix-pitft-28-35-overlays-for-6.1-driver-c.patch b/target/linux/bcm27xx/patches-6.1/950-0793-dtoverlays-Fix-pitft-28-35-overlays-for-6.1-driver-c.patch
new file mode 100644
index 0000000000..d8307f9009
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0793-dtoverlays-Fix-pitft-28-35-overlays-for-6.1-driver-c.patch
@@ -0,0 +1,41 @@
+From bd8e59b0456870997fb917bcd3b3b696e78d4ac2 Mon Sep 17 00:00:00 2001
+From: 6by9 <6by9@users.noreply.github.com>
+Date: Mon, 19 Jun 2023 16:02:36 +0100
+Subject: [PATCH] dtoverlays: Fix pitft[28|35] overlays for 6.1 driver change.
+ (#5508)
+
+The overlays configured both irq-gpio and an interrupts/
+interrupt-parent configuration for the stmpe MFD device.
+
+irq-gpio was reworked in 6.1 and has issues with the configuration
+as provided. Removing it and using the interrupts/interrupt-parent
+configuration works fine, so do that.
+
+See: https://forums.raspberrypi.com/viewtopic.php?t=351394
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/pitft28-resistive-overlay.dts | 1 -
+ arch/arm/boot/dts/overlays/pitft35-resistive-overlay.dts | 1 -
+ 2 files changed, 2 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/pitft28-resistive-overlay.dts
++++ b/arch/arm/boot/dts/overlays/pitft28-resistive-overlay.dts
+@@ -68,7 +68,6 @@
+ 				reg = <1>;
+ 
+ 				spi-max-frequency = <500000>;
+-				irq-gpio = <&gpio 24 0x2>; /* IRQF_TRIGGER_FALLING */
+ 				interrupts = <24 2>; /* high-to-low edge triggered */
+ 				interrupt-parent = <&gpio>;
+ 				interrupt-controller;
+--- a/arch/arm/boot/dts/overlays/pitft35-resistive-overlay.dts
++++ b/arch/arm/boot/dts/overlays/pitft35-resistive-overlay.dts
+@@ -68,7 +68,6 @@
+ 				reg = <1>;
+ 
+ 				spi-max-frequency = <500000>;
+-				irq-gpio = <&gpio 24 0x2>; /* IRQF_TRIGGER_FALLING */
+ 				interrupts = <24 2>; /* high-to-low edge triggered */
+ 				interrupt-parent = <&gpio>;
+ 				interrupt-controller;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0795-driver-media-i2c-imx477-Re-enable-temperature-sensor.patch b/target/linux/bcm27xx/patches-6.1/950-0795-driver-media-i2c-imx477-Re-enable-temperature-sensor.patch
new file mode 100644
index 0000000000..2255efd988
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0795-driver-media-i2c-imx477-Re-enable-temperature-sensor.patch
@@ -0,0 +1,23 @@
+From 713a7ef9d73fca0f7fed122cb854d930b7a6ba5a Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Wed, 21 Jun 2023 08:45:02 +0100
+Subject: [PATCH] driver: media: i2c: imx477: Re-enable temperature sensor
+
+The temperature sensor enable register write got lost at some point.
+Re-enable it.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/i2c/imx477.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/media/i2c/imx477.c
++++ b/drivers/media/i2c/imx477.c
+@@ -167,6 +167,7 @@ struct imx477_mode {
+ static const struct imx477_reg mode_common_regs[] = {
+ 	{0x0136, 0x18},
+ 	{0x0137, 0x00},
++	{0x0138, 0x01},
+ 	{0xe000, 0x00},
+ 	{0xe07a, 0x01},
+ 	{0x0808, 0x02},
diff --git a/target/linux/bcm27xx/patches-6.1/950-0796-overlays-allo-katana-dac-audio-Reduce-I2C-clock.patch b/target/linux/bcm27xx/patches-6.1/950-0796-overlays-allo-katana-dac-audio-Reduce-I2C-clock.patch
new file mode 100644
index 0000000000..43f63a1c63
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0796-overlays-allo-katana-dac-audio-Reduce-I2C-clock.patch
@@ -0,0 +1,25 @@
+From d4c3133378b377ee519ea50247339cd61221fc47 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 21 Jun 2023 09:20:36 +0100
+Subject: [PATCH] overlays: allo-katana-dac-audio: Reduce I2C clock
+
+Higher speeds have been shown to cause data corruption on a Pi 4,
+possibly due to clock-stretching.
+
+See: https://github.com/raspberrypi/linux/issues/5511
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/allo-katana-dac-audio-overlay.dts | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm/boot/dts/overlays/allo-katana-dac-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/allo-katana-dac-audio-overlay.dts
+@@ -30,6 +30,7 @@
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			status = "okay";
++			clock-frequency = <50000>;
+ 
+ 			allo-katana-codec@30 {
+ 				#sound-dai-cells = <0>;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0797-overlays-jedec-spi-nor-Add-speed-parameter.patch b/target/linux/bcm27xx/patches-6.1/950-0797-overlays-jedec-spi-nor-Add-speed-parameter.patch
new file mode 100644
index 0000000000..66c147837d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0797-overlays-jedec-spi-nor-Add-speed-parameter.patch
@@ -0,0 +1,308 @@
+From 76c457e7e2920342637b1955fbaadf2aae282f05 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 23 Jun 2023 09:48:59 +0100
+Subject: [PATCH] overlays: jedec-spi-nor: Add speed parameter
+
+Add a speed parameter to the jedec-spi-nor overlay to allow much
+faster accesses, taking the opportunity to simplify the internals.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README             |   8 +-
+ .../dts/overlays/jedec-spi-nor-overlay.dts    | 245 +++---------------
+ 2 files changed, 41 insertions(+), 212 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -2557,9 +2557,11 @@ Name:   jedec-spi-nor
+ Info:   Adds support for JEDEC-compliant SPI NOR flash devices.  (Note: The
+         "jedec,spi-nor" kernel driver was formerly known as "m25p80".)
+ Load:   dtoverlay=jedec-spi-nor,<param>=<val>
+-Params: flash-spi<n>-<m>        Enables flash device on SPI<n>, CS#<m>.
+-        flash-fastr-spi<n>-<m>  Enables flash device with fast read capability
+-                                on SPI<n>, CS#<m>.
++Params: spi<n>-<m>              Enable flash device on SPI<n>, CS#<m>
++        fastr                   Add fast read capability to the flash device
++        speed                   Maximum SPI frequency (Hz)
++        flash-spi<n>-<m>        Same as spi<n>-<m> (deprecated)
++        flash-fastr-spi<n>-<m>  Same as spi<n>->m>,fastr (deprecated)
+ 
+ 
+ Name:   justboom-both
+--- a/arch/arm/boot/dts/overlays/jedec-spi-nor-overlay.dts
++++ b/arch/arm/boot/dts/overlays/jedec-spi-nor-overlay.dts
+@@ -3,6 +3,7 @@
+ // dtparams:
+ //     flash-spi<n>-<m>        - Enables flash device on SPI<n>, CS#<m>.
+ //     flash-fastr-spi<n>-<m>  - Enables flash device with fast read capability on SPI<n>, CS#<m>.
++//     speed                   - Set the SPI clock speed in Hz
+ //
+ // If devices are present on SPI1 or SPI2, those interfaces must be enabled with one of the spi1-1/2/3cs and/or spi2-1/2/3cs overlays.
+ //
+@@ -79,50 +80,23 @@
+ 		};
+ 	};
+ 
+-	// enable flash on spi0.0
++	// Enable fast read for device
++	// Use default active low interrupt signalling.
+ 	fragment@8 {
+-		target = <&spi0>;
++		target = <&spi_nor>;
+ 		__dormant__ {
+-			status = "okay";
+-                        #address-cells = <1>;
+-                        #size-cells = <0>;
+-			spi_nor_00: spi_nor@0 {
+-				#address-cells = <1>;
+-				#size-cells = <1>;
+-				compatible = "jedec,spi-nor";
+-				reg = <0>;
+-				spi-max-frequency = <500000>;
+-			};
++			m25p,fast-read;
+ 		};
+ 	};
+ 
+-	// enable flash on spi0.1
+-	fragment@9 {
++	payload: fragment@100 {
+ 		target = <&spi0>;
+-		__dormant__ {
++		__overlay__ {
+ 			status = "okay";
+-                        #address-cells = <1>;
+-                        #size-cells = <0>;
+-			spi_nor_01: spi_nor@1 {
+-				#address-cells = <1>;
+-				#size-cells = <1>;
+-				compatible = "jedec,spi-nor";
+-				reg = <1>;
+-				spi-max-frequency = <500000>;
+-			};
+-		};
+-	};
++			#address-cells = <1>;
++			#size-cells = <0>;
+ 
+-	// enable flash on spi1.0
+-	fragment@10 {
+-		target = <&spi1>;
+-		__dormant__ {
+-			status = "okay";
+-                        #address-cells = <1>;
+-                        #size-cells = <0>;
+-			spi_nor_10: spi_nor@0 {
+-				#address-cells = <1>;
+-				#size-cells = <1>;
++			spi_nor: spi_nor@0 {
+ 				compatible = "jedec,spi-nor";
+ 				reg = <0>;
+ 				spi-max-frequency = <500000>;
+@@ -130,180 +104,33 @@
+ 		};
+ 	};
+ 
+-	// enable flash on spi1.1
+-	fragment@11 {
+-		target = <&spi1>;
+-		__dormant__ {
+-			status = "okay";
+-                        #address-cells = <1>;
+-                        #size-cells = <0>;
+-			spi_nor_11: spi_nor@1 {
+-				#address-cells = <1>;
+-				#size-cells = <1>;
+-				compatible = "jedec,spi-nor";
+-				reg = <1>;
+-				spi-max-frequency = <500000>;
+-			};
+-		};
+-	};
+-
+-	// enable flash on spi1.2
+-	fragment@12 {
+-		target = <&spi1>;
+-		__dormant__ {
+-			status = "okay";
+-                        #address-cells = <1>;
+-                        #size-cells = <0>;
+-			spi_nor_12: spi_nor@2 {
+-				#address-cells = <1>;
+-				#size-cells = <1>;
+-				compatible = "jedec,spi-nor";
+-				reg = <2>;
+-				spi-max-frequency = <500000>;
+-			};
+-		};
+-	};
+-
+-	// enable flash on spi2.0
+-	fragment@13 {
+-		target = <&spi2>;
+-		__dormant__ {
+-			status = "okay";
+-                        #address-cells = <1>;
+-                        #size-cells = <0>;
+-			spi_nor_20: spi_nor@0 {
+-				#address-cells = <1>;
+-				#size-cells = <1>;
+-				compatible = "jedec,spi-nor";
+-				reg = <0>;
+-				spi-max-frequency = <500000>;
+-			};
+-		};
+-	};
+-
+-	// enable flash on spi2.1
+-	fragment@14 {
+-		target = <&spi2>;
+-		__dormant__ {
+-			status = "okay";
+-                        #address-cells = <1>;
+-                        #size-cells = <0>;
+-			spi_nor_21: spi_nor@1 {
+-				#address-cells = <1>;
+-				#size-cells = <1>;
+-				compatible = "jedec,spi-nor";
+-				reg = <1>;
+-				spi-max-frequency = <500000>;
+-			};
+-		};
+-	};
+-
+-	// enable flash on spi2.2
+-	fragment@15 {
+-		target = <&spi2>;
+-		__dormant__ {
+-			status = "okay";
+-                        #address-cells = <1>;
+-                        #size-cells = <0>;
+-			spi_nor_22: spi_nor@2 {
+-				#address-cells = <1>;
+-				#size-cells = <1>;
+-				compatible = "jedec,spi-nor";
+-				reg = <2>;
+-				spi-max-frequency = <500000>;
+-			};
+-		};
+-	};
+-
+-	// Enable fast read for device on spi0.0.
+-	// Use default active low interrupt signalling.
+-	fragment@16 {
+-		target = <&spi_nor_00>;
+-		__dormant__ {
+-			m25p,fast-read;
+-		};
+-	};
+-
+-	// Enable fast read for device on spi0.1.
+-	// Use default active low interrupt signalling.
+-	fragment@17 {
+-		target = <&spi_nor_01>;
+-		__dormant__ {
+-			m25p,fast-read;
+-		};
+-	};
+-
+-	// Enable fast read for device on spi1.0.
+-	// Use default active low interrupt signalling.
+-	fragment@18 {
+-		target = <&spi_nor_10>;
+-		__dormant__ {
+-			m25p,fast-read;
+-		};
+-	};
+-
+-	// Enable fast read for device on spi1.1.
+-	// Use default active low interrupt signalling.
+-	fragment@19 {
+-		target = <&spi_nor_11>;
+-		__dormant__ {
+-			m25p,fast-read;
+-		};
+-	};
+-
+-	// Enable fast read for device on spi1.2.
+-	// Use default active low interrupt signalling.
+-	fragment@20 {
+-		target = <&spi_nor_12>;
+-		__dormant__ {
+-			m25p,fast-read;
+-		};
+-	};
+-
+-	// Enable fast read for device on spi2.0.
+-	// Use default active low interrupt signalling.
+-	fragment@21 {
+-		target = <&spi_nor_20>;
+-		__dormant__ {
+-			m25p,fast-read;
+-		};
+-	};
+-
+-	// Enable fast read for device on spi2.1.
+-	// Use default active low interrupt signalling.
+-	fragment@22 {
+-		target = <&spi_nor_21>;
+-		__dormant__ {
+-			m25p,fast-read;
+-		};
+-	};
+-
+-	// Enable fast read for device on spi2.2.
+-	// Use default active low interrupt signalling.
+-	fragment@23 {
+-		target = <&spi_nor_22>;
+-		__dormant__ {
+-			m25p,fast-read;
+-		};
+-	};
+-
+ 	__overrides__ {
+-		flash-spi0-0       = <0>,"+0+8";
+-		flash-spi0-1       = <0>,"+1+9";
+-		flash-spi1-0       = <0>,"+2+10";
+-		flash-spi1-1       = <0>,"+3+11";
+-		flash-spi1-2       = <0>,"+4+12";
+-		flash-spi2-0       = <0>,"+5+13";
+-		flash-spi2-1       = <0>,"+6+14";
+-		flash-spi2-2       = <0>,"+7+15";
+-		flash-fastr-spi0-0 = <0>,"+0+8+16";
+-		flash-fastr-spi0-1 = <0>,"+1+9+17";
+-		flash-fastr-spi1-0 = <0>,"+2+10+18";
+-		flash-fastr-spi1-1 = <0>,"+3+11+19";
+-		flash-fastr-spi1-2 = <0>,"+4+12+20";
+-		flash-fastr-spi2-0 = <0>,"+5+13+21";
+-		flash-fastr-spi2-1 = <0>,"+6+14+22";
+-		flash-fastr-spi2-2 = <0>,"+7+15+23";
++		spi0-0             = <0>,"+0", <&payload>,"target:0=",<&spi0>, <&spi_nor>,"reg:0=0";
++		spi0-1             = <0>,"+1", <&payload>,"target:0=",<&spi0>, <&spi_nor>,"reg:0=1";
++		spi1-0             = <0>,"+2", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=0";
++		spi1-1             = <0>,"+3", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=1";
++		spi1-2             = <0>,"+4", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=2";
++		spi2-0             = <0>,"+5", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=0";
++		spi2-1             = <0>,"+6", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=1";
++		spi2-2             = <0>,"+7", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=2";
++		flash-spi0-0       = <0>,"+0", <&payload>,"target:0=",<&spi0>, <&spi_nor>,"reg:0=0";
++		flash-spi0-1       = <0>,"+1", <&payload>,"target:0=",<&spi0>, <&spi_nor>,"reg:0=1";
++		flash-spi1-0       = <0>,"+2", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=0";
++		flash-spi1-1       = <0>,"+3", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=1";
++		flash-spi1-2       = <0>,"+4", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=2";
++		flash-spi2-0       = <0>,"+5", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=0";
++		flash-spi2-1       = <0>,"+6", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=1";
++		flash-spi2-2       = <0>,"+7", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=2";
++		flash-fastr-spi0-0 = <0>,"+0+8", <&payload>,"target:0=",<&spi0>, <&spi_nor>,"reg:0=0";
++		flash-fastr-spi0-1 = <0>,"+1+8", <&payload>,"target:0=",<&spi0>, <&spi_nor>,"reg:0=1";
++		flash-fastr-spi1-0 = <0>,"+2+8", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=0";
++		flash-fastr-spi1-1 = <0>,"+3+8", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=1";
++		flash-fastr-spi1-2 = <0>,"+4+8", <&payload>,"target:0=",<&spi1>, <&spi_nor>,"reg:0=2";
++		flash-fastr-spi2-0 = <0>,"+5+8", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=0";
++		flash-fastr-spi2-1 = <0>,"+6+8", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=1";
++		flash-fastr-spi2-2 = <0>,"+7+8", <&payload>,"target:0=",<&spi2>, <&spi_nor>,"reg:0=2";
++		fastr              = <0>,"+8";
++		speed              = <&spi_nor>, "spi-max-frequency:0";
+ 	};
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0798-ALSA-pcm-fix-ELD-constraints-for-E-AC3-DTS-HD-and-ML.patch b/target/linux/bcm27xx/patches-6.1/950-0798-ALSA-pcm-fix-ELD-constraints-for-E-AC3-DTS-HD-and-ML.patch
new file mode 100644
index 0000000000..a35e7f4d1b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0798-ALSA-pcm-fix-ELD-constraints-for-E-AC3-DTS-HD-and-ML.patch
@@ -0,0 +1,137 @@
+From e866f9fc7c6dd6af1e74ce6fa50db9ba21acae5e Mon Sep 17 00:00:00 2001
+From: Matthias Reichl <hias@horus.com>
+Date: Sat, 24 Jun 2023 18:52:16 +0200
+Subject: [PATCH] ALSA: pcm: fix ELD constraints for (E)AC3, DTS(-HD) and MLP
+ formats
+
+commit 04b49b90caeed0b5544ff616d654900d27d403b6 upstream.
+
+The SADs of compressed formats contain the channel and sample rate
+info of the audio data inside the compressed stream, but when
+building constraints we must use the rates and channels used to
+transport the compressed streams.
+
+eg 48kHz 6ch EAC3 needs to be transmitted as a 2ch 192kHz stream.
+
+This patch fixes the constraints for the common AC3 and DTS formats,
+the constraints for the less common MPEG, DSD etc formats are copied
+directly from the info in the SADs as before as I don't have the specs
+and equipment to test those.
+
+Signed-off-by: Matthias Reichl <hias@horus.com>
+Link: https://lore.kernel.org/r/20230624165216.5719-1-hias@horus.com
+Signed-off-by: Takashi Iwai <tiwai@suse.de>
+---
+ sound/core/pcm_drm_eld.c | 73 ++++++++++++++++++++++++++++++++++++++--
+ 1 file changed, 70 insertions(+), 3 deletions(-)
+
+--- a/sound/core/pcm_drm_eld.c
++++ b/sound/core/pcm_drm_eld.c
+@@ -2,11 +2,25 @@
+ /*
+  *  PCM DRM helpers
+  */
++#include <linux/bitfield.h>
+ #include <linux/export.h>
++#include <linux/hdmi.h>
+ #include <drm/drm_edid.h>
+ #include <sound/pcm.h>
+ #include <sound/pcm_drm_eld.h>
+ 
++#define SAD0_CHANNELS_MASK	GENMASK(2, 0) /* max number of channels - 1 */
++#define SAD0_FORMAT_MASK	GENMASK(6, 3) /* audio format */
++
++#define SAD1_RATE_MASK		GENMASK(6, 0) /* bitfield of supported rates */
++#define SAD1_RATE_32000_MASK	BIT(0)
++#define SAD1_RATE_44100_MASK	BIT(1)
++#define SAD1_RATE_48000_MASK	BIT(2)
++#define SAD1_RATE_88200_MASK	BIT(3)
++#define SAD1_RATE_96000_MASK	BIT(4)
++#define SAD1_RATE_176400_MASK	BIT(5)
++#define SAD1_RATE_192000_MASK	BIT(6)
++
+ static const unsigned int eld_rates[] = {
+ 	32000,
+ 	44100,
+@@ -17,9 +31,62 @@ static const unsigned int eld_rates[] =
+ 	192000,
+ };
+ 
++static unsigned int map_rate_families(const u8 *sad,
++				      unsigned int mask_32000,
++				      unsigned int mask_44100,
++				      unsigned int mask_48000)
++{
++	unsigned int rate_mask = 0;
++
++	if (sad[1] & SAD1_RATE_32000_MASK)
++		rate_mask |= mask_32000;
++	if (sad[1] & (SAD1_RATE_44100_MASK | SAD1_RATE_88200_MASK | SAD1_RATE_176400_MASK))
++		rate_mask |= mask_44100;
++	if (sad[1] & (SAD1_RATE_48000_MASK | SAD1_RATE_96000_MASK | SAD1_RATE_192000_MASK))
++		rate_mask |= mask_48000;
++	return rate_mask;
++}
++
++static unsigned int sad_rate_mask(const u8 *sad)
++{
++	switch (FIELD_GET(SAD0_FORMAT_MASK, sad[0])) {
++	case HDMI_AUDIO_CODING_TYPE_PCM:
++		return sad[1] & SAD1_RATE_MASK;
++	case HDMI_AUDIO_CODING_TYPE_AC3:
++	case HDMI_AUDIO_CODING_TYPE_DTS:
++		return map_rate_families(sad,
++					 SAD1_RATE_32000_MASK,
++					 SAD1_RATE_44100_MASK,
++					 SAD1_RATE_48000_MASK);
++	case HDMI_AUDIO_CODING_TYPE_EAC3:
++	case HDMI_AUDIO_CODING_TYPE_DTS_HD:
++	case HDMI_AUDIO_CODING_TYPE_MLP:
++		return map_rate_families(sad,
++					 0,
++					 SAD1_RATE_176400_MASK,
++					 SAD1_RATE_192000_MASK);
++	default:
++		/* TODO adjust for other compressed formats as well */
++		return sad[1] & SAD1_RATE_MASK;
++	}
++}
++
+ static unsigned int sad_max_channels(const u8 *sad)
+ {
+-	return 1 + (sad[0] & 7);
++	switch (FIELD_GET(SAD0_FORMAT_MASK, sad[0])) {
++	case HDMI_AUDIO_CODING_TYPE_PCM:
++		return 1 + FIELD_GET(SAD0_CHANNELS_MASK, sad[0]);
++	case HDMI_AUDIO_CODING_TYPE_AC3:
++	case HDMI_AUDIO_CODING_TYPE_DTS:
++	case HDMI_AUDIO_CODING_TYPE_EAC3:
++		return 2;
++	case HDMI_AUDIO_CODING_TYPE_DTS_HD:
++	case HDMI_AUDIO_CODING_TYPE_MLP:
++		return 8;
++	default:
++		/* TODO adjust for other compressed formats as well */
++		return 1 + FIELD_GET(SAD0_CHANNELS_MASK, sad[0]);
++	}
+ }
+ 
+ static int eld_limit_rates(struct snd_pcm_hw_params *params,
+@@ -42,7 +109,7 @@ static int eld_limit_rates(struct snd_pc
+ 			 * requested number of channels.
+ 			 */
+ 			if (c->min <= max_channels)
+-				rate_mask |= sad[1];
++				rate_mask |= sad_rate_mask(sad);
+ 		}
+ 	}
+ 
+@@ -70,7 +137,7 @@ static int eld_limit_channels(struct snd
+ 				rate_mask |= BIT(i);
+ 
+ 		for (i = drm_eld_sad_count(eld); i > 0; i--, sad += 3)
+-			if (rate_mask & sad[1])
++			if (rate_mask & sad_rate_mask(sad))
+ 				t.max = max(t.max, sad_max_channels(sad));
+ 	}
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0799-ASoC-hdmi-codec-fix-channel-info-for-compressed-form.patch b/target/linux/bcm27xx/patches-6.1/950-0799-ASoC-hdmi-codec-fix-channel-info-for-compressed-form.patch
new file mode 100644
index 0000000000..31a351a4e8
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0799-ASoC-hdmi-codec-fix-channel-info-for-compressed-form.patch
@@ -0,0 +1,86 @@
+From 3f388718331b5ce2acd34730448db001759868aa Mon Sep 17 00:00:00 2001
+From: Matthias Reichl <hias@horus.com>
+Date: Sat, 24 Jun 2023 18:52:32 +0200
+Subject: [PATCH] ASoC: hdmi-codec: fix channel info for compressed formats
+
+commit 4e0871333661d2ec0ed3dc00a945c2160eccae77 upstream.
+
+According to CTA 861 the channel/speaker allocation info in the
+audio infoframe only applies to uncompressed (PCM) audio streams.
+
+The channel count info should indicate the number of channels
+in the transmitted audio, which usually won't match the number of
+channels used to transmit the compressed bitstream.
+
+Some devices (eg some Sony TVs) will refuse to decode compressed
+audio if these values are not set correctly.
+
+To fix this we can simply set the channel count to 0 (which means
+"refer to stream header") and set the channel/speaker allocation to 0
+as well (which would mean stereo FL/FR for PCM, a safe value all sinks
+will support) when transmitting compressed audio.
+
+Signed-off-by: Matthias Reichl <hias@horus.com>
+Link: https://lore.kernel.org/r/20230624165232.5751-1-hias@horus.com
+Signed-off-by: Takashi Iwai <tiwai@suse.de>
+---
+ sound/soc/codecs/hdmi-codec.c | 36 +++++++++++++++++++++++------------
+ 1 file changed, 24 insertions(+), 12 deletions(-)
+
+--- a/sound/soc/codecs/hdmi-codec.c
++++ b/sound/soc/codecs/hdmi-codec.c
+@@ -484,31 +484,43 @@ static int hdmi_codec_fill_codec_params(
+ 					struct hdmi_codec_params *hp)
+ {
+ 	struct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);
+-	int idx;
++	int idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;
++	u8 ca_id = 0;
++	bool pcm_audio = !(hcp->iec_status[0] & IEC958_AES0_NONAUDIO);
++
++	if (pcm_audio) {
++		/* Select a channel allocation that matches with ELD and pcm channels */
++		idx = hdmi_codec_get_ch_alloc_table_idx(hcp, channels);
++
++		if (idx < 0) {
++			dev_err(dai->dev, "Not able to map channels to speakers (%d)\n",
++				idx);
++			hcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;
++			return idx;
++		}
+ 
+-	/* Select a channel allocation that matches with ELD and pcm channels */
+-	idx = hdmi_codec_get_ch_alloc_table_idx(hcp, channels);
+-	if (idx < 0) {
+-		dev_err(dai->dev, "Not able to map channels to speakers (%d)\n",
+-			idx);
+-		hcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;
+-		return idx;
++		ca_id = hdmi_codec_channel_alloc[idx].ca_id;
+ 	}
+ 
+ 	memset(hp, 0, sizeof(*hp));
+ 
+ 	hdmi_audio_infoframe_init(&hp->cea);
+-	hp->cea.channels = channels;
++
++	if (pcm_audio)
++		hp->cea.channels = channels;
++	else
++		hp->cea.channels = 0;
++
+ 	hp->cea.coding_type = HDMI_AUDIO_CODING_TYPE_STREAM;
+ 	hp->cea.sample_size = HDMI_AUDIO_SAMPLE_SIZE_STREAM;
+ 	hp->cea.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM;
+-	hp->cea.channel_allocation = hdmi_codec_channel_alloc[idx].ca_id;
++	hp->cea.channel_allocation = ca_id;
+ 
+ 	hp->sample_width = sample_width;
+ 	hp->sample_rate = sample_rate;
+ 	hp->channels = channels;
+ 
+-	hcp->chmap_idx = hdmi_codec_channel_alloc[idx].ca_id;
++	hcp->chmap_idx = idx;
+ 
+ 	return 0;
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0800-media-i2c-arducam_64mp-Modify-the-line-length-of-128.patch b/target/linux/bcm27xx/patches-6.1/950-0800-media-i2c-arducam_64mp-Modify-the-line-length-of-128.patch
new file mode 100644
index 0000000000..a423b8061b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0800-media-i2c-arducam_64mp-Modify-the-line-length-of-128.patch
@@ -0,0 +1,44 @@
+From 9c5a7f04cab6b020389d7c5af155b1ee7f46537d Mon Sep 17 00:00:00 2001
+From: Lee Jackson <lee.jackson@arducam.com>
+Date: Thu, 4 May 2023 11:14:04 +0800
+Subject: [PATCH] media: i2c: arducam_64mp: Modify the line length of 1280x720
+ resolution
+
+Arducam 64MP has specific requirements for the line length, and if these
+conditions are not met, the camera will not function properly. Under the
+previous configuration, once a stream off operation is performed, the
+camera will not output any data, even if a stream on operation is
+performed. This prevents us from switching from 1280x720 to another
+resolution.
+
+Signed-off-by: Lee Jackson <lee.jackson@arducam.com>
+---
+ drivers/media/i2c/arducam_64mp.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+--- a/drivers/media/i2c/arducam_64mp.c
++++ b/drivers/media/i2c/arducam_64mp.c
+@@ -1063,10 +1063,10 @@ static const struct arducam_64mp_reg mod
+ 
+ /* 720p 120fps mode */
+ static const struct arducam_64mp_reg mode_1280x720_regs[] = {
+-	{0x0342, 0x1d},
+-	{0x0343, 0xc4},
+-	{0x0340, 0x03},
+-	{0x0341, 0xd8},
++	{0x0342, 0x1b},
++	{0x0343, 0x08},
++	{0x0340, 0x04},
++	{0x0341, 0x3b},
+ 	{0x0344, 0x08},
+ 	{0x0345, 0x10},
+ 	{0x0346, 0x07},
+@@ -1209,7 +1209,7 @@ static const struct arducam_64mp_mode su
+ 	}, {
+ 		.width = 1280,
+ 		.height = 720,
+-		.line_length_pix = 0x1dc4,
++		.line_length_pix = 0x1b08,
+ 		.crop = {
+ 			.left = ARDUCAM_64MP_PIXEL_ARRAY_LEFT + 2064,
+ 			.top = ARDUCAM_64MP_PIXEL_ARRAY_TOP + 2032,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0801-media-i2c-arducam_64mp-Add-8000x6000-resolution.patch b/target/linux/bcm27xx/patches-6.1/950-0801-media-i2c-arducam_64mp-Add-8000x6000-resolution.patch
new file mode 100644
index 0000000000..475ae634ad
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0801-media-i2c-arducam_64mp-Add-8000x6000-resolution.patch
@@ -0,0 +1,105 @@
+From 7b3d0124c5cf462d5be0b0d4e558002b74750911 Mon Sep 17 00:00:00 2001
+From: Lee Jackson <lee.jackson@arducam.com>
+Date: Fri, 5 May 2023 14:36:15 +0800
+Subject: [PATCH] media: i2c: arducam_64mp: Add 8000x6000 resolution
+
+Added 8000x6000 10-bit (cropped) @ 3fps mode for Arducam 64MP
+
+Signed-off-by: Lee Jackson <lee.jackson@arducam.com>
+---
+ drivers/media/i2c/arducam_64mp.c | 77 ++++++++++++++++++++++++++++++++
+ 1 file changed, 77 insertions(+)
+
+--- a/drivers/media/i2c/arducam_64mp.c
++++ b/drivers/media/i2c/arducam_64mp.c
+@@ -849,6 +849,65 @@ static const struct arducam_64mp_reg mod
+ 	{0x020f, 0x00},
+ };
+ 
++/* 48 mpix 3.0fps */
++static const struct arducam_64mp_reg mode_8000x6000_regs[] = {
++	{0x0342, 0xb6},
++	{0x0343, 0xb2},
++	{0x0340, 0x19},
++	{0x0341, 0x0e},
++	{0x0344, 0x02},
++	{0x0345, 0x70},
++	{0x0346, 0x01},
++	{0x0347, 0xd8},
++	{0x0348, 0x21},
++	{0x0349, 0xaf},
++	{0x034a, 0x19},
++	{0x034b, 0x47},
++	{0x0900, 0x00},
++	{0x0901, 0x11},
++	{0x0902, 0x0a},
++	{0x30d8, 0x00},
++	{0x3200, 0x01},
++	{0x3201, 0x01},
++	{0x0408, 0x00},
++	{0x0409, 0x00},
++	{0x040a, 0x00},
++	{0x040b, 0x00},
++	{0x040c, 0x1f},
++	{0x040d, 0x40},
++	{0x040e, 0x17},
++	{0x040f, 0x70},
++	{0x034c, 0x1f},
++	{0x034d, 0x40},
++	{0x034e, 0x17},
++	{0x034f, 0x70},
++	{0x30d9, 0x01},
++	{0x32d5, 0x01},
++	{0x32d6, 0x00},
++	{0x401e, 0x00},
++	{0x40b8, 0x04},
++	{0x40b9, 0x20},
++	{0x40bc, 0x02},
++	{0x40bd, 0x58},
++	{0x40be, 0x02},
++	{0x40bf, 0x58},
++	{0x41a4, 0x00},
++	{0x5a09, 0x01},
++	{0x5a17, 0x01},
++	{0x5a25, 0x01},
++	{0x5a33, 0x01},
++	{0x98d7, 0x14},
++	{0x98d8, 0x14},
++	{0x98d9, 0x00},
++	{0x99c4, 0x00},
++	{0x0202, 0x03},
++	{0x0203, 0xe8},
++	{0x0204, 0x00},
++	{0x0205, 0x00},
++	{0x020e, 0x01},
++	{0x020f, 0x00},
++};
++
+ /* 16 mpix 10fps */
+ static const struct arducam_64mp_reg mode_4624x3472_regs[] = {
+ 	{0x0342, 0x63},
+@@ -1135,6 +1194,24 @@ static const struct arducam_64mp_mode su
+ 			.regs = mode_9152x6944_regs,
+ 		}
+ 	}, {
++		.width = 8000,
++		.height = 6000,
++		.line_length_pix = 0xb6b2,
++		.crop = {
++			.left = ARDUCAM_64MP_PIXEL_ARRAY_LEFT + 624,
++			.top = ARDUCAM_64MP_PIXEL_ARRAY_TOP + 472,
++			.width = 9248,
++			.height = 6944,
++		},
++		.timeperframe_default = {
++			.numerator = 100,
++			.denominator = 300
++		},
++		.reg_list = {
++			.num_of_regs = ARRAY_SIZE(mode_8000x6000_regs),
++			.regs = mode_8000x6000_regs,
++		}
++	}, {
+ 		.width = 4624,
+ 		.height = 3472,
+ 		.line_length_pix = 0x6397,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0802-media-i2c-arducam_64mp-Add-PDAF-support.patch b/target/linux/bcm27xx/patches-6.1/950-0802-media-i2c-arducam_64mp-Add-PDAF-support.patch
new file mode 100644
index 0000000000..8f96b33baa
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0802-media-i2c-arducam_64mp-Add-PDAF-support.patch
@@ -0,0 +1,163 @@
+From b9d2d1862aa5b798cecb87a95d970ad34a4aebc0 Mon Sep 17 00:00:00 2001
+From: Lee Jackson <lee.jackson@arducam.com>
+Date: Tue, 30 May 2023 15:50:05 +0800
+Subject: [PATCH] media: i2c: arducam_64mp: Add PDAF support
+
+Enable PDAF output for all modes, and also need to modify Embedded Line
+Width to 11560 * 3 (two lines of Embedded Data + one line of PDAF).
+
+Signed-off-by: Lee Jackson <lee.jackson@arducam.com>
+---
+ drivers/media/i2c/arducam_64mp.c | 64 ++++++++++++++++++++++++++++++--
+ 1 file changed, 61 insertions(+), 3 deletions(-)
+
+--- a/drivers/media/i2c/arducam_64mp.c
++++ b/drivers/media/i2c/arducam_64mp.c
+@@ -95,7 +95,7 @@
+ #define ARDUCAM_64MP_TEST_PATTERN_GB_DEFAULT	0
+ 
+ /* Embedded metadata stream structure */
+-#define ARDUCAM_64MP_EMBEDDED_LINE_WIDTH 16384
++#define ARDUCAM_64MP_EMBEDDED_LINE_WIDTH (11560 * 3)
+ #define ARDUCAM_64MP_NUM_EMBEDDED_LINES 1
+ 
+ enum pad_types {
+@@ -144,6 +144,7 @@ struct arducam_64mp_mode {
+ };
+ 
+ static const struct arducam_64mp_reg mode_common_regs[] = {
++	{0x0100, 0x00},
+ 	{0x0136, 0x18},
+ 	{0x0137, 0x00},
+ 	{0x33F0, 0x01},
+@@ -788,6 +789,7 @@ static const struct arducam_64mp_reg mod
+ 	{0x3092, 0x01},
+ 	{0x3093, 0x00},
+ 	{0x0350, 0x00},
++	{0x3419, 0x00},
+ };
+ 
+ /* 64 mpix 2.7fps */
+@@ -847,6 +849,14 @@ static const struct arducam_64mp_reg mod
+ 	{0x0205, 0x00},
+ 	{0x020e, 0x01},
+ 	{0x020f, 0x00},
++	{0x341a, 0x00},
++	{0x341b, 0x00},
++	{0x341c, 0x00},
++	{0x341d, 0x00},
++	{0x341e, 0x02},
++	{0x341f, 0x3c},
++	{0x3420, 0x02},
++	{0x3421, 0x42},
+ };
+ 
+ /* 48 mpix 3.0fps */
+@@ -906,6 +916,14 @@ static const struct arducam_64mp_reg mod
+ 	{0x0205, 0x00},
+ 	{0x020e, 0x01},
+ 	{0x020f, 0x00},
++	{0x341a, 0x00},
++	{0x341b, 0x00},
++	{0x341c, 0x00},
++	{0x341d, 0x00},
++	{0x341e, 0x01},
++	{0x341f, 0xf4},
++	{0x3420, 0x01},
++	{0x3421, 0xf4},
+ };
+ 
+ /* 16 mpix 10fps */
+@@ -959,6 +977,14 @@ static const struct arducam_64mp_reg mod
+ 	{0x98d8, 0x8c},
+ 	{0x98d9, 0x0a},
+ 	{0x99c4, 0x16},
++	{0x341a, 0x00},
++	{0x341b, 0x00},
++	{0x341c, 0x00},
++	{0x341d, 0x00},
++	{0x341e, 0x01},
++	{0x341f, 0x21},
++	{0x3420, 0x01},
++	{0x3421, 0x21},
+ };
+ 
+ /* 4k 20fps mode */
+@@ -1012,6 +1038,14 @@ static const struct arducam_64mp_reg mod
+ 	{0x98d8, 0x8c},
+ 	{0x98d9, 0x0a},
+ 	{0x99c4, 0x16},
++	{0x341a, 0x00},
++	{0x341b, 0x00},
++	{0x341c, 0x00},
++	{0x341d, 0x00},
++	{0x341e, 0x00},
++	{0x341f, 0xf0},
++	{0x3420, 0x00},
++	{0x3421, 0xb4},
+ };
+ 
+ /* 4x4 binned 30fps mode */
+@@ -1031,7 +1065,7 @@ static const struct arducam_64mp_reg mod
+ 	{0x0900, 0x01},
+ 	{0x0901, 0x44},
+ 	{0x0902, 0x08},
+-	{0x30d8, 0x00},
++	{0x30d8, 0x04},
+ 	{0x3200, 0x43},
+ 	{0x3201, 0x43},
+ 	{0x0408, 0x00},
+@@ -1046,7 +1080,7 @@ static const struct arducam_64mp_reg mod
+ 	{0x034d, 0x08},
+ 	{0x034e, 0x06},
+ 	{0x034f, 0xc8},
+-	{0x30d9, 0x01},
++	{0x30d9, 0x00},
+ 	{0x32d5, 0x00},
+ 	{0x32d6, 0x00},
+ 	{0x401e, 0x00},
+@@ -1065,6 +1099,14 @@ static const struct arducam_64mp_reg mod
+ 	{0x98d8, 0x8c},
+ 	{0x98d9, 0x0a},
+ 	{0x99c4, 0x16},
++	{0x341a, 0x00},
++	{0x341b, 0x00},
++	{0x341c, 0x00},
++	{0x341d, 0x00},
++	{0x341e, 0x00},
++	{0x341f, 0x90},
++	{0x3420, 0x00},
++	{0x3421, 0x90},
+ };
+ 
+ /* 1080p 60fps mode */
+@@ -1118,6 +1160,14 @@ static const struct arducam_64mp_reg mod
+ 	{0x98d8, 0x8c},
+ 	{0x98d9, 0x0a},
+ 	{0x99c4, 0x16},
++	{0x341a, 0x00},
++	{0x341b, 0x00},
++	{0x341c, 0x00},
++	{0x341d, 0x00},
++	{0x341e, 0x00},
++	{0x341f, 0x78},
++	{0x3420, 0x00},
++	{0x3421, 0x5a},
+ };
+ 
+ /* 720p 120fps mode */
+@@ -1171,6 +1221,14 @@ static const struct arducam_64mp_reg mod
+ 	{0x98d8, 0x8c},
+ 	{0x98d9, 0x0a},
+ 	{0x99c4, 0x16},
++	{0x341a, 0x00},
++	{0x341b, 0x00},
++	{0x341c, 0x00},
++	{0x341d, 0x00},
++	{0x341e, 0x00},
++	{0x341f, 0x50},
++	{0x3420, 0x00},
++	{0x3421, 0x3c},
+ };
+ 
+ /* Mode configs */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0803-overlays-audremap-Document-CM4-40-41-restriction.patch b/target/linux/bcm27xx/patches-6.1/950-0803-overlays-audremap-Document-CM4-40-41-restriction.patch
new file mode 100644
index 0000000000..bf1646322b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0803-overlays-audremap-Document-CM4-40-41-restriction.patch
@@ -0,0 +1,24 @@
+From 6f4106f7a7fdcbc03290008713915b4122988c90 Mon Sep 17 00:00:00 2001
+From: James Hughes <JamesH65@users.noreply.github.com>
+Date: Wed, 5 Jul 2023 15:43:30 +0100
+Subject: [PATCH] overlays: audremap: Document CM4 40&41 restriction
+
+Update audremap information to state pins 40,41 are not available on the CM4.
+
+Signed-off-by: James Hughes (james.hughes@raspberrypi.com)
+---
+ arch/arm/boot/dts/overlays/README | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -703,7 +703,8 @@ Params: swap_lr                 Reverse
+                                 nothing on BCM2711 (default off)
+         pins_12_13              Select GPIOs 12 & 13 (default)
+         pins_18_19              Select GPIOs 18 & 19
+-        pins_40_41              Select GPIOs 40 & 41
++        pins_40_41              Select GPIOs 40 & 41 (not available on CM4, used
++                                for other purposes)
+         pins_40_45              Select GPIOs 40 & 45 (don't use on BCM2711 - the
+                                 pins are on different controllers)
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0804-fixup-Allow-mac-address-to-be-set-in-smsc95xx.patch b/target/linux/bcm27xx/patches-6.1/950-0804-fixup-Allow-mac-address-to-be-set-in-smsc95xx.patch
new file mode 100644
index 0000000000..9265e931fa
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0804-fixup-Allow-mac-address-to-be-set-in-smsc95xx.patch
@@ -0,0 +1,120 @@
+From 1d15e6a34222cc8d8eb1050e7a3e276b0348be41 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 3 Jul 2023 11:04:56 +0100
+Subject: [PATCH] fixup! Allow mac address to be set in smsc95xx
+
+usbnet: smsc95xx: Fix indentation of smsc95xx_is_macaddr_param()
+
+smsc95xx_is_macaddr_param() is incorrectly indented, it uses 7 spaces
+instead of tabs.  Fix it.
+
+Fixes: aac7b105788e ("Allow mac address to be set in smsc95xx")
+Signed-off-by: Philipp Rosenberger <p.rosenberger@kunbus.com>
+[lukas: fix netif_dbg() indentation as well, wordsmith commit message]
+Signed-off-by: Lukas Wunner <lukas@wunner.de>
+
+usbnet: smsc95xx: Simplify MAC address parsing
+
+Parsing the MAC address provided on the kernel command line can be
+simplified quite a bit by taking advantage of the kernel's built-in
+mac_pton() helper.
+
+Likewise emitting the MAC address can be simplified with the %pM
+format string conversion.
+
+Signed-off-by: Lukas Wunner <lukas@wunner.de>
+
+usbnet: smsc95xx: Fix style issues in smsc95xx_is_macaddr_param()
+
+It is bad practice to have a function named ..._is_...() which has side
+effects.  So drop the 'is' from the name.
+
+Per kernel convention return 0 on success and a negative errno on
+failure.
+
+Validate the MAC address retrieved from the command line.
+
+Signed-off-by: Philipp Rosenberger <p.rosenberger@kunbus.com>
+[lukas: leave 2nd function parameter unchanged, wordsmith commit message]
+Signed-off-by: Lukas Wunner <lukas@wunner.de>
+---
+ drivers/net/usb/smsc95xx.c | 61 +++++++++++---------------------------
+ 1 file changed, 17 insertions(+), 44 deletions(-)
+
+--- a/drivers/net/usb/smsc95xx.c
++++ b/drivers/net/usb/smsc95xx.c
+@@ -814,49 +814,18 @@ static int smsc95xx_ioctl(struct net_dev
+ }
+ 
+ /* Check the macaddr module parameter for a MAC address */
+-static int smsc95xx_is_macaddr_param(struct usbnet *dev, struct net_device *nd)
++static int smsc95xx_macaddr_param(struct usbnet *dev, struct net_device *nd)
+ {
+-       int i, j, got_num, num;
+-       u8 mtbl[ETH_ALEN];
++	u8 mtbl[ETH_ALEN];
+ 
+-       if (macaddr[0] == ':')
+-               return 0;
+-
+-       i = 0;
+-       j = 0;
+-       num = 0;
+-       got_num = 0;
+-       while (j < ETH_ALEN) {
+-               if (macaddr[i] && macaddr[i] != ':') {
+-                       got_num++;
+-                       if ('0' <= macaddr[i] && macaddr[i] <= '9')
+-                               num = num * 16 + macaddr[i] - '0';
+-                       else if ('A' <= macaddr[i] && macaddr[i] <= 'F')
+-                               num = num * 16 + 10 + macaddr[i] - 'A';
+-                       else if ('a' <= macaddr[i] && macaddr[i] <= 'f')
+-                               num = num * 16 + 10 + macaddr[i] - 'a';
+-                       else
+-                               break;
+-                       i++;
+-               } else if (got_num == 2) {
+-                       mtbl[j++] = (u8) num;
+-                       num = 0;
+-                       got_num = 0;
+-                       i++;
+-               } else {
+-                       break;
+-               }
+-       }
+-
+-       if (j == ETH_ALEN) {
+-               netif_dbg(dev, ifup, dev->net, "Overriding MAC address with: "
+-               "%02x:%02x:%02x:%02x:%02x:%02x\n", mtbl[0], mtbl[1], mtbl[2],
+-                                               mtbl[3], mtbl[4], mtbl[5]);
+-	       dev_addr_mod(nd, 0, mtbl, ETH_ALEN);
+-               return 1;
+-       } else {
+-               return 0;
+-       }
++	if (mac_pton(macaddr, mtbl)) {
++		netif_dbg(dev, ifup, dev->net,
++			  "Overriding MAC address with: %pM\n", mtbl);
++		dev_addr_mod(nd, 0, mtbl, ETH_ALEN);
++		return 0;
++	} else {
++		return -EINVAL;
++	}
+ }
+ 
+ static void smsc95xx_init_mac_address(struct usbnet *dev)
+@@ -883,8 +852,12 @@ static void smsc95xx_init_mac_address(st
+ 	}
+ 
+ 	/* Check module parameters */
+-	if (smsc95xx_is_macaddr_param(dev, dev->net))
+-		return;
++	if (smsc95xx_macaddr_param(dev, dev->net) == 0) {
++		if (is_valid_ether_addr(dev->net->dev_addr)) {
++			netif_dbg(dev, ifup, dev->net, "MAC address read from module parameter\n");
++			return;
++		}
++	}
+ 
+ 	/* no useful static MAC address found. generate a random one */
+ 	eth_hw_addr_random(dev->net);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0809-cfg80211-ship-debian-certificates-as-hex-files.patch b/target/linux/bcm27xx/patches-6.1/950-0809-cfg80211-ship-debian-certificates-as-hex-files.patch
new file mode 100644
index 0000000000..593c95e2a2
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0809-cfg80211-ship-debian-certificates-as-hex-files.patch
@@ -0,0 +1,1455 @@
+From a2d2745c311baa588fb0fffbe38076294f06b7c0 Mon Sep 17 00:00:00 2001
+From: Nicolai Buchwitz <n.buchwitz@kunbus.com>
+Date: Wed, 12 Jul 2023 11:30:42 +0200
+Subject: [PATCH] cfg80211: ship debian certificates as hex files
+
+Loading the regulatory database from the debian files fails with
+
+"loaded regulatory.db is malformed or signature is missing/invalid"
+
+due to missing certificates.  Add these debian-specific certificates
+from upstream to fix this error. See #5536 for details.
+
+The certificates have been imported as following:
+
+patch -p1 <<<$(
+curl https://salsa.debian.org/kernel-team/linux/-/raw/\
+master/debian/patches/debian/\
+wireless-add-debian-wireless-regdb-certificates.patch
+)
+
+Signed-off-by: Nicolai Buchwitz <n.buchwitz@kunbus.com>
+---
+ net/wireless/certs/debian.hex | 1426 +++++++++++++++++++++++++++++++++
+ 1 file changed, 1426 insertions(+)
+ create mode 100644 net/wireless/certs/debian.hex
+
+--- /dev/null
++++ b/net/wireless/certs/debian.hex
+@@ -0,0 +1,1426 @@
++0x30,
++0x82,
++0x02,
++0xbd,
++0x30,
++0x82,
++0x01,
++0xa5,
++0x02,
++0x14,
++0x57,
++0x7e,
++0x02,
++0x1c,
++0xb9,
++0x80,
++0xe0,
++0xe8,
++0x20,
++0x82,
++0x1b,
++0xa7,
++0xb5,
++0x4b,
++0x49,
++0x61,
++0xb8,
++0xb4,
++0xfa,
++0xdf,
++0x30,
++0x0d,
++0x06,
++0x09,
++0x2a,
++0x86,
++0x48,
++0x86,
++0xf7,
++0x0d,
++0x01,
++0x01,
++0x0b,
++0x05,
++0x00,
++0x30,
++0x1a,
++0x31,
++0x18,
++0x30,
++0x16,
++0x06,
++0x03,
++0x55,
++0x04,
++0x03,
++0x0c,
++0x0f,
++0x62,
++0x65,
++0x6e,
++0x68,
++0x40,
++0x64,
++0x65,
++0x62,
++0x69,
++0x61,
++0x6e,
++0x2e,
++0x6f,
++0x72,
++0x67,
++0x30,
++0x20,
++0x17,
++0x0d,
++0x32,
++0x30,
++0x30,
++0x31,
++0x33,
++0x30,
++0x31,
++0x33,
++0x32,
++0x36,
++0x31,
++0x33,
++0x5a,
++0x18,
++0x0f,
++0x32,
++0x31,
++0x32,
++0x30,
++0x30,
++0x31,
++0x30,
++0x36,
++0x31,
++0x33,
++0x32,
++0x36,
++0x31,
++0x33,
++0x5a,
++0x30,
++0x1a,
++0x31,
++0x18,
++0x30,
++0x16,
++0x06,
++0x03,
++0x55,
++0x04,
++0x03,
++0x0c,
++0x0f,
++0x62,
++0x65,
++0x6e,
++0x68,
++0x40,
++0x64,
++0x65,
++0x62,
++0x69,
++0x61,
++0x6e,
++0x2e,
++0x6f,
++0x72,
++0x67,
++0x30,
++0x82,
++0x01,
++0x22,
++0x30,
++0x0d,
++0x06,
++0x09,
++0x2a,
++0x86,
++0x48,
++0x86,
++0xf7,
++0x0d,
++0x01,
++0x01,
++0x01,
++0x05,
++0x00,
++0x03,
++0x82,
++0x01,
++0x0f,
++0x00,
++0x30,
++0x82,
++0x01,
++0x0a,
++0x02,
++0x82,
++0x01,
++0x01,
++0x00,
++0x9d,
++0xe1,
++0x77,
++0xa0,
++0x24,
++0xa0,
++0xd5,
++0x79,
++0x65,
++0x3a,
++0x07,
++0x90,
++0xc9,
++0xf6,
++0xa5,
++0xa6,
++0x1f,
++0x84,
++0x1c,
++0x23,
++0x07,
++0x4b,
++0x4f,
++0xa5,
++0x03,
++0xc6,
++0x0f,
++0xf7,
++0x54,
++0xd5,
++0x8b,
++0x7e,
++0x79,
++0x81,
++0x00,
++0xd2,
++0xe9,
++0x3d,
++0xf4,
++0x97,
++0xfe,
++0x84,
++0xcd,
++0x55,
++0xbd,
++0xc9,
++0x8f,
++0x21,
++0x57,
++0x88,
++0x06,
++0x39,
++0x90,
++0x66,
++0x41,
++0x26,
++0x79,
++0x2c,
++0xca,
++0x3f,
++0x95,
++0x87,
++0x01,
++0x11,
++0x2f,
++0x2f,
++0xb0,
++0xe1,
++0x0b,
++0x43,
++0xfc,
++0x5f,
++0x2f,
++0x4f,
++0x67,
++0x04,
++0xdb,
++0x4d,
++0xb7,
++0x72,
++0x4d,
++0xd1,
++0xc5,
++0x76,
++0x73,
++0x4d,
++0x91,
++0x69,
++0xb0,
++0x71,
++0x17,
++0x36,
++0xea,
++0xab,
++0x0a,
++0x3a,
++0xcd,
++0x95,
++0x9b,
++0x76,
++0x1b,
++0x8e,
++0x21,
++0x17,
++0x8f,
++0xc5,
++0x02,
++0xbf,
++0x24,
++0xc7,
++0xc0,
++0x40,
++0xb1,
++0x3b,
++0xc4,
++0x80,
++0x7c,
++0x71,
++0xa5,
++0x51,
++0xdc,
++0xf7,
++0x3a,
++0x58,
++0x7f,
++0xb1,
++0x07,
++0x81,
++0x8a,
++0x10,
++0xd1,
++0xf6,
++0x93,
++0x17,
++0x71,
++0xe0,
++0xfa,
++0x51,
++0x79,
++0x15,
++0xd4,
++0xd7,
++0x8f,
++0xad,
++0xbd,
++0x6f,
++0x38,
++0xe1,
++0x26,
++0x7d,
++0xbc,
++0xf0,
++0x3e,
++0x80,
++0x89,
++0xb4,
++0xec,
++0x8e,
++0x69,
++0x90,
++0xdb,
++0x97,
++0x8a,
++0xf0,
++0x23,
++0x23,
++0x83,
++0x82,
++0x3b,
++0x6a,
++0xb1,
++0xac,
++0xeb,
++0xe7,
++0x99,
++0x74,
++0x2a,
++0x35,
++0x8e,
++0xa9,
++0x64,
++0xfd,
++0x46,
++0x9e,
++0xe8,
++0xe5,
++0x48,
++0x61,
++0x31,
++0x6e,
++0xe6,
++0xfc,
++0x19,
++0x18,
++0x54,
++0xc3,
++0x1b,
++0x4f,
++0xd6,
++0x00,
++0x44,
++0x87,
++0x1c,
++0x37,
++0x45,
++0xea,
++0xf5,
++0xc9,
++0xcb,
++0x0f,
++0x0c,
++0x55,
++0xec,
++0xcf,
++0x6a,
++0xc2,
++0x45,
++0x26,
++0x23,
++0xa2,
++0x31,
++0x52,
++0x4d,
++0xee,
++0x21,
++0x7d,
++0xfd,
++0x58,
++0x72,
++0xc2,
++0x28,
++0xc5,
++0x8e,
++0xa9,
++0xd0,
++0xee,
++0x01,
++0x77,
++0x08,
++0xa5,
++0xf0,
++0x22,
++0x2b,
++0x47,
++0x79,
++0x2b,
++0xcf,
++0x9a,
++0x46,
++0xb5,
++0x8f,
++0xfd,
++0x64,
++0xa2,
++0xb5,
++0xed,
++0x02,
++0x03,
++0x01,
++0x00,
++0x01,
++0x30,
++0x0d,
++0x06,
++0x09,
++0x2a,
++0x86,
++0x48,
++0x86,
++0xf7,
++0x0d,
++0x01,
++0x01,
++0x0b,
++0x05,
++0x00,
++0x03,
++0x82,
++0x01,
++0x01,
++0x00,
++0x20,
++0x44,
++0xfe,
++0xa9,
++0x9e,
++0xdd,
++0x9b,
++0xea,
++0xce,
++0x25,
++0x75,
++0x08,
++0xf0,
++0x2b,
++0x53,
++0xf7,
++0x5a,
++0x36,
++0x1c,
++0x4a,
++0x23,
++0x7f,
++0xd0,
++0x41,
++0x3c,
++0x12,
++0x2b,
++0xb9,
++0x80,
++0x4e,
++0x8a,
++0x15,
++0x5d,
++0x1f,
++0x40,
++0xa7,
++0x26,
++0x28,
++0x32,
++0xc3,
++0x5b,
++0x06,
++0x28,
++0x2d,
++0x3d,
++0x08,
++0x09,
++0x1e,
++0x01,
++0xe9,
++0x67,
++0xe3,
++0x33,
++0xe6,
++0x15,
++0x45,
++0x39,
++0xee,
++0x17,
++0x83,
++0xdb,
++0x42,
++0xff,
++0x7f,
++0x35,
++0xf4,
++0xac,
++0x16,
++0xdb,
++0xba,
++0xb8,
++0x1a,
++0x20,
++0x21,
++0x41,
++0xff,
++0xf3,
++0x92,
++0xff,
++0x65,
++0x6e,
++0x29,
++0x16,
++0xd0,
++0xbf,
++0x8d,
++0xdf,
++0x48,
++0x2c,
++0x73,
++0x36,
++0x7f,
++0x22,
++0xe6,
++0xee,
++0x78,
++0xb4,
++0x63,
++0x83,
++0x0e,
++0x39,
++0xeb,
++0xaf,
++0x10,
++0x2a,
++0x90,
++0xd3,
++0xfc,
++0xe6,
++0xc3,
++0x8f,
++0x97,
++0x5b,
++0x76,
++0xbf,
++0x9b,
++0xf5,
++0x98,
++0xd2,
++0x53,
++0x06,
++0x8b,
++0xf8,
++0xa4,
++0x04,
++0x9b,
++0x1b,
++0x62,
++0x6a,
++0x9d,
++0xac,
++0xe6,
++0x4b,
++0x0d,
++0xc9,
++0xd7,
++0x56,
++0x63,
++0x15,
++0x01,
++0x38,
++0x8c,
++0xbe,
++0xf1,
++0x44,
++0xc4,
++0x38,
++0x27,
++0xe0,
++0xcf,
++0x72,
++0xd6,
++0x3d,
++0xe4,
++0xf7,
++0x4b,
++0x3b,
++0xd2,
++0xb1,
++0x0c,
++0xd5,
++0x83,
++0x6d,
++0x1e,
++0x10,
++0x04,
++0x69,
++0x29,
++0x88,
++0x69,
++0xe0,
++0x7d,
++0xd7,
++0xdb,
++0xb4,
++0x59,
++0x72,
++0x8d,
++0x9d,
++0x3c,
++0x43,
++0xaf,
++0xc6,
++0x7d,
++0xb7,
++0x21,
++0x15,
++0x52,
++0x8a,
++0xe9,
++0x9b,
++0x6b,
++0x2e,
++0xe8,
++0x27,
++0x3c,
++0x3f,
++0x2d,
++0x84,
++0xfb,
++0x9a,
++0x22,
++0x0a,
++0x9f,
++0x6a,
++0x25,
++0xe6,
++0x39,
++0xe4,
++0x74,
++0x73,
++0xb6,
++0x2a,
++0x70,
++0xaa,
++0x1d,
++0xcb,
++0xcc,
++0xd4,
++0xa0,
++0x1b,
++0x26,
++0x71,
++0x63,
++0x04,
++0xc5,
++0x12,
++0x21,
++0x48,
++0xba,
++0x92,
++0x27,
++0x06,
++0xa8,
++0x3e,
++0x6d,
++0xa1,
++0x43,
++0xa5,
++0xd2,
++0x2a,
++0xf7,
++0xca,
++0xc4,
++0x26,
++0xe8,
++0x5b,
++0x1f,
++0xe4,
++0xdc,
++0x89,
++0xdc,
++0x1f,
++0x04,
++0x79,
++0x3f,
++0x30,
++0x82,
++0x02,
++0xcd,
++0x30,
++0x82,
++0x01,
++0xb5,
++0x02,
++0x14,
++0x3a,
++0xbb,
++0xc6,
++0xec,
++0x14,
++0x6e,
++0x09,
++0xd1,
++0xb6,
++0x01,
++0x6a,
++0xb9,
++0xd6,
++0xcf,
++0x71,
++0xdd,
++0x23,
++0x3f,
++0x03,
++0x28,
++0x30,
++0x0d,
++0x06,
++0x09,
++0x2a,
++0x86,
++0x48,
++0x86,
++0xf7,
++0x0d,
++0x01,
++0x01,
++0x0b,
++0x05,
++0x00,
++0x30,
++0x22,
++0x31,
++0x20,
++0x30,
++0x1e,
++0x06,
++0x03,
++0x55,
++0x04,
++0x03,
++0x0c,
++0x17,
++0x72,
++0x6f,
++0x6d,
++0x61,
++0x69,
++0x6e,
++0x2e,
++0x70,
++0x65,
++0x72,
++0x69,
++0x65,
++0x72,
++0x40,
++0x67,
++0x6d,
++0x61,
++0x69,
++0x6c,
++0x2e,
++0x63,
++0x6f,
++0x6d,
++0x30,
++0x20,
++0x17,
++0x0d,
++0x32,
++0x30,
++0x30,
++0x32,
++0x32,
++0x34,
++0x31,
++0x39,
++0x30,
++0x31,
++0x34,
++0x34,
++0x5a,
++0x18,
++0x0f,
++0x32,
++0x31,
++0x32,
++0x30,
++0x30,
++0x31,
++0x33,
++0x31,
++0x31,
++0x39,
++0x30,
++0x31,
++0x34,
++0x34,
++0x5a,
++0x30,
++0x22,
++0x31,
++0x20,
++0x30,
++0x1e,
++0x06,
++0x03,
++0x55,
++0x04,
++0x03,
++0x0c,
++0x17,
++0x72,
++0x6f,
++0x6d,
++0x61,
++0x69,
++0x6e,
++0x2e,
++0x70,
++0x65,
++0x72,
++0x69,
++0x65,
++0x72,
++0x40,
++0x67,
++0x6d,
++0x61,
++0x69,
++0x6c,
++0x2e,
++0x63,
++0x6f,
++0x6d,
++0x30,
++0x82,
++0x01,
++0x22,
++0x30,
++0x0d,
++0x06,
++0x09,
++0x2a,
++0x86,
++0x48,
++0x86,
++0xf7,
++0x0d,
++0x01,
++0x01,
++0x01,
++0x05,
++0x00,
++0x03,
++0x82,
++0x01,
++0x0f,
++0x00,
++0x30,
++0x82,
++0x01,
++0x0a,
++0x02,
++0x82,
++0x01,
++0x01,
++0x00,
++0xf0,
++0xb8,
++0x4f,
++0x3f,
++0x70,
++0x78,
++0xf8,
++0x74,
++0x45,
++0xa2,
++0x28,
++0xaf,
++0x04,
++0x75,
++0x04,
++0xa3,
++0xf3,
++0xa7,
++0xc7,
++0x04,
++0xac,
++0xb6,
++0xe1,
++0xfc,
++0xe1,
++0xc0,
++0x3d,
++0xe0,
++0x26,
++0x90,
++0x8a,
++0x45,
++0x60,
++0xc4,
++0x75,
++0xf3,
++0x1a,
++0x33,
++0x37,
++0x56,
++0x7d,
++0x30,
++0x07,
++0x75,
++0x0e,
++0xa6,
++0x79,
++0x06,
++0x95,
++0x9d,
++0x17,
++0x3c,
++0x09,
++0xa9,
++0x7f,
++0xab,
++0x95,
++0x5d,
++0xed,
++0xe0,
++0x75,
++0x26,
++0x2f,
++0x65,
++0x65,
++0xcd,
++0x61,
++0xb1,
++0x33,
++0x27,
++0x67,
++0x41,
++0xa1,
++0x01,
++0x13,
++0xe9,
++0x13,
++0x6a,
++0x6d,
++0x4e,
++0x98,
++0xe1,
++0x9e,
++0x7b,
++0x0b,
++0x5b,
++0x44,
++0xef,
++0x68,
++0x5a,
++0x6f,
++0x7d,
++0x97,
++0xa1,
++0x33,
++0x22,
++0x97,
++0x12,
++0x21,
++0x09,
++0x8f,
++0x90,
++0xe0,
++0x25,
++0x94,
++0xdd,
++0x8a,
++0x3a,
++0xf7,
++0x4a,
++0x60,
++0x04,
++0x26,
++0x6d,
++0x00,
++0x82,
++0xe4,
++0xcf,
++0x64,
++0x1c,
++0x79,
++0x15,
++0x24,
++0xf2,
++0x42,
++0x86,
++0xf5,
++0x10,
++0x86,
++0xac,
++0x20,
++0x88,
++0x90,
++0x87,
++0xdf,
++0x8c,
++0x37,
++0x7c,
++0xbf,
++0x35,
++0xd5,
++0x6f,
++0x9f,
++0x77,
++0xc3,
++0xcd,
++0x69,
++0x25,
++0x06,
++0xc2,
++0x65,
++0x51,
++0x71,
++0x89,
++0x7f,
++0x6e,
++0x4d,
++0xe5,
++0xd5,
++0x8a,
++0x36,
++0x1a,
++0xad,
++0xc1,
++0x18,
++0xd6,
++0x14,
++0x42,
++0x87,
++0xf0,
++0x93,
++0x83,
++0xf1,
++0x99,
++0x74,
++0xc4,
++0x13,
++0xaa,
++0x3b,
++0x66,
++0x85,
++0x6f,
++0xe0,
++0xbc,
++0x5f,
++0xb6,
++0x40,
++0xa6,
++0x41,
++0x06,
++0x0a,
++0xba,
++0x0e,
++0xe9,
++0x32,
++0x44,
++0x10,
++0x39,
++0x53,
++0xcd,
++0xbf,
++0xf3,
++0xd3,
++0x26,
++0xf6,
++0xb6,
++0x2b,
++0x40,
++0x2e,
++0xb9,
++0x88,
++0xc1,
++0xf4,
++0xe3,
++0xa0,
++0x28,
++0x77,
++0x4f,
++0xba,
++0xa8,
++0xca,
++0x9c,
++0x05,
++0xba,
++0x88,
++0x96,
++0x99,
++0x54,
++0x89,
++0xa2,
++0x8d,
++0xf3,
++0x73,
++0xa1,
++0x8c,
++0x4a,
++0xa8,
++0x71,
++0xee,
++0x2e,
++0xd2,
++0x83,
++0x14,
++0x48,
++0xbd,
++0x98,
++0xc6,
++0xce,
++0xdc,
++0xa8,
++0xa3,
++0x97,
++0x2e,
++0x40,
++0x16,
++0x2f,
++0x02,
++0x03,
++0x01,
++0x00,
++0x01,
++0x30,
++0x0d,
++0x06,
++0x09,
++0x2a,
++0x86,
++0x48,
++0x86,
++0xf7,
++0x0d,
++0x01,
++0x01,
++0x0b,
++0x05,
++0x00,
++0x03,
++0x82,
++0x01,
++0x01,
++0x00,
++0x76,
++0x5d,
++0x03,
++0x3d,
++0xb6,
++0x96,
++0x00,
++0x1b,
++0x6e,
++0x0c,
++0xdd,
++0xbb,
++0xc8,
++0xdf,
++0xbc,
++0xeb,
++0x6c,
++0x01,
++0x40,
++0x1a,
++0x2b,
++0x07,
++0x60,
++0xa1,
++0x1a,
++0xe1,
++0x43,
++0x57,
++0xfa,
++0xbe,
++0xde,
++0xbb,
++0x8f,
++0x73,
++0xf3,
++0x92,
++0xa2,
++0xaa,
++0x83,
++0x01,
++0xc1,
++0x17,
++0xe4,
++0x9d,
++0x09,
++0x41,
++0xe0,
++0x32,
++0x33,
++0x97,
++0x4b,
++0xf2,
++0xdc,
++0x0f,
++0x8b,
++0xa8,
++0xb8,
++0x5a,
++0x04,
++0x86,
++0xf6,
++0x71,
++0xa1,
++0x97,
++0xd0,
++0x54,
++0x56,
++0x10,
++0x8e,
++0x54,
++0x99,
++0x0d,
++0x2a,
++0xa9,
++0xaf,
++0x1b,
++0x55,
++0x59,
++0x06,
++0x2b,
++0xa4,
++0x5f,
++0xb1,
++0x54,
++0xa6,
++0xec,
++0xc7,
++0xd6,
++0x43,
++0xee,
++0x86,
++0x2c,
++0x9b,
++0x18,
++0x9d,
++0x8f,
++0x00,
++0x82,
++0xc1,
++0x88,
++0x61,
++0x16,
++0x85,
++0x3c,
++0x17,
++0x56,
++0xfe,
++0x6a,
++0xa0,
++0x7a,
++0x68,
++0xc5,
++0x7b,
++0x3d,
++0x3c,
++0xb6,
++0x13,
++0x18,
++0x99,
++0x6d,
++0x74,
++0x65,
++0x13,
++0x67,
++0xb7,
++0xfc,
++0x5a,
++0x44,
++0x48,
++0x72,
++0xa0,
++0x73,
++0xb8,
++0xff,
++0x02,
++0x9d,
++0x7c,
++0x5b,
++0xf9,
++0x7c,
++0x75,
++0x0a,
++0x3c,
++0x81,
++0x80,
++0x3c,
++0x41,
++0xf2,
++0xd5,
++0xfa,
++0x3d,
++0x1f,
++0xe3,
++0xda,
++0x8c,
++0xa5,
++0x17,
++0x1f,
++0x53,
++0x1a,
++0x75,
++0xad,
++0x4e,
++0x11,
++0x1c,
++0x07,
++0xec,
++0x0a,
++0x69,
++0xfd,
++0x33,
++0xfa,
++0x32,
++0x7e,
++0x66,
++0xf5,
++0x29,
++0xe8,
++0x4d,
++0x8a,
++0xfa,
++0x0d,
++0x4b,
++0x68,
++0xc3,
++0x95,
++0x11,
++0xba,
++0x6f,
++0x1e,
++0x07,
++0x8c,
++0x85,
++0xc7,
++0xc7,
++0xc9,
++0xc1,
++0x30,
++0xa3,
++0x70,
++0xb0,
++0xa1,
++0xe0,
++0xd5,
++0x85,
++0x15,
++0x94,
++0x77,
++0xc1,
++0x1c,
++0x91,
++0xf1,
++0x5f,
++0x50,
++0xcd,
++0x2c,
++0x57,
++0x4b,
++0x22,
++0x4f,
++0xee,
++0x95,
++0xd7,
++0xa7,
++0xa4,
++0x59,
++0x62,
++0xae,
++0xb9,
++0xbf,
++0xd7,
++0x63,
++0x5a,
++0x04,
++0xfc,
++0x24,
++0x11,
++0xae,
++0x34,
++0x4b,
++0xf4,
++0x0c,
++0x9f,
++0x0b,
++0x59,
++0x7d,
++0x27,
++0x39,
++0x54,
++0x69,
++0x4f,
++0xfd,
++0x6e,
++0x44,
++0x9f,
++0x21,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0810-fixup-Add-support-for-all-the-downstream-rpi-sound-c.patch b/target/linux/bcm27xx/patches-6.1/950-0810-fixup-Add-support-for-all-the-downstream-rpi-sound-c.patch
new file mode 100644
index 0000000000..87097d2bbf
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0810-fixup-Add-support-for-all-the-downstream-rpi-sound-c.patch
@@ -0,0 +1,329 @@
+From 3ece03b1575b0c3a0989e372aaaa4557ae74dc89 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 20 Jul 2023 11:28:20 +0100
+Subject: [PATCH] fixup! Add support for all the downstream rpi sound card
+ drivers
+
+Replace the Allo Dac clock driver with an extension of the
+HiFiBerry clock driver that it cloned.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/clk/Makefile               |   1 -
+ drivers/clk/clk-allo-dac.c         | 161 -----------------------------
+ drivers/clk/clk-hifiberry-dacpro.c |  57 ++++++----
+ sound/soc/bcm/Kconfig              |   1 +
+ 4 files changed, 40 insertions(+), 180 deletions(-)
+ delete mode 100644 drivers/clk/clk-allo-dac.c
+
+--- a/drivers/clk/Makefile
++++ b/drivers/clk/Makefile
+@@ -19,7 +19,6 @@ endif
+ 
+ # hardware specific clock types
+ # please keep this section sorted lexicographically by file path name
+-obj-$(CONFIG_SND_BCM2708_SOC_ALLO_BOSS_DAC)	+= clk-allo-dac.o
+ obj-$(CONFIG_COMMON_CLK_APPLE_NCO)  	+= clk-apple-nco.o
+ obj-$(CONFIG_MACH_ASM9260)		+= clk-asm9260.o
+ obj-$(CONFIG_COMMON_CLK_AXI_CLKGEN)	+= clk-axi-clkgen.o
+--- a/drivers/clk/clk-allo-dac.c
++++ /dev/null
+@@ -1,161 +0,0 @@
+-/*
+- * Clock Driver for Allo DAC
+- *
+- * Author:	Baswaraj K <jaikumar@cem-solutions.net>
+- *		Copyright 2016
+- *		based on code by Stuart MacLean
+- *
+- * This program is free software; you can redistribute it and/or
+- * modify it under the terms of the GNU General Public License
+- * version 2 as published by the Free Software Foundation.
+- *
+- * This program is distributed in the hope that it will be useful, but
+- * WITHOUT ANY WARRANTY; without even the implied warranty of
+- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+- * General Public License for more details.
+- */
+-
+-#include <linux/clk-provider.h>
+-#include <linux/clkdev.h>
+-#include <linux/kernel.h>
+-#include <linux/module.h>
+-#include <linux/of.h>
+-#include <linux/slab.h>
+-#include <linux/platform_device.h>
+-
+-/* Clock rate of CLK44EN attached to GPIO6 pin */
+-#define CLK_44EN_RATE 45158400UL
+-/* Clock rate of CLK48EN attached to GPIO3 pin */
+-#define CLK_48EN_RATE 49152000UL
+-
+-/**
+- * struct allo_dac_clk - Common struct to the Allo DAC
+- * @hw: clk_hw for the common clk framework
+- * @mode: 0 => CLK44EN, 1 => CLK48EN
+- */
+-struct clk_allo_hw {
+-	struct clk_hw hw;
+-	uint8_t mode;
+-};
+-
+-#define to_allo_clk(_hw) container_of(_hw, struct clk_allo_hw, hw)
+-
+-static const struct of_device_id clk_allo_dac_dt_ids[] = {
+-	{ .compatible = "allo,dac-clk",},
+-	{ }
+-};
+-MODULE_DEVICE_TABLE(of, clk_allo_dac_dt_ids);
+-
+-static unsigned long clk_allo_dac_recalc_rate(struct clk_hw *hw,
+-	unsigned long parent_rate)
+-{
+-	return (to_allo_clk(hw)->mode == 0) ? CLK_44EN_RATE :
+-		CLK_48EN_RATE;
+-}
+-
+-static long clk_allo_dac_round_rate(struct clk_hw *hw,
+-	unsigned long rate, unsigned long *parent_rate)
+-{
+-	long actual_rate;
+-
+-	if (rate <= CLK_44EN_RATE) {
+-		actual_rate = (long)CLK_44EN_RATE;
+-	} else if (rate >= CLK_48EN_RATE) {
+-		actual_rate = (long)CLK_48EN_RATE;
+-	} else {
+-		long diff44Rate = (long)(rate - CLK_44EN_RATE);
+-		long diff48Rate = (long)(CLK_48EN_RATE - rate);
+-
+-		if (diff44Rate < diff48Rate)
+-			actual_rate = (long)CLK_44EN_RATE;
+-		else
+-			actual_rate = (long)CLK_48EN_RATE;
+-	}
+-	return actual_rate;
+-}
+-
+-
+-static int clk_allo_dac_set_rate(struct clk_hw *hw,
+-	unsigned long rate, unsigned long parent_rate)
+-{
+-	unsigned long actual_rate;
+-	struct clk_allo_hw *clk = to_allo_clk(hw);
+-
+-	actual_rate = (unsigned long)clk_allo_dac_round_rate(hw, rate,
+-		&parent_rate);
+-	clk->mode = (actual_rate == CLK_44EN_RATE) ? 0 : 1;
+-	return 0;
+-}
+-
+-
+-const struct clk_ops clk_allo_dac_rate_ops = {
+-	.recalc_rate = clk_allo_dac_recalc_rate,
+-	.round_rate = clk_allo_dac_round_rate,
+-	.set_rate = clk_allo_dac_set_rate,
+-};
+-
+-static int clk_allo_dac_probe(struct platform_device *pdev)
+-{
+-	int ret;
+-	struct clk_allo_hw *proclk;
+-	struct clk *clk;
+-	struct device *dev;
+-	struct clk_init_data init;
+-
+-	dev = &pdev->dev;
+-
+-	proclk = kzalloc(sizeof(struct clk_allo_hw), GFP_KERNEL);
+-	if (!proclk)
+-		return -ENOMEM;
+-
+-	init.name = "clk-allo-dac";
+-	init.ops = &clk_allo_dac_rate_ops;
+-	init.flags = 0;
+-	init.parent_names = NULL;
+-	init.num_parents = 0;
+-
+-	proclk->mode = 0;
+-	proclk->hw.init = &init;
+-
+-	clk = devm_clk_register(dev, &proclk->hw);
+-	if (!IS_ERR(clk)) {
+-		ret = of_clk_add_provider(dev->of_node, of_clk_src_simple_get,
+-			clk);
+-	} else {
+-		dev_err(dev, "Fail to register clock driver\n");
+-		kfree(proclk);
+-		ret = PTR_ERR(clk);
+-	}
+-	return ret;
+-}
+-
+-static int clk_allo_dac_remove(struct platform_device *pdev)
+-{
+-	of_clk_del_provider(pdev->dev.of_node);
+-	return 0;
+-}
+-
+-static struct platform_driver clk_allo_dac_driver = {
+-	.probe = clk_allo_dac_probe,
+-	.remove = clk_allo_dac_remove,
+-	.driver = {
+-		.name = "clk-allo-dac",
+-		.of_match_table = clk_allo_dac_dt_ids,
+-	},
+-};
+-
+-static int __init clk_allo_dac_init(void)
+-{
+-	return platform_driver_register(&clk_allo_dac_driver);
+-}
+-core_initcall(clk_allo_dac_init);
+-
+-static void __exit clk_allo_dac_exit(void)
+-{
+-	platform_driver_unregister(&clk_allo_dac_driver);
+-}
+-module_exit(clk_allo_dac_exit);
+-
+-MODULE_DESCRIPTION("Allo DAC clock driver");
+-MODULE_LICENSE("GPL v2");
+-MODULE_ALIAS("platform:clk-allo-dac");
+--- a/drivers/clk/clk-hifiberry-dacpro.c
++++ b/drivers/clk/clk-hifiberry-dacpro.c
+@@ -22,10 +22,12 @@
+ #include <linux/slab.h>
+ #include <linux/platform_device.h>
+ 
+-/* Clock rate of CLK44EN attached to GPIO6 pin */
+-#define CLK_44EN_RATE 22579200UL
+-/* Clock rate of CLK48EN attached to GPIO3 pin */
+-#define CLK_48EN_RATE 24576000UL
++struct ext_clk_rates {
++	/* Clock rate of CLK44EN attached to GPIO6 pin */
++	unsigned long clk_44en;
++	/* Clock rate of CLK48EN attached to GPIO3 pin */
++	unsigned long clk_48en;
++};
+ 
+ /**
+  * struct hifiberry_dacpro_clk - Common struct to the HiFiBerry DAC Pro
+@@ -35,12 +37,24 @@
+ struct clk_hifiberry_hw {
+ 	struct clk_hw hw;
+ 	uint8_t mode;
++	struct ext_clk_rates clk_rates;
+ };
+ 
+ #define to_hifiberry_clk(_hw) container_of(_hw, struct clk_hifiberry_hw, hw)
+ 
++static const struct ext_clk_rates hifiberry_dacpro_clks = {
++	.clk_44en = 22579200UL,
++	.clk_48en = 24576000UL,
++};
++
++static const struct ext_clk_rates allo_dac_clks = {
++	.clk_44en = 45158400UL,
++	.clk_48en = 49152000UL,
++};
++
+ static const struct of_device_id clk_hifiberry_dacpro_dt_ids[] = {
+-	{ .compatible = "hifiberry,dacpro-clk",},
++	{ .compatible = "hifiberry,dacpro-clk", &hifiberry_dacpro_clks },
++	{ .compatible = "allo,dac-clk", &allo_dac_clks },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, clk_hifiberry_dacpro_dt_ids);
+@@ -48,27 +62,29 @@ MODULE_DEVICE_TABLE(of, clk_hifiberry_da
+ static unsigned long clk_hifiberry_dacpro_recalc_rate(struct clk_hw *hw,
+ 	unsigned long parent_rate)
+ {
+-	return (to_hifiberry_clk(hw)->mode == 0) ? CLK_44EN_RATE :
+-		CLK_48EN_RATE;
++	struct clk_hifiberry_hw *clk = to_hifiberry_clk(hw);
++	return (clk->mode == 0) ? clk->clk_rates.clk_44en :
++		clk->clk_rates.clk_48en;
+ }
+ 
+ static long clk_hifiberry_dacpro_round_rate(struct clk_hw *hw,
+ 	unsigned long rate, unsigned long *parent_rate)
+ {
++	struct clk_hifiberry_hw *clk = to_hifiberry_clk(hw);
+ 	long actual_rate;
+ 
+-	if (rate <= CLK_44EN_RATE) {
+-		actual_rate = (long)CLK_44EN_RATE;
+-	} else if (rate >= CLK_48EN_RATE) {
+-		actual_rate = (long)CLK_48EN_RATE;
++	if (rate <= clk->clk_rates.clk_44en) {
++		actual_rate = (long)clk->clk_rates.clk_44en;
++	} else if (rate >= clk->clk_rates.clk_48en) {
++		actual_rate = (long)clk->clk_rates.clk_48en;
+ 	} else {
+-		long diff44Rate = (long)(rate - CLK_44EN_RATE);
+-		long diff48Rate = (long)(CLK_48EN_RATE - rate);
++		long diff44Rate = (long)(rate - clk->clk_rates.clk_44en);
++		long diff48Rate = (long)(clk->clk_rates.clk_48en - rate);
+ 
+ 		if (diff44Rate < diff48Rate)
+-			actual_rate = (long)CLK_44EN_RATE;
++			actual_rate = (long)clk->clk_rates.clk_44en;
+ 		else
+-			actual_rate = (long)CLK_48EN_RATE;
++			actual_rate = (long)clk->clk_rates.clk_48en;
+ 	}
+ 	return actual_rate;
+ }
+@@ -77,12 +93,12 @@ static long clk_hifiberry_dacpro_round_r
+ static int clk_hifiberry_dacpro_set_rate(struct clk_hw *hw,
+ 	unsigned long rate, unsigned long parent_rate)
+ {
+-	unsigned long actual_rate;
+ 	struct clk_hifiberry_hw *clk = to_hifiberry_clk(hw);
++	unsigned long actual_rate;
+ 
+ 	actual_rate = (unsigned long)clk_hifiberry_dacpro_round_rate(hw, rate,
+ 		&parent_rate);
+-	clk->mode = (actual_rate == CLK_44EN_RATE) ? 0 : 1;
++	clk->mode = (actual_rate == clk->clk_rates.clk_44en) ? 0 : 1;
+ 	return 0;
+ }
+ 
+@@ -95,13 +111,17 @@ const struct clk_ops clk_hifiberry_dacpr
+ 
+ static int clk_hifiberry_dacpro_probe(struct platform_device *pdev)
+ {
+-	int ret;
++	const struct of_device_id *of_id;
+ 	struct clk_hifiberry_hw *proclk;
+ 	struct clk *clk;
+ 	struct device *dev;
+ 	struct clk_init_data init;
++	int ret;
+ 
+ 	dev = &pdev->dev;
++	of_id = of_match_node(clk_hifiberry_dacpro_dt_ids, dev->of_node);
++	if (!of_id)
++		return -EINVAL;
+ 
+ 	proclk = kzalloc(sizeof(struct clk_hifiberry_hw), GFP_KERNEL);
+ 	if (!proclk)
+@@ -115,6 +135,7 @@ static int clk_hifiberry_dacpro_probe(st
+ 
+ 	proclk->mode = 0;
+ 	proclk->hw.init = &init;
++	memcpy(&proclk->clk_rates, of_id->data, sizeof(proclk->clk_rates));
+ 
+ 	clk = devm_clk_register(dev, &proclk->hw);
+ 	if (!IS_ERR(clk)) {
+--- a/sound/soc/bcm/Kconfig
++++ b/sound/soc/bcm/Kconfig
+@@ -271,6 +271,7 @@ config SND_BCM2708_SOC_ALLO_BOSS_DAC
+ 	tristate "Support for Allo Boss DAC"
+ 	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_PCM512x_I2C
++	select COMMON_CLK_HIFIBERRY_DACPRO
+ 	help
+ 	  Say Y or M if you want to add support for Allo Boss DAC.
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0815-fixup-drm-tc358762-Set-the-pre_enable_upstream_first.patch b/target/linux/bcm27xx/patches-6.1/950-0815-fixup-drm-tc358762-Set-the-pre_enable_upstream_first.patch
new file mode 100644
index 0000000000..22bca6c7f4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0815-fixup-drm-tc358762-Set-the-pre_enable_upstream_first.patch
@@ -0,0 +1,21 @@
+From 2addf7045f2b4866ab819f48e4d32f5734a32134 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Thu, 20 Jul 2023 15:15:27 +0100
+Subject: [PATCH] fixup! drm/tc358762: Set the pre_enable_upstream_first flag
+ to configure DSI host
+
+---
+ drivers/gpu/drm/bridge/tc358762.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/bridge/tc358762.c
++++ b/drivers/gpu/drm/bridge/tc358762.c
+@@ -229,7 +229,7 @@ static int tc358762_probe(struct mipi_ds
+ 	ctx->bridge.funcs = &tc358762_bridge_funcs;
+ 	ctx->bridge.type = DRM_MODE_CONNECTOR_DPI;
+ 	ctx->bridge.of_node = dev->of_node;
+-	ctx->bridge.pre_enable_upstream_first = true;
++	ctx->bridge.pre_enable_prev_first = true;
+ 
+ 	drm_bridge_add(&ctx->bridge);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0816-rpi-sound-cards-Fix-Codec-Zero-rate-switching.patch b/target/linux/bcm27xx/patches-6.1/950-0816-rpi-sound-cards-Fix-Codec-Zero-rate-switching.patch
new file mode 100644
index 0000000000..82a3c9ea5b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0816-rpi-sound-cards-Fix-Codec-Zero-rate-switching.patch
@@ -0,0 +1,48 @@
+From b84b8a9ad2046a855a7044b6368def01ddd5de6e Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 21 Jul 2023 16:50:56 +0100
+Subject: [PATCH] rpi sound cards: Fix Codec Zero rate switching
+
+The Raspberry Pi Codec Zero (and IQaudIO Codec) don't notify the DA7213
+codec when it needs to change PLL frequencies. As a result, audio can
+be played at the wrong rate - play a 48kHz sound immediately after a
+44.1kHz sound to see the effect, but in some configurations the codec
+can lock into the wrong state and always get some rates wrong.
+
+Add the necessary notification to fix the issue.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/bcm/iqaudio-codec.c | 7 +++++--
+ 1 file changed, 5 insertions(+), 2 deletions(-)
+
+--- a/sound/soc/bcm/iqaudio-codec.c
++++ b/sound/soc/bcm/iqaudio-codec.c
+@@ -143,6 +143,7 @@ static int snd_rpi_iqaudio_codec_hw_para
+ 					   struct snd_pcm_hw_params *params)
+ {
+ 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+ 	unsigned int samplerate = params_rate(params);
+ 
+ 	switch (samplerate) {
+@@ -152,15 +153,17 @@ static int snd_rpi_iqaudio_codec_hw_para
+ 	case 48000:
+ 	case 96000:
+ 		pll_out = DA7213_PLL_FREQ_OUT_98304000;
+-		return 0;
++		break;
+ 	case 44100:
+ 	case 88200:
+ 		pll_out = DA7213_PLL_FREQ_OUT_90316800;
+-		return 0;
++		break;
+ 	default:
+ 		dev_err(rtd->dev,"Unsupported samplerate %d\n", samplerate);
+ 		return -EINVAL;
+ 	}
++
++	return snd_soc_dai_set_pll(codec_dai, 0, DA7213_SYSCLK_PLL, 0, pll_out);
+ }
+ 
+ static const struct snd_soc_ops snd_rpi_iqaudio_codec_ops = {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0818-overlays-Add-trickle-voltage-mv-parameter-to-RTCs.patch b/target/linux/bcm27xx/patches-6.1/950-0818-overlays-Add-trickle-voltage-mv-parameter-to-RTCs.patch
new file mode 100644
index 0000000000..0539b19cf5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0818-overlays-Add-trickle-voltage-mv-parameter-to-RTCs.patch
@@ -0,0 +1,68 @@
+From 31822340129e3c4030500d7f30ce4d19bbf9dd40 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 24 Jul 2023 17:34:47 +0100
+Subject: [PATCH] overlays: Add trickle-voltage-mv parameter to RTCs
+
+The RV3032 RTC requires an additional DT property to enable trickle
+charging. Add a parameter - trickle-voltage-mv - to the i2c-rtc
+and i2c-rtc-gpio overlays to set it.
+
+See: https://github.com/raspberrypi/linux/issues/5547
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README              | 12 ++++++++----
+ arch/arm/boot/dts/overlays/i2c-rtc-common.dtsi |  2 ++
+ 2 files changed, 10 insertions(+), 4 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -1957,13 +1957,15 @@ Params: abx80x                  Select o
+                                 "schottky" (ABx80x and RV1805 only)
+ 
+         trickle-resistor-ohms   Resistor value for trickle charge (DS1339,
+-                                ABx80x, RV1805, RV3028)
++                                ABx80x, BQ32000, RV1805, RV3028, RV3032)
++
++        trickle-voltage-mv      Charge pump voltage for trickle charge (RV3032)
+ 
+         wakeup-source           Specify that the RTC can be used as a wakeup
+                                 source
+ 
+         backup-switchover-mode  Backup power supply switch mode. Must be 0 for
+-                                off or 1 for Vdd < VBackup (RV3028 only)
++                                off or 1 for Vdd < VBackup (RV3028, RV3032)
+ 
+ 
+ Name:   i2c-rtc-gpio
+@@ -2027,13 +2029,15 @@ Params: abx80x                  Select o
+                                 "schottky" (ABx80x and RV1805 only)
+ 
+         trickle-resistor-ohms   Resistor value for trickle charge (DS1339,
+-                                ABx80x, RV1805, RV3028)
++                                ABx80x, BQ32000, RV1805, RV3028, RV3032)
++
++        trickle-voltage-mv      Charge pump voltage for trickle charge (RV3032)
+ 
+         wakeup-source           Specify that the RTC can be used as a wakeup
+                                 source
+ 
+         backup-switchover-mode  Backup power supply switch mode. Must be 0 for
+-                                off or 1 for Vdd < VBackup (RV3028 only)
++                                off or 1 for Vdd < VBackup (RV3028, RV3032)
+ 
+         i2c_gpio_sda            GPIO used for I2C data (default "23")
+ 
+--- a/arch/arm/boot/dts/overlays/i2c-rtc-common.dtsi
++++ b/arch/arm/boot/dts/overlays/i2c-rtc-common.dtsi
+@@ -339,8 +339,10 @@
+ 					<&ds1340>,"trickle-resistor-ohms:0",
+ 					<&abx80x>,"abracon,tc-resistor:0",
+ 					<&rv3028>,"trickle-resistor-ohms:0",
++					<&rv3032>,"trickle-resistor-ohms:0",
+ 					<&rv1805>,"abracon,tc-resistor:0",
+ 					<&bq32000>,"abracon,tc-resistor:0";
++		trickle-voltage-mv = <&rv3032>,"trickle-voltage-millivolts:0";
+ 		backup-switchover-mode = <&rv3028>,"backup-switchover-mode:0";
+ 		wakeup-source = <&ds1339>,"wakeup-source?",
+ 				<&ds3231>,"wakeup-source?",
diff --git a/target/linux/bcm27xx/patches-6.1/950-0819-drivers-media-imx296-Add-standby-delay-during-probe.patch b/target/linux/bcm27xx/patches-6.1/950-0819-drivers-media-imx296-Add-standby-delay-during-probe.patch
new file mode 100644
index 0000000000..f10c0f03b5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0819-drivers-media-imx296-Add-standby-delay-during-probe.patch
@@ -0,0 +1,25 @@
+From 5fb3b300557d6a6902e7321f42fdabb8c09eef54 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Fri, 28 Jul 2023 12:00:40 +0100
+Subject: [PATCH] drivers: media: imx296: Add standby delay during probe
+
+Add a 2-5ms delay when coming out of standby and before reading the
+sensor info register durning probe, as instructed by the datasheet. This
+standby delay is already present when the sensor starts streaming.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/i2c/imx296.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/media/i2c/imx296.c
++++ b/drivers/media/i2c/imx296.c
+@@ -1022,6 +1022,8 @@ static int imx296_identify_model(struct
+ 		return ret;
+ 	}
+ 
++	usleep_range(2000, 5000);
++
+ 	ret = imx296_read(sensor, IMX296_SENSOR_INFO);
+ 	if (ret < 0) {
+ 		dev_err(sensor->dev, "failed to read sensor information (%d)\n",
diff --git a/target/linux/bcm27xx/patches-6.1/950-0820-overlays-Add-bmp380-to-i2c-sensor-overlay.patch b/target/linux/bcm27xx/patches-6.1/950-0820-overlays-Add-bmp380-to-i2c-sensor-overlay.patch
new file mode 100644
index 0000000000..535511eb93
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0820-overlays-Add-bmp380-to-i2c-sensor-overlay.patch
@@ -0,0 +1,78 @@
+From e1016d61e3dcb058932e8ec5072f2c4bbb05fcb7 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Sun, 30 Jul 2023 18:27:03 +0100
+Subject: [PATCH] overlays: Add bmp380 to i2c-sensor overlay
+
+Add support for the BMP380 pressor sensor to the i2c-sensor overlay.
+
+See: https://github.com/raspberrypi/linux/issues/5558
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README             |  7 +++++--
+ .../boot/dts/overlays/i2c-sensor-common.dtsi  | 19 ++++++++++++++++++-
+ 2 files changed, 23 insertions(+), 3 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -2052,8 +2052,8 @@ Info:   Adds support for a number of I2C
+         light level and chemical sensors on i2c_arm
+ Load:   dtoverlay=i2c-sensor,<param>=<val>
+ Params: addr                    Set the address for the BH1750, BME280, BME680,
+-                                BMP280, CCS811, DS1621, HDC100X, JC42, LM75,
+-                                MCP980x, MPU6050, MPU9250, MS5637, MS5803,
++                                BMP280, BMP380, CCS811, DS1621, HDC100X, JC42,
++                                LM75, MCP980x, MPU6050, MPU9250, MS5637, MS5803,
+                                 MS5805, MS5837, MS8607, SHT3x or TMP102
+ 
+         aht10                   Select the Aosong AHT10 temperature and humidity
+@@ -2075,6 +2075,9 @@ Params: addr                    Set the
+         bmp280                  Select the Bosch Sensortronic BMP280
+                                 Valid addresses 0x76-0x77, default 0x76
+ 
++        bmp380                  Select the Bosch Sensortronic BMP380
++                                Valid addresses 0x76-0x77, default 0x76
++
+         bno055                  Select the Bosch Sensortronic BNO055 IMU
+                                 Valid address 0x28-0x29, default 0x29
+ 
+--- a/arch/arm/boot/dts/overlays/i2c-sensor-common.dtsi
++++ b/arch/arm/boot/dts/overlays/i2c-sensor-common.dtsi
+@@ -493,11 +493,27 @@
+ 		};
+ 	};
+ 
++	fragment@33 {
++		target = <&i2cbus>;
++		__dormant__ {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "okay";
++
++			bmp380: bmp380@76 {
++				compatible = "bosch,bmp380";
++				reg = <0x76>;
++				status = "okay";
++			};
++		};
++	};
++
+ 	__overrides__ {
+ 		bme280 = <0>,"+0";
+ 		bmp085 = <0>,"+1";
+ 		bmp180 = <0>,"+2";
+ 		bmp280 = <0>,"+3";
++		bmp380 = <0>,"+33";
+ 		htu21 = <0>,"+4";
+ 		lm75 = <0>,"+5";
+ 		lm75addr = <&lm75>,"reg:0";
+@@ -535,7 +551,8 @@
+ 			<&ms5637>,"reg:0", <&ms5803>,"reg:0", <&ms5805>,"reg:0",
+ 			<&ms5837>,"reg:0", <&ms8607>,"reg:0",
+ 			<&mpu6050>,"reg:0", <&mpu9250>,"reg:0",
+-			<&bno055>,"reg:0", <&sht4x>,"reg:0";
++			<&bno055>,"reg:0", <&sht4x>,"reg:0",
++			<&bmp380>,"reg:0";
+ 		int_pin = <&max30102>, "interrupts:0",
+ 			<&mpu6050>, "interrupts:0",
+ 			<&mpu9250>, "interrupts:0";
diff --git a/target/linux/bcm27xx/patches-6.1/950-0821-can-isotp-add-module-parameter-for-maximum-pdu-size.patch b/target/linux/bcm27xx/patches-6.1/950-0821-can-isotp-add-module-parameter-for-maximum-pdu-size.patch
new file mode 100644
index 0000000000..d5cce9a433
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0821-can-isotp-add-module-parameter-for-maximum-pdu-size.patch
@@ -0,0 +1,162 @@
+From 4b729a06b15fc5ee3694dcc62346dcb718ae4290 Mon Sep 17 00:00:00 2001
+From: Oliver Hartkopp <socketcan@hartkopp.net>
+Date: Sun, 26 Mar 2023 13:59:11 +0200
+Subject: [PATCH] can: isotp: add module parameter for maximum pdu size
+
+commit 96d1c81e6a0478535342dff6c730adb076cd84e8 upstream.
+
+With ISO 15765-2:2016 the PDU size is not limited to 2^12 - 1 (4095)
+bytes but can be represented as a 32 bit unsigned integer value which
+allows 2^32 - 1 bytes (~4GB). The use-cases like automotive unified
+diagnostic services (UDS) and flashing of ECUs still use the small
+static buffers which are provided at socket creation time.
+
+When a use-case requires to transfer PDUs up to 1025 kByte the maximum
+PDU size can now be extended by setting the module parameter
+max_pdu_size. The extended size buffers are only allocated on a
+per-socket/connection base when needed at run-time.
+
+changes since v2: https://lore.kernel.org/all/20230313172510.3851-1-socketcan@hartkopp.net
+- use ARRAY_SIZE() to reference DEFAULT_MAX_PDU_SIZE only at one place
+
+changes since v1: https://lore.kernel.org/all/20230311143446.3183-1-socketcan@hartkopp.net
+- limit the minimum 'max_pdu_size' to 4095 to maintain the classic
+  behavior before ISO 15765-2:2016
+
+Link: https://github.com/raspberrypi/linux/issues/5371
+Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
+Link: https://lore.kernel.org/all/20230326115911.15094-1-socketcan@hartkopp.net
+Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
+---
+ net/can/isotp.c | 65 ++++++++++++++++++++++++++++++++++++++++++-------
+ 1 file changed, 56 insertions(+), 9 deletions(-)
+
+--- a/net/can/isotp.c
++++ b/net/can/isotp.c
+@@ -85,10 +85,21 @@ MODULE_ALIAS("can-proto-6");
+ 
+ /* ISO 15765-2:2016 supports more than 4095 byte per ISO PDU as the FF_DL can
+  * take full 32 bit values (4 Gbyte). We would need some good concept to handle
+- * this between user space and kernel space. For now increase the static buffer
+- * to something about 64 kbyte to be able to test this new functionality.
++ * this between user space and kernel space. For now set the static buffer to
++ * something about 8 kbyte to be able to test this new functionality.
+  */
+-#define MAX_MSG_LENGTH 66000
++#define DEFAULT_MAX_PDU_SIZE 8300
++
++/* maximum PDU size before ISO 15765-2:2016 extension was 4095 */
++#define MAX_12BIT_PDU_SIZE 4095
++
++/* limit the isotp pdu size from the optional module parameter to 1MByte */
++#define MAX_PDU_SIZE (1025 * 1024U)
++
++static unsigned int max_pdu_size __read_mostly = DEFAULT_MAX_PDU_SIZE;
++module_param(max_pdu_size, uint, 0444);
++MODULE_PARM_DESC(max_pdu_size, "maximum isotp pdu size (default "
++		 __stringify(DEFAULT_MAX_PDU_SIZE) ")");
+ 
+ /* N_PCI type values in bits 7-4 of N_PCI bytes */
+ #define N_PCI_SF 0x00	/* single frame */
+@@ -124,13 +135,15 @@ enum {
+ };
+ 
+ struct tpcon {
+-	unsigned int idx;
++	u8 *buf;
++	unsigned int buflen;
+ 	unsigned int len;
++	unsigned int idx;
+ 	u32 state;
+ 	u8 bs;
+ 	u8 sn;
+ 	u8 ll_dl;
+-	u8 buf[MAX_MSG_LENGTH + 1];
++	u8 sbuf[DEFAULT_MAX_PDU_SIZE];
+ };
+ 
+ struct isotp_sock {
+@@ -498,7 +511,17 @@ static int isotp_rcv_ff(struct sock *sk,
+ 	if (so->rx.len + ae + off + ff_pci_sz < so->rx.ll_dl)
+ 		return 1;
+ 
+-	if (so->rx.len > MAX_MSG_LENGTH) {
++	/* PDU size > default => try max_pdu_size */
++	if (so->rx.len > so->rx.buflen && so->rx.buflen < max_pdu_size) {
++		u8 *newbuf = kmalloc(max_pdu_size, GFP_ATOMIC);
++
++		if (newbuf) {
++			so->rx.buf = newbuf;
++			so->rx.buflen = max_pdu_size;
++		}
++	}
++
++	if (so->rx.len > so->rx.buflen) {
+ 		/* send FC frame with overflow status */
+ 		isotp_send_fc(sk, ae, ISOTP_FC_OVFLW);
+ 		return 1;
+@@ -802,7 +825,7 @@ static void isotp_create_fframe(struct c
+ 		cf->data[0] = so->opt.ext_address;
+ 
+ 	/* create N_PCI bytes with 12/32 bit FF_DL data length */
+-	if (so->tx.len > 4095) {
++	if (so->tx.len > MAX_12BIT_PDU_SIZE) {
+ 		/* use 32 bit FF_DL notation */
+ 		cf->data[ae] = N_PCI_FF;
+ 		cf->data[ae + 1] = 0;
+@@ -939,7 +962,17 @@ static int isotp_sendmsg(struct socket *
+ 			goto err_event_drop;
+ 	}
+ 
+-	if (!size || size > MAX_MSG_LENGTH) {
++	/* PDU size > default => try max_pdu_size */
++	if (size > so->tx.buflen && so->tx.buflen < max_pdu_size) {
++		u8 *newbuf = kmalloc(max_pdu_size, GFP_KERNEL);
++
++		if (newbuf) {
++			so->tx.buf = newbuf;
++			so->tx.buflen = max_pdu_size;
++		}
++	}
++
++	if (!size || size > so->tx.buflen) {
+ 		err = -EINVAL;
+ 		goto err_out_drop;
+ 	}
+@@ -1194,6 +1227,12 @@ static int isotp_release(struct socket *
+ 	so->ifindex = 0;
+ 	so->bound = 0;
+ 
++	if (so->rx.buf != so->rx.sbuf)
++		kfree(so->rx.buf);
++
++	if (so->tx.buf != so->tx.sbuf)
++		kfree(so->tx.buf);
++
+ 	sock_orphan(sk);
+ 	sock->sk = NULL;
+ 
+@@ -1588,6 +1627,11 @@ static int isotp_init(struct sock *sk)
+ 	so->rx.state = ISOTP_IDLE;
+ 	so->tx.state = ISOTP_IDLE;
+ 
++	so->rx.buf = so->rx.sbuf;
++	so->tx.buf = so->tx.sbuf;
++	so->rx.buflen = ARRAY_SIZE(so->rx.sbuf);
++	so->tx.buflen = ARRAY_SIZE(so->tx.sbuf);
++
+ 	hrtimer_init(&so->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);
+ 	so->rxtimer.function = isotp_rx_timer_handler;
+ 	hrtimer_init(&so->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);
+@@ -1670,7 +1714,10 @@ static __init int isotp_module_init(void
+ {
+ 	int err;
+ 
+-	pr_info("can: isotp protocol\n");
++	max_pdu_size = max_t(unsigned int, max_pdu_size, MAX_12BIT_PDU_SIZE);
++	max_pdu_size = min_t(unsigned int, max_pdu_size, MAX_PDU_SIZE);
++
++	pr_info("can: isotp protocol (max_pdu_size %d)\n", max_pdu_size);
+ 
+ 	err = can_proto_register(&isotp_can_proto);
+ 	if (err < 0)
diff --git a/target/linux/bcm27xx/patches-6.1/950-0822-drivers-media-imx296-Updated-imx296-driver-for-exter.patch b/target/linux/bcm27xx/patches-6.1/950-0822-drivers-media-imx296-Updated-imx296-driver-for-exter.patch
new file mode 100644
index 0000000000..ee4079cd64
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0822-drivers-media-imx296-Updated-imx296-driver-for-exter.patch
@@ -0,0 +1,40 @@
+From e1b03ea9e84320e6bf36a1486abaebbceadd7fc7 Mon Sep 17 00:00:00 2001
+From: Ben Benson <ben.benson@raspberrypi.com>
+Date: Fri, 21 Jul 2023 15:59:51 +0100
+Subject: [PATCH] drivers: media: imx296: Updated imx296 driver for external
+ trigger
+
+Updated imx296 driver to support external trigger mode via XTR pin.
+Added module parameter to control this mode.
+
+Signed-off-by: Ben Benson <ben.benson@raspberrypi.com>
+---
+ drivers/media/i2c/imx296.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/media/i2c/imx296.c
++++ b/drivers/media/i2c/imx296.c
+@@ -20,6 +20,10 @@
+ #include <media/v4l2-fwnode.h>
+ #include <media/v4l2-subdev.h>
+ 
++static int trigger_mode;
++module_param(trigger_mode, int, 0644);
++MODULE_PARM_DESC(trigger_mode, "Set trigger mode: 0=default, 1=XTRIG");
++
+ #define IMX296_PIXEL_ARRAY_WIDTH			1456
+ #define IMX296_PIXEL_ARRAY_HEIGHT			1088
+ 
+@@ -645,6 +649,12 @@ static int imx296_stream_on(struct imx29
+ 
+ 	imx296_write(sensor, IMX296_CTRL00, 0, &ret);
+ 	usleep_range(2000, 5000);
++
++	if (trigger_mode == 1) {
++		imx296_write(sensor, IMX296_CTRL0B, IMX296_CTRL0B_TRIGEN, &ret);
++		imx296_write(sensor, IMX296_LOWLAGTRG,  IMX296_LOWLAGTRG_FAST, &ret);
++	}
++
+ 	imx296_write(sensor, IMX296_CTRL0A, 0, &ret);
+ 
+ 	/* vflip and hflip cannot change during streaming */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0823-media-dt-bindings-imx258-Fix-alternate-compatible-st.patch b/target/linux/bcm27xx/patches-6.1/950-0823-media-dt-bindings-imx258-Fix-alternate-compatible-st.patch
new file mode 100644
index 0000000000..f45b68f154
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0823-media-dt-bindings-imx258-Fix-alternate-compatible-st.patch
@@ -0,0 +1,26 @@
+From 74bc238e86e62109c74d8f229dc105bf3818b4a7 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 2 Aug 2023 14:35:32 +0100
+Subject: [PATCH] media: dt-bindings: imx258: Fix alternate compatible strings
+
+Multiple compatible strings must appear as an enum.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ Documentation/devicetree/bindings/media/i2c/imx258.yaml | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+--- a/Documentation/devicetree/bindings/media/i2c/imx258.yaml
++++ b/Documentation/devicetree/bindings/media/i2c/imx258.yaml
+@@ -19,8 +19,9 @@ description: |-
+ 
+ properties:
+   compatible:
+-    const: sony,imx258
+-    const: sony,imx258-pdaf
++    enum:
++      - sony,imx258
++      - sony,imx258-pdaf
+ 
+   assigned-clocks: true
+   assigned-clock-parents: true
diff --git a/target/linux/bcm27xx/patches-6.1/950-0825-char-broadcom-vc_mem-Fix-preprocessor-conditional.patch b/target/linux/bcm27xx/patches-6.1/950-0825-char-broadcom-vc_mem-Fix-preprocessor-conditional.patch
new file mode 100644
index 0000000000..43283784dd
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0825-char-broadcom-vc_mem-Fix-preprocessor-conditional.patch
@@ -0,0 +1,21 @@
+From 282819aead0166af415b780241dc2def4caee7f4 Mon Sep 17 00:00:00 2001
+From: Alexander Winkowski <dereference23@outlook.com>
+Date: Mon, 3 Jul 2023 18:12:01 +0000
+Subject: [PATCH] char: broadcom: vc_mem: Fix preprocessor conditional
+
+Signed-off-by: Alexander Winkowski <dereference23@outlook.com>
+---
+ drivers/char/broadcom/vc_mem.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/char/broadcom/vc_mem.c
++++ b/drivers/char/broadcom/vc_mem.c
+@@ -353,7 +353,7 @@ vc_mem_exit(void)
+ 	pr_debug("%s: called\n", __func__);
+ 
+ 	if (vc_mem_inited) {
+-#if CONFIG_DEBUG_FS
++#ifdef CONFIG_DEBUG_FS
+ 		vc_mem_debugfs_deinit();
+ #endif
+ 		device_destroy(vc_mem_class, vc_mem_devnum);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0826-drivers-dwc_otg-Fix-fallthrough-warnings.patch b/target/linux/bcm27xx/patches-6.1/950-0826-drivers-dwc_otg-Fix-fallthrough-warnings.patch
new file mode 100644
index 0000000000..fe74c75e07
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0826-drivers-dwc_otg-Fix-fallthrough-warnings.patch
@@ -0,0 +1,32 @@
+From ec61075a786c455444a1d5df338a41bacfce0bb1 Mon Sep 17 00:00:00 2001
+From: Alexander Winkowski <dereference23@outlook.com>
+Date: Mon, 3 Jul 2023 18:23:02 +0000
+Subject: [PATCH] drivers: dwc_otg: Fix fallthrough warnings
+
+Signed-off-by: Alexander Winkowski <dereference23@outlook.com>
+---
+ drivers/usb/host/dwc_otg/dwc_otg_hcd.c      | 1 +
+ drivers/usb/host/dwc_otg/dwc_otg_hcd_intr.c | 2 +-
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/usb/host/dwc_otg/dwc_otg_hcd.c
++++ b/drivers/usb/host/dwc_otg/dwc_otg_hcd.c
+@@ -2049,6 +2049,7 @@ int fiq_fsm_queue_split_transaction(dwc_
+ 			} else {
+ 				st->fsm = FIQ_PER_SSPLIT_QUEUED;
+ 			}
++			break;
+ 		default:
+ 			break;
+ 	}
+--- a/drivers/usb/host/dwc_otg/dwc_otg_hcd_intr.c
++++ b/drivers/usb/host/dwc_otg/dwc_otg_hcd_intr.c
+@@ -402,7 +402,7 @@ int32_t dwc_otg_hcd_handle_rx_status_q_l
+ 			hc->xfer_count += grxsts.b.bcnt;
+ 			hc->xfer_buff += grxsts.b.bcnt;
+ 		}
+-
++		break;
+ 	case DWC_GRXSTS_PKTSTS_IN_XFER_COMP:
+ 	case DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
+ 	case DWC_GRXSTS_PKTSTS_CH_HALTED:
diff --git a/target/linux/bcm27xx/patches-6.1/950-0827-vc04_services-vc-sm-cma-Switch-one-bit-bitfields-to-.patch b/target/linux/bcm27xx/patches-6.1/950-0827-vc04_services-vc-sm-cma-Switch-one-bit-bitfields-to-.patch
new file mode 100644
index 0000000000..edd117c9b5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0827-vc04_services-vc-sm-cma-Switch-one-bit-bitfields-to-.patch
@@ -0,0 +1,61 @@
+From 2dd2f36d10961e3819ff0525ae2567e601973826 Mon Sep 17 00:00:00 2001
+From: Alexander Winkowski <dereference23@outlook.com>
+Date: Mon, 3 Jul 2023 18:29:37 +0000
+Subject: [PATCH] vc04_services/vc-sm-cma: Switch one-bit bitfields to bool
+
+Clang 16 warns:
+
+../drivers/staging/vc04_services/vc-sm-cma/vc_sm.c:816:19: warning: implicit truncation from 'int' to a one-bit wide bit-field changes value from 1 to -1 [-Wsingle-bit-bitfield-constant-conversion]
+        buffer->imported = 1;
+                         ^ ~
+../drivers/staging/vc04_services/vc-sm-cma/vc_sm.c:822:17: warning: implicit truncation from 'int' to a one-bit wide bit-field changes value from 1 to -1 [-Wsingle-bit-bitfield-constant-conversion]
+        buffer->in_use = 1;
+                       ^ ~
+2 warnings generated.
+
+Signed-off-by: Alexander Winkowski <dereference23@outlook.com>
+---
+ drivers/staging/vc04_services/vc-sm-cma/vc_sm.c | 6 +++---
+ drivers/staging/vc04_services/vc-sm-cma/vc_sm.h | 4 ++--
+ 2 files changed, 5 insertions(+), 5 deletions(-)
+
+--- a/drivers/staging/vc04_services/vc-sm-cma/vc_sm.c
++++ b/drivers/staging/vc04_services/vc-sm-cma/vc_sm.c
+@@ -533,7 +533,7 @@ static void vc_sm_dma_buf_release(struct
+ 
+ 	pr_debug("%s dmabuf %p, buffer %p\n", __func__, dmabuf, buffer);
+ 
+-	buffer->in_use = 0;
++	buffer->in_use = false;
+ 
+ 	/* Unmap on the VPU */
+ 	vc_sm_vpu_free(buffer);
+@@ -813,13 +813,13 @@ vc_sm_cma_import_dmabuf_internal(struct
+ 	buffer->size = import.size;
+ 	buffer->vpu_state = VPU_MAPPED;
+ 
+-	buffer->imported = 1;
++	buffer->imported = true;
+ 	buffer->import.dma_buf = dma_buf;
+ 
+ 	buffer->import.attach = attach;
+ 	buffer->import.sgt = sgt;
+ 	buffer->dma_addr = dma_addr;
+-	buffer->in_use = 1;
++	buffer->in_use = true;
+ 	buffer->kernel_id = import.kernel_id;
+ 
+ 	/*
+--- a/drivers/staging/vc04_services/vc-sm-cma/vc_sm.h
++++ b/drivers/staging/vc04_services/vc-sm-cma/vc_sm.h
+@@ -57,8 +57,8 @@ struct vc_sm_buffer {
+ 
+ 	char name[VC_SM_MAX_NAME_LEN];
+ 
+-	int in_use:1;	/* Kernel is still using this resource */
+-	int imported:1;	/* Imported dmabuf */
++	bool in_use:1;   /* Kernel is still using this resource */
++	bool imported:1; /* Imported dmabuf */
+ 
+ 	enum vc_sm_vpu_mapping_state vpu_state;
+ 	u32 vc_handle;	/* VideoCore handle for this buffer */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0828-media-i2c-ov2311-Fix-uninitialized-variable-usage.patch b/target/linux/bcm27xx/patches-6.1/950-0828-media-i2c-ov2311-Fix-uninitialized-variable-usage.patch
new file mode 100644
index 0000000000..d6fd3a9f92
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0828-media-i2c-ov2311-Fix-uninitialized-variable-usage.patch
@@ -0,0 +1,21 @@
+From 3333d45347d313ea589b8b8da1193d342060a946 Mon Sep 17 00:00:00 2001
+From: Alexander Winkowski <dereference23@outlook.com>
+Date: Mon, 3 Jul 2023 18:36:45 +0000
+Subject: [PATCH] media: i2c: ov2311: Fix uninitialized variable usage
+
+Signed-off-by: Alexander Winkowski <dereference23@outlook.com>
+---
+ drivers/media/i2c/ov2311.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/media/i2c/ov2311.c
++++ b/drivers/media/i2c/ov2311.c
+@@ -1018,7 +1018,7 @@ static int ov2311_check_sensor_id(struct
+ 				  struct i2c_client *client)
+ {
+ 	struct device *dev = &ov2311->client->dev;
+-	u32 id = 0, id_msb;
++	u32 id = 0, id_msb = 0;
+ 	int ret;
+ 
+ 	ret = ov2311_read_reg(client, OV2311_REG_CHIP_ID + 1,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0830-drm-panel-Fix-default-values-for-Waveshare-7.9-inch-.patch b/target/linux/bcm27xx/patches-6.1/950-0830-drm-panel-Fix-default-values-for-Waveshare-7.9-inch-.patch
new file mode 100644
index 0000000000..035b5b0049
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0830-drm-panel-Fix-default-values-for-Waveshare-7.9-inch-.patch
@@ -0,0 +1,29 @@
+From e89e7655a197d28df49da2be7e2003436cf52197 Mon Sep 17 00:00:00 2001
+From: Ignacio Larrain <ilarrain@gmail.com>
+Date: Tue, 22 Aug 2023 11:11:56 -0400
+Subject: [PATCH] drm/panel: Fix default values for Waveshare 7.9 inch DSI
+ touchscreen (#5565)
+
+This fixes touchscreen calibration, axis swapping and inversion.
+
+As referenced in https://github.com/raspberrypi/linux/issues/5550
+---
+ .../dts/overlays/vc4-kms-dsi-waveshare-panel-overlay.dts    | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/vc4-kms-dsi-waveshare-panel-overlay.dts
++++ b/arch/arm/boot/dts/overlays/vc4-kms-dsi-waveshare-panel-overlay.dts
+@@ -93,10 +93,10 @@
+ 				   <&touch>, "touchscreen-size-x:0=800",
+ 				   <&touch>, "touchscreen-size-y:0=480";
+ 		7_9_inch = <&panel>, "compatible=waveshare,7.9inch-panel",
+-				   <&touch>, "touchscreen-size-x:0=400",
+-				   <&touch>, "touchscreen-size-y:0=1280",
++				   <&touch>, "touchscreen-size-x:0=4096",
++				   <&touch>, "touchscreen-size-y:0=4096",
+ 				   <&touch>, "touchscreen-inverted-x?",
+-				   <&touch>, "touchscreen-inverted-y?";
++				   <&touch>, "touchscreen-swapped-x-y?";
+ 		8_0_inch = <&panel>, "compatible=waveshare,8.0inch-panel",
+ 				   <&touch>, "touchscreen-size-x:0=800",
+ 				   <&touch>, "touchscreen-size-y:0=1280",
diff --git a/target/linux/bcm27xx/patches-6.1/950-0831-dtoverlays-Add-i2c-bus-overrides-to-edt-ft5406-overl.patch b/target/linux/bcm27xx/patches-6.1/950-0831-dtoverlays-Add-i2c-bus-overrides-to-edt-ft5406-overl.patch
new file mode 100644
index 0000000000..cf703b0029
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0831-dtoverlays-Add-i2c-bus-overrides-to-edt-ft5406-overl.patch
@@ -0,0 +1,102 @@
+From 3fa2fbb7f6e60b85086e454403c5eab1af63b1aa Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 14 Jun 2023 13:43:58 +0100
+Subject: [PATCH] dtoverlays: Add i2c bus overrides to edt-ft5406 overlay
+
+Adds the option for the touch controller to be connected to any
+of the I2C ports.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README             | 17 +++++++++++++++-
+ .../boot/dts/overlays/edt-ft5406-overlay.dts  | 20 +++++++++++++++++++
+ arch/arm/boot/dts/overlays/edt-ft5406.dtsi    |  9 ++++++++-
+ 3 files changed, 44 insertions(+), 2 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -1040,9 +1040,11 @@ Params: dr_mode                 Dual rol
+ 
+ 
+ Name:   edt-ft5406
+-Info:   Overlay for the EDT FT5406 touchscreen on the CSI/DSI I2C interface.
++Info:   Overlay for the EDT FT5406 touchscreen.
+         This works with the Raspberry Pi 7" touchscreen when not being polled
+         by the firmware.
++        By default the overlay uses the i2c_csi_dsi I2C interface, but this
++        can be overridden
+         You MUST use either "disable_touchscreen=1" or "ignore_lcd=1" in
+         config.txt to stop the firmware polling the touchscreen.
+ Load:   dtoverlay=edt-ft5406,<param>=<val>
+@@ -1051,6 +1053,19 @@ Params: sizex                   Touchscr
+         invx                    Touchscreen inverted x axis
+         invy                    Touchscreen inverted y axis
+         swapxy                  Touchscreen swapped x y axis
++        i2c0                    Choose the I2C0 bus on GPIOs 0&1
++        i2c1                    Choose the I2C1 bus on GPIOs 2&3
++        i2c3                    Choose the I2C3 bus (configure with the i2c3
++                                overlay - BCM2711 only)
++        i2c4                    Choose the I2C4 bus (configure with the i2c4
++                                overlay - BCM2711 only)
++        i2c5                    Choose the I2C5 bus (configure with the i2c5
++                                overlay - BCM2711 only)
++        i2c6                    Choose the I2C6 bus (configure with the i2c6
++                                overlay - BCM2711 only)
++        addr                    Sets the address for the touch controller. Note
++                                that the device must be configured to use the
++                                specified address.
+ 
+ 
+ Name:   enc28j60
+--- a/arch/arm/boot/dts/overlays/edt-ft5406-overlay.dts
++++ b/arch/arm/boot/dts/overlays/edt-ft5406-overlay.dts
+@@ -23,4 +23,24 @@
+ 			status = "okay";
+ 		};
+ 	};
++
++	__overrides__ {
++		i2c0 = <&frag13>,"target:0=",<&i2c0>;
++		i2c1 = <&frag13>, "target?=0",
++		       <&frag13>, "target-path=i2c1",
++		       <0>,"-0-1";
++		i2c3 = <&frag13>, "target?=0",
++		       <&frag13>, "target-path=i2c3",
++		       <0>,"-0-1";
++		i2c4 = <&frag13>, "target?=0",
++		       <&frag13>, "target-path=i2c4",
++		       <0>,"-0-1";
++		i2c5 = <&frag13>, "target?=0",
++		       <&frag13>, "target-path=i2c5",
++		       <0>,"-0-1";
++		i2c6 = <&frag13>, "target?=0",
++		       <&frag13>, "target-path=i2c6",
++		       <0>,"-0-1";
++		addr = <&ft5406>,"reg:0";
++	};
+ };
+--- a/arch/arm/boot/dts/overlays/edt-ft5406.dtsi
++++ b/arch/arm/boot/dts/overlays/edt-ft5406.dtsi
+@@ -23,7 +23,7 @@
+ 	};
+ 
+ 	fragment@12 {
+-		target = <&i2c_csi_dsi>;
++		target = <&i2cbus>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+@@ -37,6 +37,13 @@
+ 		};
+ 	};
+ 
++	frag13: fragment@13 {
++		target = <&i2c_csi_dsi>;
++		i2cbus: __overlay__ {
++			status = "okay";
++		};
++	};
++
+ 	__overrides__ {
+ 		sizex = <&ft5406>,"touchscreen-size-x:0";
+ 		sizey = <&ft5406>,"touchscreen-size-y:0";
diff --git a/target/linux/bcm27xx/patches-6.1/950-0832-dtoverlays-Fix-README-text-for-i2c-fan.patch b/target/linux/bcm27xx/patches-6.1/950-0832-dtoverlays-Fix-README-text-for-i2c-fan.patch
new file mode 100644
index 0000000000..23953c9636
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0832-dtoverlays-Fix-README-text-for-i2c-fan.patch
@@ -0,0 +1,25 @@
+From 9d9586dc0c0deecb90675bd70862fe262f7376ab Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 14 Jun 2023 14:25:21 +0100
+Subject: [PATCH] dtoverlays: Fix README text for i2c-fan
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -1800,10 +1800,10 @@ Params: addr                    Sets the
+         i2c3                    Choose the I2C3 bus (configure with the i2c3
+                                 overlay - BCM2711 only)
+ 
+-        i2c4                    Choose the I2C3 bus (configure with the i2c3
++        i2c4                    Choose the I2C4 bus (configure with the i2c4
+                                 overlay - BCM2711 only)
+ 
+-        i2c5                    Choose the I2C5 bus (configure with the i2c4
++        i2c5                    Choose the I2C5 bus (configure with the i2c5
+                                 overlay - BCM2711 only)
+ 
+         i2c6                    Choose the I2C6 bus (configure with the i2c6
diff --git a/target/linux/bcm27xx/patches-6.1/950-0833-drivers-irqchip-irq-bcm2835-Concurrency-fix.patch b/target/linux/bcm27xx/patches-6.1/950-0833-drivers-irqchip-irq-bcm2835-Concurrency-fix.patch
new file mode 100644
index 0000000000..48e2fcdc74
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0833-drivers-irqchip-irq-bcm2835-Concurrency-fix.patch
@@ -0,0 +1,50 @@
+From e804bd1843236a63815e9acfb1a38ebf9a28ef5b Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 31 Aug 2023 16:45:44 +0100
+Subject: [PATCH] drivers: irqchip: irq-bcm2835: Concurrency fix
+
+The commit shown in Fixes: aims to improve interrupt throughput by
+getting the handlers invoked on different CPU cores. It does so (*) by
+using an irq_ack hook to change the interrupt routing.
+
+Unfortunately, the IRQ status bits must be cleared at source, which only
+happens once the interrupt handler has run - there is no easy way for
+one core to claim one of the IRQs before sending the remainder to the
+next core on the list, so waking another core immediately results in a
+race with a chance of both cores handling the same IRQ. It is probably
+for this reason that the routing change is deferred to irq_ack, but that
+doesn't guarantee no clashes - after irq_ack is called, control returns
+to bcm2836_chained_handler_irq which proceeds to check for other pending
+IRQs at a time when the next core is probably doing the same thing.
+
+Since the whole point of the original commit is to distribute the IRQ
+handling, there is no reason to attempt to handle multiple IRQs in one
+interrupt callback, so the problem can be solved (or at least made much
+harder to reproduce) by changing a "while" into an "if", so that each
+invocation only handles one IRQ.
+
+(*) I'm not convinced it's as effective as claimed since irq_ack is
+called _after_ the interrupt handler, but the author thought it made a
+difference.
+
+See: https://github.com/raspberrypi/linux/issues/5214
+     https://github.com/raspberrypi/linux/pull/1794
+
+Fixes: fd4c9785bde8 ("ARM64: Round-Robin dispatch IRQs between CPUs.")
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/irqchip/irq-bcm2835.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/irqchip/irq-bcm2835.c
++++ b/drivers/irqchip/irq-bcm2835.c
+@@ -343,7 +343,8 @@ static void bcm2836_chained_handle_irq(s
+ {
+ 	u32 hwirq;
+ 
+-	while ((hwirq = get_next_armctrl_hwirq()) != ~0)
++	hwirq = get_next_armctrl_hwirq();
++	if (hwirq != ~0)
+ 		generic_handle_domain_irq(intc.domain, hwirq);
+ }
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0835-dtoverlays-Add-drm-option-to-piscreen-overlay.patch b/target/linux/bcm27xx/patches-6.1/950-0835-dtoverlays-Add-drm-option-to-piscreen-overlay.patch
new file mode 100644
index 0000000000..10b1f15d2c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0835-dtoverlays-Add-drm-option-to-piscreen-overlay.patch
@@ -0,0 +1,58 @@
+From 5e54398e1b61335883dff1be46a6c8b3ca973926 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 30 Aug 2023 18:03:37 +0100
+Subject: [PATCH] dtoverlays: Add drm option to piscreen overlay
+
+Adds the option of selecting the DRM/KMS TinyDRM driver for
+this panel, rather than the deprecated FBTFT one.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README               |  3 +++
+ arch/arm/boot/dts/overlays/piscreen-overlay.dts | 10 +++++++---
+ 2 files changed, 10 insertions(+), 3 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -3245,6 +3245,9 @@ Params: speed                   Display
+ 
+         xohms                   Touchpanel sensitivity (X-plate resistance)
+ 
++        drm                     Select the DRM/KMS driver instead of the FBTFT
++                                one
++
+ 
+ Name:   piscreen2r
+ Info:   PiScreen 2 with resistive TP display by OzzMaker.com
+--- a/arch/arm/boot/dts/overlays/piscreen-overlay.dts
++++ b/arch/arm/boot/dts/overlays/piscreen-overlay.dts
+@@ -6,6 +6,8 @@
+ /dts-v1/;
+ /plugin/;
+ 
++#include <dt-bindings/gpio/gpio.h>
++
+ / {
+ 	compatible = "brcm,bcm2835";
+ 
+@@ -59,9 +61,9 @@
+ 				fps = <30>;
+ 				buswidth = <8>;
+ 				regwidth = <16>;
+-				reset-gpios = <&gpio 25 1>;
+-				dc-gpios = <&gpio 24 0>;
+-				led-gpios = <&gpio 22 0>;
++				reset-gpios = <&gpio 25 GPIO_ACTIVE_LOW>;
++				dc-gpios = <&gpio 24 GPIO_ACTIVE_HIGH>;
++				led-gpios = <&gpio 22 GPIO_ACTIVE_HIGH>;
+ 				debug = <0>;
+ 
+ 				init = <0x10000b0 0x00
+@@ -98,5 +100,7 @@
+ 		fps =		<&piscreen>,"fps:0";
+ 		debug =		<&piscreen>,"debug:0";
+ 		xohms =		<&piscreen_ts>,"ti,x-plate-ohms;0";
++		drm =		<&piscreen>,"compatible=waveshare,rpi-lcd-35",
++				<&piscreen>,"reset-gpios:8=",<GPIO_ACTIVE_HIGH>;
+ 	};
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-0836-drm-ili9486-Resolve-clash-in-spi_device_id-names.patch b/target/linux/bcm27xx/patches-6.1/950-0836-drm-ili9486-Resolve-clash-in-spi_device_id-names.patch
new file mode 100644
index 0000000000..0bce9f9e78
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0836-drm-ili9486-Resolve-clash-in-spi_device_id-names.patch
@@ -0,0 +1,36 @@
+From f59fe2d1bd056af117eb512bb0e9210a943c6d47 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 1 Sep 2023 12:17:38 +0100
+Subject: [PATCH] drm/ili9486: Resolve clash in spi_device_id names
+
+For "Really Good Reasons" [1] the SPI core requires a match
+between compatible device strings and the name in spi_device_id.
+
+The ili9486 driver uses compatible strings "waveshare,rpi-lcd-35"
+and "ozzmaker,piscreen", but "rpi-lcd-35" and "piscreen" are missing,
+so add them.
+
+Compatible string "ilitek,ili9486" is already used by
+staging/fbtft/fb_ili9486, therefore leaving it present in ili9486 as an
+spi_device_id causes the incorrect module to be loaded, therefore remove
+this id.
+
+[1] https://elixir.bootlin.com/linux/latest/source/drivers/spi/spi.c#L487
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/tiny/ili9486.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/tiny/ili9486.c
++++ b/drivers/gpu/drm/tiny/ili9486.c
+@@ -187,7 +187,8 @@ static const struct of_device_id ili9486
+ MODULE_DEVICE_TABLE(of, ili9486_of_match);
+ 
+ static const struct spi_device_id ili9486_id[] = {
+-	{ "ili9486", 0 },
++	{ "rpi-lcd-35", 0 },
++	{ "piscreen", 0 },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(spi, ili9486_id);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0837-input-ads7846-Add-missing-spi_device_id-strings.patch b/target/linux/bcm27xx/patches-6.1/950-0837-input-ads7846-Add-missing-spi_device_id-strings.patch
new file mode 100644
index 0000000000..71f1063986
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0837-input-ads7846-Add-missing-spi_device_id-strings.patch
@@ -0,0 +1,50 @@
+From 50c5a8558f4aaa54a3c4f5a8c2b6053f641d94eb Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 1 Sep 2023 12:23:30 +0100
+Subject: [PATCH] input: ads7846: Add missing spi_device_id strings
+
+The SPI core logs error messages if a compatible string device
+name is not also present as an spi_device_id.
+
+No spi_device_id values are specified by the driver, therefore
+we get 4 log lines every time it is loaded:
+SPI driver ads7846 has no spi_device_id for ti,tsc2046
+SPI driver ads7846 has no spi_device_id for ti,ads7843
+SPI driver ads7846 has no spi_device_id for ti,ads7845
+SPI driver ads7846 has no spi_device_id for ti,ads7873
+
+Add the spi_device_id values for these devices.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/input/touchscreen/ads7846.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/drivers/input/touchscreen/ads7846.c
++++ b/drivers/input/touchscreen/ads7846.c
+@@ -1127,6 +1127,17 @@ static const struct of_device_id ads7846
+ };
+ MODULE_DEVICE_TABLE(of, ads7846_dt_ids);
+ 
++static const struct spi_device_id ads7846_spi_ids[] = {
++	{ "tsc2046", 0 },
++	{ "ads7843", 0 },
++	{ "ads7843", 0 },
++	{ "ads7845", 0 },
++	{ "ads7846", 0 },
++	{ "ads7873", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(spi, ads7846_spi_ids);
++
+ static const struct ads7846_platform_data *ads7846_probe_dt(struct device *dev)
+ {
+ 	struct ads7846_platform_data *pdata;
+@@ -1424,6 +1435,7 @@ static struct spi_driver ads7846_driver
+ 		.pm	= &ads7846_pm,
+ 		.of_match_table = of_match_ptr(ads7846_dt_ids),
+ 	},
++	.id_table	= ads7846_spi_ids,
+ 	.probe		= ads7846_probe,
+ 	.remove		= ads7846_remove,
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-0838-staging-bcm2835-codec-Downgrade-the-level-for-a-debu.patch b/target/linux/bcm27xx/patches-6.1/950-0838-staging-bcm2835-codec-Downgrade-the-level-for-a-debu.patch
new file mode 100644
index 0000000000..5af23821a8
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0838-staging-bcm2835-codec-Downgrade-the-level-for-a-debu.patch
@@ -0,0 +1,27 @@
+From 65742d7116e89b08858fcd7d67bd521ee19ee837 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 30 Aug 2023 18:05:43 +0100
+Subject: [PATCH] staging: bcm2835-codec: Downgrade the level for a debug
+ message
+
+The debug message from bcm2835_codec_buf_prepare when the buffer
+size is incorrect can be a little spammy if the application isn't
+careful on how it drives it, therefore drop the priority of the
+message.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ .../staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c    | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c
++++ b/drivers/staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c
+@@ -2883,7 +2883,7 @@ static int bcm2835_codec_buf_prepare(str
+ 	}
+ 
+ 	if (vb2_plane_size(vb, 0) < q_data->sizeimage) {
+-		v4l2_err(&ctx->dev->v4l2_dev, "%s data will not fit into plane (%lu < %lu)\n",
++		v4l2_dbg(1, debug, &ctx->dev->v4l2_dev, "%s data will not fit into plane (%lu < %lu)\n",
+ 			 __func__, vb2_plane_size(vb, 0),
+ 			 (long)q_data->sizeimage);
+ 		return -EINVAL;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0840-gpio-fsm-Sort-functions-into-a-more-logical-order.patch b/target/linux/bcm27xx/patches-6.1/950-0840-gpio-fsm-Sort-functions-into-a-more-logical-order.patch
new file mode 100644
index 0000000000..873077f51c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0840-gpio-fsm-Sort-functions-into-a-more-logical-order.patch
@@ -0,0 +1,286 @@
+From cee471c3ada3215d6dfc53fb0f1b97548444dea7 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 5 Sep 2023 11:56:19 +0100
+Subject: [PATCH] gpio-fsm: Sort functions into a more logical order
+
+Move some functions into a more logical ordering. This change causes
+no functional change and is essentially cosmetic.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/gpio/gpio-fsm.c | 245 ++++++++++++++++++++--------------------
+ 1 file changed, 125 insertions(+), 120 deletions(-)
+
+--- a/drivers/gpio/gpio-fsm.c
++++ b/drivers/gpio/gpio-fsm.c
+@@ -193,131 +193,14 @@ static void free_symbols(struct symtab_e
+ 	}
+ }
+ 
+-static int gpio_fsm_get_direction(struct gpio_chip *gc, unsigned int off)
+-{
+-	struct gpio_fsm *gf = gpiochip_get_data(gc);
+-	struct soft_gpio *sg;
+-
+-	if (off >= gf->num_soft_gpios)
+-		return -EINVAL;
+-	sg = &gf->soft_gpios[off];
+-
+-	return sg->dir;
+-}
+-
+-static int gpio_fsm_get(struct gpio_chip *gc, unsigned int off)
+-{
+-	struct gpio_fsm *gf = gpiochip_get_data(gc);
+-	struct soft_gpio *sg;
+-
+-	if (off >= gf->num_soft_gpios)
+-		return -EINVAL;
+-	sg = &gf->soft_gpios[off];
+-
+-	return sg->value;
+-}
+-
+ static void gpio_fsm_go_to_state(struct gpio_fsm *gf,
+-				   struct fsm_state *new_state)
+-{
+-	struct input_gpio_state *inp_state;
+-	struct gpio_event *gp_ev;
+-	struct fsm_state *state;
+-	int i;
+-
+-	dev_dbg(gf->dev, "go_to_state(%s)\n",
+-		  new_state ? new_state->name : "<unset>");
+-
+-	spin_lock(&gf->spinlock);
+-
+-	if (gf->next_state) {
+-		/* Something else has already requested a transition */
+-		spin_unlock(&gf->spinlock);
+-		return;
+-	}
+-
+-	gf->next_state = new_state;
+-	state = gf->current_state;
+-	gf->delay_target_state = NULL;
+-
+-	if (state) {
+-		/* Disarm any GPIO IRQs */
+-		for (i = 0; i < state->num_gpio_events; i++) {
+-			gp_ev = &state->gpio_events[i];
+-			inp_state = &gf->input_gpio_states[gp_ev->index];
+-			inp_state->target = NULL;
+-		}
+-	}
+-
+-	spin_unlock(&gf->spinlock);
+-
+-	if (new_state)
+-		schedule_work(&gf->work);
+-}
++				 struct fsm_state *new_state);
+ 
+ static void gpio_fsm_set_soft(struct gpio_fsm *gf,
+-				unsigned int off, int val)
+-{
+-	struct soft_gpio *sg = &gf->soft_gpios[off];
+-	struct gpio_event *gp_ev;
+-	struct fsm_state *state;
+-	int i;
+-
+-	dev_dbg(gf->dev, "set(%d,%d)\n", off, val);
+-	state = gf->current_state;
+-	sg->value = val;
+-	for (i = 0; i < state->num_soft_events; i++) {
+-		gp_ev = &state->soft_events[i];
+-		if (gp_ev->index == off && gp_ev->value == val) {
+-			if (gf->debug)
+-				dev_info(gf->dev,
+-					 "GF_SOFT %d->%d -> %s\n", gp_ev->index,
+-					 gp_ev->value, gp_ev->target->name);
+-			gpio_fsm_go_to_state(gf, gp_ev->target);
+-			break;
+-		}
+-	}
+-}
+-
+-static int gpio_fsm_direction_input(struct gpio_chip *gc, unsigned int off)
+-{
+-	struct gpio_fsm *gf = gpiochip_get_data(gc);
+-	struct soft_gpio *sg;
+-
+-	if (off >= gf->num_soft_gpios)
+-		return -EINVAL;
+-	sg = &gf->soft_gpios[off];
+-	sg->dir = GPIOF_DIR_IN;
+-
+-	return 0;
+-}
+-
+-static int gpio_fsm_direction_output(struct gpio_chip *gc, unsigned int off,
+-				       int value)
+-{
+-	struct gpio_fsm *gf = gpiochip_get_data(gc);
+-	struct soft_gpio *sg;
+-
+-	if (off >= gf->num_soft_gpios)
+-		return -EINVAL;
+-	sg = &gf->soft_gpios[off];
+-	sg->dir = GPIOF_DIR_OUT;
+-	gpio_fsm_set_soft(gf, off, value);
+-
+-	return 0;
+-}
+-
+-static void gpio_fsm_set(struct gpio_chip *gc, unsigned int off, int val)
+-{
+-	struct gpio_fsm *gf;
+-
+-	gf = gpiochip_get_data(gc);
+-	if (off < gf->num_soft_gpios)
+-		gpio_fsm_set_soft(gf, off, val);
+-}
++			      unsigned int off, int val);
+ 
+ static void gpio_fsm_enter_state(struct gpio_fsm *gf,
+-				   struct fsm_state *state)
++				 struct fsm_state *state)
+ {
+ 	struct input_gpio_state *inp_state;
+ 	struct output_signal *signal;
+@@ -431,6 +314,44 @@ static void gpio_fsm_enter_state(struct
+ 	}
+ }
+ 
++static void gpio_fsm_go_to_state(struct gpio_fsm *gf,
++				 struct fsm_state *new_state)
++{
++	struct input_gpio_state *inp_state;
++	struct gpio_event *gp_ev;
++	struct fsm_state *state;
++	int i;
++
++	dev_dbg(gf->dev, "go_to_state(%s)\n",
++		  new_state ? new_state->name : "<unset>");
++
++	spin_lock(&gf->spinlock);
++
++	if (gf->next_state) {
++		/* Something else has already requested a transition */
++		spin_unlock(&gf->spinlock);
++		return;
++	}
++
++	gf->next_state = new_state;
++	state = gf->current_state;
++	gf->delay_target_state = NULL;
++
++	if (state) {
++		/* Disarm any GPIO IRQs */
++		for (i = 0; i < state->num_gpio_events; i++) {
++			gp_ev = &state->gpio_events[i];
++			inp_state = &gf->input_gpio_states[gp_ev->index];
++			inp_state->target = NULL;
++		}
++	}
++
++	spin_unlock(&gf->spinlock);
++
++	if (new_state)
++		schedule_work(&gf->work);
++}
++
+ static void gpio_fsm_work(struct work_struct *work)
+ {
+ 	struct input_gpio_state *inp_state;
+@@ -851,6 +772,90 @@ static int resolve_sym_to_state(struct g
+ 	return 0;
+ }
+ 
++static void gpio_fsm_set_soft(struct gpio_fsm *gf,
++			      unsigned int off, int val)
++{
++	struct soft_gpio *sg = &gf->soft_gpios[off];
++	struct gpio_event *gp_ev;
++	struct fsm_state *state;
++	int i;
++
++	dev_dbg(gf->dev, "set(%d,%d)\n", off, val);
++	state = gf->current_state;
++	sg->value = val;
++	for (i = 0; i < state->num_soft_events; i++) {
++		gp_ev = &state->soft_events[i];
++		if (gp_ev->index == off && gp_ev->value == val) {
++			if (gf->debug)
++				dev_info(gf->dev,
++					 "GF_SOFT %d->%d -> %s\n", gp_ev->index,
++					 gp_ev->value, gp_ev->target->name);
++			gpio_fsm_go_to_state(gf, gp_ev->target);
++			break;
++		}
++	}
++}
++
++static int gpio_fsm_get(struct gpio_chip *gc, unsigned int off)
++{
++	struct gpio_fsm *gf = gpiochip_get_data(gc);
++	struct soft_gpio *sg;
++
++	if (off >= gf->num_soft_gpios)
++		return -EINVAL;
++	sg = &gf->soft_gpios[off];
++
++	return sg->value;
++}
++
++static void gpio_fsm_set(struct gpio_chip *gc, unsigned int off, int val)
++{
++	struct gpio_fsm *gf;
++
++	gf = gpiochip_get_data(gc);
++	if (off < gf->num_soft_gpios)
++		gpio_fsm_set_soft(gf, off, val);
++}
++
++static int gpio_fsm_get_direction(struct gpio_chip *gc, unsigned int off)
++{
++	struct gpio_fsm *gf = gpiochip_get_data(gc);
++	struct soft_gpio *sg;
++
++	if (off >= gf->num_soft_gpios)
++		return -EINVAL;
++	sg = &gf->soft_gpios[off];
++
++	return sg->dir;
++}
++
++static int gpio_fsm_direction_input(struct gpio_chip *gc, unsigned int off)
++{
++	struct gpio_fsm *gf = gpiochip_get_data(gc);
++	struct soft_gpio *sg;
++
++	if (off >= gf->num_soft_gpios)
++		return -EINVAL;
++	sg = &gf->soft_gpios[off];
++	sg->dir = GPIOF_DIR_IN;
++
++	return 0;
++}
++
++static int gpio_fsm_direction_output(struct gpio_chip *gc, unsigned int off,
++				       int value)
++{
++	struct gpio_fsm *gf = gpiochip_get_data(gc);
++	struct soft_gpio *sg;
++
++	if (off >= gf->num_soft_gpios)
++		return -EINVAL;
++	sg = &gf->soft_gpios[off];
++	sg->dir = GPIOF_DIR_OUT;
++	gpio_fsm_set_soft(gf, off, value);
++
++	return 0;
++}
+ 
+ /*
+  * /sys/class/gpio-fsm/<fsm-name>/
diff --git a/target/linux/bcm27xx/patches-6.1/950-0841-gpio_fsm-Rework-the-atomic-vs-non-atomic-split.patch b/target/linux/bcm27xx/patches-6.1/950-0841-gpio_fsm-Rework-the-atomic-vs-non-atomic-split.patch
new file mode 100644
index 0000000000..ae3c019e25
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0841-gpio_fsm-Rework-the-atomic-vs-non-atomic-split.patch
@@ -0,0 +1,192 @@
+From f0061ffc98c6e027c5774e2a24ceadcfee4167ea Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 5 Sep 2023 12:01:13 +0100
+Subject: [PATCH] gpio_fsm: Rework the atomic-vs-non-atomic split
+
+Partition the code to separate atomic and non-atomic methods so that
+none of them have to handle both cases. The result avoids using deferred
+work unless necessary, and should be easier to understand.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/gpio/gpio-fsm.c | 84 ++++++++++++++++++++---------------------
+ 1 file changed, 41 insertions(+), 43 deletions(-)
+
+--- a/drivers/gpio/gpio-fsm.c
++++ b/drivers/gpio/gpio-fsm.c
+@@ -193,9 +193,6 @@ static void free_symbols(struct symtab_e
+ 	}
+ }
+ 
+-static void gpio_fsm_go_to_state(struct gpio_fsm *gf,
+-				 struct fsm_state *new_state);
+-
+ static void gpio_fsm_set_soft(struct gpio_fsm *gf,
+ 			      unsigned int off, int val);
+ 
+@@ -213,6 +210,7 @@ static void gpio_fsm_enter_state(struct
+ 	dev_dbg(gf->dev, "enter_state(%s)\n", state->name);
+ 
+ 	gf->current_state = state;
++	gf->delay_target_state = NULL;
+ 
+ 	// 1. Apply any listed signals
+ 	for (i = 0; i < state->num_signals; i++) {
+@@ -271,7 +269,7 @@ static void gpio_fsm_enter_state(struct
+ 				dev_info(gf->dev,
+ 					 "GF_SOFT %d=%d -> %s\n", event->index,
+ 					 event->value, event->target->name);
+-			gpio_fsm_go_to_state(gf, event->target);
++			gpio_fsm_enter_state(gf, event->target);
+ 			return;
+ 		}
+ 	}
+@@ -284,7 +282,7 @@ static void gpio_fsm_enter_state(struct
+ 		inp_state->value = event->value;
+ 		inp_state->enabled = true;
+ 
+-		value = gpiod_get_value(gf->input_gpios->desc[event->index]);
++		value = gpiod_get_value_cansleep(gf->input_gpios->desc[event->index]);
+ 
+ 		// Clear stale event state
+ 		disable_irq(inp_state->irq);
+@@ -299,7 +297,7 @@ static void gpio_fsm_enter_state(struct
+ 				dev_info(gf->dev,
+ 					 "GF_IN %d=%d -> %s\n", event->index,
+ 					 event->value, event->target->name);
+-			gpio_fsm_go_to_state(gf, event->target);
++			gpio_fsm_enter_state(gf, event->target);
+ 			return;
+ 		}
+ 	}
+@@ -325,6 +323,33 @@ static void gpio_fsm_go_to_state(struct
+ 	dev_dbg(gf->dev, "go_to_state(%s)\n",
+ 		  new_state ? new_state->name : "<unset>");
+ 
++	state = gf->current_state;
++
++	/* Disable any enabled GPIO IRQs */
++	for (i = 0; i < state->num_gpio_events; i++) {
++		gp_ev = &state->gpio_events[i];
++		inp_state = &gf->input_gpio_states[gp_ev->index];
++		if (inp_state->enabled) {
++			inp_state->enabled = false;
++			irq_set_irq_type(inp_state->irq,
++					 IRQF_TRIGGER_NONE);
++		}
++	}
++
++	gpio_fsm_enter_state(gf, new_state);
++}
++
++static void gpio_fsm_go_to_state_deferred(struct gpio_fsm *gf,
++					  struct fsm_state *new_state)
++{
++	struct input_gpio_state *inp_state;
++	struct gpio_event *gp_ev;
++	struct fsm_state *state;
++	int i;
++
++	dev_dbg(gf->dev, "go_to_state_deferred(%s)\n",
++		  new_state ? new_state->name : "<unset>");
++
+ 	spin_lock(&gf->spinlock);
+ 
+ 	if (gf->next_state) {
+@@ -335,57 +360,31 @@ static void gpio_fsm_go_to_state(struct
+ 
+ 	gf->next_state = new_state;
+ 	state = gf->current_state;
+-	gf->delay_target_state = NULL;
+ 
+-	if (state) {
+-		/* Disarm any GPIO IRQs */
+-		for (i = 0; i < state->num_gpio_events; i++) {
+-			gp_ev = &state->gpio_events[i];
+-			inp_state = &gf->input_gpio_states[gp_ev->index];
+-			inp_state->target = NULL;
+-		}
++	/* Disarm any GPIO IRQs */
++	for (i = 0; i < state->num_gpio_events; i++) {
++		gp_ev = &state->gpio_events[i];
++		inp_state = &gf->input_gpio_states[gp_ev->index];
++		inp_state->target = NULL;
+ 	}
+ 
+ 	spin_unlock(&gf->spinlock);
+ 
+-	if (new_state)
+-		schedule_work(&gf->work);
++	schedule_work(&gf->work);
+ }
+ 
+ static void gpio_fsm_work(struct work_struct *work)
+ {
+-	struct input_gpio_state *inp_state;
+ 	struct fsm_state *new_state;
+-	struct fsm_state *state;
+-	struct gpio_event *gp_ev;
+ 	struct gpio_fsm *gf;
+-	int i;
+ 
+ 	gf = container_of(work, struct gpio_fsm, work);
+ 	spin_lock(&gf->spinlock);
+-	state = gf->current_state;
+ 	new_state = gf->next_state;
+-	if (!new_state)
+-		new_state = gf->delay_target_state;
+ 	gf->next_state = NULL;
+-	gf->delay_target_state = NULL;
+ 	spin_unlock(&gf->spinlock);
+ 
+-	if (state) {
+-		/* Disable any enabled GPIO IRQs */
+-		for (i = 0; i < state->num_gpio_events; i++) {
+-			gp_ev = &state->gpio_events[i];
+-			inp_state = &gf->input_gpio_states[gp_ev->index];
+-			if (inp_state->enabled) {
+-				inp_state->enabled = false;
+-				irq_set_irq_type(inp_state->irq,
+-						 IRQF_TRIGGER_NONE);
+-			}
+-		}
+-	}
+-
+-	if (new_state)
+-		gpio_fsm_enter_state(gf, new_state);
++	gpio_fsm_go_to_state(gf, new_state);
+ }
+ 
+ static irqreturn_t gpio_fsm_gpio_irq_handler(int irq, void *dev_id)
+@@ -404,7 +403,7 @@ static irqreturn_t gpio_fsm_gpio_irq_han
+ 	if (gf->debug)
+ 		dev_info(gf->dev, "GF_IN %d->%d -> %s\n",
+ 			 inp_state->index, inp_state->value, target->name);
+-	gpio_fsm_go_to_state(gf, target);
++	gpio_fsm_go_to_state_deferred(gf, target);
+ 	return IRQ_HANDLED;
+ }
+ 
+@@ -416,12 +415,11 @@ static void gpio_fsm_timer(struct timer_
+ 	target = gf->delay_target_state;
+ 	if (!target)
+ 		return;
+-
+ 	if (gf->debug)
+ 		dev_info(gf->dev, "GF_DELAY %d -> %s\n", gf->delay_ms,
+ 			 target->name);
+ 
+-	gpio_fsm_go_to_state(gf, target);
++	gpio_fsm_go_to_state_deferred(gf, target);
+ }
+ 
+ int gpio_fsm_parse_signals(struct gpio_fsm *gf, struct fsm_state *state,
+@@ -1119,7 +1117,7 @@ static int gpio_fsm_probe(struct platfor
+ 	if (gf->debug)
+ 		dev_info(gf->dev, "Start -> %s\n", gf->start_state->name);
+ 
+-	gpio_fsm_go_to_state(gf, gf->start_state);
++	gpio_fsm_enter_state(gf, gf->start_state);
+ 
+ 	return devm_gpiochip_add_data(dev, &gf->gc, gf);
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0842-f2fs-fix-to-avoid-NULL-pointer-dereference-in-f2fs_i.patch b/target/linux/bcm27xx/patches-6.1/950-0842-f2fs-fix-to-avoid-NULL-pointer-dereference-in-f2fs_i.patch
new file mode 100644
index 0000000000..33150551b3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0842-f2fs-fix-to-avoid-NULL-pointer-dereference-in-f2fs_i.patch
@@ -0,0 +1,63 @@
+From bf9fb25f3265605572f04e5c7836bb83ee345236 Mon Sep 17 00:00:00 2001
+From: Chao Yu <chao@kernel.org>
+Date: Fri, 30 Dec 2022 23:43:32 +0800
+Subject: [PATCH] f2fs: fix to avoid NULL pointer dereference in
+ f2fs_issue_flush()
+
+commit b3d83066cbebc76dbac8a5fca931f64b4c6fff34 upstream.
+
+With below two cases, it will cause NULL pointer dereference when
+accessing SM_I(sbi)->fcc_info in f2fs_issue_flush().
+
+a) If kthread_run() fails in f2fs_create_flush_cmd_control(), it will
+release SM_I(sbi)->fcc_info,
+
+- mount -o noflush_merge /dev/vda /mnt/f2fs
+- mount -o remount,flush_merge /dev/vda /mnt/f2fs  -- kthread_run() fails
+- dd if=/dev/zero of=/mnt/f2fs/file bs=4k count=1 conv=fsync
+
+b) we will never allocate memory for SM_I(sbi)->fcc_info w/ below
+testcase,
+
+- mount -o ro /dev/vda /mnt/f2fs
+- mount -o rw,remount /dev/vda /mnt/f2fs
+- dd if=/dev/zero of=/mnt/f2fs/file bs=4k count=1 conv=fsync
+
+In order to fix this issue, let change as below:
+- fix error path handling in f2fs_create_flush_cmd_control().
+- allocate SM_I(sbi)->fcc_info even if readonly is on.
+
+Signed-off-by: Chao Yu <chao@kernel.org>
+Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
+---
+ fs/f2fs/segment.c | 12 ++++--------
+ 1 file changed, 4 insertions(+), 8 deletions(-)
+
+--- a/fs/f2fs/segment.c
++++ b/fs/f2fs/segment.c
+@@ -663,9 +663,7 @@ init_thread:
+ 				"f2fs_flush-%u:%u", MAJOR(dev), MINOR(dev));
+ 	if (IS_ERR(fcc->f2fs_issue_flush)) {
+ 		err = PTR_ERR(fcc->f2fs_issue_flush);
+-		kfree(fcc);
+-		SM_I(sbi)->fcc_info = NULL;
+-		return err;
++		fcc->f2fs_issue_flush = NULL;
+ 	}
+ 
+ 	return err;
+@@ -5062,11 +5060,9 @@ int f2fs_build_segment_manager(struct f2
+ 
+ 	init_f2fs_rwsem(&sm_info->curseg_lock);
+ 
+-	if (!f2fs_readonly(sbi->sb)) {
+-		err = f2fs_create_flush_cmd_control(sbi);
+-		if (err)
+-			return err;
+-	}
++	err = f2fs_create_flush_cmd_control(sbi);
++	if (err)
++		return err;
+ 
+ 	err = create_discard_cmd_control(sbi);
+ 	if (err)
diff --git a/target/linux/bcm27xx/patches-6.1/950-0843-ASoC-hdmi-codec-Fix-broken-channel-map-reporting.patch b/target/linux/bcm27xx/patches-6.1/950-0843-ASoC-hdmi-codec-Fix-broken-channel-map-reporting.patch
new file mode 100644
index 0000000000..045bd7e608
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0843-ASoC-hdmi-codec-Fix-broken-channel-map-reporting.patch
@@ -0,0 +1,47 @@
+From a319c6c1a5661af2014b98cd0a02526e7f2f515a Mon Sep 17 00:00:00 2001
+From: Matthias Reichl <hias@horus.com>
+Date: Sat, 9 Sep 2023 13:46:33 +0200
+Subject: [PATCH] ASoC: hdmi-codec: Fix broken channel map reporting
+
+Commit 4e0871333661 ("ASoC: hdmi-codec: fix channel info for
+compressed formats") accidentally changed hcp->chmap_idx from
+ca_id, the CEA channel allocation ID, to idx, the index to
+the table of channel mappings ordered by preference.
+
+This resulted in wrong channel maps being reported to userspace,
+eg for 5.1 "FL,FR,LFE,FC" was reported instead of the expected
+"FL,FR,LFE,FC,RL,RR":
+
+~ # speaker-test -c 6 -t sine
+...
+ 0 - Front Left
+ 3 - Front Center
+ 1 - Front Right
+ 2 - LFE
+ 4 - Unknown
+ 5 - Unknown
+
+~ # amixer cget iface=PCM,name='Playback Channel Map' | grep ': values'
+  : values=3,4,8,7,0,0,0,0
+
+Revert this incorrect change so that channel maps are properly
+reported again.
+
+Fixes: 4e0871333661 ("ASoC: hdmi-codec: fix channel info for compressed formats")
+Cc: stable@vger.kernel.org
+Signed-off-by: Matthias Reichl <hias@horus.com>
+---
+ sound/soc/codecs/hdmi-codec.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/sound/soc/codecs/hdmi-codec.c
++++ b/sound/soc/codecs/hdmi-codec.c
+@@ -520,7 +520,7 @@ static int hdmi_codec_fill_codec_params(
+ 	hp->sample_rate = sample_rate;
+ 	hp->channels = channels;
+ 
+-	hcp->chmap_idx = idx;
++	hcp->chmap_idx = ca_id;
+ 
+ 	return 0;
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0845-Revert-hwrng-iproc-rng200-Add-BCM2838-support.patch b/target/linux/bcm27xx/patches-6.1/950-0845-Revert-hwrng-iproc-rng200-Add-BCM2838-support.patch
new file mode 100644
index 0000000000..d07dcec3b9
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0845-Revert-hwrng-iproc-rng200-Add-BCM2838-support.patch
@@ -0,0 +1,142 @@
+From 6fbb2ac651a51ddc1754caf24ebf7b7dc9cf3312 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Wed, 13 Sep 2023 17:48:36 +0100
+Subject: [PATCH] Revert "hwrng: iproc-rng200: Add BCM2838 support"
+
+This reverts commit 7a01051faa2cdd074fa54fc59610251c39aefdfc.
+---
+ drivers/char/hw_random/Kconfig        |  2 +-
+ drivers/char/hw_random/iproc-rng200.c | 78 ++-------------------------
+ 2 files changed, 4 insertions(+), 76 deletions(-)
+
+--- a/drivers/char/hw_random/Kconfig
++++ b/drivers/char/hw_random/Kconfig
+@@ -104,7 +104,7 @@ config HW_RANDOM_IPROC_RNG200
+ 	default HW_RANDOM
+ 	help
+ 	  This driver provides kernel-side support for the RNG200
+-	  hardware found on the Broadcom iProc, BCM2711 and STB SoCs.
++	  hardware found on the Broadcom iProc and STB SoCs.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called iproc-rng200
+--- a/drivers/char/hw_random/iproc-rng200.c
++++ b/drivers/char/hw_random/iproc-rng200.c
+@@ -21,7 +21,6 @@
+ #define RNG_CTRL_OFFSET					0x00
+ #define RNG_CTRL_RNG_RBGEN_MASK				0x00001FFF
+ #define RNG_CTRL_RNG_RBGEN_ENABLE			0x00000001
+-#define RNG_CTRL_RNG_DIV_CTRL_SHIFT			13
+ 
+ #define RNG_SOFT_RESET_OFFSET				0x04
+ #define RNG_SOFT_RESET					0x00000001
+@@ -29,23 +28,16 @@
+ #define RBG_SOFT_RESET_OFFSET				0x08
+ #define RBG_SOFT_RESET					0x00000001
+ 
+-#define RNG_TOTAL_BIT_COUNT_OFFSET			0x0C
+-
+-#define RNG_TOTAL_BIT_COUNT_THRESHOLD_OFFSET		0x10
+-
+ #define RNG_INT_STATUS_OFFSET				0x18
+ #define RNG_INT_STATUS_MASTER_FAIL_LOCKOUT_IRQ_MASK	0x80000000
+ #define RNG_INT_STATUS_STARTUP_TRANSITIONS_MET_IRQ_MASK	0x00020000
+ #define RNG_INT_STATUS_NIST_FAIL_IRQ_MASK		0x00000020
+ #define RNG_INT_STATUS_TOTAL_BITS_COUNT_IRQ_MASK	0x00000001
+ 
+-#define RNG_INT_ENABLE_OFFSET				0x1C
+-
+ #define RNG_FIFO_DATA_OFFSET				0x20
+ 
+ #define RNG_FIFO_COUNT_OFFSET				0x24
+ #define RNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK		0x000000FF
+-#define RNG_FIFO_COUNT_RNG_FIFO_THRESHOLD_SHIFT		8
+ 
+ struct iproc_rng200_dev {
+ 	struct hwrng rng;
+@@ -166,64 +158,6 @@ static int iproc_rng200_init(struct hwrn
+ 	return 0;
+ }
+ 
+-static int bcm2711_rng200_read(struct hwrng *rng, void *buf, size_t max,
+-			       bool wait)
+-{
+-	struct iproc_rng200_dev *priv = to_rng_priv(rng);
+-	u32 max_words = max / sizeof(u32);
+-	u32 num_words, count, val;
+-
+-	/* ensure warm up period has elapsed */
+-	while (1) {
+-		val = ioread32(priv->base + RNG_TOTAL_BIT_COUNT_OFFSET);
+-		if (val > 16)
+-			break;
+-		cpu_relax();
+-	}
+-
+-	/* ensure fifo is not empty */
+-	while (1) {
+-		num_words = ioread32(priv->base + RNG_FIFO_COUNT_OFFSET) &
+-			    RNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK;
+-		if (num_words)
+-			break;
+-		if (!wait)
+-			return 0;
+-		cpu_relax();
+-	}
+-
+-	if (num_words > max_words)
+-		num_words = max_words;
+-
+-	for (count = 0; count < num_words; count++) {
+-		((u32 *)buf)[count] = ioread32(priv->base +
+-					       RNG_FIFO_DATA_OFFSET);
+-	}
+-
+-	return num_words * sizeof(u32);
+-}
+-
+-static int bcm2711_rng200_init(struct hwrng *rng)
+-{
+-	struct iproc_rng200_dev *priv = to_rng_priv(rng);
+-	uint32_t val;
+-
+-	if (ioread32(priv->base + RNG_CTRL_OFFSET) & RNG_CTRL_RNG_RBGEN_MASK)
+-		return 0;
+-
+-	/* initial numbers generated are "less random" so will be discarded */
+-	val = 0x40000;
+-	iowrite32(val, priv->base + RNG_TOTAL_BIT_COUNT_THRESHOLD_OFFSET);
+-	/* min fifo count to generate full interrupt */
+-	val = 2 << RNG_FIFO_COUNT_RNG_FIFO_THRESHOLD_SHIFT;
+-	iowrite32(val, priv->base + RNG_FIFO_COUNT_OFFSET);
+-	/* enable the rng - 1Mhz sample rate */
+-	val = (0x3 << RNG_CTRL_RNG_DIV_CTRL_SHIFT) | RNG_CTRL_RNG_RBGEN_MASK;
+-	iowrite32(val, priv->base + RNG_CTRL_OFFSET);
+-
+-	return 0;
+-}
+-
+ static void iproc_rng200_cleanup(struct hwrng *rng)
+ {
+ 	struct iproc_rng200_dev *priv = to_rng_priv(rng);
+@@ -250,17 +184,11 @@ static int iproc_rng200_probe(struct pla
+ 
+ 	dev_set_drvdata(dev, priv);
+ 
+-	priv->rng.name = pdev->name;
++	priv->rng.name = "iproc-rng200";
++	priv->rng.read = iproc_rng200_read;
++	priv->rng.init = iproc_rng200_init;
+ 	priv->rng.cleanup = iproc_rng200_cleanup;
+ 
+-	if (of_device_is_compatible(dev->of_node, "brcm,bcm2711-rng200")) {
+-		priv->rng.init = bcm2711_rng200_init;
+-		priv->rng.read = bcm2711_rng200_read;
+-	} else {
+-		priv->rng.init = iproc_rng200_init;
+-		priv->rng.read = iproc_rng200_read;
+-	}
+-
+ 	/* Register driver */
+ 	ret = devm_hwrng_register(dev, &priv->rng);
+ 	if (ret) {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0846-hwrng-iproc-rng200-Add-BCM2838-support.patch b/target/linux/bcm27xx/patches-6.1/950-0846-hwrng-iproc-rng200-Add-BCM2838-support.patch
new file mode 100644
index 0000000000..a179d930df
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0846-hwrng-iproc-rng200-Add-BCM2838-support.patch
@@ -0,0 +1,161 @@
+From e079555a4c68356e58249cfc041b28f6eb455bd5 Mon Sep 17 00:00:00 2001
+From: Stefan Wahren <wahrenst@gmx.net>
+Date: Sat, 4 May 2019 17:06:15 +0200
+Subject: [PATCH] hwrng: iproc-rng200: Add BCM2838 support
+
+The HWRNG on the BCM2838 is compatible to iproc-rng200, so add the
+support to this driver instead of bcm2835-rng.
+
+Signed-off-by: Stefan Wahren <wahrenst@gmx.net>
+
+hwrng: iproc-rng200: Correct SoC name
+
+The Pi 4 SoC is called BCM2711, not BCM2838.
+
+Fixes: "hwrng: iproc-rng200: Add BCM2838 support"
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/char/hw_random/Kconfig        |  2 +-
+ drivers/char/hw_random/iproc-rng200.c | 79 ++++++++++++++++++++++++++-
+ 2 files changed, 77 insertions(+), 4 deletions(-)
+
+--- a/drivers/char/hw_random/Kconfig
++++ b/drivers/char/hw_random/Kconfig
+@@ -104,7 +104,7 @@ config HW_RANDOM_IPROC_RNG200
+ 	default HW_RANDOM
+ 	help
+ 	  This driver provides kernel-side support for the RNG200
+-	  hardware found on the Broadcom iProc and STB SoCs.
++	  hardware found on the Broadcom iProc, BCM2711 and STB SoCs.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called iproc-rng200
+--- a/drivers/char/hw_random/iproc-rng200.c
++++ b/drivers/char/hw_random/iproc-rng200.c
+@@ -14,6 +14,7 @@
+ #include <linux/module.h>
+ #include <linux/of_address.h>
+ #include <linux/of_platform.h>
++#include <linux/of.h>
+ #include <linux/platform_device.h>
+ #include <linux/delay.h>
+ 
+@@ -21,6 +22,7 @@
+ #define RNG_CTRL_OFFSET					0x00
+ #define RNG_CTRL_RNG_RBGEN_MASK				0x00001FFF
+ #define RNG_CTRL_RNG_RBGEN_ENABLE			0x00000001
++#define RNG_CTRL_RNG_DIV_CTRL_SHIFT			13
+ 
+ #define RNG_SOFT_RESET_OFFSET				0x04
+ #define RNG_SOFT_RESET					0x00000001
+@@ -28,16 +30,23 @@
+ #define RBG_SOFT_RESET_OFFSET				0x08
+ #define RBG_SOFT_RESET					0x00000001
+ 
++#define RNG_TOTAL_BIT_COUNT_OFFSET			0x0C
++
++#define RNG_TOTAL_BIT_COUNT_THRESHOLD_OFFSET		0x10
++
+ #define RNG_INT_STATUS_OFFSET				0x18
+ #define RNG_INT_STATUS_MASTER_FAIL_LOCKOUT_IRQ_MASK	0x80000000
+ #define RNG_INT_STATUS_STARTUP_TRANSITIONS_MET_IRQ_MASK	0x00020000
+ #define RNG_INT_STATUS_NIST_FAIL_IRQ_MASK		0x00000020
+ #define RNG_INT_STATUS_TOTAL_BITS_COUNT_IRQ_MASK	0x00000001
+ 
++#define RNG_INT_ENABLE_OFFSET				0x1C
++
+ #define RNG_FIFO_DATA_OFFSET				0x20
+ 
+ #define RNG_FIFO_COUNT_OFFSET				0x24
+ #define RNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK		0x000000FF
++#define RNG_FIFO_COUNT_RNG_FIFO_THRESHOLD_SHIFT		8
+ 
+ struct iproc_rng200_dev {
+ 	struct hwrng rng;
+@@ -158,6 +167,64 @@ static int iproc_rng200_init(struct hwrn
+ 	return 0;
+ }
+ 
++static int bcm2711_rng200_read(struct hwrng *rng, void *buf, size_t max,
++			       bool wait)
++{
++	struct iproc_rng200_dev *priv = to_rng_priv(rng);
++	u32 max_words = max / sizeof(u32);
++	u32 num_words, count, val;
++
++	/* ensure warm up period has elapsed */
++	while (1) {
++		val = ioread32(priv->base + RNG_TOTAL_BIT_COUNT_OFFSET);
++		if (val > 16)
++			break;
++		cpu_relax();
++	}
++
++	/* ensure fifo is not empty */
++	while (1) {
++		num_words = ioread32(priv->base + RNG_FIFO_COUNT_OFFSET) &
++			    RNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK;
++		if (num_words)
++			break;
++		if (!wait)
++			return 0;
++		cpu_relax();
++	}
++
++	if (num_words > max_words)
++		num_words = max_words;
++
++	for (count = 0; count < num_words; count++) {
++		((u32 *)buf)[count] = ioread32(priv->base +
++					       RNG_FIFO_DATA_OFFSET);
++	}
++
++	return num_words * sizeof(u32);
++}
++
++static int bcm2711_rng200_init(struct hwrng *rng)
++{
++	struct iproc_rng200_dev *priv = to_rng_priv(rng);
++	uint32_t val;
++
++	if (ioread32(priv->base + RNG_CTRL_OFFSET) & RNG_CTRL_RNG_RBGEN_MASK)
++		return 0;
++
++	/* initial numbers generated are "less random" so will be discarded */
++	val = 0x40000;
++	iowrite32(val, priv->base + RNG_TOTAL_BIT_COUNT_THRESHOLD_OFFSET);
++	/* min fifo count to generate full interrupt */
++	val = 2 << RNG_FIFO_COUNT_RNG_FIFO_THRESHOLD_SHIFT;
++	iowrite32(val, priv->base + RNG_FIFO_COUNT_OFFSET);
++	/* enable the rng - 1Mhz sample rate */
++	val = (0x3 << RNG_CTRL_RNG_DIV_CTRL_SHIFT) | RNG_CTRL_RNG_RBGEN_MASK;
++	iowrite32(val, priv->base + RNG_CTRL_OFFSET);
++
++	return 0;
++}
++
+ static void iproc_rng200_cleanup(struct hwrng *rng)
+ {
+ 	struct iproc_rng200_dev *priv = to_rng_priv(rng);
+@@ -184,11 +251,17 @@ static int iproc_rng200_probe(struct pla
+ 
+ 	dev_set_drvdata(dev, priv);
+ 
+-	priv->rng.name = "iproc-rng200";
+-	priv->rng.read = iproc_rng200_read;
+-	priv->rng.init = iproc_rng200_init;
++	priv->rng.name = pdev->name;
+ 	priv->rng.cleanup = iproc_rng200_cleanup;
+ 
++	if (of_device_is_compatible(dev->of_node, "brcm,bcm2711-rng200")) {
++		priv->rng.init = bcm2711_rng200_init;
++		priv->rng.read = bcm2711_rng200_read;
++	} else {
++		priv->rng.init = iproc_rng200_init;
++		priv->rng.read = iproc_rng200_read;
++	}
++
+ 	/* Register driver */
+ 	ret = devm_hwrng_register(dev, &priv->rng);
+ 	if (ret) {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0847-PCI-brcmstb-Wait-for-100ms-following-PERST-deassert.patch b/target/linux/bcm27xx/patches-6.1/950-0847-PCI-brcmstb-Wait-for-100ms-following-PERST-deassert.patch
new file mode 100644
index 0000000000..b08676253e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0847-PCI-brcmstb-Wait-for-100ms-following-PERST-deassert.patch
@@ -0,0 +1,39 @@
+From 6f634d7efb8876e5953c30c0a613aaa5f575fe05 Mon Sep 17 00:00:00 2001
+From: Jim Quinlan <jim2101024@gmail.com>
+Date: Tue, 11 Oct 2022 14:42:07 -0400
+Subject: [PATCH] PCI: brcmstb: Wait for 100ms following PERST# deassert
+
+commit 3ae140ad827b359bc4fa7c7985691c4c1e3ca8f4 upstream.
+
+Be prudent and give some time for power and clocks to become stable.  As
+described in the PCIe CEM specification sections 2.2 and 2.2.1; as well as
+PCIe r5.0, 6.6.1.
+
+Link: https://lore.kernel.org/r/20221011184211.18128-3-jim2101024@gmail.com
+Signed-off-by: Jim Quinlan <jim2101024@gmail.com>
+Signed-off-by: Lorenzo Pieralisi <lpieralisi@kernel.org>
+Acked-by: Florian Fainelli <f.fainelli@gmail.com>
+---
+ drivers/pci/controller/pcie-brcmstb.c | 11 +++++++++--
+ 1 file changed, 9 insertions(+), 2 deletions(-)
+
+--- a/drivers/pci/controller/pcie-brcmstb.c
++++ b/drivers/pci/controller/pcie-brcmstb.c
+@@ -1038,8 +1038,15 @@ static int brcm_pcie_start_link(struct b
+ 	pcie->perst_set(pcie, 0);
+ 
+ 	/*
+-	 * Give the RC/EP time to wake up, before trying to configure RC.
+-	 * Intermittently check status for link-up, up to a total of 100ms.
++	 * Wait for 100ms after PERST# deassertion; see PCIe CEM specification
++	 * sections 2.2, PCIe r5.0, 6.6.1.
++	 */
++	msleep(100);
++
++	/*
++	 * Give the RC/EP even more time to wake up, before trying to
++	 * configure RC.  Intermittently check status for link-up, up to a
++	 * total of 100ms.
+ 	 */
+ 	for (i = 0; i < 100 && !brcm_pcie_link_up(pcie); i += 5)
+ 		msleep(5);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0848-drm-edid-Add-option-to-report-basic-audio-support-wi.patch b/target/linux/bcm27xx/patches-6.1/950-0848-drm-edid-Add-option-to-report-basic-audio-support-wi.patch
new file mode 100644
index 0000000000..245cfd4dc7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0848-drm-edid-Add-option-to-report-basic-audio-support-wi.patch
@@ -0,0 +1,128 @@
+From 2bcf744dd2b4e7e861cc3d86bda8218cbdf7a3c4 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Fri, 15 Sep 2023 17:25:17 +0100
+Subject: [PATCH] drm/edid: Add option to report basic audio support with a
+ generic edid
+
+Hardware that fails to read the edid is quite common.
+The kernel provides a mechanism to use one a of a few
+pre-built generic edid files for getting a basic video mode.
+
+However there is no easy was to add basic audio support,
+which requires a CTA extension block to report capabilities.
+
+Add an module option to request this.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/gpu/drm/drm_edid.c      | 16 +++++++++++++++
+ drivers/gpu/drm/drm_edid_load.c | 36 +++++++++++++++++++++++++++++++++
+ include/drm/drm_edid.h          |  2 ++
+ 3 files changed, 54 insertions(+)
+
+--- a/drivers/gpu/drm/drm_edid.c
++++ b/drivers/gpu/drm/drm_edid.c
+@@ -2091,6 +2091,22 @@ static struct edid *edid_filter_invalid_
+ 	return new;
+ }
+ 
++/*
++ * add a CTA extension (block) comtaining audio support
++ * fix up the base extension to include the extra
++ * extension and report as digital (required for audio)
++ * and fix up checksums.
++ */
++void drm_edid_add_audio_extension(void *block)
++{
++	struct edid *edid = block;
++	edid->input = DRM_EDID_INPUT_DIGITAL;
++	edid->extensions++;
++	edid->checksum = edid_block_compute_checksum(edid);
++	edid = block + EDID_LENGTH;
++	edid->checksum = edid_block_compute_checksum(edid);
++}
++
+ #define DDC_SEGMENT_ADDR 0x30
+ /**
+  * drm_do_probe_ddc_edid() - get EDID information via I2C
+--- a/drivers/gpu/drm/drm_edid_load.c
++++ b/drivers/gpu/drm/drm_edid_load.c
+@@ -22,6 +22,9 @@ module_param_string(edid_firmware, edid_
+ MODULE_PARM_DESC(edid_firmware, "Do not probe monitor, use specified EDID blob "
+ 	"from built-in data or /lib/firmware instead. ");
+ 
++static bool support_audio;
++module_param(support_audio, bool, 0400);
++
+ /* Use only for backward compatibility with drm_kms_helper.edid_firmware */
+ int __drm_set_edid_firmware_path(const char *path)
+ {
+@@ -167,12 +170,29 @@ static int edid_size(const u8 *edid, int
+ 	return (edid[0x7e] + 1) * EDID_LENGTH;
+ }
+ 
++/* Minimal edid extension block that reports basic audio support */
++static const u8 generic_edid_audio[] = {
++	0x02, /* CTA extension block */
++	0x03, /* version */
++	0x12, /* 18 bytes are valid */
++	0xc0, /* underscan | basic audio */
++	0x23, /* Audio Data Block, length 3 */
++	0x09, /* Linear PCM, 2 channel */
++	0x07, /* Supported sample rates (kHz): 48 44.1 32 */
++	0x07, /* Supported sample sizes (bits): 24 20 16 */
++	0x83, /* Speaker Allocation Data Block, length 3 */
++	0x01, 0x00, 0x00, /* FL/FR */
++	0x65, /* Vendor-Specific Data Block, length 3 */
++	0x03, 0x0c, 0x00, 0x00, 0x00, /* HDMI PA:0.0.0.0 */
++};
++
+ static void *edid_load(struct drm_connector *connector, const char *name,
+ 			const char *connector_name)
+ {
+ 	const struct firmware *fw = NULL;
+ 	const u8 *fwdata;
+ 	u8 *edid;
++	u8 *fwdata2 = NULL;
+ 	int fwsize, builtin;
+ 	int i, valid_extensions = 0;
+ 	bool print_bad_edid = !connector->bad_edid_counter || drm_debug_enabled(DRM_UT_KMS);
+@@ -181,6 +201,20 @@ static void *edid_load(struct drm_connec
+ 	if (builtin >= 0) {
+ 		fwdata = generic_edid[builtin];
+ 		fwsize = sizeof(generic_edid[builtin]);
++		if (support_audio) {
++			fwdata2 = kzalloc(fwsize + EDID_LENGTH, GFP_KERNEL);
++			if (!fwdata2) {
++				drm_err(connector->dev,
++					"[CONNECTOR:%d:%s] Failed to allocate combined EDID firmware \"%s\"\n",
++					connector->base.id, connector->name, name);
++				return ERR_PTR(-ENOMEM);
++			}
++			memcpy(fwdata2, fwdata, fwsize);
++			memcpy(fwdata2 + fwsize, generic_edid_audio, sizeof generic_edid_audio);
++			drm_edid_add_audio_extension(fwdata2);
++			fwsize += EDID_LENGTH;
++			fwdata = fwdata2;
++		}
+ 	} else {
+ 		struct platform_device *pdev;
+ 		int err;
+@@ -260,6 +294,8 @@ static void *edid_load(struct drm_connec
+ 
+ out:
+ 	release_firmware(fw);
++	if (fwdata2)
++		kfree(fwdata2);
+ 	return edid;
+ }
+ 
+--- a/include/drm/drm_edid.h
++++ b/include/drm/drm_edid.h
+@@ -614,4 +614,6 @@ int drm_edid_connector_update(struct drm
+ const u8 *drm_find_edid_extension(const struct drm_edid *drm_edid,
+ 				  int ext_id, int *ext_index);
+ 
++void drm_edid_add_audio_extension(void *block);
++
+ #endif /* __DRM_EDID_H__ */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0849-Revert-drm-edid-Add-option-to-report-basic-audio-sup.patch b/target/linux/bcm27xx/patches-6.1/950-0849-Revert-drm-edid-Add-option-to-report-basic-audio-sup.patch
new file mode 100644
index 0000000000..8cb6a54c50
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0849-Revert-drm-edid-Add-option-to-report-basic-audio-sup.patch
@@ -0,0 +1,119 @@
+From df4d584e66a660195422ca2b7ce1d68d1181f2a2 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Wed, 20 Sep 2023 15:13:53 +0100
+Subject: [PATCH] Revert "drm/edid: Add option to report basic audio support
+ with a generic edid"
+
+This reverts commit 2bcf744dd2b4e7e861cc3d86bda8218cbdf7a3c4.
+---
+ drivers/gpu/drm/drm_edid.c      | 16 ---------------
+ drivers/gpu/drm/drm_edid_load.c | 36 ---------------------------------
+ include/drm/drm_edid.h          |  2 --
+ 3 files changed, 54 deletions(-)
+
+--- a/drivers/gpu/drm/drm_edid.c
++++ b/drivers/gpu/drm/drm_edid.c
+@@ -2091,22 +2091,6 @@ static struct edid *edid_filter_invalid_
+ 	return new;
+ }
+ 
+-/*
+- * add a CTA extension (block) comtaining audio support
+- * fix up the base extension to include the extra
+- * extension and report as digital (required for audio)
+- * and fix up checksums.
+- */
+-void drm_edid_add_audio_extension(void *block)
+-{
+-	struct edid *edid = block;
+-	edid->input = DRM_EDID_INPUT_DIGITAL;
+-	edid->extensions++;
+-	edid->checksum = edid_block_compute_checksum(edid);
+-	edid = block + EDID_LENGTH;
+-	edid->checksum = edid_block_compute_checksum(edid);
+-}
+-
+ #define DDC_SEGMENT_ADDR 0x30
+ /**
+  * drm_do_probe_ddc_edid() - get EDID information via I2C
+--- a/drivers/gpu/drm/drm_edid_load.c
++++ b/drivers/gpu/drm/drm_edid_load.c
+@@ -22,9 +22,6 @@ module_param_string(edid_firmware, edid_
+ MODULE_PARM_DESC(edid_firmware, "Do not probe monitor, use specified EDID blob "
+ 	"from built-in data or /lib/firmware instead. ");
+ 
+-static bool support_audio;
+-module_param(support_audio, bool, 0400);
+-
+ /* Use only for backward compatibility with drm_kms_helper.edid_firmware */
+ int __drm_set_edid_firmware_path(const char *path)
+ {
+@@ -170,29 +167,12 @@ static int edid_size(const u8 *edid, int
+ 	return (edid[0x7e] + 1) * EDID_LENGTH;
+ }
+ 
+-/* Minimal edid extension block that reports basic audio support */
+-static const u8 generic_edid_audio[] = {
+-	0x02, /* CTA extension block */
+-	0x03, /* version */
+-	0x12, /* 18 bytes are valid */
+-	0xc0, /* underscan | basic audio */
+-	0x23, /* Audio Data Block, length 3 */
+-	0x09, /* Linear PCM, 2 channel */
+-	0x07, /* Supported sample rates (kHz): 48 44.1 32 */
+-	0x07, /* Supported sample sizes (bits): 24 20 16 */
+-	0x83, /* Speaker Allocation Data Block, length 3 */
+-	0x01, 0x00, 0x00, /* FL/FR */
+-	0x65, /* Vendor-Specific Data Block, length 3 */
+-	0x03, 0x0c, 0x00, 0x00, 0x00, /* HDMI PA:0.0.0.0 */
+-};
+-
+ static void *edid_load(struct drm_connector *connector, const char *name,
+ 			const char *connector_name)
+ {
+ 	const struct firmware *fw = NULL;
+ 	const u8 *fwdata;
+ 	u8 *edid;
+-	u8 *fwdata2 = NULL;
+ 	int fwsize, builtin;
+ 	int i, valid_extensions = 0;
+ 	bool print_bad_edid = !connector->bad_edid_counter || drm_debug_enabled(DRM_UT_KMS);
+@@ -201,20 +181,6 @@ static void *edid_load(struct drm_connec
+ 	if (builtin >= 0) {
+ 		fwdata = generic_edid[builtin];
+ 		fwsize = sizeof(generic_edid[builtin]);
+-		if (support_audio) {
+-			fwdata2 = kzalloc(fwsize + EDID_LENGTH, GFP_KERNEL);
+-			if (!fwdata2) {
+-				drm_err(connector->dev,
+-					"[CONNECTOR:%d:%s] Failed to allocate combined EDID firmware \"%s\"\n",
+-					connector->base.id, connector->name, name);
+-				return ERR_PTR(-ENOMEM);
+-			}
+-			memcpy(fwdata2, fwdata, fwsize);
+-			memcpy(fwdata2 + fwsize, generic_edid_audio, sizeof generic_edid_audio);
+-			drm_edid_add_audio_extension(fwdata2);
+-			fwsize += EDID_LENGTH;
+-			fwdata = fwdata2;
+-		}
+ 	} else {
+ 		struct platform_device *pdev;
+ 		int err;
+@@ -294,8 +260,6 @@ static void *edid_load(struct drm_connec
+ 
+ out:
+ 	release_firmware(fw);
+-	if (fwdata2)
+-		kfree(fwdata2);
+ 	return edid;
+ }
+ 
+--- a/include/drm/drm_edid.h
++++ b/include/drm/drm_edid.h
+@@ -614,6 +614,4 @@ int drm_edid_connector_update(struct drm
+ const u8 *drm_find_edid_extension(const struct drm_edid *drm_edid,
+ 				  int ext_id, int *ext_index);
+ 
+-void drm_edid_add_audio_extension(void *block);
+-
+ #endif /* __DRM_EDID_H__ */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0850-overlays-Add-a-sample-hat_map.patch b/target/linux/bcm27xx/patches-6.1/950-0850-overlays-Add-a-sample-hat_map.patch
new file mode 100644
index 0000000000..19550b6fd5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0850-overlays-Add-a-sample-hat_map.patch
@@ -0,0 +1,47 @@
+From cc08810f89e52337a99cc6ae5f53f08588357c5f Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 19 Sep 2023 20:31:34 +0100
+Subject: [PATCH] overlays: Add a sample hat_map
+
+The HAT map is way of associating named overlays with HATs whose
+EEPROMs were programmed with the contents of the overlay.
+Unfortunately, change in the DT and kernel drivers has meant that some
+of these embedded overlays no longer function, or even don't apply.
+
+The HAT map is a mapping from HAT UUIDs to overlay names. If a HAT with
+a listed UUID is detected, the embedded overlay is ignored and the
+overlay named in the mapping is loaded in its place.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/Makefile    |  2 +-
+ arch/arm/boot/dts/overlays/hat_map.dts | 13 +++++++++++++
+ 2 files changed, 14 insertions(+), 1 deletion(-)
+ create mode 100644 arch/arm/boot/dts/overlays/hat_map.dts
+
+--- a/arch/arm/boot/dts/overlays/Makefile
++++ b/arch/arm/boot/dts/overlays/Makefile
+@@ -1,6 +1,6 @@
+ # Overlays for the Raspberry Pi platform
+ 
+-dtb-$(CONFIG_ARCH_BCM2835) += overlay_map.dtb
++dtb-$(CONFIG_ARCH_BCM2835) += overlay_map.dtb hat_map.dtb
+ 
+ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	act-led.dtbo \
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/hat_map.dts
+@@ -0,0 +1,13 @@
++/dts-v1/;
++
++/ {
++	iqaudio-pi-codecplus {
++		uuid = [ dc1c9594 c1ab 4c6c acda a88dc59a3c5b ];
++		overlay = "iqaudio-codec";
++	};
++
++	recalbox-rgbdual {
++		uuid = [ 1c955808 681f 4bbc a2ef b7ea47cd388e ];
++		overlay = "recalboxrgbdual";
++	};
++};
diff --git a/target/linux/bcm27xx/patches-6.1/950-0851-Revert-usb-phy-generic-Get-the-vbus-supply.patch b/target/linux/bcm27xx/patches-6.1/950-0851-Revert-usb-phy-generic-Get-the-vbus-supply.patch
new file mode 100644
index 0000000000..aaf49e6a7c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0851-Revert-usb-phy-generic-Get-the-vbus-supply.patch
@@ -0,0 +1,26 @@
+From 406e7dc82be6ce1b81c88b418640daeef6c2be42 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Mon, 23 May 2022 16:56:44 +0100
+Subject: [PATCH] Revert "usb: phy: generic: Get the vbus supply"
+
+This reverts commit c0ea202fbc855d60bc4a0603ca52a9e80654b327.
+---
+ drivers/usb/phy/phy-generic.c | 7 -------
+ 1 file changed, 7 deletions(-)
+
+--- a/drivers/usb/phy/phy-generic.c
++++ b/drivers/usb/phy/phy-generic.c
+@@ -265,13 +265,6 @@ int usb_phy_gen_create_phy(struct device
+ 			return -EPROBE_DEFER;
+ 	}
+ 
+-	nop->vbus_draw = devm_regulator_get_exclusive(dev, "vbus");
+-	if (PTR_ERR(nop->vbus_draw) == -ENODEV)
+-		nop->vbus_draw = NULL;
+-	if (IS_ERR(nop->vbus_draw))
+-		return dev_err_probe(dev, PTR_ERR(nop->vbus_draw),
+-				     "could not get vbus regulator\n");
+-
+ 	nop->dev		= dev;
+ 	nop->phy.dev		= nop->dev;
+ 	nop->phy.label		= "nop-xceiv";
diff --git a/target/linux/bcm27xx/patches-6.1/950-0853-dts-2712-Update-for-device-tree.patch b/target/linux/bcm27xx/patches-6.1/950-0853-dts-2712-Update-for-device-tree.patch
new file mode 100644
index 0000000000..6a5c40ef4e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0853-dts-2712-Update-for-device-tree.patch
@@ -0,0 +1,7672 @@
+From 1196bf1a7736ff0ab79f5012fa84082e298031a7 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Tue, 19 Sep 2023 15:55:00 +0100
+Subject: [PATCH] dts: 2712: Update for device tree
+
+dtoverlays: Fix up edt5406 entries to match with vc4-kms-dsi-7inch
+
+vc4-kms-dsi-7inch expects the touch fragment to be named ts_i2c_frag,
+but edt5406 didn't do this.
+
+Fixes: 736d601fb38c ("dts: 2712: Update for device tree")
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/Makefile                    |    3 +-
+ arch/arm/boot/dts/bcm2708-rpi-b-plus.dts      |    3 +
+ arch/arm/boot/dts/bcm2708-rpi-b-rev1.dts      |    3 +
+ arch/arm/boot/dts/bcm2708-rpi-b.dts           |    3 +
+ arch/arm/boot/dts/bcm2708-rpi-cm.dts          |    3 +
+ arch/arm/boot/dts/bcm2708-rpi-zero-w.dts      |    1 +
+ arch/arm/boot/dts/bcm2708-rpi-zero.dts        |    1 +
+ arch/arm/boot/dts/bcm2709-rpi-2-b.dts         |    3 +
+ arch/arm/boot/dts/bcm2709-rpi-cm2.dts         |    3 +
+ arch/arm/boot/dts/bcm270x-rpi.dtsi            |    3 +
+ arch/arm/boot/dts/bcm2710-rpi-2-b.dts         |    3 +
+ arch/arm/boot/dts/bcm2710-rpi-3-b-plus.dts    |    3 +
+ arch/arm/boot/dts/bcm2710-rpi-3-b.dts         |    3 +
+ arch/arm/boot/dts/bcm2710-rpi-cm3.dts         |    3 +
+ arch/arm/boot/dts/bcm2710-rpi-zero-2-w.dts    |    3 +
+ arch/arm/boot/dts/bcm2711-rpi-4-b.dts         |    3 +
+ arch/arm/boot/dts/bcm2711-rpi-cm4.dts         |    3 +
+ arch/arm/boot/dts/bcm2711-rpi-cm4s.dts        |    3 +
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts         |  824 +++++++++++
+ arch/arm/boot/dts/bcm2712-rpi.dtsi            |  281 ++++
+ arch/arm/boot/dts/bcm2712.dtsi                | 1287 +++++++++++++++++
+ arch/arm/boot/dts/overlays/Makefile           |   23 +
+ arch/arm/boot/dts/overlays/README             |  360 ++++-
+ .../dts/overlays/adau1977-adc-overlay.dts     |    4 +-
+ .../dts/overlays/adau7002-simple-overlay.dts  |    4 +-
+ .../overlays/akkordion-iqdacplus-overlay.dts  |    4 +-
+ .../allo-boss-dac-pcm512x-audio-overlay.dts   |   10 +-
+ .../overlays/allo-boss2-dac-audio-overlay.dts |    2 +-
+ .../dts/overlays/allo-digione-overlay.dts     |    4 +-
+ .../allo-katana-dac-audio-overlay.dts         |    2 +-
+ .../allo-piano-dac-pcm512x-audio-overlay.dts  |    4 +-
+ ...o-piano-dac-plus-pcm512x-audio-overlay.dts |    4 +-
+ .../boot/dts/overlays/applepi-dac-overlay.dts |    4 +-
+ .../dts/overlays/arducam-64mp-overlay.dts     |    2 +-
+ .../overlays/arducam-pivariety-overlay.dts    |    2 +-
+ .../overlays/audioinjector-addons-overlay.dts |    4 +-
+ .../audioinjector-bare-i2s-overlay.dts        |    6 +-
+ ...dioinjector-isolated-soundcard-overlay.dts |    4 +-
+ .../overlays/audioinjector-ultra-overlay.dts  |    6 +-
+ .../audioinjector-wm8731-audio-overlay.dts    |    4 +-
+ .../dts/overlays/audiosense-pi-overlay.dts    |    4 +-
+ .../boot/dts/overlays/chipdip-dac-overlay.dts |    4 +-
+ .../dts/overlays/cirrus-wm5102-overlay.dts    |    4 +-
+ .../boot/dts/overlays/dacberry400-overlay.dts |    4 +-
+ .../dts/overlays/dionaudio-kiwi-overlay.dts   |    4 +-
+ .../dts/overlays/dionaudio-loco-overlay.dts   |    4 +-
+ .../overlays/dionaudio-loco-v2-overlay.dts    |    4 +-
+ .../dts/overlays/disable-bt-pi5-overlay.dts   |   17 +
+ .../dts/overlays/disable-wifi-pi5-overlay.dts |   13 +
+ arch/arm/boot/dts/overlays/draws-overlay.dts  |    6 +-
+ .../boot/dts/overlays/edt-ft5406-overlay.dts  |   22 +-
+ arch/arm/boot/dts/overlays/edt-ft5406.dtsi    |    2 +-
+ .../boot/dts/overlays/fe-pi-audio-overlay.dts |    4 +-
+ .../boot/dts/overlays/ghost-amp-overlay.dts   |    4 +-
+ .../googlevoicehat-soundcard-overlay.dts      |    4 +-
+ .../dts/overlays/hifiberry-amp-overlay.dts    |    4 +-
+ .../dts/overlays/hifiberry-amp100-overlay.dts |   11 +-
+ .../dts/overlays/hifiberry-amp3-overlay.dts   |    4 +-
+ .../dts/overlays/hifiberry-dac-overlay.dts    |    4 +-
+ .../overlays/hifiberry-dacplus-overlay.dts    |   11 +-
+ .../overlays/hifiberry-dacplusadc-overlay.dts |   10 +-
+ .../hifiberry-dacplusadcpro-overlay.dts       |   10 +-
+ .../overlays/hifiberry-dacplusdsp-overlay.dts |    4 +-
+ .../overlays/hifiberry-dacplushd-overlay.dts  |    4 +-
+ .../dts/overlays/hifiberry-digi-overlay.dts   |    4 +-
+ .../overlays/hifiberry-digi-pro-overlay.dts   |    4 +-
+ .../boot/dts/overlays/i-sabre-q2m-overlay.dts |    4 +-
+ .../boot/dts/overlays/i2c0-pi5-overlay.dts    |   34 +
+ .../boot/dts/overlays/i2c1-pi5-overlay.dts    |   34 +
+ .../boot/dts/overlays/i2c2-pi5-overlay.dts    |   21 +
+ .../boot/dts/overlays/i2c3-pi5-overlay.dts    |   22 +
+ .../arm/boot/dts/overlays/i2s-dac-overlay.dts |    4 +-
+ arch/arm/boot/dts/overlays/imx219-overlay.dts |    2 +-
+ arch/arm/boot/dts/overlays/imx258-overlay.dts |    2 +-
+ .../boot/dts/overlays/imx290_327-overlay.dtsi |    2 +-
+ arch/arm/boot/dts/overlays/imx296-overlay.dts |    2 +-
+ .../boot/dts/overlays/imx477_378-overlay.dtsi |    2 +-
+ arch/arm/boot/dts/overlays/imx519-overlay.dts |    2 +-
+ arch/arm/boot/dts/overlays/imx708-overlay.dts |    4 +-
+ .../dts/overlays/iqaudio-codec-overlay.dts    |    4 +-
+ .../boot/dts/overlays/iqaudio-dac-overlay.dts |    4 +-
+ .../dts/overlays/iqaudio-dacplus-overlay.dts  |    4 +-
+ .../iqaudio-digi-wm8804-audio-overlay.dts     |    4 +-
+ .../arm/boot/dts/overlays/irs1125-overlay.dts |    2 +-
+ .../dts/overlays/justboom-both-overlay.dts    |    4 +-
+ .../dts/overlays/justboom-dac-overlay.dts     |    4 +-
+ .../dts/overlays/justboom-digi-overlay.dts    |    4 +-
+ .../boot/dts/overlays/max98357a-overlay.dts   |    6 +-
+ .../boot/dts/overlays/mbed-dac-overlay.dts    |    6 +-
+ .../boot/dts/overlays/merus-amp-overlay.dts   |    4 +-
+ .../dts/overlays/midi-uart0-pi5-overlay.dts   |   35 +
+ .../dts/overlays/midi-uart1-pi5-overlay.dts   |   35 +
+ .../dts/overlays/midi-uart2-pi5-overlay.dts   |   35 +
+ .../dts/overlays/midi-uart3-pi5-overlay.dts   |   35 +
+ .../dts/overlays/midi-uart4-pi5-overlay.dts   |   35 +
+ arch/arm/boot/dts/overlays/ov2311-overlay.dts |    2 +-
+ arch/arm/boot/dts/overlays/ov5647-overlay.dts |    2 +-
+ arch/arm/boot/dts/overlays/ov7251-overlay.dts |    2 +-
+ arch/arm/boot/dts/overlays/ov9281-overlay.dts |    2 +-
+ arch/arm/boot/dts/overlays/overlay_map.dts    |  226 +++
+ arch/arm/boot/dts/overlays/pibell-overlay.dts |    6 +-
+ .../arm/boot/dts/overlays/pifi-40-overlay.dts |    4 +-
+ .../boot/dts/overlays/pifi-dac-hd-overlay.dts |    4 +-
+ .../dts/overlays/pifi-dac-zero-overlay.dts    |    4 +-
+ .../dts/overlays/pifi-mini-210-overlay.dts    |    4 +-
+ .../arm/boot/dts/overlays/pisound-overlay.dts |    4 +-
+ .../boot/dts/overlays/proto-codec-overlay.dts |    4 +-
+ .../rra-digidac1-wm8741-audio-overlay.dts     |    4 +-
+ .../dts/overlays/spi2-1cs-pi5-overlay.dts     |   33 +
+ .../dts/overlays/spi2-2cs-pi5-overlay.dts     |   44 +
+ .../dts/overlays/spi3-1cs-pi5-overlay.dts     |   33 +
+ .../dts/overlays/spi3-2cs-pi5-overlay.dts     |   44 +
+ .../dts/overlays/spi5-1cs-pi5-overlay.dts     |   33 +
+ .../dts/overlays/spi5-2cs-pi5-overlay.dts     |   44 +
+ .../dts/overlays/superaudioboard-overlay.dts  |    6 +-
+ .../dts/overlays/tc358743-audio-overlay.dts   |   10 +-
+ .../boot/dts/overlays/tc358743-overlay.dts    |    2 +-
+ .../boot/dts/overlays/uart0-pi5-overlay.dts   |   17 +
+ .../boot/dts/overlays/uart1-pi5-overlay.dts   |   17 +
+ .../boot/dts/overlays/uart2-pi5-overlay.dts   |   17 +
+ .../boot/dts/overlays/uart3-pi5-overlay.dts   |   17 +
+ .../boot/dts/overlays/uart4-pi5-overlay.dts   |   17 +
+ arch/arm/boot/dts/overlays/udrc-overlay.dts   |    6 +-
+ .../dts/overlays/ugreen-dabboard-overlay.dts  |   10 +-
+ .../dts/overlays/vc4-fkms-v3d-overlay.dts     |    6 +
+ .../dts/overlays/vc4-fkms-v3d-pi4-overlay.dts |    6 +
+ .../overlays/vc4-kms-dsi-7inch-overlay.dts    |   18 +-
+ .../vc4-kms-dsi-waveshare-panel-overlay.dts   |    8 +-
+ .../dts/overlays/vc4-kms-v3d-pi5-overlay.dts  |  147 ++
+ .../dts/overlays/vc4-kms-vga666-overlay.dts   |    9 +-
+ .../dts/overlays/wm8960-soundcard-overlay.dts |    4 +-
+ arch/arm/boot/dts/rp1.dtsi                    | 1168 +++++++++++++++
+ arch/arm64/boot/dts/broadcom/Makefile         |    1 +
+ .../boot/dts/broadcom/bcm2712-rpi-5-b.dts     |    1 +
+ 134 files changed, 5143 insertions(+), 264 deletions(-)
+ create mode 100644 arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+ create mode 100644 arch/arm/boot/dts/bcm2712-rpi.dtsi
+ create mode 100644 arch/arm/boot/dts/bcm2712.dtsi
+ create mode 100644 arch/arm/boot/dts/overlays/disable-bt-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/disable-wifi-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/i2c0-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/i2c1-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/i2c2-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/i2c3-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/midi-uart0-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/midi-uart1-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/midi-uart2-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/midi-uart3-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/midi-uart4-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/spi2-1cs-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/spi2-2cs-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/spi3-1cs-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/spi3-2cs-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/spi5-1cs-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/spi5-2cs-pi5-overlay.dts
+ create mode 100755 arch/arm/boot/dts/overlays/uart0-pi5-overlay.dts
+ create mode 100755 arch/arm/boot/dts/overlays/uart1-pi5-overlay.dts
+ create mode 100755 arch/arm/boot/dts/overlays/uart2-pi5-overlay.dts
+ create mode 100755 arch/arm/boot/dts/overlays/uart3-pi5-overlay.dts
+ create mode 100755 arch/arm/boot/dts/overlays/uart4-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/vc4-kms-v3d-pi5-overlay.dts
+ create mode 100644 arch/arm/boot/dts/rp1.dtsi
+ create mode 100644 arch/arm64/boot/dts/broadcom/bcm2712-rpi-5-b.dts
+
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -18,7 +18,8 @@ dtb-$(CONFIG_ARCH_BCM2835) += \
+ 	bcm2709-rpi-cm2.dtb \
+ 	bcm2710-rpi-cm3.dtb \
+ 	bcm2711-rpi-cm4.dtb \
+-	bcm2711-rpi-cm4s.dtb
++	bcm2711-rpi-cm4s.dtb \
++	bcm2712-rpi-5-b.dtb
+ 
+ dtb-$(CONFIG_ARCH_ALPINE) += \
+ 	alpine-db.dtb
+--- a/arch/arm/boot/dts/bcm2708-rpi-b-plus.dts
++++ b/arch/arm/boot/dts/bcm2708-rpi-b-plus.dts
+@@ -192,6 +192,9 @@ i2c_arm: &i2c1 {
+ i2c_vc: &i2c0 {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_headphones=1 snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_headphones=0 snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2708-rpi-b-rev1.dts
++++ b/arch/arm/boot/dts/bcm2708-rpi-b-rev1.dts
+@@ -203,6 +203,9 @@ i2c_arm: &i2c0 {
+ i2c_vc: &i2c1 {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_headphones=1 snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_headphones=0 snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2708-rpi-b.dts
++++ b/arch/arm/boot/dts/bcm2708-rpi-b.dts
+@@ -185,6 +185,9 @@ i2c_arm: &i2c1 {
+ i2c_vc: &i2c0 {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_headphones=1 snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_headphones=0 snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2708-rpi-cm.dts
++++ b/arch/arm/boot/dts/bcm2708-rpi-cm.dts
+@@ -19,6 +19,9 @@ cam0_reg: &cam0_regulator {
+ 	gpio = <&gpio 31 GPIO_ACTIVE_HIGH>;
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ &uart0 {
+ 	status = "okay";
+ };
+--- a/arch/arm/boot/dts/bcm2708-rpi-zero-w.dts
++++ b/arch/arm/boot/dts/bcm2708-rpi-zero-w.dts
+@@ -243,6 +243,7 @@ cam0_reg: &cam_dummy_reg {
+ 
+ i2c_arm: &i2c1 {};
+ i2c_vc: &i2c0 {};
++i2c_csi_dsi0: &i2c0 {};
+ 
+ / {
+ 	__overrides__ {
+--- a/arch/arm/boot/dts/bcm2708-rpi-zero.dts
++++ b/arch/arm/boot/dts/bcm2708-rpi-zero.dts
+@@ -178,6 +178,7 @@ cam0_reg: &cam_dummy_reg {
+ 
+ i2c_arm: &i2c1 {};
+ i2c_vc: &i2c0 {};
++i2c_csi_dsi0: &i2c0 {};
+ 
+ / {
+ 	__overrides__ {
+--- a/arch/arm/boot/dts/bcm2709-rpi-2-b.dts
++++ b/arch/arm/boot/dts/bcm2709-rpi-2-b.dts
+@@ -186,6 +186,9 @@
+ cam0_reg: &cam_dummy_reg {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_headphones=1 snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_headphones=0 snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2709-rpi-cm2.dts
++++ b/arch/arm/boot/dts/bcm2709-rpi-cm2.dts
+@@ -20,6 +20,9 @@ cam0_reg: &cam0_regulator {
+ 	gpio = <&gpio 30 GPIO_ACTIVE_HIGH>;
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ &uart0 {
+ 	status = "okay";
+ };
+--- a/arch/arm/boot/dts/bcm270x-rpi.dtsi
++++ b/arch/arm/boot/dts/bcm270x-rpi.dtsi
+@@ -127,6 +127,9 @@
+ 	status = "disabled";
+ };
+ 
++i2s_clk_producer: &i2s {};
++i2s_clk_consumer: &i2s {};
++
+ &clocks {
+ 	firmware = <&firmware>;
+ };
+--- a/arch/arm/boot/dts/bcm2710-rpi-2-b.dts
++++ b/arch/arm/boot/dts/bcm2710-rpi-2-b.dts
+@@ -186,6 +186,9 @@
+ cam0_reg: &cam_dummy_reg {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_headphones=1 snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_headphones=0 snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2710-rpi-3-b-plus.dts
++++ b/arch/arm/boot/dts/bcm2710-rpi-3-b-plus.dts
+@@ -274,6 +274,9 @@
+ cam0_reg: &cam_dummy_reg {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_headphones=1 snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_headphones=0 snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2710-rpi-3-b.dts
++++ b/arch/arm/boot/dts/bcm2710-rpi-3-b.dts
+@@ -283,6 +283,9 @@
+ cam0_reg: &cam_dummy_reg {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_headphones=1 snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_headphones=0 snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2710-rpi-cm3.dts
++++ b/arch/arm/boot/dts/bcm2710-rpi-cm3.dts
+@@ -19,6 +19,9 @@ cam0_reg: &cam0_regulator {
+ 	gpio = <&gpio 31 GPIO_ACTIVE_HIGH>;
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ &uart0 {
+ 	status = "okay";
+ };
+--- a/arch/arm/boot/dts/bcm2710-rpi-zero-2-w.dts
++++ b/arch/arm/boot/dts/bcm2710-rpi-zero-2-w.dts
+@@ -262,6 +262,9 @@
+ cam0_reg: &cam_dummy_reg {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2711-rpi-4-b.dts
++++ b/arch/arm/boot/dts/bcm2711-rpi-4-b.dts
+@@ -400,6 +400,9 @@
+ cam0_reg: &cam_dummy_reg {
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_headphones=1 snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_headphones=0 snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
++++ b/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
+@@ -409,6 +409,9 @@ cam0_reg: &cam1_reg {
+ 	gpio = <&expgpio 5 GPIO_ACTIVE_HIGH>;
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_hdmi=0'}";
+--- a/arch/arm/boot/dts/bcm2711-rpi-cm4s.dts
++++ b/arch/arm/boot/dts/bcm2711-rpi-cm4s.dts
+@@ -282,6 +282,9 @@ cam0_reg: &cam0_regulator {
+ 	status = "disabled";
+ };
+ 
++i2c_csi_dsi0: &i2c0 {
++};
++
+ / {
+ 	__overrides__ {
+ 		audio = <&chosen>,"bootargs{on='snd_bcm2835.enable_hdmi=1',off='snd_bcm2835.enable_hdmi=0'}";
+--- /dev/null
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -0,0 +1,824 @@
++// SPDX-License-Identifier: GPL-2.0
++/dts-v1/;
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/clock/rp1.h>
++#include <dt-bindings/interrupt-controller/irq.h>
++#include <dt-bindings/mfd/rp1.h>
++#include <dt-bindings/pwm/pwm.h>
++#include <dt-bindings/reset/raspberrypi,firmware-reset.h>
++
++#define i2c0 _i2c0
++#define i2c3 _i2c3
++#define i2c4 _i2c4
++#define i2c5 _i2c5
++#define i2c6 _i2c6
++#define i2c8 _i2c8
++#define i2s _i2s
++#define pwm0 _pwm0
++#define pwm1 _pwm1
++#define spi0 _spi0
++#define spi3 _spi3
++#define spi4 _spi4
++#define spi5 _spi5
++#define spi6 _spi6
++#define uart0 _uart0
++#define uart2 _uart2
++#define uart3 _uart3
++#define uart4 _uart4
++#define uart5 _uart5
++
++#include "bcm2712.dtsi"
++
++#undef i2c0
++#undef i2c3
++#undef i2c4
++#undef i2c5
++#undef i2c6
++#undef i2c8
++#undef i2s
++#undef pwm0
++#undef pwm1
++#undef spi0
++#undef spi3
++#undef spi4
++#undef spi5
++#undef spi6
++#undef uart0
++#undef uart2
++#undef uart3
++#undef uart4
++#undef uart5
++
++/ {
++	compatible = "raspberrypi,5-model-b", "brcm,bcm2712";
++	model = "Raspberry Pi 5 Model B";
++
++	/* Will be filled by the bootloader */
++	memory@0 {
++		device_type = "memory";
++		reg = <0 0 0x28000000>;
++	};
++
++	leds: leds {
++		compatible = "gpio-leds";
++
++		pwr_led: led-pwr {
++			label = "PWR";
++			gpios = <&rp1_gpio 44 GPIO_ACTIVE_LOW>;
++			default-state = "off";
++			linux,default-trigger = "none";
++		};
++
++		act_led: led-act {
++			label = "ACT";
++			gpios = <&gio_aon 9 GPIO_ACTIVE_LOW>;
++			default-state = "off";
++			linux,default-trigger = "mmc0";
++		};
++	};
++
++	sd_io_1v8_reg: sd_io_1v8_reg {
++		compatible = "regulator-gpio";
++		regulator-name = "vdd-sd-io";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++		regulator-always-on;
++		regulator-settling-time-us = <5000>;
++		gpios = <&gio_aon 3 GPIO_ACTIVE_HIGH>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		status = "okay";
++	};
++
++	sd_vcc_reg: sd_vcc_reg {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc-sd";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++		enable-active-high;
++		gpios = <&gio_aon 4 GPIO_ACTIVE_HIGH>;
++		status = "okay";
++	};
++
++	wl_on_reg: wl_on_reg {
++		compatible = "regulator-fixed";
++		regulator-name = "wl-on-regulator";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		pinctrl-0 = <&wl_on_pins>;
++		pinctrl-names = "default";
++
++		gpio = <&gio 28 GPIO_ACTIVE_HIGH>;
++
++		startup-delay-us = <150000>;
++		enable-active-high;
++	};
++
++	clocks: clocks {
++	};
++
++	cam1_clk: cam1_clk {
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		status = "disabled";
++	};
++
++	cam0_clk: cam0_clk {
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		status = "disabled";
++	};
++
++	cam0_reg: cam0_reg {
++		compatible = "regulator-fixed";
++		regulator-name = "cam0_reg";
++		enable-active-high;
++		status = "okay";
++		gpio = <&rp1_gpio 34 0>;  // CD0_IO0_MICCLK, to MIPI 0 connector
++	};
++
++	cam1_reg: cam1_reg {
++		compatible = "regulator-fixed";
++		regulator-name = "cam1_reg";
++		enable-active-high;
++		status = "okay";
++		gpio = <&rp1_gpio 46 0>;  // CD1_IO0_MICCLK, to MIPI 1 connector
++	};
++
++	cam_dummy_reg: cam_dummy_reg {
++		compatible = "regulator-fixed";
++		regulator-name = "cam-dummy-reg";
++		status = "okay";
++	};
++
++	dummy: dummy {
++		// A target for unwanted overlay fragments
++	};
++};
++
++rp1_target: &pcie2 {
++	brcm,vdm-qos-map = <0xbbaa9888>;
++	aspm-no-l0s;
++	status = "okay";
++};
++
++// Add some labels to 2712 device
++
++// The system UART
++uart10: &_uart0 { status = "okay"; };
++
++// The system SPI for the bootloader EEPROM
++spi10: &_spi0 { status = "okay"; };
++
++i2c_rp1boot: &_i2c3 { };
++
++#include "rp1.dtsi"
++
++&rp1 {
++	// PCIe address space layout:
++	// 00_00000000-00_00xxxxxx = RP1 peripherals
++	// 10_00000000-1x_xxxxxxxx = up to 64GB system RAM
++
++	// outbound access aimed at PCIe 0_00xxxxxx -> RP1 c0_40xxxxxx
++	// This is the RP1 peripheral space
++	ranges = <0xc0 0x40000000
++		  0x02000000 0x00 0x00000000
++		  0x00 0x00400000>;
++
++	dma-ranges =
++	// inbound RP1 1x_xxxxxxxx -> PCIe 1x_xxxxxxxx
++		     <0x10 0x00000000
++		      0x43000000 0x10 0x00000000
++		      0x10 0x00000000>,
++
++	// inbound RP1 c0_40xxxxxx -> PCIe 00_00xxxxxx
++	// This allows the RP1 DMA controller to address RP1 hardware
++		     <0xc0 0x40000000
++		      0x02000000 0x0 0x00000000
++		      0x0 0x00400000>,
++
++	// inbound RP1 0x_xxxxxxxx -> PCIe 1x_xxxxxxxx
++		     <0x00 0x00000000
++		      0x02000000 0x10 0x00000000
++		      0x10 0x00000000>;
++};
++
++// Expose RP1 nodes as system nodes with labels
++
++&rp1_dma  {
++	status = "okay";
++};
++
++&rp1_eth {
++	status = "okay";
++	phy-handle = <&phy1>;
++	phy-reset-gpios = <&rp1_gpio 32 GPIO_ACTIVE_LOW>;
++	phy-reset-duration = <5>;
++
++	phy1: ethernet-phy@1 {
++		reg = <0x1>;
++		brcm,powerdown-enable;
++	};
++};
++
++gpio: &rp1_gpio {
++	status = "okay";
++};
++
++aux: &dummy {};
++
++&rp1_usb0 {
++	pinctrl-0 = <&usb_vbus_pins>;
++	pinctrl-names = "default";
++	status = "okay";
++};
++
++&rp1_usb1 {
++	status = "okay";
++};
++
++#include "bcm2712-rpi.dtsi"
++
++// A few extra labels to keep overlays happy
++
++i2c0if: &rp1_gpio {};
++i2c0mux: &rp1_gpio {};
++
++i2c_csi_dsi0: &i2c6 { // Note: This is for MIPI0 connector only
++	pinctrl-0 = <&rp1_i2c6_38_39>;
++	pinctrl-names = "default";
++};
++
++i2c_csi_dsi1: &i2c4 { // Note: This is for MIPI1 connector only
++	pinctrl-0 = <&rp1_i2c4_40_41>;
++	pinctrl-names = "default";
++};
++
++i2c_csi_dsi: &i2c_csi_dsi1 { }; // An alias for compatibility
++
++csi0: &rp1_csi0 { };
++csi1: &rp1_csi1 { };
++dsi0: &rp1_dsi0 { };
++dsi1: &rp1_dsi1 { };
++dpi: &rp1_dpi { };
++vec: &rp1_vec { };
++dpi_gpio0:              &rp1_dpi_24bit_gpio0        { };
++dpi_gpio1:              &rp1_dpi_24bit_gpio2        { };
++dpi_18bit_cpadhi_gpio0: &rp1_dpi_18bit_cpadhi_gpio0 { };
++dpi_18bit_cpadhi_gpio2: &rp1_dpi_18bit_cpadhi_gpio2 { };
++dpi_18bit_gpio0:        &rp1_dpi_18bit_gpio0        { };
++dpi_18bit_gpio2:        &rp1_dpi_18bit_gpio2        { };
++dpi_16bit_cpadhi_gpio0: &rp1_dpi_16bit_cpadhi_gpio0 { };
++dpi_16bit_cpadhi_gpio2: &rp1_dpi_16bit_cpadhi_gpio2 { };
++dpi_16bit_gpio0:        &rp1_dpi_16bit_gpio0        { };
++dpi_16bit_gpio2:        &rp1_dpi_16bit_gpio2        { };
++
++/* Add the IOMMUs for some RP1 bus masters */
++
++&csi0 {
++	iommus = <&iommu5>;
++};
++
++&csi1 {
++	iommus = <&iommu5>;
++};
++
++&dsi0 {
++	iommus = <&iommu5>;
++};
++
++&dsi1 {
++	iommus = <&iommu5>;
++};
++
++&dpi {
++	iommus = <&iommu5>;
++};
++
++&vec {
++	iommus = <&iommu5>;
++};
++
++&ddc0 {
++	status = "disabled";
++};
++
++&ddc1 {
++	status = "disabled";
++};
++
++&hdmi0 {
++	clocks = <&firmware_clocks 13>, <&firmware_clocks 14>, <&dvp 0>, <&clk_27MHz>;
++	clock-names = "hdmi", "bvb", "audio", "cec";
++	status = "disabled";
++};
++
++&hdmi1 {
++	clocks = <&firmware_clocks 13>, <&firmware_clocks 14>, <&dvp 1>, <&clk_27MHz>;
++	clock-names = "hdmi", "bvb", "audio", "cec";
++	status = "disabled";
++};
++
++&hvs {
++	clocks = <&firmware_clocks 4>, <&firmware_clocks 16>;
++	clock-names = "core", "disp";
++};
++
++&mop {
++	status = "disabled";
++};
++
++&moplet {
++	status = "disabled";
++};
++
++&pixelvalve0 {
++	status = "disabled";
++};
++
++&pixelvalve1 {
++	status = "disabled";
++};
++
++&disp_intr {
++	status = "disabled";
++};
++
++/* SDIO1 is used to drive the SD card */
++&sdio1 {
++	pinctrl-0 = <&emmc_sd_pulls>, <&emmc_aon_cd_pins>;
++	pinctrl-names = "default";
++	vqmmc-supply = <&sd_io_1v8_reg>;
++	vmmc-supply = <&sd_vcc_reg>;
++	bus-width = <4>;
++	sd-uhs-sdr50;
++	sd-uhs-ddr50;
++	sd-uhs-sdr104;
++	//broken-cd;
++	//no-1-8-v;
++	status = "okay";
++};
++
++&pinctrl_aon {
++	emmc_aon_cd_pins: emmc_aon_cd_pins {
++		function = "sd_card_g";
++		pins = "aon_gpio5";
++		bias-pull-up;
++	};
++
++	/* Slight hack - only one PWM pin (status LED) is usable */
++	aon_pwm_1pin: aon_pwm_1pin {
++		function = "aon_pwm";
++		pins = "aon_gpio9";
++	};
++};
++
++&pinctrl {
++	pwr_button_pins: pwr_button_pins {
++		function = "gpio";
++		pins = "gpio20";
++		bias-pull-up;
++	};
++
++	wl_on_pins: wl_on_pins {
++		function = "gpio";
++		pins = "gpio28";
++	};
++
++	bt_shutdown_pins: bt_shutdown_pins {
++		function = "gpio";
++		pins = "gpio29";
++	};
++
++	emmc_sd_pulls: emmc_sd_pulls {
++		function = "emmc_dat0", "emmc_dat1", "emmc_dat2", "emmc_dat3";
++		bias-pull-up;
++	};
++};
++
++/* uarta communicates with the BT module */
++&uarta {
++	uart-has-rtscts;
++	auto-flow-control;
++	status = "okay";
++	clock-frequency = <96000000>;
++	pinctrl-0 = <&uarta_24_pins &bt_shutdown_pins>;
++	pinctrl-names = "default";
++
++	bluetooth: bluetooth {
++		compatible = "brcm,bcm43438-bt";
++		max-speed = <3000000>;
++		shutdown-gpios = <&gio 29 GPIO_ACTIVE_HIGH>;
++		local-bd-address = [ 00 00 00 00 00 00 ];
++	};
++};
++
++&i2c_rp1boot {
++	clock-frequency = <400000>;
++	pinctrl-0 = <&i2c3_m4_agpio0_pins>;
++	pinctrl-names = "default";
++};
++
++/ {
++	chosen: chosen {
++		bootargs = "coherent_pool=1M 8250.nr_uarts=1 pci=pcie_bus_safe snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1";
++		stdout-path = "serial10:115200n8";
++	};
++
++	fan: cooling_fan {
++		status = "disabled";
++		compatible = "pwm-fan";
++		#cooling-cells = <2>;
++		cooling-min-state = <0>;
++		cooling-max-state = <3>;
++		cooling-levels = <0 75 125 175 250>;
++		pwms = <&rp1_pwm1 3 41566 PWM_POLARITY_INVERTED>;
++		rpm-regmap = <&rp1_pwm1>;
++		rpm-offset = <0x3c>;
++	};
++
++	pwr_button {
++		compatible = "gpio-keys";
++
++		pinctrl-names = "default";
++		pinctrl-0 = <&pwr_button_pins>;
++		status = "okay";
++
++		pwr_key: pwr {
++			label = "pwr_button";
++			// linux,code = <205>; // KEY_SUSPEND
++			linux,code = <116>; // KEY_POWER
++			gpios = <&gio 20 GPIO_ACTIVE_LOW>;
++			debounce-interval = <50>; // ms
++		};
++	};
++};
++
++&usb {
++	power-domains = <&power RPI_POWER_DOMAIN_USB>;
++};
++
++/* SDIO2 drives the WLAN interface */
++&sdio2 {
++	pinctrl-0 = <&sdio2_30_pins>;
++	pinctrl-names = "default";
++	bus-width = <4>;
++	vmmc-supply = <&wl_on_reg>;
++	sd-uhs-ddr50;
++	non-removable;
++	status = "okay";
++	#address-cells = <1>;
++	#size-cells = <0>;
++
++	wifi: wifi@1 {
++		reg = <1>;
++		compatible = "brcm,bcm4329-fmac";
++		local-mac-address = [00 00 00 00 00 00];
++	};
++};
++
++&rpivid {
++	status = "okay";
++};
++
++&pinctrl {
++	spi10_gpio2: spi10_gpio2 {
++		function = "vc_spi0";
++		pins = "gpio2", "gpio3", "gpio4";
++		bias-disable;
++	};
++
++	spi10_cs_gpio1: spi10_cs_gpio1 {
++		function = "gpio";
++		pins = "gpio1";
++		bias-pull-up;
++	};
++};
++
++spi10_pins: &spi10_gpio2 {};
++spi10_cs_pins: &spi10_cs_gpio1 {};
++
++&spi10 {
++	pinctrl-names = "default";
++	cs-gpios = <&gio 1 1>;
++	pinctrl-0 = <&spi10_pins &spi10_cs_pins>;
++
++	spidev10: spidev@0 {
++		compatible = "spidev";
++		reg = <0>;	/* CE0 */
++		#address-cells = <1>;
++		#size-cells = <0>;
++		spi-max-frequency = <20000000>;
++		status = "okay";
++	};
++};
++
++// =============================================
++// Board specific stuff here
++
++&gio_aon {
++	// Don't use GIO_AON as an interrupt controller because it will
++	// clash with the firmware monitoring the PMIC interrupt via the VPU.
++
++	/delete-property/ interrupt-controller;
++};
++
++&main_aon_irq {
++	// Don't use the MAIN_AON_IRQ interrupt controller because it will
++	// clash with the firmware monitoring the PMIC interrupt via the VPU.
++
++	status = "disabled";
++};
++
++&rp1_pwm1 {
++	status = "disabled";
++	pinctrl-0 = <&rp1_pwm1_gpio45>;
++	pinctrl-names = "default";
++};
++
++&thermal_trips {
++	cpu_tepid: cpu-tepid {
++		temperature = <50000>;
++		hysteresis = <5000>;
++		type = "active";
++	};
++
++	cpu_warm: cpu-warm {
++		temperature = <60000>;
++		hysteresis = <5000>;
++		type = "active";
++	};
++
++	cpu_hot: cpu-hot {
++		temperature = <67500>;
++		hysteresis = <5000>;
++		type = "active";
++	};
++
++	cpu_vhot: cpu-vhot {
++		temperature = <75000>;
++		hysteresis = <5000>;
++		type = "active";
++	};
++};
++
++&cooling_maps {
++	tepid {
++		trip = <&cpu_tepid>;
++		cooling-device = <&fan 1 1>;
++	};
++
++	warm {
++		trip = <&cpu_warm>;
++		cooling-device = <&fan 2 2>;
++	};
++
++	hot {
++		trip = <&cpu_hot>;
++		cooling-device = <&fan 3 3>;
++	};
++
++	vhot {
++		trip = <&cpu_vhot>;
++		cooling-device = <&fan 4 4>;
++	};
++
++	melt {
++		trip = <&cpu_crit>;
++		cooling-device = <&fan 4 4>;
++	};
++};
++
++&gio {
++	// The GPIOs above 35 are not used on Pi 5, so shrink the upper bank
++	// to reduce the clutter in gpioinfo/pinctrl
++	brcm,gpio-bank-widths = <32 4>;
++
++	gpio-line-names =
++		"-", // GPIO_000
++		"2712_BOOT_CS_N", // GPIO_001
++		"2712_BOOT_MISO", // GPIO_002
++		"2712_BOOT_MOSI", // GPIO_003
++		"2712_BOOT_SCLK", // GPIO_004
++		"-", // GPIO_005
++		"-", // GPIO_006
++		"-", // GPIO_007
++		"-", // GPIO_008
++		"-", // GPIO_009
++		"-", // GPIO_010
++		"-", // GPIO_011
++		"-", // GPIO_012
++		"-", // GPIO_013
++		"PCIE_SDA", // GPIO_014
++		"PCIE_SCL", // GPIO_015
++		"-", // GPIO_016
++		"-", // GPIO_017
++		"-", // GPIO_018
++		"-", // GPIO_019
++		"PWR_GPIO", // GPIO_020
++		"2712_G21_FS", // GPIO_021
++		"-", // GPIO_022
++		"-", // GPIO_023
++		"BT_RTS", // GPIO_024
++		"BT_CTS", // GPIO_025
++		"BT_TXD", // GPIO_026
++		"BT_RXD", // GPIO_027
++		"WL_ON", // GPIO_028
++		"BT_ON", // GPIO_029
++		"WIFI_SDIO_CLK", // GPIO_030
++		"WIFI_SDIO_CMD", // GPIO_031
++		"WIFI_SDIO_D0", // GPIO_032
++		"WIFI_SDIO_D1", // GPIO_033
++		"WIFI_SDIO_D2", // GPIO_034
++		"WIFI_SDIO_D3"; // GPIO_035
++};
++
++&gio_aon {
++	gpio-line-names =
++		"RP1_SDA", // AON_GPIO_00
++		"RP1_SCL", // AON_GPIO_01
++		"RP1_RUN", // AON_GPIO_02
++		"SD_IOVDD_SEL", // AON_GPIO_03
++		"SD_PWR_ON", // AON_GPIO_04
++		"SD_CDET_N", // AON_GPIO_05
++		"SD_FLG_N", // AON_GPIO_06
++		"-", // AON_GPIO_07
++		"2712_WAKE", // AON_GPIO_08
++		"2712_STAT_LED", // AON_GPIO_09
++		"-", // AON_GPIO_10
++		"-", // AON_GPIO_11
++		"PMIC_INT", // AON_GPIO_12
++		"UART_TX_FS", // AON_GPIO_13
++		"UART_RX_FS", // AON_GPIO_14
++		"-", // AON_GPIO_15
++		"-", // AON_GPIO_16
++
++		// Pad bank0 out to 32 entries
++		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
++
++		"HDMI0_SCL", // AON_SGPIO_00
++		"HDMI0_SDA", // AON_SGPIO_01
++		"HDMI1_SCL", // AON_SGPIO_02
++		"HDMI1_SDA", // AON_SGPIO_03
++		"PMIC_SCL", // AON_SGPIO_04
++		"PMIC_SDA"; // AON_SGPIO_05
++
++	rp1_run_hog {
++		gpio-hog;
++		gpios = <2 GPIO_ACTIVE_HIGH>;
++		output-high;
++		line-name = "RP1 RUN pin";
++	};
++};
++
++&rp1_gpio {
++	gpio-line-names =
++		"ID_SD", // GPIO0
++		"ID_SC", // GPIO1
++		"PIN3", // GPIO2
++		"PIN5", // GPIO3
++		"PIN7", // GPIO4
++		"PIN29", // GPIO5
++		"PIN31", // GPIO6
++		"PIN26", // GPIO7
++		"PIN24", // GPIO8
++		"PIN21", // GPIO9
++		"PIN19", // GPIO10
++		"PIN23", // GPIO11
++		"PIN32", // GPIO12
++		"PIN33", // GPIO13
++		"PIN8", // GPIO14
++		"PIN10", // GPIO15
++		"PIN36", // GPIO16
++		"PIN11", // GPIO17
++		"PIN12", // GPIO18
++		"PIN35", // GPIO19
++		"PIN38", // GPIO20
++		"PIN40", // GPIO21
++		"PIN15", // GPIO22
++		"PIN16", // GPIO23
++		"PIN18", // GPIO24
++		"PIN22", // GPIO25
++		"PIN37", // GPIO26
++		"PIN13", // GPIO27
++
++		"PCIE_RP1_WAKE", // GPIO28
++		"FAN_TACH", // GPIO29
++		"HOST_SDA", // GPIO30
++		"HOST_SCL", // GPIO31
++		"ETH_RST_N", // GPIO32
++		"-", // GPIO33
++
++		"CD0_IO0_MICCLK", // GPIO34
++		"CD0_IO0_MICDAT0", // GPIO35
++		"RP1_PCIE_CLKREQ_N", // GPIO36
++		"-", // GPIO37
++		"CD0_SDA", // GPIO38
++		"CD0_SCL", // GPIO39
++		"CD1_SDA", // GPIO40
++		"CD1_SCL", // GPIO41
++		"USB_VBUS_EN", // GPIO42
++		"USB_OC_N", // GPIO43
++		"RP1_STAT_LED", // GPIO44
++		"FAN_PWM", // GPIO45
++		"CD1_IO0_MICCLK", // GPIO46
++		"2712_WAKE", // GPIO47
++		"CD1_IO1_MICDAT1", // GPIO48
++		"EN_MAX_USB_CUR", // GPIO49
++		"-", // GPIO50
++		"-", // GPIO51
++		"-", // GPIO52
++		"-"; // GPIO53
++
++	usb_vbus_pins: usb_vbus_pins {
++		function = "vbus1";
++		pins = "gpio42", "gpio43";
++	};
++};
++
++/ {
++	aliases: aliases {
++		blconfig = &blconfig;
++		bluetooth = &bluetooth;
++		console = &uart10;
++		ethernet0 = &rp1_eth;
++		wifi0 = &wifi;
++		fb = &fb;
++		mailbox = &mailbox;
++		mmc0 = &sdio1;
++		uart0 = &uart0;
++		uart1 = &uart1;
++		uart2 = &uart2;
++		uart3 = &uart3;
++		uart4 = &uart4;
++		uart10 = &uart10;
++		serial0 = &uart0;
++		serial1 = &uart1;
++		serial2 = &uart2;
++		serial3 = &uart3;
++		serial4 = &uart4;
++		serial10 = &uart10;
++		i2c = &i2c_arm;
++		i2c0 = &i2c0;
++		i2c1 = &i2c1;
++		i2c2 = &i2c2;
++		i2c3 = &i2c3;
++		i2c4 = &i2c4;
++		i2c5 = &i2c5;
++		i2c6 = &i2c6;
++		i2c10 = &i2c_rp1boot;
++		// Bit-bashed i2c_gpios start at 10
++		spi0 = &spi0;
++		spi1 = &spi1;
++		spi2 = &spi2;
++		spi3 = &spi3;
++		spi4 = &spi4;
++		spi5 = &spi5;
++		spi10 = &spi10;
++		gpio0 = &gpio;
++		gpio1 = &gio;
++		gpio2 = &gio_aon;
++		gpio3 = &pinctrl;
++		gpio4 = &pinctrl_aon;
++		usb0 = &rp1_usb0;
++		usb1 = &rp1_usb1;
++	};
++
++	__overrides__ {
++		bdaddr = <&bluetooth>, "local-bd-address[";
++		button_debounce = <&pwr_key>, "debounce-interval:0";
++		cooling_fan = <&fan>, "status", <&rp1_pwm1>, "status";
++		uart0_console = <&uart0>,"status", <&aliases>, "console=",&uart0;
++		i2c0 = <&i2c0>, "status";
++		i2c1 = <&i2c1>, "status";
++		i2c = <&i2c1>, "status";
++		i2c_arm = <&i2c_arm>, "status";
++		i2c_vc = <&i2c_vc>, "status";
++		i2c_csi_dsi = <&i2c_csi_dsi>, "status";
++		i2c_csi_dsi0 = <&i2c_csi_dsi0>, "status";
++		i2c_csi_dsi1 = <&i2c_csi_dsi1>, "status";
++		i2c0_baudrate = <&i2c0>, "clock-frequency:0";
++		i2c1_baudrate = <&i2c1>, "clock-frequency:0";
++		i2c_baudrate = <&i2c_arm>, "clock-frequency:0";
++		i2c_arm_baudrate = <&i2c_arm>, "clock-frequency:0";
++		i2c_vc_baudrate = <&i2c_vc>, "clock-frequency:0";
++		nvme = <&pciex1>, "status";
++		pciex1 = <&pciex1>, "status";
++		pciex1_gen = <&pciex1> , "max-link-speed:0";
++		pciex1_no_l0s = <&pciex1>, "aspm-no-l0s?";
++		random = <&random>, "status";
++		rtc_bbat_vchg = <&rpi_rtc>, "trickle-charge-microvolt:0";
++		spi = <&spi0>, "status";
++		suspend = <&pwr_key>, "linux,code:0=205";
++		uart0 = <&uart0>, "status";
++		wifiaddr = <&wifi>, "local-mac-address[";
++
++		act_led_activelow = <&act_led>, "active-low?";
++		act_led_trigger = <&act_led>, "linux,default-trigger";
++		pwr_led_activelow = <&pwr_led>, "gpios:8";
++		pwr_led_trigger = <&pwr_led>, "linux,default-trigger";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/bcm2712-rpi.dtsi
+@@ -0,0 +1,281 @@
++// SPDX-License-Identifier: GPL-2.0
++
++#include <dt-bindings/power/raspberrypi-power.h>
++
++&soc {
++	firmware: firmware {
++		compatible = "raspberrypi,bcm2835-firmware", "simple-mfd";
++		#address-cells = <1>;
++		#size-cells = <1>;
++
++		mboxes = <&mailbox>;
++		dma-ranges;
++
++		firmware_clocks: clocks {
++			compatible = "raspberrypi,firmware-clocks";
++			#clock-cells = <1>;
++		};
++
++		reset: reset {
++			compatible = "raspberrypi,firmware-reset";
++			#reset-cells = <1>;
++		};
++
++		vcio: vcio {
++			compatible = "raspberrypi,vcio";
++		};
++	};
++
++	power: power {
++		compatible = "raspberrypi,bcm2835-power";
++		firmware = <&firmware>;
++		#power-domain-cells = <1>;
++	};
++
++	fb: fb {
++		compatible = "brcm,bcm2708-fb";
++		firmware = <&firmware>;
++		status = "okay";
++	};
++
++	rpi_rtc: rpi_rtc {
++		compatible = "raspberrypi,rpi-rtc";
++		firmware = <&firmware>;
++		status = "okay";
++		trickle-charge-microvolt = <0>;
++	};
++
++	/* Define these notional regulators for use by overlays, etc. */
++	vdd_3v3_reg: fixedregulator_3v3 {
++		compatible = "regulator-fixed";
++		regulator-always-on;
++		regulator-max-microvolt = <3300000>;
++		regulator-min-microvolt = <3300000>;
++		regulator-name = "3v3";
++	};
++
++	vdd_5v0_reg: fixedregulator_5v0 {
++		compatible = "regulator-fixed";
++		regulator-always-on;
++		regulator-max-microvolt = <5000000>;
++		regulator-min-microvolt = <5000000>;
++		regulator-name = "5v0";
++	};
++};
++
++/ {
++	__overrides__ {
++		arm_freq;
++	};
++};
++
++pciex1: &pcie1 { };
++pciex4: &pcie2 { };
++
++&dma32 {
++	/* The VPU firmware uses DMA channel 11 for VCHIQ */
++	brcm,dma-channel-mask = <0x03f>;
++};
++
++&dma40 {
++	/* The VPU firmware DMA channel 11 for VCHIQ */
++	brcm,dma-channel-mask = <0x07c0>;
++};
++
++&hdmi0 {
++	dmas = <&dma40 (10|(1<<30)|(1<<24)|(10<<16)|(15<<20))>;
++};
++
++&hdmi1 {
++	dmas = <&dma40 (17|(1<<30)|(1<<24)|(10<<16)|(15<<20))>;
++};
++
++&spi10 {
++	dmas = <&dma40 6>, <&dma40 7>;
++	dma-names = "tx", "rx";
++};
++
++&usb {
++	power-domains = <&power RPI_POWER_DOMAIN_USB>;
++};
++
++&rmem {
++	/*
++	 * RPi4's co-processor will copy the board's bootloader configuration
++	 * into memory for the OS to consume. It'll also update this node with
++	 * its placement information.
++	 */
++	blconfig: nvram@0 {
++		compatible = "raspberrypi,bootloader-config", "nvmem-rmem";
++		#address-cells = <1>;
++		#size-cells = <1>;
++		reg = <0x0 0x0 0x0>;
++		no-map;
++		status = "disabled";
++	};
++};
++
++&rp1_adc {
++	status = "okay";
++};
++
++/* Add some gpiomem nodes to make the devices accessible to userspace.
++ * /dev/gpiomem<n> should expose the registers for the interface with DT alias
++ * gpio<n>.
++ */
++
++&rp1 {
++	gpiomem@d0000 {
++		/* Export IO_BANKs, RIO_BANKs and PADS_BANKs to userspace */
++		compatible = "raspberrypi,gpiomem";
++		reg = <0xc0 0x400d0000  0x0 0x30000>;
++		chardev-name = "gpiomem0";
++	};
++};
++
++&soc {
++	gpiomem@7d508500 {
++		compatible = "raspberrypi,gpiomem";
++		reg = <0x7d508500 0x40>;
++		chardev-name = "gpiomem1";
++	};
++
++	gpiomem@7d517c00 {
++		compatible = "raspberrypi,gpiomem";
++		reg = <0x7d517c00 0x40>;
++		chardev-name = "gpiomem2";
++	};
++
++	gpiomem@7d504100 {
++		compatible = "raspberrypi,gpiomem";
++		reg = <0x7d504100 0x20>;
++		chardev-name = "gpiomem3";
++	};
++
++	gpiomem@7d510700 {
++		compatible = "raspberrypi,gpiomem";
++		reg = <0x7d510700 0x20>;
++		chardev-name = "gpiomem4";
++	};
++};
++
++i2c0: &rp1_i2c0 { };
++i2c1: &rp1_i2c1 { };
++i2c2: &rp1_i2c2 { };
++i2c3: &rp1_i2c3 { };
++i2c4: &rp1_i2c4 { };
++i2c5: &rp1_i2c5 { };
++i2c6: &rp1_i2c6 { };
++i2s:  &rp1_i2s0 { };
++i2s_clk_producer: &rp1_i2s0 { };
++i2s_clk_consumer: &rp1_i2s1 { };
++pwm0: &rp1_pwm0 { };
++pwm1: &rp1_pwm1 { };
++pwm: &pwm0 { };
++spi0: &rp1_spi0 { };
++spi1: &rp1_spi1 { };
++spi2: &rp1_spi2 { };
++spi3: &rp1_spi3 { };
++spi4: &rp1_spi4 { };
++spi5: &rp1_spi5 { };
++
++uart0_pins: &rp1_uart0_14_15 {};
++uart0_ctsrts_pins: &rp1_uart0_ctsrts_16_17 {};
++uart0: &rp1_uart0 {
++	pinctrl-0 = <&uart0_pins>;
++};
++
++uart1_pins: &rp1_uart1_0_1 {};
++uart1_ctsrts_pins: &rp1_uart1_ctsrts_2_3 {};
++uart1: &rp1_uart1 { };
++
++uart2_pins: &rp1_uart2_4_5 {};
++uart2_ctsrts_pins: &rp1_uart2_ctsrts_6_7 {};
++uart2: &rp1_uart2 { };
++
++uart3_pins: &rp1_uart3_8_9 {};
++uart3_ctsrts_pins: &rp1_uart3_ctsrts_10_11 {};
++uart3: &rp1_uart3 { };
++
++uart4_pins: &rp1_uart4_12_13 {};
++uart4_ctsrts_pins: &rp1_uart4_ctsrts_14_15 {};
++uart4: &rp1_uart4 { };
++
++i2c_vc: &i2c0 {      // This is pins 27,28 on the header (not MIPI)
++	pinctrl-0 = <&rp1_i2c0_0_1>;
++	pinctrl-names = "default";
++};
++
++i2c_arm: &i2c1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rp1_i2c1_2_3>;
++};
++
++&i2c2 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rp1_i2c2_4_5>;
++};
++
++&i2c3 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rp1_i2c3_6_7>;
++};
++
++&i2s_clk_producer {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rp1_i2s0_18_21>;
++};
++
++&i2s_clk_consumer {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rp1_i2s1_18_21>;
++};
++
++spi0_pins: &rp1_spi0_gpio9 {};
++spi0_cs_pins: &rp1_spi0_cs_gpio7 {};
++
++&spi0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi0_pins &spi0_cs_pins>;
++	cs-gpios = <&gpio 8 1>, <&gpio 7 1>;
++
++	spidev0: spidev@0 {
++		compatible = "spidev";
++		reg = <0>;	/* CE0 */
++		#address-cells = <1>;
++		#size-cells = <0>;
++		spi-max-frequency = <125000000>;
++	};
++
++	spidev1: spidev@1 {
++		compatible = "spidev";
++		reg = <1>;	/* CE1 */
++		#address-cells = <1>;
++		#size-cells = <0>;
++		spi-max-frequency = <125000000>;
++	};
++};
++
++spi2_pins: &rp1_spi2_gpio1 {};
++&spi2 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi2_pins>;
++};
++
++spi3_pins: &rp1_spi3_gpio5 {};
++&spi3 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi3_pins>;
++};
++
++spi4_pins: &rp1_spi4_gpio9 {};
++&spi4 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi4_pins>;
++};
++
++spi5_pins: &rp1_spi5_gpio13 {};
++&spi5 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi5_pins>;
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/bcm2712.dtsi
+@@ -0,0 +1,1287 @@
++// SPDX-License-Identifier: GPL-2.0
++#include <dt-bindings/interrupt-controller/arm-gic.h>
++#include <dt-bindings/soc/bcm2835-pm.h>
++#include <dt-bindings/phy/phy.h>
++
++/ {
++	compatible = "brcm,bcm2712", "brcm,bcm2711";
++	model = "BCM2712";
++
++	#address-cells = <2>;
++	#size-cells = <1>;
++
++	interrupt-parent = <&gicv2>;
++
++	rmem: reserved-memory {
++		#address-cells = <2>;
++		#size-cells = <1>;
++		ranges;
++
++		atf@0 {
++			reg = <0x0 0x0 0x80000>;
++			no-map;
++		};
++
++		cma: linux,cma {
++			compatible = "shared-dma-pool";
++			size = <0x4000000>; /* 64MB */
++			reusable;
++			linux,cma-default;
++
++			/*
++			 * arm64 reserves the CMA by default somewhere in
++			 * ZONE_DMA32, that's not good enough for the BCM2711
++			 * as some devices can only address the lower 1G of
++			 * memory (ZONE_DMA).
++			 */
++			alloc-ranges = <0x0 0x00000000 0x40000000>;
++		};
++	};
++
++	thermal-zones {
++		cpu_thermal: cpu-thermal {
++			polling-delay-passive = <2000>;
++			polling-delay = <1000>;
++			coefficients = <(-550) 450000>;
++			thermal-sensors = <&thermal>;
++
++			thermal_trips: trips {
++				cpu_crit: cpu-crit {
++					temperature	= <110000>;
++					hysteresis	= <0>;
++					type		= "critical";
++				};
++			};
++
++			cooling_maps: cooling-maps {
++			};
++		};
++	};
++
++	clk_27MHz: clk-27M {
++		#clock-cells = <0>;
++		compatible = "fixed-clock";
++		clock-frequency = <27000000>;
++		clock-output-names = "27MHz-clock";
++	};
++
++	clk_108MHz: clk-108M {
++		#clock-cells = <0>;
++		compatible = "fixed-clock";
++		clock-frequency = <108000000>;
++		clock-output-names = "108MHz-clock";
++	};
++
++	hvs: hvs@107c580000 {
++		compatible = "brcm,bcm2712-hvs";
++		reg = <0x10 0x7c580000 0x1a000>;
++		interrupt-parent = <&disp_intr>;
++		interrupts = <2>, <9>, <16>;
++		interrupt-names = "ch0-eof", "ch1-eof", "ch2-eof";
++		//iommus = <&iommu4>;
++		status = "disabled";
++	};
++
++	soc: soc {
++		compatible = "simple-bus";
++		#address-cells = <1>;
++		#size-cells = <1>;
++
++		ranges     = <0x7c000000  0x10 0x7c000000  0x04000000>;
++		/* Emulate a contiguous 30-bit address range for DMA */
++		dma-ranges = <0xc0000000  0x00 0x00000000  0x40000000>,
++			     <0x7c000000  0x10 0x7c000000  0x04000000>;
++
++		system_timer: timer@7c003000 {
++			compatible = "brcm,bcm2835-system-timer";
++			reg = <0x7c003000 0x1000>;
++			interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>,
++		     		     <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
++		     		     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
++			clock-frequency = <1000000>;
++		};
++
++		firmwarekms: firmwarekms@7d503000 {
++			compatible = "raspberrypi,rpi-firmware-kms";
++			/* SUN_L2 interrupt reg */
++			reg = <0x7d503000 0x18>;
++			interrupt-parent = <&cpu_l2_irq>;
++			interrupts = <19>;
++			brcm,firmware = <&firmware>;
++			status = "disabled";
++		};
++
++		mailbox: mailbox@7c013880 {
++			compatible = "brcm,bcm2835-mbox";
++			reg = <0x7c013880 0x40>;
++			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++			#mbox-cells = <0>;
++		};
++
++		pixelvalve0: pixelvalve@7c410000 {
++			compatible = "brcm,bcm2712-pixelvalve0";
++			reg = <0x7c410000 0x100>;
++			interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
++			status = "disabled";
++		};
++
++		pixelvalve1: pixelvalve@7c411000 {
++			compatible = "brcm,bcm2712-pixelvalve1";
++			reg = <0x7c411000 0x100>;
++			interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
++			status = "disabled";
++		};
++
++		usb: usb@7c480000 {
++			compatible = "brcm,bcm2835-usb";
++			reg = <0x7c480000 0x10000>;
++			interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			clocks = <&clk_usb>;
++			clock-names = "otg";
++			phys = <&usbphy>;
++			phy-names = "usb2-phy";
++			status = "disabled";
++		};
++
++		mop: mop@7c500000 {
++			compatible = "brcm,bcm2712-mop";
++			reg = <0x7c500000 0x20>;
++			interrupt-parent = <&disp_intr>;
++			interrupts = <1>;
++			status = "disabled";
++		};
++
++		moplet: moplet@7c501000 {
++			compatible = "brcm,bcm2712-moplet";
++			reg = <0x7c501000 0x20>;
++			interrupt-parent = <&disp_intr>;
++			interrupts = <0>;
++			status = "disabled";
++		};
++
++		disp_intr: interrupt-controller@7c502000 {
++			compatible = "brcm,bcm2711-l2-intc", "brcm,l2-intc";
++			reg = <0x7c502000 0x30>;
++			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++			status = "disabled";
++		};
++
++		dvp: clock@7c700000 {
++			compatible = "brcm,brcm2711-dvp";
++			reg = <0x7c700000 0x10>;
++			clocks = <&clk_108MHz>;
++			#clock-cells = <1>;
++			#reset-cells = <1>;
++		};
++
++		/*
++		 * This node is the provider for the enable-method for
++		 * bringing up secondary cores.
++		 */
++		local_intc: local_intc@7cd00000 {
++			compatible = "brcm,bcm2836-l1-intc";
++			reg = <0x7cd00000 0x100>;
++		};
++
++		uart0: serial@7d001000 {
++			compatible = "arm,pl011", "arm,primecell";
++			reg = <0x7d001000 0x200>;
++			interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_uart>,
++				 <&clk_vpu>;
++			clock-names = "uartclk", "apb_pclk";
++			arm,primecell-periphid = <0x00241011>;
++			status = "disabled";
++		};
++
++		uart2: serial@7d001400 {
++			compatible = "arm,pl011", "arm,primecell";
++			reg = <0x7d001400 0x200>;
++			interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_uart>,
++				 <&clk_vpu>;
++			clock-names = "uartclk", "apb_pclk";
++			arm,primecell-periphid = <0x00241011>;
++			status = "disabled";
++		};
++
++		uart3: serial@7d001600 {
++			compatible = "arm,pl011", "arm,primecell";
++			reg = <0x7d001600 0x200>;
++			interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_uart>,
++				 <&clk_vpu>;
++			clock-names = "uartclk", "apb_pclk";
++			arm,primecell-periphid = <0x00241011>;
++			status = "disabled";
++		};
++
++		uart4: serial@7d001800 {
++			compatible = "arm,pl011", "arm,primecell";
++			reg = <0x7d001800 0x200>;
++			interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_uart>,
++				 <&clk_vpu>;
++			clock-names = "uartclk", "apb_pclk";
++			arm,primecell-periphid = <0x00241011>;
++			status = "disabled";
++		};
++
++		uart5: serial@7d001a00 {
++			compatible = "arm,pl011", "arm,primecell";
++			reg = <0x7d001a00 0x200>;
++			interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_uart>,
++				 <&clk_vpu>;
++			clock-names = "uartclk", "apb_pclk";
++			arm,primecell-periphid = <0x00241011>;
++			status = "disabled";
++		};
++
++		sdhost: mmc@7d002000 {
++			compatible = "brcm,bcm2835-sdhost";
++			reg = <0x7d002000 0x100>;
++			//interrupts = <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			status = "disabled";
++		};
++
++		i2s: i2s@7d003000 {
++			compatible = "brcm,bcm2835-i2s";
++			reg = <0x7d003000 0x24>;
++			//clocks = <&cprman BCM2835_CLOCK_PCM>;
++			status = "disabled";
++		};
++
++		spi0: spi@7d004000 {
++			compatible = "brcm,bcm2835-spi";
++			reg = <0x7d004000 0x200>;
++			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			num-cs = <1>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		spi3: spi@7d004600 {
++			compatible = "brcm,bcm2835-spi";
++			reg = <0x7d004600 0x0200>;
++			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		spi4: spi@7d004800 {
++			compatible = "brcm,bcm2835-spi";
++			reg = <0x7d004800 0x0200>;
++			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		spi5: spi@7d004a00 {
++			compatible = "brcm,bcm2835-spi";
++			reg = <0x7d004a00 0x0200>;
++			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		spi6: spi@7d004c00 {
++			compatible = "brcm,bcm2835-spi";
++			reg = <0x7d004c00 0x0200>;
++			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		i2c0: i2c@7d005000 {
++			compatible = "brcm,bcm2711-i2c", "brcm,bcm2835-i2c";
++			reg = <0x7d005000 0x20>;
++			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		i2c3: i2c@7d005600 {
++			compatible = "brcm,bcm2711-i2c", "brcm,bcm2835-i2c";
++			reg = <0x7d005600 0x20>;
++			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		i2c4: i2c@7d005800 {
++			compatible = "brcm,bcm2711-i2c", "brcm,bcm2835-i2c";
++			reg = <0x7d005800 0x20>;
++			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		i2c5: i2c@7d005a00 {
++			compatible = "brcm,bcm2711-i2c", "brcm,bcm2835-i2c";
++			reg = <0x7d005a00 0x20>;
++			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		i2c6: i2c@7d005c00 {
++			compatible = "brcm,bcm2711-i2c", "brcm,bcm2835-i2c";
++			reg = <0x7d005c00 0x20>;
++			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		i2c8: i2c@7d005e00 {
++			compatible = "brcm,bcm2711-i2c", "brcm,bcm2835-i2c";
++			reg = <0x7d005e00 0x20>;
++			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_vpu>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		pwm0: pwm@7d00c000 {
++			compatible = "brcm,bcm2835-pwm";
++			reg = <0x7d00c000 0x28>;
++			assigned-clock-rates = <10000000>;
++			#pwm-cells = <2>;
++			status = "disabled";
++		};
++
++		pwm1: pwm@7d00c800 {
++			compatible = "brcm,bcm2835-pwm";
++			reg = <0x7d00c800 0x28>;
++			assigned-clock-rates = <10000000>;
++			#pwm-cells = <2>;
++			status = "disabled";
++		};
++
++		pm: watchdog@7d200000 {
++			compatible = "brcm,bcm2712-pm";
++			reg = <0x7d200000 0x308>;
++			reg-names = "pm";
++			#power-domain-cells = <1>;
++			#reset-cells = <1>;
++			//clocks = <&cprman BCM2835_CLOCK_V3D>,
++			//	 <&cprman BCM2835_CLOCK_PERI_IMAGE>,
++			//	 <&cprman BCM2835_CLOCK_H264>,
++			//	 <&cprman BCM2835_CLOCK_ISP>;
++			clock-names = "v3d", "peri_image", "h264", "isp";
++			system-power-controller;
++		};
++
++		cprman: cprman@7d202000 {
++			compatible = "brcm,bcm2711-cprman";
++			reg = <0x7d202000 0x2000>;
++			#clock-cells = <1>;
++
++			/* CPRMAN derives almost everything from the
++			 * platform's oscillator.  However, the DSI
++			 * pixel clocks come from the DSI analog PHY.
++			 */
++			clocks = <&clk_osc>;
++			status = "disabled";
++		};
++
++		random: rng@7d208000 {
++			compatible = "brcm,bcm2711-rng200";
++			reg = <0x7d208000 0x28>;
++			status = "okay";
++		};
++
++		cpu_l2_irq: intc@7d503000 {
++			compatible = "brcm,l2-intc";
++			reg = <0x7d503000 0x18>;
++			interrupts = <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++		};
++
++		pinctrl: pinctrl@7d504100 {
++			compatible = "brcm,bcm2712-pinctrl";
++			reg = <0x7d504100 0x30>;
++
++			uarta_24_pins: uarta_24_pins {
++				pin_rts {
++					function = "uart0";
++					pins = "gpio24";
++					bias-disable;
++				};
++				pin_cts {
++					function = "uart0";
++					pins = "gpio25";
++					bias-pull-up;
++				};
++				pin_txd {
++					function = "uart0";
++					pins = "gpio26";
++					bias-disable;
++				};
++				pin_rxd {
++					function = "uart0";
++					pins = "gpio27";
++					bias-pull-up;
++				};
++			};
++
++			sdio2_30_pins: sdio2_30_pins {
++				pin_clk {
++					function = "sd2";
++					pins = "gpio30";
++					bias-disable;
++				};
++				pin_cmd {
++					function = "sd2";
++					pins = "gpio31";
++					bias-pull-up;
++				};
++				pins_dat {
++					function = "sd2";
++					pins = "gpio32", "gpio33", "gpio34", "gpio35";
++					bias-pull-up;
++				};
++			};
++		};
++
++		ddc0: i2c@7d508200 {
++			compatible = "brcm,brcmstb-i2c";
++			reg = <0x7d508200 0x58>;
++			interrupt-parent = <&bsc_irq>;
++			interrupts = <1>;
++			clock-frequency = <200000>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		ddc1: i2c@7d508280 {
++			compatible = "brcm,brcmstb-i2c";
++			reg = <0x7d508280 0x58>;
++			interrupt-parent = <&bsc_irq>;
++			interrupts = <2>;
++			clock-frequency = <200000>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		bscd: i2c@7d508300 {
++			compatible = "brcm,brcmstb-i2c";
++			reg = <0x7d508300 0x58>;
++			interrupt-parent = <&bsc_irq>;
++			interrupts = <0>;
++			clock-frequency = <200000>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		bsc_irq: intc@7d508380 {
++			compatible = "brcm,bcm7271-l2-intc";
++			reg = <0x7d508380 0x10>;
++			interrupts = <GIC_SPI 242 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++		};
++
++		main_irq: intc@7d508400 {
++			compatible = "brcm,bcm7271-l2-intc";
++			reg = <0x7d508400 0x10>;
++			interrupts = <GIC_SPI 244 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++		};
++
++		gio: gpio@7d508500 {
++			compatible = "brcm,brcmstb-gpio";
++			reg = <0x7d508500 0x40>;
++			interrupt-parent = <&main_irq>;
++			interrupts = <0>;
++			gpio-controller;
++			#gpio-cells = <2>;
++			interrupt-controller;
++			#interrupt-cells = <2>;
++			brcm,gpio-bank-widths = <32 22>;
++			brcm,gpio-direct;
++		};
++
++		uarta: serial@7d50c000 {
++			compatible = "brcm,bcm7271-uart";
++			reg = <0x7d50c000 0x20>;
++			reg-names = "uart";
++			reg-shift = <2>;
++			reg-io-width = <4>;
++			interrupts = <GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>;
++			skip-init;
++			status = "disabled";
++		};
++
++		uartb: serial@7d50d000 {
++			compatible = "brcm,bcm7271-uart";
++			reg = <0x7d50d000 0x20>;
++			reg-names = "uart";
++			reg-shift = <2>;
++			reg-io-width = <4>;
++			interrupts = <GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>;
++			skip-init;
++			status = "disabled";
++		};
++
++		uartc: serial@7d50e000 {
++			compatible = "brcm,bcm7271-uart";
++			reg = <0x7d50e000 0x20>;
++			reg-names = "uart";
++			reg-shift = <2>;
++			reg-io-width = <4>;
++			interrupts = <GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>;
++			skip-init;
++			status = "disabled";
++		};
++
++		aon_intr: interrupt-controller@7d510600 {
++			compatible = "brcm,bcm2711-l2-intc", "brcm,l2-intc";
++			reg = <0x7d510600 0x30>;
++			interrupts = <GIC_SPI 239 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++			status = "disabled";
++		};
++
++		pinctrl_aon: pinctrl@7d510700 {
++			compatible = "brcm,bcm2712-aon-pinctrl";
++			reg = <0x7d510700 0x20>;
++
++			i2c3_m4_agpio0_pins: i2c3_m4_agpio0_pins {
++				function = "vc_i2c3";
++				pins = "aon_gpio0", "aon_gpio1";
++				bias-pull-up;
++			};
++
++			bsc_m1_agpio13_pins: bsc_m1_agpio13_pins {
++				function = "bsc_m1";
++				pins = "aon_gpio13", "aon_gpio14";
++				bias-pull-up;
++			};
++
++			bsc_pmu_sgpio4_pins: bsc_pmu_sgpio4_pins {
++				function = "avs_pmu_bsc";
++				pins = "aon_sgpio4", "aon_sgpio5";
++			};
++
++			bsc_m2_sgpio4_pins: bsc_m2_sgpio4_pins {
++				function = "bsc_m2";
++				pins = "aon_sgpio4", "aon_sgpio5";
++			};
++
++			pwm_aon_agpio1_pins: pwm_aon_agpio1_pins {
++				function = "aon_pwm";
++				pins = "aon_gpio1", "aon_gpio2";
++			};
++
++			pwm_aon_agpio4_pins: pwm_aon_agpio4_pins {
++				function = "vc_pwm0";
++				pins = "aon_gpio4", "aon_gpio5";
++			};
++
++			pwm_aon_agpio7_pins: pwm_aon_agpio7_pins {
++				function = "aon_pwm";
++				pins = "aon_gpio7", "aon_gpio9";
++			};
++		};
++
++		intc@7d517000 {
++			compatible = "brcm,bcm7271-l2-intc";
++			reg = <0x7d517000 0x10>;
++			interrupts = <GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++			status = "disabled";
++		};
++
++		bscc: i2c@7d517a00 {
++			compatible = "brcm,brcmstb-i2c";
++			reg = <0x7d517a00 0x58>;
++			interrupt-parent = <&bsc_aon_irq>;
++			interrupts = <0>;
++			clock-frequency = <200000>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		pwm_aon: pwm@7d517a80 {
++			compatible = "brcm,bcm7038-pwm";
++			reg = <0x7d517a80 0x28>;
++			#pwm-cells = <2>;
++			clocks = <&clk_27MHz>;
++		};
++
++		main_aon_irq: intc@7d517ac0 {
++			compatible = "brcm,bcm7271-l2-intc";
++			reg = <0x7d517ac0 0x10>;
++			interrupts = <GIC_SPI 245 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++		};
++
++		bsc_aon_irq: intc@7d517b00 {
++			compatible = "brcm,bcm7271-l2-intc";
++			reg = <0x7d517b00 0x10>;
++			interrupts = <GIC_SPI 243 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++		};
++
++		gio_aon: gpio@7d517c00 {
++			compatible = "brcm,brcmstb-gpio";
++			reg = <0x7d517c00 0x40>;
++			interrupt-parent = <&main_aon_irq>;
++			interrupts = <0>;
++			gpio-controller;
++			#gpio-cells = <2>;
++			interrupt-controller;
++			#interrupt-cells = <2>;
++			brcm,gpio-bank-widths = <17 6>;
++			brcm,gpio-direct;
++		};
++
++		avs_monitor: avs-monitor@7d542000 {
++			compatible = "brcm,bcm2711-avs-monitor",
++				     "syscon", "simple-mfd";
++			reg = <0x7d542000 0xf00>;
++			status = "okay";
++
++			thermal: thermal {
++				compatible = "brcm,bcm2711-thermal";
++				#thermal-sensor-cells = <0>;
++			};
++		};
++
++		bsc_pmu: i2c@7d544000 {
++			compatible = "brcm,brcmstb-i2c";
++			reg = <0x7d544000 0x58>;
++			interrupt-parent = <&bsc_aon_irq>;
++			interrupts = <1>;
++			clock-frequency = <200000>;
++			status = "disabled";
++		};
++
++		hdmi0: hdmi@7ef00700 {
++			compatible = "brcm,bcm2712-hdmi0";
++			reg = <0x7c701400 0x300>,
++			      <0x7c701000 0x200>,
++			      <0x7c701d00 0x300>,
++			      <0x7c702000 0x80>,
++			      <0x7c703800 0x200>,
++			      <0x7c704000 0x800>,
++			      <0x7c700100 0x80>,
++			      <0x7d510800 0x100>,
++			      <0x7c720000 0x100>;
++			reg-names = "hdmi",
++				    "dvp",
++				    "phy",
++				    "rm",
++				    "packet",
++				    "metadata",
++				    "csc",
++				    "cec",
++				    "hd";
++			resets = <&dvp 1>;
++			interrupt-parent = <&aon_intr>;
++			interrupts = <1>, <2>, <3>,
++				     <7>, <8>;
++			interrupt-names = "cec-tx", "cec-rx", "cec-low",
++					  "hpd-connected", "hpd-removed";
++			ddc = <&ddc0>;
++			dmas = <&dma32 10>;
++			dma-names = "audio-rx";
++			status = "disabled";
++		};
++
++		hdmi1: hdmi@7ef05700 {
++			compatible = "brcm,bcm2712-hdmi1";
++			reg = <0x7c706400 0x300>,
++			      <0x7c706000 0x200>,
++			      <0x7c706d00 0x300>,
++			      <0x7c707000 0x80>,
++			      <0x7c708800 0x200>,
++			      <0x7c709000 0x800>,
++			      <0x7c700180 0x80>,
++			      <0x7d511000 0x100>,
++			      <0x7c720000 0x100>;
++			reg-names = "hdmi",
++				    "dvp",
++				    "phy",
++				    "rm",
++				    "packet",
++				    "metadata",
++				    "csc",
++				    "cec",
++				    "hd";
++			ddc = <&ddc1>;
++			resets = <&dvp 2>;
++			interrupt-parent = <&aon_intr>;
++			interrupts = <11>, <12>, <13>,
++				     <14>, <15>;
++			interrupt-names = "cec-tx", "cec-rx", "cec-low",
++					  "hpd-connected", "hpd-removed";
++			dmas = <&dma32 17>;
++			dma-names = "audio-rx";
++			status = "disabled";
++		};
++
++		sound: sound {
++		};
++	};
++
++	arm-pmu {
++		compatible = "arm,cortex-a76-pmu";
++		interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
++			<GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
++			<GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
++			<GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
++		interrupt-affinity = <&cpu0>, <&cpu1>, <&cpu2>, <&cpu3>;
++	};
++
++	timer {
++		compatible = "arm,armv8-timer";
++		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) |
++					  IRQ_TYPE_LEVEL_LOW)>,
++			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) |
++					  IRQ_TYPE_LEVEL_LOW)>,
++			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) |
++					  IRQ_TYPE_LEVEL_LOW)>,
++			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) |
++					  IRQ_TYPE_LEVEL_LOW)>;
++		/* This only applies to the ARMv7 stub */
++		arm,cpu-registers-not-fw-configured;
++	};
++
++	cpus: cpus {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		enable-method = "brcm,bcm2836-smp"; // for ARM 32-bit
++
++		cpu0: cpu@0 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a76";
++			reg = <0x000>;
++			enable-method = "psci";
++			next-level-cache = <&l2_cache>;
++		};
++
++		cpu1: cpu@1 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a76";
++			reg = <0x100>;
++			enable-method = "psci";
++			next-level-cache = <&l2_cache>;
++		};
++
++		cpu2: cpu@2 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a76";
++			reg = <0x200>;
++			enable-method = "psci";
++			next-level-cache = <&l2_cache>;
++		};
++
++		cpu3: cpu@3 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a76";
++			reg = <0x300>;
++			enable-method = "psci";
++			next-level-cache = <&l2_cache>;
++		};
++
++		l2_cache: l2-cache {
++			compatible = "cache";
++			next-level-cache = <&l3_cache>;
++		};
++
++		l3_cache: l3-cache {
++			compatible = "cache";
++		};
++	};
++
++	psci {
++		method = "smc";
++		compatible = "arm,psci-1.0", "arm,psci-0.2", "arm,psci";
++		cpu_on = <0xc4000003>;
++		cpu_suspend = <0xc4000001>;
++		cpu_off = <0x84000002>;
++	};
++
++	axi: axi {
++		compatible = "simple-bus";
++		#address-cells = <2>;
++		#size-cells = <2>;
++
++		ranges = <0x00 0x00000000  0x00 0x00000000  0x10 0x00000000>,
++			 <0x10 0x00000000  0x10 0x00000000  0x01 0x00000000>,
++			 <0x14 0x00000000  0x14 0x00000000  0x04 0x00000000>,
++			 <0x18 0x00000000  0x18 0x00000000  0x04 0x00000000>,
++			 <0x1c 0x00000000  0x1c 0x00000000  0x04 0x00000000>;
++
++		dma-ranges = <0x00 0x00000000  0x00 0x00000000  0x10 0x00000000>,
++			     <0x10 0x00000000  0x10 0x00000000  0x01 0x00000000>,
++			     <0x14 0x00000000  0x14 0x00000000  0x04 0x00000000>,
++			     <0x18 0x00000000  0x18 0x00000000  0x04 0x00000000>,
++			     <0x1c 0x00000000  0x1c 0x00000000  0x04 0x00000000>;
++
++		vc4: gpu {
++			compatible = "brcm,bcm2712-vc6";
++		};
++
++		iommu2: iommu@5100 {
++			/* IOMMU2 for PISP-BE, HEVC; and (unused) H264 accelerators */
++			compatible = "brcm,bcm2712-iommu";
++			reg = <0x10 0x5100  0x0 0x80>;
++			cache = <&iommuc>;
++			#iommu-cells = <0>;
++		};
++
++		iommu4: iommu@5200 {
++			/* IOMMU4 for HVS, MPL/TXP; and (unused) Unicam, PISP-FE, MiniBVN */
++			compatible = "brcm,bcm2712-iommu";
++			reg = <0x10 0x5200  0x0 0x80>;
++			cache = <&iommuc>;
++			#iommu-cells = <0>;
++			#interconnect-cells = <0>;
++		};
++
++		iommu5: iommu@5280 {
++			/* IOMMU5 for PCIe2 (RP1); and (unused) BSTM */
++			compatible = "brcm,bcm2712-iommu";
++			reg = <0x10 0x5280  0x0 0x80>;
++			cache = <&iommuc>;
++			#iommu-cells = <0>;
++			dma-iova-offset = <0x10 0x00000000>; // HACK for RP1 masters over PCIe
++		};
++
++		iommuc: iommuc@5b00 {
++			compatible = "brcm,bcm2712-iommuc";
++			reg = <0x10 0x5b00  0x0 0x80>;
++		};
++
++		dma32: dma@10000 {
++			compatible = "brcm,bcm2712-dma";
++			reg = <0x10 0x00010000 0 0x600>;
++			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "dma0",
++					  "dma1",
++					  "dma2",
++					  "dma3",
++					  "dma4",
++					  "dma5";
++			#dma-cells = <1>;
++			brcm,dma-channel-mask = <0x0035>;
++		};
++
++		dma40: dma@10600 {
++			compatible = "brcm,bcm2712-dma";
++			reg = <0x10 0x00010600 0 0x600>;
++			interrupts =
++				<GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>, /* dma4 6 */
++				<GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>, /* dma4 7 */
++				<GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>, /* dma4 8 */
++				<GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>, /* dma4 9 */
++				<GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>, /* dma4 10 */
++				<GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>; /* dma4 11 */
++			interrupt-names = "dma6",
++					  "dma7",
++					  "dma8",
++					  "dma9",
++					  "dma10",
++					  "dma11";
++			#dma-cells = <1>;
++			brcm,dma-channel-mask = <0x0fc0>;
++		};
++
++		// Single-lane Gen3 PCIe
++		// Outbound window at 0x14_000000-0x17_ffffff
++		pcie0: pcie@100000 {
++			compatible = "brcm,bcm2712-pcie";
++			reg = <0x10 0x00100000  0x0 0x9310>;
++			device_type = "pci";
++			max-link-speed = <2>;
++			#address-cells = <3>;
++			#interrupt-cells = <1>;
++			#size-cells = <2>;
++			/*
++			 * Unused interrupts:
++			 * 208: AER
++			 * 215: NMI
++			 * 216: PME
++			 */
++			interrupt-parent = <&gicv2>;
++			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "pcie", "msi";
++			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
++			interrupt-map = <0 0 0 1 &gicv2 GIC_SPI 209
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 2 &gicv2 GIC_SPI 210
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 3 &gicv2 GIC_SPI 211
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 4 &gicv2 GIC_SPI 212
++							IRQ_TYPE_LEVEL_HIGH>;
++			resets = <&bcm_reset 5>, <&bcm_reset 42>, <&pcie_rescal>;
++			reset-names = "swinit", "bridge", "rescal";
++			msi-controller;
++			msi-parent = <&pcie0>;
++
++			ranges = <0x02000000 0x00 0x00000000
++				  0x17 0x00000000
++				  0x0 0xfffffffc>,
++				 <0x43000000 0x04 0x00000000
++				  0x14 0x00000000
++				  0x3 0x00000000>;
++
++			dma-ranges = <0x43000000 0x10 0x00000000
++				      0x00 0x00000000
++				      0x10 0x00000000>;
++
++			status = "disabled";
++		};
++
++		// Single-lane Gen3 PCIe
++		// Outbound window at 0x18_000000-0x1b_ffffff
++		pcie1: pcie@110000 {
++			compatible = "brcm,bcm2712-pcie";
++			reg = <0x10 0x00110000  0x0 0x9310>;
++			device_type = "pci";
++			max-link-speed = <2>;
++			#address-cells = <3>;
++			#interrupt-cells = <1>;
++			#size-cells = <2>;
++			/*
++			 * Unused interrupts:
++			 * 218: AER
++			 * 225: NMI
++			 * 226: PME
++			 */
++			interrupt-parent = <&gicv2>;
++			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "pcie", "msi";
++			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
++			interrupt-map = <0 0 0 1 &gicv2 GIC_SPI 219
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 2 &gicv2 GIC_SPI 220
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 3 &gicv2 GIC_SPI 221
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 4 &gicv2 GIC_SPI 222
++							IRQ_TYPE_LEVEL_HIGH>;
++			resets = <&bcm_reset 7>, <&bcm_reset 43>, <&pcie_rescal>;
++			reset-names = "swinit", "bridge", "rescal";
++			msi-controller;
++			msi-parent = <&mip1>;
++
++			ranges = <0x02000000 0x00 0x00000000
++				  0x1b 0x00000000
++				  0x00 0xfffffffc>,
++				 <0x43000000 0x04 0x00000000
++				  0x18 0x00000000
++				  0x03 0x00000000>;
++
++			dma-ranges = <0x03000000 0x10 0x00000000
++				      0x00 0x00000000
++				      0x10 0x00000000>;
++
++			brcm,enable-l1ss;
++			status = "disabled";
++		};
++
++		pcie_rescal: reset-controller@119500 {
++			compatible = "brcm,bcm7216-pcie-sata-rescal";
++			reg = <0x10 0x00119500  0x0 0x10>;
++			#reset-cells = <0>;
++		};
++
++		// Quad-lane Gen3 PCIe
++		// Outbound window at 0x1c_000000-0x1f_ffffff
++		pcie2: pcie@120000 {
++			compatible = "brcm,bcm2712-pcie";
++			reg = <0x10 0x00120000  0x0 0x9310>;
++			device_type = "pci";
++			max-link-speed = <2>;
++			#address-cells = <3>;
++			#interrupt-cells = <1>;
++			#size-cells = <2>;
++			/*
++			 * Unused interrupts:
++			 * 228: AER
++			 * 235: NMI
++			 * 236: PME
++			 */
++			interrupt-parent = <&gicv2>;
++			interrupts = <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 234 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "pcie", "msi";
++			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
++			interrupt-map = <0 0 0 1 &gicv2 GIC_SPI 229
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 2 &gicv2 GIC_SPI 230
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 3 &gicv2 GIC_SPI 231
++							IRQ_TYPE_LEVEL_HIGH>,
++					<0 0 0 4 &gicv2 GIC_SPI 232
++							IRQ_TYPE_LEVEL_HIGH>;
++			resets = <&bcm_reset 32>, <&bcm_reset 44>, <&pcie_rescal>;
++			reset-names = "swinit", "bridge", "rescal";
++			msi-controller;
++			msi-parent = <&mip0>;
++
++			// ~4GB, 32-bit, not-prefetchable at PCIe 00_00000000
++			ranges = <0x02000000 0x00 0x00000000
++				  0x1f 0x00000000
++				  0x0 0xfffffffc>,
++			// 12GB, 64-bit, prefetchable at PCIe 04_00000000
++				 <0x43000000 0x04 0x00000000
++				  0x1c 0x00000000
++				  0x03 0x00000000>;
++
++			// 64GB system RAM space at PCIe 10_00000000
++			dma-ranges = <0x02000000 0x00 0x00000000
++				      0x1f 0x00000000
++				      0x00 0x00400000>,
++				     <0x43000000 0x10 0x00000000
++				      0x00 0x00000000
++				      0x10 0x00000000>;
++
++			brcm,enable-mps-rcb;
++			brcm,enable-l1ss;
++			status = "disabled";
++		};
++
++		mip0: msi-controller@130000 {
++			compatible = "brcm,bcm2712-mip-intc";
++			reg = <0x10 0x00130000  0x0 0xc0>;
++			msi-controller;
++			interrupt-controller;
++			#interrupt-cells = <2>;
++			brcm,msi-base-spi = <128>;
++			brcm,msi-num-spis = <64>;
++			brcm,msi-offset = <0>;
++			brcm,msi-pci-addr = <0xff 0xfffff000>;
++		};
++
++		mip1: msi-controller@131000 {
++			compatible = "brcm,bcm2712-mip-intc";
++			reg = <0x10 0x00131000  0x0 0xc0>;
++			msi-controller;
++			interrupt-controller;
++			#interrupt-cells = <2>;
++			brcm,msi-base-spi = <247>;
++			/* Actually 20 total, but the others are
++			 * both sparse and non-consecutive */
++			brcm,msi-num-spis = <8>;
++			brcm,msi-offset = <8>;
++			brcm,msi-pci-addr = <0xff 0xffffe000>;
++		};
++
++		genet: ethernet@1300000 {
++			compatible = "brcm,bcm2711-genet-v5";
++			reg = <0x10 0x01300000  0x0 0x20010>;
++			#address-cells = <0x1>;
++			#size-cells = <0x0>;
++			interrupts = <GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>;
++			status = "disabled";
++			phy-mode = "rgmii";
++			fixed-link = <0x0 0x1 0x3e8 0x0 0x0>;
++	                  phy-speed = <0x3e8>;
++	                  phy-id = <0x101>;
++	                  phy-type = <0x6>;
++	                  local-mac-address = [ 00 10 18 d8 45 de ];
++	                  device_type = "network";
++
++			genet_mdio: mdio@e14 {
++				compatible = "brcm,genet-mdio-v5";
++				reg = <0xe14 0x8>;
++				#address-cells = <0x1>;
++				#size-cells = <0x0>;
++			};
++		};
++
++		syscon_piarbctl: syscon@400018 {
++			compatible = "brcm,syscon-piarbctl", "syscon", "simple-mfd";
++			reg = <0x10 0x00400018  0x0 0x18>;
++		};
++
++		rpivid: codec@800000 {
++			compatible = "raspberrypi,rpivid-vid-decoder";
++			reg = <0x10 0x00800000  0x0 0x10000>, /* HEVC */
++			      <0x10 0x00840000  0x0 0x1000>;  /* INTC */
++			reg-names = "hevc",
++				    "intc";
++
++			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
++
++			clocks = <&firmware_clocks 11>;
++			clock-names = "hevc";
++			status = "disabled";
++		};
++
++		sdio1: mmc@fff000 {
++			compatible = "brcm,bcm2712-sdhci";
++			reg = <0x10 0x00fff000  0x0 0x260>,
++			      <0x10 0x00fff400  0x0 0x200>,
++			      <0x10 0x015040b0  0x0 0x4>,  // Bus isolation control
++			      <0x10 0x015200f0  0x0 0x24>; // LCPLL control misc0-8
++			reg-names = "host", "cfg", "busisol", "lcpll";
++			interrupts = <GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_emmc2>;
++			sdhci-caps-mask = <0x0000C000 0x0>;
++			sdhci-caps = <0x0 0x0>;
++			supports-cqe;
++			mmc-ddr-3_3v;
++		};
++
++		sdio2: mmc@1100000 {
++			compatible = "brcm,bcm2712-sdhci";
++			reg = <0x10 0x01100000  0x0 0x260>,
++			      <0x10 0x01100400  0x0 0x200>;
++			reg-names = "host", "cfg";
++			interrupts = <GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_emmc2>;
++			sdhci-caps-mask = <0x0000C000 0x0>;
++			sdhci-caps = <0x0 0x0>;
++			supports-cqe;
++			mmc-ddr-3_3v;
++			status = "disabled";
++		};
++
++		sdio0: mmc@1108000 {
++			compatible = "brcm,bcm2711-emmc2";
++			reg = <0x10 0x01108000  0x0 0x100>;
++			interrupts = <GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&clk_emmc2>;
++			mmc-ddr-3_3v;
++			status = "disabled";
++		};
++
++		bcm_reset: reset-controller@1504318 {
++			compatible = "brcm,brcmstb-reset";
++			reg = <0x10 0x01504318  0x0 0x30>;
++			#reset-cells = <1>;
++		};
++
++		v3d: v3d@2000000 {
++			compatible = "brcm,2712-v3d";
++			reg = <0x10 0x02000000  0x0 0x4000>,
++			      <0x10 0x02008000  0x0 0x6000>;
++			reg-names = "hub", "core0";
++
++			power-domains = <&pm BCM2835_POWER_DOMAIN_GRAFX_V3D>;
++			resets = <&pm BCM2835_RESET_V3D>;
++			clocks = <&firmware_clocks 5>;
++			clocks-names = "v3d";
++			interrupts = <GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>;
++			status = "disabled";
++		};
++
++		gicv2: interrupt-controller@7fff9000 {
++			interrupt-controller;
++			#interrupt-cells = <3>;
++			compatible = "arm,gic-400";
++			reg =	<0x10 0x7fff9000  0x0 0x1000>,
++				<0x10 0x7fffa000  0x0 0x2000>,
++				<0x10 0x7fffc000  0x0 0x2000>,
++				<0x10 0x7fffe000  0x0 0x2000>;
++			interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) |
++						 IRQ_TYPE_LEVEL_HIGH)>;
++		};
++
++		pisp_be: pisp_be@880000  {
++			compatible = "raspberrypi,pispbe";
++			reg = <0x10 0x00880000  0x0 0x4000>;
++			interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&firmware_clocks 7>;
++			clocks-names = "isp_be";
++			status = "okay";
++			iommus = <&iommu2>;
++		};
++	};
++
++	clocks {
++		/* The oscillator is the root of the clock tree. */
++		clk_osc: clk-osc {
++			compatible = "fixed-clock";
++			#clock-cells = <0>;
++			clock-output-names = "osc";
++			clock-frequency = <54000000>;
++		};
++
++		clk_usb: clk-usb {
++			compatible = "fixed-clock";
++			#clock-cells = <0>;
++			clock-output-names = "otg";
++			clock-frequency = <480000000>;
++		};
++
++		clk_vpu: clk_vpu {
++			#clock-cells = <0>;
++			compatible = "fixed-clock";
++			clock-frequency = <750000000>;
++			clock-output-names = "vpu-clock";
++		};
++
++		clk_uart: clk_uart {
++			#clock-cells = <0>;
++			compatible = "fixed-clock";
++			clock-frequency = <9216000>;
++			clock-output-names = "uart-clock";
++		};
++
++		clk_emmc2: clk_emmc2 {
++			#clock-cells = <0>;
++			compatible = "fixed-clock";
++			clock-frequency = <54000000>;
++			clock-output-names = "emmc2-clock";
++		};
++	};
++
++	usbphy: phy {
++		compatible = "usb-nop-xceiv";
++		#phy-cells = <0>;
++	};
++};
+--- a/arch/arm/boot/dts/overlays/Makefile
++++ b/arch/arm/boot/dts/overlays/Makefile
+@@ -49,8 +49,10 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	dionaudio-loco.dtbo \
+ 	dionaudio-loco-v2.dtbo \
+ 	disable-bt.dtbo \
++	disable-bt-pi5.dtbo \
+ 	disable-emmc2.dtbo \
+ 	disable-wifi.dtbo \
++	disable-wifi-pi5.dtbo \
+ 	dpi18.dtbo \
+ 	dpi18cpadhi.dtbo \
+ 	dpi24.dtbo \
+@@ -106,8 +108,12 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	i2c-rtc-gpio.dtbo \
+ 	i2c-sensor.dtbo \
+ 	i2c0.dtbo \
++	i2c0-pi5.dtbo \
+ 	i2c1.dtbo \
++	i2c1-pi5.dtbo \
++	i2c2-pi5.dtbo \
+ 	i2c3.dtbo \
++	i2c3-pi5.dtbo \
+ 	i2c4.dtbo \
+ 	i2c5.dtbo \
+ 	i2c6.dtbo \
+@@ -150,10 +156,15 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	media-center.dtbo \
+ 	merus-amp.dtbo \
+ 	midi-uart0.dtbo \
++	midi-uart0-pi5.dtbo \
+ 	midi-uart1.dtbo \
++	midi-uart1-pi5.dtbo \
+ 	midi-uart2.dtbo \
++	midi-uart2-pi5.dtbo \
+ 	midi-uart3.dtbo \
++	midi-uart3-pi5.dtbo \
+ 	midi-uart4.dtbo \
++	midi-uart4-pi5.dtbo \
+ 	midi-uart5.dtbo \
+ 	minipitft13.dtbo \
+ 	miniuart-bt.dtbo \
+@@ -231,14 +242,20 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	spi1-2cs.dtbo \
+ 	spi1-3cs.dtbo \
+ 	spi2-1cs.dtbo \
++	spi2-1cs-pi5.dtbo \
+ 	spi2-2cs.dtbo \
++	spi2-2cs-pi5.dtbo \
+ 	spi2-3cs.dtbo \
+ 	spi3-1cs.dtbo \
++	spi3-1cs-pi5.dtbo \
+ 	spi3-2cs.dtbo \
++	spi3-2cs-pi5.dtbo \
+ 	spi4-1cs.dtbo \
+ 	spi4-2cs.dtbo \
+ 	spi5-1cs.dtbo \
++	spi5-1cs-pi5.dtbo \
+ 	spi5-2cs.dtbo \
++	spi5-2cs-pi5.dtbo \
+ 	spi6-1cs.dtbo \
+ 	spi6-2cs.dtbo \
+ 	ssd1306.dtbo \
+@@ -253,10 +270,15 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	tpm-slb9670.dtbo \
+ 	tpm-slb9673.dtbo \
+ 	uart0.dtbo \
++	uart0-pi5.dtbo \
+ 	uart1.dtbo \
++	uart1-pi5.dtbo \
+ 	uart2.dtbo \
++	uart2-pi5.dtbo \
+ 	uart3.dtbo \
++	uart3-pi5.dtbo \
+ 	uart4.dtbo \
++	uart4-pi5.dtbo \
+ 	uart5.dtbo \
+ 	udrc.dtbo \
+ 	ugreen-dabboard.dtbo \
+@@ -276,6 +298,7 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	vc4-kms-kippah-7inch.dtbo \
+ 	vc4-kms-v3d.dtbo \
+ 	vc4-kms-v3d-pi4.dtbo \
++	vc4-kms-v3d-pi5.dtbo \
+ 	vc4-kms-vga666.dtbo \
+ 	vga666.dtbo \
+ 	vl805.dtbo \
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -151,6 +151,9 @@ Params:
+                                 bdaddr=06:05:04:03:02:01
+                                 will set the BDADDR to 01:02:03:04:05:06.
+ 
++        button_debounce         Set the debounce delay (in ms) on the power/
++                                shutdown button (default 50ms)
++
+         cam0_reg                Enables CAM 0 regulator.
+                                 Only required on CM1 & 3.
+ 
+@@ -167,6 +170,9 @@ Params:
+                                 Default of GPIO expander 5 on CM4, but override
+                                 switches to normal GPIO.
+ 
++        cooling_fan             Enables the Pi 5 cooling fan (enabled
++                                automatically by the firmware)
++
+         eee                     Enable Energy Efficient Ethernet support for
+                                 compatible devices (default "on"). See also
+                                 "tx_lpi_timer". Pi3B+ only.
+@@ -206,23 +212,29 @@ Params:
+         hdmi                    Set to "off" to disable the HDMI interface
+                                 (default "on")
+ 
++        i2c                     An alias for i2c_arm
++
+         i2c_arm                 Set to "on" to enable the ARM's i2c interface
+                                 (default "off")
+ 
++        i2c_arm_baudrate        Set the baudrate of the ARM's i2c interface
++                                (default "100000")
++
++        i2c_baudrate            An alias for i2c_arm_baudrate
++
++        i2c_csi_dsi             Set to "on" to enable the i2c_csi_dsi interface
++
++        i2c_csi_dsi0            Set to "on" to enable the i2c_csi_dsi0 interface
++
++        i2c_csi_dsi1            Set to "on" to enable the i2c_csi_dsi1 interface
++
+         i2c_vc                  Set to "on" to enable the i2c interface
+                                 usually reserved for the VideoCore processor
+                                 (default "off")
+ 
+-        i2c                     An alias for i2c_arm
+-
+-        i2c_arm_baudrate        Set the baudrate of the ARM's i2c interface
+-                                (default "100000")
+-
+         i2c_vc_baudrate         Set the baudrate of the VideoCore i2c interface
+                                 (default "100000")
+ 
+-        i2c_baudrate            An alias for i2c_arm_baudrate
+-
+         i2s                     Set to "on" to enable the i2s interface
+                                 (default "off")
+ 
+@@ -237,11 +249,23 @@ Params:
+         krnbt_baudrate          Set the baudrate of the PL011 UART when used
+                                 with krnbt=on
+ 
++        nvme                    Alias for "pciex1" (2712 only)
++
+         pcie                    Set to "off" to disable the PCIe interface
+                                 (default "on")
+                                 (2711 only, but not applicable on CM4S)
+                                 N.B. USB-A ports on 4B are subsequently disabled
+ 
++        pciex1                  Set to "on" to enable the external PCIe link
++                                (2712 only, default "off")
++
++        pciex1_gen              Sets the PCIe "GEN"/speed for the external PCIe
++                                link (2712 only, default "2")
++
++        pciex1_no_l0s           Set to "on" to disable ASPM L0s on the external
++                                PCIe link for devices that have broken
++                                implementations (2712 only, default "off")
++
+         spi                     Set to "on" to enable the spi interfaces
+                                 (default "off")
+ 
+@@ -252,6 +276,11 @@ Params:
+         random                  Set to "on" to enable the hardware random
+                                 number generator (default "on")
+ 
++        rtc_bbat_vchg           Set the RTC backup battery charging voltage in
++                                microvolts. If set to 0 or not specified, the
++                                trickle charger is disabled.
++                                (2712 only, default "0")
++
+         sd                      Set to "off" to disable the SD card (or eMMC on
+                                 non-lite SKU of CM4).
+                                 (default "on")
+@@ -276,18 +305,30 @@ Params:
+         sdio_overclock          Clock (in MHz) to use when the MMC framework
+                                 requests 50MHz for the SDIO/WLAN interface.
+ 
++        suspend                 Make the power button trigger a suspend rather
++                                than a power-off (2712 only, default "off")
++
+         tx_lpi_timer            Set the delay in microseconds between going idle
+                                 and entering the low power state (default 600).
+                                 Requires EEE to be enabled - see "eee".
+ 
+         uart0                   Set to "off" to disable uart0 (default "on")
+ 
++        uart0_console           Move the kernel boot console to UART0 on pins
++                                6, 8 and 10 of the 40-way header (2712 only,
++                                default "off")
++
+         uart1                   Set to "on" or "off" to enable or disable uart1
+                                 (default varies)
+ 
+         watchdog                Set to "on" to enable the hardware watchdog
+                                 (default "off")
+ 
++        wifiaddr                Set an alternative WiFi MAC address.
++                                The value should be a 6-byte hexadecimal value,
++                                with or without colon separators, written in the
++                                natural (big-endian) order.
++
+         act_led_trigger         Choose which activity the LED tracks.
+                                 Use "heartbeat" for a nice load indicator.
+                                 (default "mmc")
+@@ -919,14 +960,16 @@ Params: 24db_digital_gain       Allow ga
+ 
+ 
+ Name:   disable-bt
+-Info:   Disable onboard Bluetooth on Pi 3B, 3B+, 3A+, 4B and Zero W, restoring
+-        UART0/ttyAMA0 over GPIOs 14 & 15.
+-        N.B. To disable the systemd service that initialises the modem so it
+-        doesn't use the UART, use 'sudo systemctl disable hciuart'.
++Info:   Disable onboard Bluetooth on Bluetooth-capable Raspberry Pis. On Pis
++        prior to Pi 5 this restores UART0/ttyAMA0 over GPIOs 14 & 15.
+ Load:   dtoverlay=disable-bt
+ Params: <None>
+ 
+ 
++Name:   disable-bt-pi5
++Info:   See disable-bt
++
++
+ Name:   disable-emmc2
+ Info:   Disable EMMC2 controller on BCM2711.
+         The allows the onboard EMMC storage on Compute Module 4 to be disabled
+@@ -936,11 +979,15 @@ Params: <None>
+ 
+ 
+ Name:   disable-wifi
+-Info:   Disable onboard WLAN on Pi 3B, 3B+, 3A+, 4B and Zero W.
++Info:   Disable onboard WLAN on WiFi-capable Raspberry Pis.
+ Load:   dtoverlay=disable-wifi
+ Params: <None>
+ 
+ 
++Name:   disable-wifi-pi5
++Info:   See disable-wifi
++
++
+ Name:   dpi18
+ Info:   Overlay for a generic 18-bit DPI display
+         This uses GPIOs 0-21 (so no I2C, uart etc.), and activates the output
+@@ -2233,6 +2280,15 @@ Info:   Deprecated, legacy version of i2
+ Load:   <Deprecated>
+ 
+ 
++Name:   i2c0-pi5
++Info:   Enable i2c0 (Pi 5 only)
++Load:   dtoverlay=i2c0-pi5,<param>=<val>
++Params: pins_0_1                Use GPIOs 0 and 1 (default)
++        pins_8_9                Use GPIOs 8 and 9
++        baudrate                Set the baudrate for the interface (default
++                                "100000")
++
++
+ Name:   i2c1
+ Info:   Change i2c1 pin usage. Not all pin combinations are usable on all
+         platforms - platforms other then Compute Modules can only use this
+@@ -2249,6 +2305,24 @@ Info:   Deprecated, legacy version of i2
+ Load:   <Deprecated>
+ 
+ 
++Name:   i2c1-pi5
++Info:   Enable i2c1 (Pi 5 only)
++Load:   dtoverlay=i2c1-pi5,<param>=<val>
++Params: pins_2_3                Use GPIOs 2 and 3 (default)
++        pins_10_11              Use GPIOs 10 and 11
++        baudrate                Set the baudrate for the interface (default
++                                "100000")
++
++
++Name:   i2c2-pi5
++Info:   Enable i2c2 (Pi 5 only)
++Load:   dtoverlay=i2c2-pi5,<param>=<val>
++Params: pins_4_5                Use GPIOs 4 and 5 (default)
++        pins_12_13              Use GPIOs 12 and 13
++        baudrate                Set the baudrate for the interface (default
++                                "100000")
++
++
+ Name:   i2c3
+ Info:   Enable the i2c3 bus. BCM2711 only.
+ Load:   dtoverlay=i2c3,<param>
+@@ -2258,6 +2332,16 @@ Params: pins_2_3                Use GPIO
+                                 "100000")
+ 
+ 
++Name:   i2c3-pi5
++Info:   Enable i2c3 (Pi 5 only)
++Load:   dtoverlay=i2c3-pi5,<param>=<val>
++Params: pins_6_7                Use GPIOs 6 and 7 (default)
++        pins_14_15              Use GPIOs 14 and 15
++        pins_22_23              Use GPIOs 22 and 23
++        baudrate                Set the baudrate for the interface (default
++                                "100000")
++
++
+ Name:   i2c4
+ Info:   Enable the i2c4 bus. BCM2711 only.
+ Load:   dtoverlay=i2c4,<param>
+@@ -2869,6 +2953,10 @@ Load:   dtoverlay=midi-uart0
+ Params: <None>
+ 
+ 
++Name:   midi-uart0-pi5
++Info:   See midi-uart0 (this is the Pi 5 version)
++
++
+ Name:   midi-uart1
+ Info:   Configures UART1 (ttyS0) so that a requested 38.4kbaud actually gets
+         31.25kbaud, the frequency required for MIDI
+@@ -2876,29 +2964,45 @@ Load:   dtoverlay=midi-uart1
+ Params: <None>
+ 
+ 
++Name:   midi-uart1-pi5
++Info:   See midi-uart1 (this is the Pi 5 version)
++
++
+ Name:   midi-uart2
+-Info:   Configures UART2 (ttyAMA1) so that a requested 38.4kbaud actually gets
++Info:   Configures UART2 (ttyAMA2) so that a requested 38.4kbaud actually gets
+         31.25kbaud, the frequency required for MIDI
+ Load:   dtoverlay=midi-uart2
+ Params: <None>
+ 
+ 
++Name:   midi-uart2-pi5
++Info:   See midi-uart2 (this is the Pi 5 version)
++
++
+ Name:   midi-uart3
+-Info:   Configures UART3 (ttyAMA2) so that a requested 38.4kbaud actually gets
++Info:   Configures UART3 (ttyAMA3) so that a requested 38.4kbaud actually gets
+         31.25kbaud, the frequency required for MIDI
+ Load:   dtoverlay=midi-uart3
+ Params: <None>
+ 
+ 
++Name:   midi-uart3-pi5
++Info:   See midi-uart3 (this is the Pi 5 version)
++
++
+ Name:   midi-uart4
+-Info:   Configures UART4 (ttyAMA3) so that a requested 38.4kbaud actually gets
++Info:   Configures UART4 (ttyAMA4) so that a requested 38.4kbaud actually gets
+         31.25kbaud, the frequency required for MIDI
+ Load:   dtoverlay=midi-uart4
+ Params: <None>
+ 
+ 
++Name:   midi-uart4-pi5
++Info:   See midi-uart4 (this is the Pi 5 version)
++
++
+ Name:   midi-uart5
+-Info:   Configures UART5 (ttyAMA4) so that a requested 38.4kbaud actually gets
++Info:   Configures UART5 (ttyAMA5) so that a requested 38.4kbaud actually gets
+         31.25kbaud, the frequency required for MIDI
+ Load:   dtoverlay=midi-uart5
+ Params: <None>
+@@ -3921,105 +4025,131 @@ Name:   spi1-1cs
+ Info:   Enables spi1 with a single chip select (CS) line and associated spidev
+         dev node. The gpio pin number for the CS line and spidev device node
+         creation are configurable.
+-        N.B.: spi1 is only accessible on devices with a 40pin header, eg:
+-              A+, B+, Zero and PI2 B; as well as the Compute Module.
++        N.B.: spi1 is not accessible on old Pis without a 40-pin header.
+ Load:   dtoverlay=spi1-1cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 18 - BCM SPI1_CE0).
+-        cs0_spidev              Set to 'disabled' to stop the creation of a
++        cs0_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev1.0 (default
+-                                is 'okay' or enabled).
++                                is 'on' or enabled).
+ 
+ 
+ Name:   spi1-2cs
+ Info:   Enables spi1 with two chip select (CS) lines and associated spidev
+         dev nodes. The gpio pin numbers for the CS lines and spidev device node
+         creation are configurable.
+-        N.B.: spi1 is only accessible on devices with a 40pin header, eg:
+-              A+, B+, Zero and PI2 B; as well as the Compute Module.
++        N.B.: spi1 is not accessible on old Pis without a 40-pin header.
+ Load:   dtoverlay=spi1-2cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 18 - BCM SPI1_CE0).
+         cs1_pin                 GPIO pin for CS1 (default 17 - BCM SPI1_CE1).
+-        cs0_spidev              Set to 'disabled' to stop the creation of a
++        cs0_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev1.0 (default
+-                                is 'okay' or enabled).
+-        cs1_spidev              Set to 'disabled' to stop the creation of a
++                                is 'on' or enabled).
++        cs1_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev1.1 (default
+-                                is 'okay' or enabled).
++                                is 'on' or enabled).
+ 
+ 
+ Name:   spi1-3cs
+ Info:   Enables spi1 with three chip select (CS) lines and associated spidev
+         dev nodes. The gpio pin numbers for the CS lines and spidev device node
+         creation are configurable.
+-        N.B.: spi1 is only accessible on devices with a 40pin header, eg:
+-              A+, B+, Zero and PI2 B; as well as the Compute Module.
++        N.B.: spi1 is not accessible on old Pis without a 40-pin header.
+ Load:   dtoverlay=spi1-3cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 18 - BCM SPI1_CE0).
+         cs1_pin                 GPIO pin for CS1 (default 17 - BCM SPI1_CE1).
+         cs2_pin                 GPIO pin for CS2 (default 16 - BCM SPI1_CE2).
+-        cs0_spidev              Set to 'disabled' to stop the creation of a
++        cs0_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev1.0 (default
+-                                is 'okay' or enabled).
+-        cs1_spidev              Set to 'disabled' to stop the creation of a
++                                is 'on' or enabled).
++        cs1_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev1.1 (default
+-                                is 'okay' or enabled).
+-        cs2_spidev              Set to 'disabled' to stop the creation of a
++                                is 'on' or enabled).
++        cs2_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev1.2 (default
+-                                is 'okay' or enabled).
++                                is 'on' or enabled).
+ 
+ 
+ Name:   spi2-1cs
+-Info:   Enables spi2 with a single chip select (CS) line and associated spidev
+-        dev node. The gpio pin number for the CS line and spidev device node
+-        creation are configurable.
+-        N.B.: spi2 is only accessible with the Compute Module.
++Info:   Enables spi2 on GPIOs 40-42 with a single chip select (CS) line and
++        associated spidev dev node. The gpio pin number for the CS line and
++        spidev device node creation are configurable. spi2-2cs-pi5 is
++        substituted on a Pi 5.
++        N.B.: spi2 is only accessible with the Compute Module or Pi 5.
+ Load:   dtoverlay=spi2-1cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 43 - BCM SPI2_CE0).
+-        cs0_spidev              Set to 'disabled' to stop the creation of a
++        cs0_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev2.0 (default
+-                                is 'okay' or enabled).
++                                is 'on' or enabled).
++
++
++Name:   spi2-1cs-pi5
++Info:   Enables spi2 on GPIOs 1-3 with a single chip select (CS) line and
++        associated spidev dev node. The gpio pin number for the CS line and
++        spidev device node creation are configurable. Pi 5 only.
++Load:   dtoverlay=spi2-1cs-pi5,<param>=<val>
++Params: cs0_pin                 GPIO pin for CS0 (default 0).
++        cs0_spidev              Set to 'off' to stop the creation of a
++                                userspace device node /dev/spidev2.0 (default
++                                is 'on' or enabled).
+ 
+ 
+ Name:   spi2-2cs
+-Info:   Enables spi2 with two chip select (CS) lines and associated spidev
+-        dev nodes. The gpio pin numbers for the CS lines and spidev device node
+-        creation are configurable.
+-        N.B.: spi2 is only accessible with the Compute Module.
++Info:   Enables spi2 on GPIOs 40-42 with two chip select (CS) lines and
++        associated spidev dev nodes. The gpio pin numbers for the CS lines and
++        spidev device node creation are configurable. spi2-2cs-pi5 is
++        substituted on a Pi 5.
++        N.B.: spi2 is only accessible with the Compute Module or Pi 5.
+ Load:   dtoverlay=spi2-2cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 43 - BCM SPI2_CE0).
+         cs1_pin                 GPIO pin for CS1 (default 44 - BCM SPI2_CE1).
+-        cs0_spidev              Set to 'disabled' to stop the creation of a
++        cs0_spidev              Set to 'off' to stop the creation of a
++                                userspace device node /dev/spidev2.0 (default
++                                is 'on' or enabled).
++        cs1_spidev              Set to 'off' to stop the creation of a
++                                userspace device node /dev/spidev2.1 (default
++                                is 'on' or enabled).
++
++
++Name:   spi2-2cs-pi5
++Info:   Enables spi2 on GPIOs 1-3 with two chip select (CS) lines and
++        associated spidev dev nodes. The gpio pin numbers for the CS lines and
++        spidev device node creation are configurable. Pi 5 only.
++Load:   dtoverlay=spi2-2cs-pi5,<param>=<val>
++Params: cs0_pin                 GPIO pin for CS0 (default 0).
++        cs1_pin                 GPIO pin for CS1 (default 24).
++        cs0_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev2.0 (default
+-                                is 'okay' or enabled).
+-        cs1_spidev              Set to 'disabled' to stop the creation of a
++                                is 'on' or enabled).
++        cs1_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev2.1 (default
+-                                is 'okay' or enabled).
++                                is 'on' or enabled).
+ 
+ 
+ Name:   spi2-3cs
+-Info:   Enables spi2 with three chip select (CS) lines and associated spidev
+-        dev nodes. The gpio pin numbers for the CS lines and spidev device node
+-        creation are configurable.
+-        N.B.: spi2 is only accessible with the Compute Module.
++Info:   Enables spi2 on GPIOs 40-42 with three chip select (CS) lines and
++        associated spidev dev nodes. The gpio pin numbers for the CS lines and
++        spidev device node creation are configurable.
++        N.B.: spi2 is only accessible with the Compute Module or Pi 5.
+ Load:   dtoverlay=spi2-3cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 43 - BCM SPI2_CE0).
+         cs1_pin                 GPIO pin for CS1 (default 44 - BCM SPI2_CE1).
+         cs2_pin                 GPIO pin for CS2 (default 45 - BCM SPI2_CE2).
+-        cs0_spidev              Set to 'disabled' to stop the creation of a
++        cs0_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev2.0 (default
+-                                is 'okay' or enabled).
+-        cs1_spidev              Set to 'disabled' to stop the creation of a
++                                is 'on' or enabled).
++        cs1_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev2.1 (default
+-                                is 'okay' or enabled).
+-        cs2_spidev              Set to 'disabled' to stop the creation of a
++                                is 'on' or enabled).
++        cs2_spidev              Set to 'off' to stop the creation of a
+                                 userspace device node /dev/spidev2.2 (default
+-                                is 'okay' or enabled).
++                                is 'on' or enabled).
+ 
+ 
+ Name:   spi3-1cs
+-Info:   Enables spi3 with a single chip select (CS) line and associated spidev
+-        dev node. The gpio pin number for the CS line and spidev device node
+-        creation are configurable. BCM2711 only.
++Info:   Enables spi3 on GPIOs 1-3 with a single chip select (CS) line and
++        associated spidev dev node. The gpio pin number for the CS line and
++        spidev device node creation are configurable. BCM2711 only,
++        spi3-1cs-pi5 is substituted on Pi 5.
+ Load:   dtoverlay=spi3-1cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 0 - BCM SPI3_CE0).
+         cs0_spidev              Set to 'off' to prevent the creation of a
+@@ -4027,10 +4157,22 @@ Params: cs0_pin                 GPIO pin
+                                 is 'on' or enabled).
+ 
+ 
++Name:   spi3-1cs-pi5
++Info:   Enables spi3 on GPIOs 5-7 with a single chip select (CS) line and
++        associated spidev dev node. The gpio pin number for the CS line and
++        spidev device node creation are configurable. Pi 5 only.
++Load:   dtoverlay=spi3-1cs-pi5,<param>=<val>
++Params: cs0_pin                 GPIO pin for CS0 (default 4).
++        cs0_spidev              Set to 'off' to prevent the creation of a
++                                userspace device node /dev/spidev3.0 (default
++                                is 'on' or enabled).
++
++
+ Name:   spi3-2cs
+-Info:   Enables spi3 with two chip select (CS) lines and associated spidev
+-        dev nodes. The gpio pin numbers for the CS lines and spidev device node
+-        creation are configurable. BCM2711 only.
++Info:   Enables spi3 on GPIO2 1-3 with two chip select (CS) lines and
++        associated spidev dev nodes. The gpio pin numbers for the CS lines and
++        spidev device node creation are configurable. BCM2711 only,
++        spi3-2cs-pi5 is substituted on Pi 5.
+ Load:   dtoverlay=spi3-2cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 0 - BCM SPI3_CE0).
+         cs1_pin                 GPIO pin for CS1 (default 24 - BCM SPI3_CE1).
+@@ -4042,10 +4184,25 @@ Params: cs0_pin                 GPIO pin
+                                 is 'on' or enabled).
+ 
+ 
++Name:   spi3-2cs-pi5
++Info:   Enables spi3 on GPIOs 5-7 with two chip select (CS) lines and
++        associated spidev dev nodes. The gpio pin numbers for the CS lines and
++        spidev device node creation are configurable. Pi 5 only.
++Load:   dtoverlay=spi3-2cs-pi5,<param>=<val>
++Params: cs0_pin                 GPIO pin for CS0 (default 4).
++        cs1_pin                 GPIO pin for CS1 (default 25).
++        cs0_spidev              Set to 'off' to prevent the creation of a
++                                userspace device node /dev/spidev3.0 (default
++                                is 'on' or enabled).
++        cs1_spidev              Set to 'off' to prevent the creation of a
++                                userspace device node /dev/spidev3.1 (default
++                                is 'on' or enabled).
++
++
+ Name:   spi4-1cs
+-Info:   Enables spi4 with a single chip select (CS) line and associated spidev
+-        dev node. The gpio pin number for the CS line and spidev device node
+-        creation are configurable. BCM2711 only.
++Info:   Enables spi4 on GPIOs 5-7 with a single chip select (CS) line and
++        associated spidev dev node. The gpio pin number for the CS line and
++        spidev device node creation are configurable. BCM2711 only.
+ Load:   dtoverlay=spi4-1cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 4 - BCM SPI4_CE0).
+         cs0_spidev              Set to 'off' to prevent the creation of a
+@@ -4054,9 +4211,9 @@ Params: cs0_pin                 GPIO pin
+ 
+ 
+ Name:   spi4-2cs
+-Info:   Enables spi4 with two chip select (CS) lines and associated spidev
+-        dev nodes. The gpio pin numbers for the CS lines and spidev device node
+-        creation are configurable. BCM2711 only.
++Info:   Enables spi4 on GPIOs 5-6 with two chip select (CS) lines and
++        associated spidev dev nodes. The gpio pin numbers for the CS lines and
++        spidev device node creation are configurable. BCM2711 only.
+ Load:   dtoverlay=spi4-2cs,<param>=<val>
+ Params: cs0_pin                 GPIO pin for CS0 (default 4 - BCM SPI4_CE0).
+         cs1_pin                 GPIO pin for CS1 (default 25 - BCM SPI4_CE1).
+@@ -4069,23 +4226,27 @@ Params: cs0_pin                 GPIO pin
+ 
+ 
+ Name:   spi5-1cs
+-Info:   Enables spi5 with a single chip select (CS) line and associated spidev
+-        dev node. The gpio pin numbers for the CS lines and spidev device node
+-        creation are configurable. BCM2711 only.
++Info:   Enables spi5 on GPIOs 13-15 with a single chip select (CS) line and
++        associated spidev dev node. The gpio pin numbers for the CS lines and
++        spidev device node creation are configurable. BCM2711 and Pi 5.
+ Load:   dtoverlay=spi5-1cs,<param>=<val>
+-Params: cs0_pin                 GPIO pin for CS0 (default 12 - BCM SPI5_CE0).
++Params: cs0_pin                 GPIO pin for CS0 (default 12).
+         cs0_spidev              Set to 'off' to prevent the creation of a
+                                 userspace device node /dev/spidev5.0 (default
+                                 is 'on' or enabled).
+ 
+ 
++Name:   spi5-1cs-pi5
++Info:   See spi5-1cs
++
++
+ Name:   spi5-2cs
+-Info:   Enables spi5 with two chip select (CS) lines and associated spidev
+-        dev nodes. The gpio pin numbers for the CS lines and spidev device node
+-        creation are configurable. BCM2711 only.
++Info:   Enables spi5 on GPIOs 13-15 with two chip select (CS) lines and
++        associated spidev dev nodes. The gpio pin numbers for the CS lines and
++        spidev device node creation are configurable. BCM2711 and Pi 5.
+ Load:   dtoverlay=spi5-2cs,<param>=<val>
+-Params: cs0_pin                 GPIO pin for CS0 (default 12 - BCM SPI5_CE0).
+-        cs1_pin                 GPIO pin for CS1 (default 26 - BCM SPI5_CE1).
++Params: cs0_pin                 GPIO pin for CS0 (default 12).
++        cs1_pin                 GPIO pin for CS1 (default 26).
+         cs0_spidev              Set to 'off' to prevent the creation of a
+                                 userspace device node /dev/spidev5.0 (default
+                                 is 'on' or enabled).
+@@ -4094,6 +4255,10 @@ Params: cs0_pin                 GPIO pin
+                                 is 'on' or enabled).
+ 
+ 
++Name:   spi5-2cs-pi5
++Info:   See spi5-2cs
++
++
+ Name:   spi6-1cs
+ Info:   Enables spi6 with a single chip select (CS) line and associated spidev
+         dev node. The gpio pin number for the CS line and spidev device node
+@@ -4296,6 +4461,12 @@ Params: txd0_pin                GPIO pin
+                                 7(Alt3) for 32&33, 6(Alt2) for 36&37
+ 
+ 
++Name:   uart0-pi5
++Info:   Enable uart 0 on GPIOs 14-15. Pi 5 only.
++Load:   dtoverlay=uart0-pi5,<param>
++Params: ctsrts                  Enable CTS/RTS on GPIOs 16-17 (default off)
++
++
+ Name:   uart1
+ Info:   Change the pin usage of uart1
+ Load:   dtoverlay=uart1,<param>=<val>
+@@ -4304,24 +4475,48 @@ Params: txd1_pin                GPIO pin
+         rxd1_pin                GPIO pin for RXD1 (15, 33 or 41 - default 15)
+ 
+ 
++Name:   uart1-pi5
++Info:   Enable uart 1 on GPIOs 0-1. Pi 5 only.
++Load:   dtoverlay=uart1-pi5,<param>
++Params: ctsrts                  Enable CTS/RTS on GPIOs 2-3 (default off)
++
++
+ Name:   uart2
+ Info:   Enable uart 2 on GPIOs 0-3. BCM2711 only.
+ Load:   dtoverlay=uart2,<param>
+ Params: ctsrts                  Enable CTS/RTS on GPIOs 2-3 (default off)
+ 
+ 
++Name:   uart2-pi5
++Info:   Enable uart 2 on GPIOs 4-5. Pi 5 only.
++Load:   dtoverlay=uart2-pi5,<param>
++Params: ctsrts                  Enable CTS/RTS on GPIOs 6-7 (default off)
++
++
+ Name:   uart3
+ Info:   Enable uart 3 on GPIOs 4-7. BCM2711 only.
+ Load:   dtoverlay=uart3,<param>
+ Params: ctsrts                  Enable CTS/RTS on GPIOs 6-7 (default off)
+ 
+ 
++Name:   uart3-pi5
++Info:   Enable uart 3 on GPIOs 8-9. Pi 5 only.
++Load:   dtoverlay=uart3-pi5,<param>
++Params: ctsrts                  Enable CTS/RTS on GPIOs 10-11 (default off)
++
++
+ Name:   uart4
+ Info:   Enable uart 4 on GPIOs 8-11. BCM2711 only.
+ Load:   dtoverlay=uart4,<param>
+ Params: ctsrts                  Enable CTS/RTS on GPIOs 10-11 (default off)
+ 
+ 
++Name:   uart4-pi5
++Info:   Enable uart 4 on GPIOs 12-13. Pi 5 only.
++Load:   dtoverlay=uart4-pi5,<param>
++Params: ctsrts                  Enable CTS/RTS on GPIOs 14-15 (default off)
++
++
+ Name:   uart5
+ Info:   Enable uart 5 on GPIOs 12-15. BCM2711 only.
+ Load:   dtoverlay=uart5,<param>
+@@ -4530,6 +4725,8 @@ Params: sizex                   Touchscr
+         invy                    Touchscreen inverted y axis
+         swapxy                  Touchscreen swapped x y axis
+         disable_touch           Disables the touch screen overlay driver
++        dsi0                    Use DSI0 and i2c_csi_dsi0 (rather than
++                                the default DSI1 and i2c_csi_dsi).
+ 
+ 
+ Name:   vc4-kms-dsi-lt070me05000
+@@ -4579,6 +4776,8 @@ Params: 2_8_inch                2.8" 480
+         invx                    Touchscreen inverted x axis
+         invy                    Touchscreen inverted y axis
+         swapxy                  Touchscreen swapped x y axis
++        dsi0                    Use DSI0 and i2c_csi_dsi0 (rather than
++                                the default DSI1 and i2c_csi_dsi).
+ 
+ 
+ Name:   vc4-kms-kippah-7inch
+@@ -4633,6 +4832,9 @@ Params: cma-512                 CMA is 5
+         nohdmi1                 Disable HDMI 1 output
+ 
+ 
++Name:   vc4-kms-v3d-pi5
++Info:   See vc4-kms-v3d-pi4 (this is the Pi 5 version)
++
+ 
+ Name:   vc4-kms-vga666
+ Info:   Enable the VGA666 (resistor ladder ADC) for the vc4-kms-v3d driver.
+--- a/arch/arm/boot/dts/overlays/adau1977-adc-overlay.dts
++++ b/arch/arm/boot/dts/overlays/adau1977-adc-overlay.dts
+@@ -23,7 +23,7 @@
+ 	};
+ 
+ 	fragment@1 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -33,7 +33,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "adi,adau1977-adc";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/adau7002-simple-overlay.dts
++++ b/arch/arm/boot/dts/overlays/adau7002-simple-overlay.dts
+@@ -5,7 +5,7 @@
+     compatible = "brcm,bcm2835";
+ 
+     fragment@0 {
+-        target = <&i2s>;
++        target = <&i2s_clk_producer>;
+         __overlay__ {
+             status = "okay";
+         };
+@@ -37,7 +37,7 @@
+                     "PDM_DAT", "Microphone Jack";
+             status = "okay";
+             simple-audio-card,cpu {
+-                sound-dai = <&i2s>;
++                sound-dai = <&i2s_clk_producer>;
+             };
+             dailink0_slave: simple-audio-card,codec {
+                 sound-dai = <&adau7002_codec>;
+--- a/arch/arm/boot/dts/overlays/akkordion-iqdacplus-overlay.dts
++++ b/arch/arm/boot/dts/overlays/akkordion-iqdacplus-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -38,7 +38,7 @@
+ 			card_name = "Akkordion";
+ 			dai_name = "IQaudIO DAC";
+ 			dai_stream_name = "IQaudIO DAC HiFi";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/allo-boss-dac-pcm512x-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/allo-boss-dac-pcm512x-audio-overlay.dts
+@@ -18,8 +18,8 @@
+ 		};
+ 	};
+ 
+-	fragment@1 {
+-		target = <&i2s>;
++	frag1: fragment@1 {
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -46,7 +46,7 @@
+ 		target = <&sound>;
+ 		boss_dac: __overlay__ {
+ 			compatible = "allo,boss-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			mute-gpios = <&gpio 6 1>;
+ 			status = "okay";
+ 		};
+@@ -54,6 +54,8 @@
+ 
+ 	__overrides__ {
+ 		24db_digital_gain = <&boss_dac>,"allo,24db_digital_gain?";
+-		slave = <&boss_dac>,"allo,slave?";
++		slave = <&boss_dac>,"allo,slave?",
++			<&frag1>,"target:0=",<&i2s_clk_producer>,
++			<&boss_dac>,"i2s-controller:0=",<&i2s_clk_producer>;
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/allo-boss2-dac-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/allo-boss2-dac-audio-overlay.dts
+@@ -8,7 +8,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			#sound-dai-cells = <0>;
+ 			status = "okay";
+--- a/arch/arm/boot/dts/overlays/allo-digione-overlay.dts
++++ b/arch/arm/boot/dts/overlays/allo-digione-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -35,7 +35,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "allo,allo-digione";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 			clock44-gpio = <&gpio 5 0>;
+ 			clock48-gpio = <&gpio 6 0>;
+--- a/arch/arm/boot/dts/overlays/allo-katana-dac-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/allo-katana-dac-audio-overlay.dts
+@@ -9,7 +9,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			#sound-dai-cells = <0>;
+ 			status = "okay";
+--- a/arch/arm/boot/dts/overlays/allo-piano-dac-pcm512x-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/allo-piano-dac-pcm512x-audio-overlay.dts
+@@ -16,7 +16,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -42,7 +42,7 @@
+ 		target = <&sound>;
+ 		piano_dac: __overlay__ {
+ 			compatible = "allo,piano-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/allo-piano-dac-plus-pcm512x-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/allo-piano-dac-plus-pcm512x-audio-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -41,7 +41,7 @@
+ 		piano_dac: __overlay__ {
+ 			compatible = "allo,piano-dac-plus";
+ 			audio-codec = <&allo_pcm5122_4c &allo_pcm5122_4d>;
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			mute1-gpios = <&gpio 6 1>;
+ 			mute2-gpios = <&gpio 25 1>;
+ 			status = "okay";
+--- a/arch/arm/boot/dts/overlays/applepi-dac-overlay.dts
++++ b/arch/arm/boot/dts/overlays/applepi-dac-overlay.dts
+@@ -16,7 +16,7 @@
+                 format = "i2s";
+ 
+                 p_cpu_dai: cpu {
+-                    sound-dai = <&i2s>;
++                    sound-dai = <&i2s_clk_producer>;
+                     dai-tdm-slot-num = <2>;
+                     dai-tdm-slot-width = <32>;
+                 };
+@@ -40,7 +40,7 @@
+     };
+ 
+     fragment@2 {
+-        target = <&i2s>;
++        target = <&i2s_clk_producer>;
+         __overlay__ {
+             #sound-dai-cells = <0>;
+             status = "okay";
+--- a/arch/arm/boot/dts/overlays/arducam-64mp-overlay.dts
++++ b/arch/arm/boot/dts/overlays/arducam-64mp-overlay.dts
+@@ -67,7 +67,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/arducam-pivariety-overlay.dts
++++ b/arch/arm/boot/dts/overlays/arducam-pivariety-overlay.dts
+@@ -85,7 +85,7 @@
+ 		rotation = <&arducam_pivariety>,"rotation:0";
+ 		orientation = <&arducam_pivariety>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&arducam_pivariety>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/audioinjector-addons-overlay.dts
++++ b/arch/arm/boot/dts/overlays/audioinjector-addons-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -48,7 +48,7 @@
+ 			mult-gpios = <&gpio 27 0>, <&gpio 22 0>, <&gpio 23 0>,
+ 				     <&gpio 24 0>;
+ 			reset-gpios = <&gpio 5 0>;
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			codec = <&cs42448>;
+ 			status = "okay";
+ 		};
+--- a/arch/arm/boot/dts/overlays/audioinjector-bare-i2s-overlay.dts
++++ b/arch/arm/boot/dts/overlays/audioinjector-bare-i2s-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -27,7 +27,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "simple-audio-card";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 
+ 			simple-audio-card,name = "audioinjector-bare";
+@@ -37,7 +37,7 @@
+ 			simple-audio-card,frame-master = <&dailink0_master>;
+ 
+ 			dailink0_master: simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_producer>;
+ 				dai-tdm-slot-num = <2>;
+ 				dai-tdm-slot-width = <32>;
+ 			};
+--- a/arch/arm/boot/dts/overlays/audioinjector-isolated-soundcard-overlay.dts
++++ b/arch/arm/boot/dts/overlays/audioinjector-isolated-soundcard-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -47,7 +47,7 @@
+ 		snd: __overlay__ {
+ 			compatible = "ai,audioinjector-isolated-soundcard";
+ 			mute-gpios = <&gpio 17 0>;
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			codec = <&cs4272>;
+ 			status = "okay";
+ 		};
+--- a/arch/arm/boot/dts/overlays/audioinjector-ultra-overlay.dts
++++ b/arch/arm/boot/dts/overlays/audioinjector-ultra-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -33,7 +33,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "simple-audio-card";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 
+ 			simple-audio-card,name = "audioinjector-ultra";
+@@ -57,7 +57,7 @@
+ 			simple-audio-card,frame-master = <&sound_master>;
+ 
+ 			simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_consumer>;
+ 				dai-tdm-slot-num = <2>;
+ 				dai-tdm-slot-width = <32>;
+ 			};
+--- a/arch/arm/boot/dts/overlays/audioinjector-wm8731-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/audioinjector-wm8731-audio-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -32,7 +32,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "ai,audioinjector-pi-soundcard";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/audiosense-pi-overlay.dts
++++ b/arch/arm/boot/dts/overlays/audiosense-pi-overlay.dts
+@@ -8,7 +8,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -75,7 +75,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "as,audiosense-pi";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/chipdip-dac-overlay.dts
++++ b/arch/arm/boot/dts/overlays/chipdip-dac-overlay.dts
+@@ -9,7 +9,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -32,7 +32,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "chipdip,chipdip-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			sr0-gpios = <&gpio 5 0>;
+ 			sr1-gpios = <&gpio 6 0>;
+ 			sr2-gpios = <&gpio 12 0>;
+--- a/arch/arm/boot/dts/overlays/cirrus-wm5102-overlay.dts
++++ b/arch/arm/boot/dts/overlays/cirrus-wm5102-overlay.dts
+@@ -9,7 +9,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -165,7 +165,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "wlf,rpi-cirrus";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/dacberry400-overlay.dts
++++ b/arch/arm/boot/dts/overlays/dacberry400-overlay.dts
+@@ -5,7 +5,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -62,7 +62,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "osaelectronics,dacberry400";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/dionaudio-kiwi-overlay.dts
++++ b/arch/arm/boot/dts/overlays/dionaudio-kiwi-overlay.dts
+@@ -11,7 +11,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -32,7 +32,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "dionaudio,dionaudio-kiwi";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/dionaudio-loco-overlay.dts
++++ b/arch/arm/boot/dts/overlays/dionaudio-loco-overlay.dts
+@@ -11,7 +11,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -32,7 +32,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "dionaudio,loco-pcm5242-tpa3118";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/dionaudio-loco-v2-overlay.dts
++++ b/arch/arm/boot/dts/overlays/dionaudio-loco-v2-overlay.dts
+@@ -15,13 +15,13 @@
+ 		target = <&sound>;
+ 		frag0: __overlay__ {
+ 			compatible = "dionaudio,dionaudio-loco-v2";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+ 
+ 	fragment@1 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/disable-bt-pi5-overlay.dts
+@@ -0,0 +1,17 @@
++/dts-v1/;
++/plugin/;
++
++/* Disable Bluetooth */
++
++#include <dt-bindings/gpio/gpio.h>
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&bluetooth>;
++		__overlay__ {
++			status = "disabled";
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/disable-wifi-pi5-overlay.dts
+@@ -0,0 +1,13 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&sdio2>;
++		__overlay__ {
++			status = "disabled";
++		};
++	};
++};
+--- a/arch/arm/boot/dts/overlays/draws-overlay.dts
++++ b/arch/arm/boot/dts/overlays/draws-overlay.dts
+@@ -9,7 +9,7 @@
+ / {
+     compatible = "brcm,bcm2835";
+     fragment@0 {
+-        target = <&i2s>;
++        target = <&i2s_clk_producer>;
+         __overlay__ {
+             status = "okay";
+         };
+@@ -131,7 +131,7 @@
+         target = <&sound>;
+         snd: __overlay__ {
+             compatible = "simple-audio-card";
+-            i2s-controller = <&i2s>;
++            i2s-controller = <&i2s_clk_producer>;
+             status = "okay";
+ 
+             simple-audio-card,name = "draws";
+@@ -153,7 +153,7 @@
+                 "Line Out", "LOL";
+ 
+             dailink0_master: simple-audio-card,cpu {
+-                sound-dai = <&i2s>;
++                sound-dai = <&i2s_clk_producer>;
+             };
+ 
+             simple-audio-card,codec {
+--- a/arch/arm/boot/dts/overlays/edt-ft5406-overlay.dts
++++ b/arch/arm/boot/dts/overlays/edt-ft5406-overlay.dts
+@@ -25,21 +25,21 @@
+ 	};
+ 
+ 	__overrides__ {
+-		i2c0 = <&frag13>,"target:0=",<&i2c0>;
+-		i2c1 = <&frag13>, "target?=0",
+-		       <&frag13>, "target-path=i2c1",
++		i2c0 = <&ts_i2c_frag>,"target:0=",<&i2c0>;
++		i2c1 = <&ts_i2c_frag>, "target?=0",
++		       <&ts_i2c_frag>, "target-path=i2c1",
+ 		       <0>,"-0-1";
+-		i2c3 = <&frag13>, "target?=0",
+-		       <&frag13>, "target-path=i2c3",
++		i2c3 = <&ts_i2c_frag>, "target?=0",
++		       <&ts_i2c_frag>, "target-path=i2c3",
+ 		       <0>,"-0-1";
+-		i2c4 = <&frag13>, "target?=0",
+-		       <&frag13>, "target-path=i2c4",
++		i2c4 = <&ts_i2c_frag>, "target?=0",
++		       <&ts_i2c_frag>, "target-path=i2c4",
+ 		       <0>,"-0-1";
+-		i2c5 = <&frag13>, "target?=0",
+-		       <&frag13>, "target-path=i2c5",
++		i2c5 = <&ts_i2c_frag>, "target?=0",
++		       <&ts_i2c_frag>, "target-path=i2c5",
+ 		       <0>,"-0-1";
+-		i2c6 = <&frag13>, "target?=0",
+-		       <&frag13>, "target-path=i2c6",
++		i2c6 = <&ts_i2c_frag>, "target?=0",
++		       <&ts_i2c_frag>, "target-path=i2c6",
+ 		       <0>,"-0-1";
+ 		addr = <&ft5406>,"reg:0";
+ 	};
+--- a/arch/arm/boot/dts/overlays/edt-ft5406.dtsi
++++ b/arch/arm/boot/dts/overlays/edt-ft5406.dtsi
+@@ -37,7 +37,7 @@
+ 		};
+ 	};
+ 
+-	frag13: fragment@13 {
++	ts_i2c_frag: fragment@13 {
+ 		target = <&i2c_csi_dsi>;
+ 		i2cbus: __overlay__ {
+ 			status = "okay";
+--- a/arch/arm/boot/dts/overlays/fe-pi-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/fe-pi-audio-overlay.dts
+@@ -53,7 +53,7 @@
+ 	};
+ 
+ 	fragment@3 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -63,7 +63,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "fe-pi,fe-pi-audio";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/ghost-amp-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ghost-amp-overlay.dts
+@@ -14,7 +14,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -43,7 +43,7 @@
+ 		target = <&sound>;
+ 		iqaudio_dac: __overlay__ {
+ 			compatible = "iqaudio,iqaudio-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			mute-gpios = <&amp 0 0>;
+ 			iqaudio-dac,auto-mute-amp;
+ 			status = "okay";
+--- a/arch/arm/boot/dts/overlays/googlevoicehat-soundcard-overlay.dts
++++ b/arch/arm/boot/dts/overlays/googlevoicehat-soundcard-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -42,7 +42,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "googlevoicehat,googlevoicehat-soundcard";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/hifiberry-amp-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-amp-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -32,7 +32,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "hifiberry,hifiberry-amp";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/hifiberry-amp100-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-amp100-overlay.dts
+@@ -15,8 +15,8 @@
+ 		};
+ 	};
+ 
+-	fragment@1 {
+-		target = <&i2s>;
++	frag1: fragment@1 {
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -46,7 +46,7 @@
+ 		target = <&sound>;
+ 		hifiberry_dacplus: __overlay__ {
+ 			compatible = "hifiberry,hifiberry-dacplus";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 			mute-gpio = <&gpio 4 0>;
+ 			reset-gpio = <&gpio 17 0x11>;
+@@ -56,7 +56,10 @@
+ 	__overrides__ {
+ 		24db_digital_gain =
+ 			<&hifiberry_dacplus>,"hifiberry,24db_digital_gain?";
+-		slave = <&hifiberry_dacplus>,"hifiberry-dacplus,slave?";
++		slave = <&hifiberry_dacplus>,"hifiberry-dacplus,slave?",
++			<&frag1>,"target:0=",<&i2s_clk_producer>,
++			<&hifiberry_dacplus>,"i2s-controller:0=",<&i2s_clk_producer>;
++
+ 		leds_off = <&hifiberry_dacplus>,"hifiberry-dacplus,leds_off?";
+ 		mute_ext_ctl = <&hifiberry_dacplus>,"hifiberry-dacplus,mute_ext_ctl:0";
+ 		auto_mute = <&hifiberry_dacplus>,"hifiberry-dacplus,auto_mute?";
+--- a/arch/arm/boot/dts/overlays/hifiberry-amp3-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-amp3-overlay.dts
+@@ -10,7 +10,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -50,7 +50,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "hifiberry,hifiberry-amp3";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/hifiberry-dac-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-dac-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -27,7 +27,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "hifiberry,hifiberry-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/hifiberry-dacplus-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-dacplus-overlay.dts
+@@ -15,8 +15,8 @@
+ 		};
+ 	};
+ 
+-	fragment@1 {
+-		target = <&i2s>;
++	frag1: fragment@1 {
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -51,7 +51,7 @@
+ 		target = <&sound>;
+ 		hifiberry_dacplus: __overlay__ {
+ 			compatible = "hifiberry,hifiberry-dacplus";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+@@ -59,7 +59,10 @@
+ 	__overrides__ {
+ 		24db_digital_gain =
+ 			<&hifiberry_dacplus>,"hifiberry,24db_digital_gain?";
+-		slave = <&hifiberry_dacplus>,"hifiberry-dacplus,slave?";
++		slave = <&hifiberry_dacplus>,"hifiberry-dacplus,slave?",
++			<&frag1>,"target:0=",<&i2s_clk_producer>,
++			<&hifiberry_dacplus>,"i2s-controller:0=",<&i2s_clk_producer>;
++
+ 		leds_off = <&hifiberry_dacplus>,"hifiberry-dacplus,leds_off?";
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/hifiberry-dacplusadc-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-dacplusadc-overlay.dts
+@@ -15,8 +15,8 @@
+ 		};
+ 	};
+ 
+-	fragment@1 {
+-		target = <&i2s>;
++	frag1: fragment@1 {
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -58,7 +58,7 @@
+ 		target = <&sound>;
+ 		hifiberry_dacplusadc: __overlay__ {
+ 			compatible = "hifiberry,hifiberry-dacplusadc";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+@@ -66,7 +66,9 @@
+ 	__overrides__ {
+ 		24db_digital_gain =
+ 			<&hifiberry_dacplusadc>,"hifiberry,24db_digital_gain?";
+-		slave = <&hifiberry_dacplusadc>,"hifiberry-dacplusadc,slave?";
++		slave = <&hifiberry_dacplusadc>,"hifiberry-dacplusadc,slave?",
++			<&frag1>,"target:0=",<&i2s_clk_producer>,
++			<&hifiberry_dacplusadc>,"i2s-controller:0=",<&i2s_clk_producer>;
+ 		leds_off = <&hifiberry_dacplusadc>,"hifiberry-dacplusadc,leds_off?";
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/hifiberry-dacplusadcpro-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-dacplusadcpro-overlay.dts
+@@ -15,8 +15,8 @@
+ 		};
+ 	};
+ 
+-	fragment@1 {
+-		target = <&i2s>;
++	frag1: fragment@1 {
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -56,7 +56,7 @@
+ 		hifiberry_dacplusadcpro: __overlay__ {
+ 			compatible = "hifiberry,hifiberry-dacplusadcpro";
+ 			audio-codec = <&hb_dac &hb_adc>;
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+@@ -64,7 +64,9 @@
+ 	__overrides__ {
+ 		24db_digital_gain =
+ 			<&hifiberry_dacplusadcpro>,"hifiberry-dacplusadcpro,24db_digital_gain?";
+-		slave = <&hifiberry_dacplusadcpro>,"hifiberry-dacplusadcpro,slave?";
++		slave = <&hifiberry_dacplusadcpro>,"hifiberry-dacplusadcpro,slave?",
++			<&frag1>,"target:0=",<&i2s_clk_producer>,
++			<&hifiberry_dacplusadcpro>,"i2s-controller:0=",<&i2s_clk_producer>;
+ 		leds_off = <&hifiberry_dacplusadcpro>,"hifiberry-dacplusadcpro,leds_off?";
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/hifiberry-dacplusdsp-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-dacplusdsp-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -27,7 +27,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "hifiberrydacplusdsp,hifiberrydacplusdsp-soundcard";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/hifiberry-dacplushd-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-dacplushd-overlay.dts
+@@ -8,7 +8,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -84,7 +84,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "hifiberry,hifiberry-dacplushd";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			clocks = <&pll 0>;
+ 			reset-gpio = <&gpio 16 GPIO_ACTIVE_LOW>;
+ 			status = "okay";
+--- a/arch/arm/boot/dts/overlays/hifiberry-digi-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-digi-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -34,7 +34,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "hifiberry,hifiberry-digi";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/hifiberry-digi-pro-overlay.dts
++++ b/arch/arm/boot/dts/overlays/hifiberry-digi-pro-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -34,7 +34,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "hifiberry,hifiberry-digi";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 			clock44-gpio = <&gpio 5 0>;
+ 			clock48-gpio = <&gpio 6 0>;
+--- a/arch/arm/boot/dts/overlays/i-sabre-q2m-overlay.dts
++++ b/arch/arm/boot/dts/overlays/i-sabre-q2m-overlay.dts
+@@ -9,13 +9,13 @@
+ 		target = <&sound>;
+ 		frag0: __overlay__ {
+ 			compatible = "audiophonics,i-sabre-q2m";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+ 
+ 	fragment@1 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/i2c0-pi5-overlay.dts
+@@ -0,0 +1,34 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&i2c0>;
++		frag0: __overlay__ {
++			status = "okay";
++			clock-frequency = <100000>;
++		};
++	};
++
++	fragment@1 {
++		target = <&frag0>;
++		__overlay__ {
++			pinctrl-0 = <&rp1_i2c0_0_1>;
++		};
++	};
++
++	fragment@2 {
++		target = <&frag0>;
++		__dormant__ {
++			pinctrl-0 = <&rp1_i2c0_8_9>;
++		};
++	};
++
++	__overrides__ {
++		pins_0_1 = <0>,"+1-2";
++		pins_8_9 = <0>,"-1+2";
++		baudrate = <&frag0>, "clock-frequency:0";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/i2c1-pi5-overlay.dts
+@@ -0,0 +1,34 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&i2c1>;
++		frag0: __overlay__ {
++			status = "okay";
++			clock-frequency = <100000>;
++		};
++	};
++
++	fragment@1 {
++		target = <&frag0>;
++		__overlay__ {
++			pinctrl-0 = <&rp1_i2c1_2_3>;
++		};
++	};
++
++	fragment@2 {
++		target = <&frag0>;
++		__dormant__ {
++			pinctrl-0 = <&rp1_i2c1_10_11>;
++		};
++	};
++
++	__overrides__ {
++		pins_2_3 = <0>,"+1-2";
++		pins_10_11 = <0>,"-1+2";
++		baudrate = <&frag0>, "clock-frequency:0";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/i2c2-pi5-overlay.dts
+@@ -0,0 +1,21 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&i2c2>;
++		frag0: __overlay__ {
++			status = "okay";
++			clock-frequency = <100000>;
++			pinctrl-0 = <&rp1_i2c2_4_5>;
++		};
++	};
++
++	__overrides__ {
++		pins_4_5 = <&frag0>,"pinctrl-0:0=", <&rp1_i2c2_4_5>;
++		pins_12_13 = <&frag0>,"pinctrl-0:0=", <&rp1_i2c2_12_13>;
++		baudrate = <&frag0>, "clock-frequency:0";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/i2c3-pi5-overlay.dts
+@@ -0,0 +1,22 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&i2c3>;
++		frag0: __overlay__ {
++			status = "okay";
++			clock-frequency = <100000>;
++			pinctrl-0 = <&rp1_i2c3_6_7>;
++		};
++	};
++
++	__overrides__ {
++		pins_6_7 = <&frag0>,"pinctrl-0:0=", <&rp1_i2c3_6_7>;
++		pins_14_15 = <&frag0>,"pinctrl-0:0=", <&rp1_i2c3_14_15>;
++		pins_22_23 = <&frag0>,"pinctrl-0:0=", <&rp1_i2c3_22_23>;
++		baudrate = <&frag0>, "clock-frequency:0";
++	};
++};
+--- a/arch/arm/boot/dts/overlays/i2s-dac-overlay.dts
++++ b/arch/arm/boot/dts/overlays/i2s-dac-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -27,7 +27,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "rpi,rpi-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/imx219-overlay.dts
++++ b/arch/arm/boot/dts/overlays/imx219-overlay.dts
+@@ -69,7 +69,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/imx258-overlay.dts
++++ b/arch/arm/boot/dts/overlays/imx258-overlay.dts
+@@ -110,7 +110,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&reg_frag>, "target:0=",<&cam0_reg>,
+--- a/arch/arm/boot/dts/overlays/imx290_327-overlay.dtsi
++++ b/arch/arm/boot/dts/overlays/imx290_327-overlay.dtsi
+@@ -95,7 +95,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/imx296-overlay.dts
++++ b/arch/arm/boot/dts/overlays/imx296-overlay.dts
+@@ -94,7 +94,7 @@
+ 		rotation = <&imx296>,"rotation:0";
+ 		orientation = <&imx296>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&imx296>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/imx477_378-overlay.dtsi
++++ b/arch/arm/boot/dts/overlays/imx477_378-overlay.dtsi
+@@ -65,7 +65,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&reg_frag>, "target:0=",<&cam0_reg>,
+--- a/arch/arm/boot/dts/overlays/imx519-overlay.dts
++++ b/arch/arm/boot/dts/overlays/imx519-overlay.dts
+@@ -69,7 +69,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/imx708-overlay.dts
++++ b/arch/arm/boot/dts/overlays/imx708-overlay.dts
+@@ -79,12 +79,12 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&reg_frag>, "target:0=",<&cam0_reg>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+-		       <&cam_node>, "VANA1-supply:0=",<&cam0_reg>,
++		       <&cam_node>, "vana1-supply:0=",<&cam0_reg>,
+ 		       <&vcm_node>, "VDD-supply:0=",<&cam0_reg>;
+ 		vcm = <&vcm_node>, "status",
+ 		      <0>, "=4";
+--- a/arch/arm/boot/dts/overlays/iqaudio-codec-overlay.dts
++++ b/arch/arm/boot/dts/overlays/iqaudio-codec-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -32,7 +32,7 @@
+ 		target = <&sound>;
+ 		iqaudio_dac: __overlay__ {
+ 			compatible = "iqaudio,iqaudio-codec";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/iqaudio-dac-overlay.dts
++++ b/arch/arm/boot/dts/overlays/iqaudio-dac-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -35,7 +35,7 @@
+ 		target = <&sound>;
+ 		frag2: __overlay__ {
+ 			compatible = "iqaudio,iqaudio-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/iqaudio-dacplus-overlay.dts
++++ b/arch/arm/boot/dts/overlays/iqaudio-dacplus-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -35,7 +35,7 @@
+ 		target = <&sound>;
+ 		iqaudio_dac: __overlay__ {
+ 			compatible = "iqaudio,iqaudio-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			mute-gpios = <&gpio 22 0>;
+ 			status = "okay";
+ 		};
+--- a/arch/arm/boot/dts/overlays/iqaudio-digi-wm8804-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/iqaudio-digi-wm8804-audio-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -34,7 +34,7 @@
+ 		target = <&sound>;
+ 		wm8804_digi: __overlay__ {
+ 			compatible = "iqaudio,wm8804-digi";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/irs1125-overlay.dts
++++ b/arch/arm/boot/dts/overlays/irs1125-overlay.dts
+@@ -82,7 +82,7 @@
+ 
+ 	__overrides__ {
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&irs1125>, "clocks:0=",<&cam0_clk>;
+--- a/arch/arm/boot/dts/overlays/justboom-both-overlay.dts
++++ b/arch/arm/boot/dts/overlays/justboom-both-overlay.dts
+@@ -7,7 +7,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -54,7 +54,7 @@
+ 		target = <&sound>;
+ 		frag3: __overlay__ {
+ 			compatible = "justboom,justboom-both";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/justboom-dac-overlay.dts
++++ b/arch/arm/boot/dts/overlays/justboom-dac-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -35,7 +35,7 @@
+ 		target = <&sound>;
+ 		frag2: __overlay__ {
+ 			compatible = "justboom,justboom-dac";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/justboom-digi-overlay.dts
++++ b/arch/arm/boot/dts/overlays/justboom-digi-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -34,7 +34,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "justboom,justboom-digi";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/max98357a-overlay.dts
++++ b/arch/arm/boot/dts/overlays/max98357a-overlay.dts
+@@ -12,7 +12,7 @@
+ 
+ 	/* Enable I2S */
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -52,7 +52,7 @@
+ 			simple-audio-card,name = "MAX98357A";
+ 			status = "okay";
+ 			simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_producer>;
+ 			};
+ 			simple-audio-card,codec {
+ 				sound-dai = <&max98357a_dac>;
+@@ -69,7 +69,7 @@
+ 			simple-audio-card,name = "MAX98357A";
+ 			status = "okay";
+ 			simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_producer>;
+ 			};
+ 			simple-audio-card,codec {
+ 				sound-dai = <&max98357a_nsd>;
+--- a/arch/arm/boot/dts/overlays/mbed-dac-overlay.dts
++++ b/arch/arm/boot/dts/overlays/mbed-dac-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -32,7 +32,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "simple-audio-card";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 
+ 			simple-audio-card,name = "mbed-DAC";
+@@ -52,7 +52,7 @@
+ 			simple-audio-card,format = "i2s";
+ 
+ 			simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_producer>;
+ 			};
+ 
+ 			sound_master: simple-audio-card,codec {
+--- a/arch/arm/boot/dts/overlays/merus-amp-overlay.dts
++++ b/arch/arm/boot/dts/overlays/merus-amp-overlay.dts
+@@ -9,7 +9,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -52,7 +52,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "merus,merus-amp";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/midi-uart0-pi5-overlay.dts
+@@ -0,0 +1,35 @@
++/dts-v1/;
++/plugin/;
++
++#include <dt-bindings/clock/rp1.h>
++
++/*
++ * Fake a higher clock rate to get a larger divisor, and thereby a lower
++ * baudrate. The real clock is 100MHz, which we scale so that requesting
++ * 38.4kHz results in an actual 31.25kHz.
++ *
++ *   100000000*38400/31250 = 122880000
++ */
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target-path = "/";
++		__overlay__ {
++			midi_clk: midi_clk0 {
++				compatible = "fixed-clock";
++				#clock-cells = <0>;
++				clock-output-names = "uart0_pclk";
++				clock-frequency = <122880000>;
++			};
++		};
++	};
++
++	fragment@1 {
++		target = <&uart0>;
++		__overlay__ {
++			clocks = <&midi_clk &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/midi-uart1-pi5-overlay.dts
+@@ -0,0 +1,35 @@
++/dts-v1/;
++/plugin/;
++
++#include <dt-bindings/clock/rp1.h>
++
++/*
++ * Fake a higher clock rate to get a larger divisor, and thereby a lower
++ * baudrate. The real clock is 100MHz, which we scale so that requesting
++ * 38.4kHz results in an actual 31.25kHz.
++ *
++ *   100000000*38400/31250 = 122880000
++ */
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target-path = "/";
++		__overlay__ {
++			midi_clk: midi_clk1 {
++				compatible = "fixed-clock";
++				#clock-cells = <0>;
++				clock-output-names = "uart1_pclk";
++				clock-frequency = <122880000>;
++			};
++		};
++	};
++
++	fragment@1 {
++		target = <&uart1>;
++		__overlay__ {
++			clocks = <&midi_clk &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/midi-uart2-pi5-overlay.dts
+@@ -0,0 +1,35 @@
++/dts-v1/;
++/plugin/;
++
++#include <dt-bindings/clock/rp1.h>
++
++/*
++ * Fake a higher clock rate to get a larger divisor, and thereby a lower
++ * baudrate. The real clock is 100MHz, which we scale so that requesting
++ * 38.4kHz results in an actual 31.25kHz.
++ *
++ *   100000000*38400/31250 = 122880000
++ */
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target-path = "/";
++		__overlay__ {
++			midi_clk: midi_clk2 {
++				compatible = "fixed-clock";
++				#clock-cells = <0>;
++				clock-output-names = "uart2_pclk";
++				clock-frequency = <122880000>;
++			};
++		};
++	};
++
++	fragment@1 {
++		target = <&uart2>;
++		__overlay__ {
++			clocks = <&midi_clk &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/midi-uart3-pi5-overlay.dts
+@@ -0,0 +1,35 @@
++/dts-v1/;
++/plugin/;
++
++#include <dt-bindings/clock/rp1.h>
++
++/*
++ * Fake a higher clock rate to get a larger divisor, and thereby a lower
++ * baudrate. The real clock is 100MHz, which we scale so that requesting
++ * 38.4kHz results in an actual 31.25kHz.
++ *
++ *   100000000*38400/31250 = 122880000
++ */
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target-path = "/";
++		__overlay__ {
++			midi_clk: midi_clk3 {
++				compatible = "fixed-clock";
++				#clock-cells = <0>;
++				clock-output-names = "uart3_pclk";
++				clock-frequency = <122880000>;
++			};
++		};
++	};
++
++	fragment@1 {
++		target = <&uart3>;
++		__overlay__ {
++			clocks = <&midi_clk &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/midi-uart4-pi5-overlay.dts
+@@ -0,0 +1,35 @@
++/dts-v1/;
++/plugin/;
++
++#include <dt-bindings/clock/rp1.h>
++
++/*
++ * Fake a higher clock rate to get a larger divisor, and thereby a lower
++ * baudrate. The real clock is 100MHz, which we scale so that requesting
++ * 38.4kHz results in an actual 31.25kHz.
++ *
++ *   100000000*38400/31250 = 122880000
++ */
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target-path = "/";
++		__overlay__ {
++			midi_clk: midi_clk4 {
++				compatible = "fixed-clock";
++				#clock-cells = <0>;
++				clock-output-names = "uart4_pclk";
++				clock-frequency = <122880000>;
++			};
++		};
++	};
++
++	fragment@1 {
++		target = <&uart4>;
++		__overlay__ {
++			clocks = <&midi_clk &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++		};
++	};
++};
+--- a/arch/arm/boot/dts/overlays/ov2311-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ov2311-overlay.dts
+@@ -60,7 +60,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/ov5647-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ov5647-overlay.dts
+@@ -72,7 +72,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&reg_frag>, "target:0=",<&cam0_reg>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/ov7251-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ov7251-overlay.dts
+@@ -60,7 +60,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/ov9281-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ov9281-overlay.dts
+@@ -61,7 +61,7 @@
+ 		rotation = <&cam_node>,"rotation:0";
+ 		orientation = <&cam_node>,"orientation:0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+--- a/arch/arm/boot/dts/overlays/overlay_map.dts
++++ b/arch/arm/boot/dts/overlays/overlay_map.dts
+@@ -1,32 +1,100 @@
+ /dts-v1/;
+ 
+ / {
++	audremap {
++		bcm2835;
++		bcm2711;
++	};
++
++	balena-fin {
++		bcm2835;
++		bcm2711;
++	};
++
+ 	bmp085_i2c-sensor {
+ 		deprecated = "use i2c-sensor,bmp085";
+ 	};
+ 
++	cm-swap-i2c0 {
++		bcm2835;
++		bcm2711;
++	};
++
+ 	cutiepi-panel {
+ 		bcm2711;
+ 	};
+ 
++	disable-bt {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "disable-bt-pi5";
++	};
++
++	disable-bt-pi5 {
++		bcm2712;
++	};
++
+ 	disable-emmc2 {
+ 		bcm2711;
+ 	};
+ 
++	disable-wifi {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "disable-wifi-pi5";
++	};
++
++	disable-wifi-pi5 {
++		bcm2712;
++	};
++
+ 	highperi {
+ 		bcm2711;
+ 	};
+ 
++	i2c0 {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "i2c0-pi5";
++	};
++
+ 	i2c0-bcm2708 {
+ 		deprecated = "use i2c0";
+ 	};
+ 
++	i2c0-pi5 {
++		bcm2712;
++	};
++
++	i2c1 {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "i2c1-pi5";
++	};
++
+ 	i2c1-bcm2708 {
+ 		deprecated = "use i2c1";
+ 	};
+ 
++	i2c1-pi5 {
++		bcm2712;
++	};
++
++	i2c2 {
++		bcm2712 = "i2c2-pi5";
++	};
++
++	i2c2-pi5 {
++		bcm2712;
++	};
++
+ 	i2c3 {
+ 		bcm2711;
++		bcm2712 = "i2c3-pi5";
++	};
++
++	i2c3-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	i2c4 {
+@@ -41,26 +109,76 @@
+ 		bcm2711;
+ 	};
+ 
++	i2s-gpio28-31 {
++		bcm2835;
++		bcm2711;
++	};
++
+ 	lirc-rpi {
+ 		deprecated = "use gpio-ir";
+ 	};
+ 
++	midi-uart0 {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "midi-uart0-pi5";
++	};
++
++	midi-uart0-pi5 {
++		bcm2712;
++	};
++
++	midi-uart1 {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "midi-uart1-pi5";
++	};
++
++	midi-uart1-pi5 {
++		bcm2712;
++	};
++
+ 	midi-uart2 {
+ 		bcm2711;
++		bcm2712 = "midi-uart2-pi5";
++	};
++
++	midi-uart2-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	midi-uart3 {
+ 		bcm2711;
++		bcm2712 = "midi-uart3-pi5";
++	};
++
++	midi-uart3-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	midi-uart4 {
+ 		bcm2711;
++		bcm2712 = "midi-uart4-pi5";
++	};
++
++	midi-uart4-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	midi-uart5 {
+ 		bcm2711;
+ 	};
+ 
++	miniuart-bt {
++		bcm2835;
++		bcm2711;
++	};
++
++	mmc {
++		bcm2835;
++		bcm2711;
++	};
++
+ 	mpu6050 {
+ 		deprecated = "use i2c-sensor,mpu6050";
+ 	};
+@@ -118,6 +236,16 @@
+ 		deprecated = "no longer necessary";
+ 	};
+ 
++	sdhost {
++		bcm2835;
++		bcm2711;
++	};
++
++	sdio {
++		bcm2835;
++		bcm2711;
++	};
++
+ 	sdio-1bit {
+ 		deprecated = "use sdio,bus_width=1,gpios_22_25";
+ 	};
+@@ -126,6 +254,21 @@
+ 		deprecated = "use 'dtparam=sd_poll_once' etc.";
+ 	};
+ 
++	smi {
++		bcm2835;
++		bcm2711;
++	};
++
++	smi-dev {
++		bcm2835;
++		bcm2711;
++	};
++
++	smi-nand {
++		bcm2835;
++		bcm2711;
++	};
++
+ 	spi0-cs {
+ 		renamed = "spi0-2cs";
+ 	};
+@@ -134,12 +277,42 @@
+ 		deprecated = "no longer necessary";
+ 	};
+ 
++	spi2-1cs {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "spi2-1cs-pi5";
++	};
++
++	spi2-1cs-pi5 {
++		bcm2712;
++	};
++
++	spi2-2cs {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "spi2-2cs-pi5";
++	};
++
++	spi2-2cs-pi5 {
++		bcm2712;
++	};
++
+ 	spi3-1cs {
+ 		bcm2711;
++		bcm2712 = "spi3-1cs-pi5";
++	};
++
++	spi3-1cs-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	spi3-2cs {
+ 		bcm2711;
++		bcm2712 = "spi3-2cs-pi5";
++	};
++
++	spi3-2cs-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	spi4-1cs {
+@@ -152,10 +325,20 @@
+ 
+ 	spi5-1cs {
+ 		bcm2711;
++		bcm2712 = "spi5-1cs-pi5";
++	};
++
++	spi5-1cs-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	spi5-2cs {
+ 		bcm2711;
++		bcm2712 = "spi5-2cs-pi5";
++	};
++
++	spi5-2cs-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	spi6-1cs {
+@@ -166,16 +349,51 @@
+ 		bcm2711;
+ 	};
+ 
++	uart0 {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "uart0-pi5";
++	};
++
++	uart0-pi5 {
++		bcm2712;
++	};
++
++	uart1 {
++		bcm2835;
++		bcm2711;
++		bcm2712 = "uart1-pi5";
++	};
++
++	uart1-pi5 {
++		bcm2712;
++	};
++
+ 	uart2 {
+ 		bcm2711;
++		bcm2712 = "uart2-pi5";
++	};
++
++	uart2-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	uart3 {
+ 		bcm2711;
++		bcm2712 = "uart3-pi5";
++	};
++
++	uart3-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	uart4 {
+ 		bcm2711;
++		bcm2712 = "uart4-pi5";
++	};
++
++	uart4-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	uart5 {
+@@ -198,10 +416,12 @@
+ 	vc4-fkms-v3d {
+ 		bcm2835;
+ 		bcm2711 = "vc4-fkms-v3d-pi4";
++		bcm2712 = "vc4-fkms-v3d-pi4";
+ 	};
+ 
+ 	vc4-fkms-v3d-pi4 {
+ 		bcm2711;
++		bcm2712;
+ 	};
+ 
+ 	vc4-kms-dpi-at056tn53v1 {
+@@ -211,10 +431,16 @@
+ 	vc4-kms-v3d {
+ 		bcm2835;
+ 		bcm2711 = "vc4-kms-v3d-pi4";
++		bcm2712 = "vc4-kms-v3d-pi5";
+ 	};
+ 
+ 	vc4-kms-v3d-pi4 {
+ 		bcm2711;
++		bcm2712 = "vc4-kms-v3d-pi5";
++	};
++
++	vc4-kms-v3d-pi5 {
++		bcm2712;
+ 	};
+ 
+ 	vl805 {
+--- a/arch/arm/boot/dts/overlays/pibell-overlay.dts
++++ b/arch/arm/boot/dts/overlays/pibell-overlay.dts
+@@ -24,7 +24,7 @@
+     };
+ 
+     fragment@1 {
+-        target = <&i2s>;
++        target = <&i2s_clk_producer>;
+         __overlay__ {
+             #sound-dai-cells = <0>;
+             status = "okay";
+@@ -43,7 +43,7 @@
+                 format = "i2s";
+ 
+                 r_cpu_dai: cpu {
+-                    sound-dai = <&i2s>;
++                    sound-dai = <&i2s_clk_producer>;
+ 
+ /* example TDM slot configuration
+                     dai-tdm-slot-num = <2>;
+@@ -60,7 +60,7 @@
+                 format = "i2s";
+ 
+                 p_cpu_dai: cpu {
+-                    sound-dai = <&i2s>;
++                    sound-dai = <&i2s_clk_producer>;
+ 
+ /* example TDM slot configuration
+                     dai-tdm-slot-num = <2>;
+--- a/arch/arm/boot/dts/overlays/pifi-40-overlay.dts
++++ b/arch/arm/boot/dts/overlays/pifi-40-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -42,7 +42,7 @@
+ 		pifi_40: __overlay__ {
+ 			compatible = "pifi,pifi-40";
+ 			audio-codec = <&tas5711l &tas5711r>;
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 			pdn-gpios = <&gpio 23 1>;
+ 			status = "okay";
+ 		};
+--- a/arch/arm/boot/dts/overlays/pifi-dac-hd-overlay.dts
++++ b/arch/arm/boot/dts/overlays/pifi-dac-hd-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -38,7 +38,7 @@
+ 			simple-audio-card,dai-link@1 {
+ 				format = "i2s";
+ 				cpu {
+-					sound-dai = <&i2s>;
++					sound-dai = <&i2s_clk_producer>;
+ 				};
+ 				codec {
+ 					sound-dai = <&pcm5142>;
+--- a/arch/arm/boot/dts/overlays/pifi-dac-zero-overlay.dts
++++ b/arch/arm/boot/dts/overlays/pifi-dac-zero-overlay.dts
+@@ -16,7 +16,7 @@
+ 				format = "i2s";
+ 
+ 				cpu {
+-					sound-dai = <&i2s>;
++					sound-dai = <&i2s_clk_producer>;
+ 					dai-tdm-slot-num = <2>;
+ 					dai-tdm-slot-width = <32>;
+ 				};
+@@ -40,7 +40,7 @@
+ 	};
+ 
+ 	fragment@2 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			#sound-dai-cells = <0>;
+ 			status = "okay";
+--- a/arch/arm/boot/dts/overlays/pifi-mini-210-overlay.dts
++++ b/arch/arm/boot/dts/overlays/pifi-mini-210-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -34,7 +34,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "pifi,pifi-mini-210";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_producer>;
+ 
+ 			status = "okay";
+ 		};
+--- a/arch/arm/boot/dts/overlays/pisound-overlay.dts
++++ b/arch/arm/boot/dts/overlays/pisound-overlay.dts
+@@ -75,7 +75,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "blokaslabs,pisound";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 
+ 			pinctrl-names = "default";
+@@ -108,7 +108,7 @@
+ 	};
+ 
+ 	fragment@7 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+--- a/arch/arm/boot/dts/overlays/proto-codec-overlay.dts
++++ b/arch/arm/boot/dts/overlays/proto-codec-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -32,7 +32,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "rpi,rpi-proto";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- a/arch/arm/boot/dts/overlays/rra-digidac1-wm8741-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/rra-digidac1-wm8741-audio-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -42,7 +42,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "rra,digidac1-soundcard";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 		};
+ 	};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/spi2-1cs-pi5-overlay.dts
+@@ -0,0 +1,33 @@
++/dts-v1/;
++/plugin/;
++
++
++/ {
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&spi2>;
++		frag1: __overlay__ {
++			/* needed to avoid dtc warning */
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			cs-gpios = <&gpio 0 1>;
++			status = "okay";
++
++			spidev2_0: spidev@0 {
++				compatible = "spidev";
++				reg = <0>;      /* CE0 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++		};
++	};
++
++	__overrides__ {
++		cs0_pin  = <&frag1>,"cs-gpios:4";
++		cs0_spidev = <&spidev2_0>,"status";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/spi2-2cs-pi5-overlay.dts
+@@ -0,0 +1,44 @@
++/dts-v1/;
++/plugin/;
++
++
++/ {
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&spi2>;
++		frag1: __overlay__ {
++			/* needed to avoid dtc warning */
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			cs-gpios = <&gpio 0 1>, <&gpio 24 1>;
++			status = "okay";
++
++			spidev2_0: spidev@0 {
++				compatible = "spidev";
++				reg = <0>;      /* CE0 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++
++			spidev2_1: spidev@1 {
++				compatible = "spidev";
++				reg = <1>;      /* CE1 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++		};
++	};
++
++	__overrides__ {
++		cs0_pin  = <&frag1>,"cs-gpios:4";
++		cs1_pin  = <&frag1>,"cs-gpios:16";
++		cs0_spidev = <&spidev2_0>,"status";
++		cs1_spidev = <&spidev2_1>,"status";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/spi3-1cs-pi5-overlay.dts
+@@ -0,0 +1,33 @@
++/dts-v1/;
++/plugin/;
++
++
++/ {
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&spi3>;
++		frag1: __overlay__ {
++			/* needed to avoid dtc warning */
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			cs-gpios = <&gpio 4 1>;
++			status = "okay";
++
++			spidev3_0: spidev@0 {
++				compatible = "spidev";
++				reg = <0>;      /* CE0 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++		};
++	};
++
++	__overrides__ {
++		cs0_pin  = <&frag1>,"cs-gpios:4";
++		cs0_spidev = <&spidev3_0>,"status";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/spi3-2cs-pi5-overlay.dts
+@@ -0,0 +1,44 @@
++/dts-v1/;
++/plugin/;
++
++
++/ {
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&spi3>;
++		frag1: __overlay__ {
++			/* needed to avoid dtc warning */
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			cs-gpios = <&gpio 4 1>, <&gpio 25 1>;
++			status = "okay";
++
++			spidev3_0: spidev@0 {
++				compatible = "spidev";
++				reg = <0>;      /* CE0 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++
++			spidev3_1: spidev@1 {
++				compatible = "spidev";
++				reg = <1>;      /* CE1 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++		};
++	};
++
++	__overrides__ {
++		cs0_pin  = <&frag1>,"cs-gpios:4";
++		cs1_pin  = <&frag1>,"cs-gpios:16";
++		cs0_spidev = <&spidev3_0>,"status";
++		cs1_spidev = <&spidev3_1>,"status";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/spi5-1cs-pi5-overlay.dts
+@@ -0,0 +1,33 @@
++/dts-v1/;
++/plugin/;
++
++
++/ {
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&spi5>;
++		frag1: __overlay__ {
++			/* needed to avoid dtc warning */
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			cs-gpios = <&gpio 12 1>;
++			status = "okay";
++
++			spidev5_0: spidev@0 {
++				compatible = "spidev";
++				reg = <0>;      /* CE0 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++		};
++	};
++
++	__overrides__ {
++		cs0_pin  = <&frag1>,"cs-gpios:4";
++		cs0_spidev = <&spidev5_0>,"status";
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/spi5-2cs-pi5-overlay.dts
+@@ -0,0 +1,44 @@
++/dts-v1/;
++/plugin/;
++
++
++/ {
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&spi5>;
++		frag1: __overlay__ {
++			/* needed to avoid dtc warning */
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			cs-gpios = <&gpio 12 1>, <&gpio 26 1>;
++			status = "okay";
++
++			spidev5_0: spidev@0 {
++				compatible = "spidev";
++				reg = <0>;      /* CE0 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++
++			spidev5_1: spidev@1 {
++				compatible = "spidev";
++				reg = <1>;      /* CE1 */
++				#address-cells = <1>;
++				#size-cells = <0>;
++				spi-max-frequency = <125000000>;
++				status = "okay";
++			};
++		};
++	};
++
++	__overrides__ {
++		cs0_pin  = <&frag1>,"cs-gpios:4";
++		cs1_pin  = <&frag1>,"cs-gpios:16";
++		cs0_spidev = <&spidev5_0>,"status";
++		cs1_spidev = <&spidev5_1>,"status";
++	};
++};
+--- a/arch/arm/boot/dts/overlays/superaudioboard-overlay.dts
++++ b/arch/arm/boot/dts/overlays/superaudioboard-overlay.dts
+@@ -9,7 +9,7 @@
+ 		target = <&sound>;
+ 		__overlay__ {
+ 			compatible = "simple-audio-card";
+-			i2s-controller = <&i2s>;
++			i2s-controller = <&i2s_clk_consumer>;
+ 			status = "okay";
+ 
+ 			simple-audio-card,name = "SuperAudioBoard";
+@@ -32,7 +32,7 @@
+ 			simple-audio-card,frame-master = <&sound_master>;
+ 
+ 			simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_consumer>;
+ 				dai-tdm-slot-num = <2>;
+ 				dai-tdm-slot-width = <32>;
+ 			};
+@@ -45,7 +45,7 @@
+ 	};
+ 
+ 	fragment@1 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+--- a/arch/arm/boot/dts/overlays/tc358743-audio-overlay.dts
++++ b/arch/arm/boot/dts/overlays/tc358743-audio-overlay.dts
+@@ -8,7 +8,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -31,16 +31,16 @@
+ 			compatible = "simple-audio-card";
+ 			simple-audio-card,format = "i2s";
+ 			simple-audio-card,name = "tc358743";
+-			simple-audio-card,bitclock-master = <&dailink0_slave>;
+-			simple-audio-card,frame-master = <&dailink0_slave>;
++			simple-audio-card,bitclock-master = <&dailink0_master>;
++			simple-audio-card,frame-master = <&dailink0_master>;
+ 			status = "okay";
+ 
+ 			simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_consumer>;
+ 				dai-tdm-slot-num = <2>;
+ 				dai-tdm-slot-width = <32>;
+ 			};
+-			dailink0_slave: simple-audio-card,codec {
++			dailink0_master: simple-audio-card,codec {
+ 				sound-dai = <&tc358743_codec>;
+ 			};
+ 		};
+--- a/arch/arm/boot/dts/overlays/tc358743-overlay.dts
++++ b/arch/arm/boot/dts/overlays/tc358743-overlay.dts
+@@ -101,7 +101,7 @@
+ 		4lane = <0>, "-2+3-7+8";
+ 		link-frequency = <&tc358743_0>,"link-frequencies#0";
+ 		media-controller = <&csi>,"brcm,media-controller?";
+-		cam0 = <&i2c_frag>, "target:0=",<&i2c_vc>,
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&tc358743>, "clocks:0=",<&cam0_clk>;
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/uart0-pi5-overlay.dts
+@@ -0,0 +1,17 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&uart0>;
++		frag0: __overlay__ {
++			status = "okay";
++		};
++	};
++
++	__overrides__ {
++		ctsrts = <&frag0>,"pinctrl-0:4=",<&uart0_ctsrts_pins>;
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/uart1-pi5-overlay.dts
+@@ -0,0 +1,17 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&uart1>;
++		frag0: __overlay__ {
++			status = "okay";
++		};
++	};
++
++	__overrides__ {
++		ctsrts = <&frag0>,"pinctrl-0:4=",<&uart1_ctsrts_pins>;
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/uart2-pi5-overlay.dts
+@@ -0,0 +1,17 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&uart2>;
++		frag0: __overlay__ {
++			status = "okay";
++		};
++	};
++
++	__overrides__ {
++		ctsrts = <&frag0>,"pinctrl-0:4=",<&uart2_ctsrts_pins>;
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/uart3-pi5-overlay.dts
+@@ -0,0 +1,17 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&uart3>;
++		frag0: __overlay__ {
++			status = "okay";
++		};
++	};
++
++	__overrides__ {
++		ctsrts = <&frag0>,"pinctrl-0:4=",<&uart3_ctsrts_pins>;
++	};
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/uart4-pi5-overlay.dts
+@@ -0,0 +1,17 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&uart4>;
++		frag0: __overlay__ {
++			status = "okay";
++		};
++	};
++
++	__overrides__ {
++		ctsrts = <&frag0>,"pinctrl-0:4=",<&uart4_ctsrts_pins>;
++	};
++};
+--- a/arch/arm/boot/dts/overlays/udrc-overlay.dts
++++ b/arch/arm/boot/dts/overlays/udrc-overlay.dts
+@@ -9,7 +9,7 @@
+ / {
+     compatible = "brcm,bcm2835";
+     fragment@0 {
+-        target = <&i2s>;
++        target = <&i2s_clk_producer>;
+         __overlay__ {
+             clocks = <&clocks BCM2835_CLOCK_PCM>;
+             clock-names = "pcm";
+@@ -71,7 +71,7 @@
+         target = <&sound>;
+         snd: __overlay__ {
+             compatible = "simple-audio-card";
+-            i2s-controller = <&i2s>;
++            i2s-controller = <&i2s_clk_producer>;
+             status = "okay";
+ 
+             simple-audio-card,name = "udrc";
+@@ -93,7 +93,7 @@
+                 "Line Out", "LOL";
+ 
+             dailink0_master: simple-audio-card,cpu {
+-                sound-dai = <&i2s>;
++                sound-dai = <&i2s_clk_producer>;
+             };
+ 
+             simple-audio-card,codec {
+--- a/arch/arm/boot/dts/overlays/ugreen-dabboard-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ugreen-dabboard-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_consumer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -29,14 +29,14 @@
+ 			compatible = "simple-audio-card";
+ 			simple-audio-card,format = "i2s";
+ 			simple-audio-card,name = "dabboard";
+-			simple-audio-card,bitclock-master = <&dailink0_slave>;
+-			simple-audio-card,frame-master = <&dailink0_slave>;
++			simple-audio-card,bitclock-master = <&dailink0_master>;
++			simple-audio-card,frame-master = <&dailink0_master>;
+ 			simple-audio-card,widgets = "Microphone", "Microphone Jack";
+ 			status = "okay";
+ 			simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_consumer>;
+ 			};
+-			dailink0_slave: simple-audio-card,codec {
++			dailink0_master: simple-audio-card,codec {
+ 				#sound-dai-cells = <0>;
+ 				sound-dai = <&dmic_codec>;
+ 			};
+--- a/arch/arm/boot/dts/overlays/vc4-fkms-v3d-overlay.dts
++++ b/arch/arm/boot/dts/overlays/vc4-fkms-v3d-overlay.dts
+@@ -37,4 +37,10 @@
+ 			status = "okay";
+ 		};
+ 	};
++	fragment@5 {
++		target-path = "/chosen";
++		__overlay__  {
++			bootargs = "clk_ignore_unused";
++		};
++	};
+ };
+--- a/arch/arm/boot/dts/overlays/vc4-fkms-v3d-pi4-overlay.dts
++++ b/arch/arm/boot/dts/overlays/vc4-fkms-v3d-pi4-overlay.dts
+@@ -41,4 +41,10 @@
+ 			status = "okay";
+ 		};
+ 	};
++	fragment@5 {
++		target-path = "/chosen";
++		__overlay__  {
++			bootargs = "clk_ignore_unused";
++		};
++	};
+ };
+--- a/arch/arm/boot/dts/overlays/vc4-kms-dsi-7inch-overlay.dts
++++ b/arch/arm/boot/dts/overlays/vc4-kms-dsi-7inch-overlay.dts
+@@ -11,7 +11,7 @@
+ / {
+ 	/* No compatible as it will have come from edt-ft5406.dtsi */
+ 
+-	fragment@0 {
++	dsi_frag: fragment@0 {
+ 		target = <&dsi1>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+@@ -51,8 +51,8 @@
+ 	fragment@1 {
+ 		target-path = "/";
+ 		__overlay__ {
+-			panel_disp1: panel_disp1@0 {
+-				reg = <0>;
++			panel_disp: panel_disp@1 {
++				reg = <1>;
+ 				compatible = "raspberrypi,7inch-dsi", "simple-panel";
+ 				backlight = <&reg_display>;
+ 				power-supply = <&reg_display>;
+@@ -64,8 +64,8 @@
+ 				};
+ 			};
+ 
+-			reg_bridge: reg_bridge@0 {
+-				reg = <0>;
++			reg_bridge: reg_bridge@1 {
++				reg = <1>;
+ 				compatible = "regulator-fixed";
+ 				regulator-name = "bridge_reg";
+ 				gpio = <&reg_display 0 0>;
+@@ -75,7 +75,7 @@
+ 		};
+ 	};
+ 
+-	fragment@2 {
++	i2c_frag: fragment@2 {
+ 		target = <&i2c_csi_dsi>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+@@ -113,6 +113,12 @@
+ 	};
+ 
+ 	__overrides__ {
++		dsi0 = <&dsi_frag>, "target:0=",<&dsi0>,
++		       <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
++		       <&ts_i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
++		       <&panel_disp>, "reg:0=0",
++		       <&reg_bridge>, "reg:0=0",
++		       <&reg_bridge>, "regulator-name=bridge_reg_0";
+ 		disable_touch = <0>, "-10-11-12";
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/vc4-kms-dsi-waveshare-panel-overlay.dts
++++ b/arch/arm/boot/dts/overlays/vc4-kms-dsi-waveshare-panel-overlay.dts
+@@ -9,7 +9,7 @@
+ / {
+ 	compatible = "brcm,bcm2835";
+ 
+-	fragment@0 {
++	dsi_frag: fragment@0 {
+ 		target = <&dsi1>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+@@ -29,7 +29,7 @@
+ 		};
+ 	};
+ 
+-	frag2: fragment@2 {
++	i2c_frag: fragment@2 {
+ 		target = <&i2c_csi_dsi>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+@@ -112,12 +112,14 @@
+ 				   <&touch>, "touchscreen-size-y:0=1480",
+ 				   <&touch>, "touchscreen-inverted-x?",
+ 				   <&touch>, "touchscreen-swapped-x-y?";
+-		i2c1 = <&frag2>, "target:0=",<&i2c1>,
++		i2c1 = <&i2c_frag>, "target:0=",<&i2c1>,
+ 		       <0>, "-3-4+5";
+ 		disable_touch = <&touch>, "status=disabled";
+ 		rotation = <&panel>, "rotation:0";
+ 		invx = <&touch>,"touchscreen-inverted-x?";
+ 		invy = <&touch>,"touchscreen-inverted-y?";
+ 		swapxy = <&touch>,"touchscreen-swapped-x-y?";
++		dsi0 = <&dsi_frag>, "target:0=",<&dsi0>,
++		       <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>;
+ 	};
+ };
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/vc4-kms-v3d-pi5-overlay.dts
+@@ -0,0 +1,147 @@
++// SPDX-License-Identifier: GPL-2.0
++
++#include "cma-overlay.dts"
++
++&frag0 {
++	size = <((320-4)*1024*1024)>;
++};
++
++/ {
++	compatible = "brcm,bcm2712";
++
++	fragment@1 {
++		target = <&fb>;
++		__overlay__ {
++			status = "disabled";
++		};
++	};
++
++	fragment@2 {
++		target = <&aon_intr>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@3 {
++		target = <&ddc0>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@4 {
++		target = <&ddc1>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@5 {
++		target = <&hdmi0>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@6 {
++		target = <&hdmi1>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@7 {
++		target = <&hvs>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@8 {
++		target = <&mop>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@9 {
++		target = <&moplet>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@10 {
++		target = <&pixelvalve0>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@11 {
++		target = <&pixelvalve1>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@12 {
++		target = <&v3d>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@13 {
++		target = <&vec>;
++		frag13: __overlay__ {
++			status = "disabled";
++		};
++	};
++
++	fragment@14 {
++		target = <&hdmi0>;
++		__dormant__  {
++			dmas;
++		};
++	};
++
++	fragment@15 {
++		target = <&hdmi1>;
++		__dormant__  {
++			dmas;
++		};
++	};
++
++	fragment@16 {
++		target = <&disp_intr>;
++		__overlay__  {
++			status = "okay";
++		};
++	};
++
++	fragment@17 {
++		target = <&vc4>;
++		__overlay__  {
++			/* IOMMU attaches here, where we allocate DMA buffers */
++			iommus = <&iommu4>;
++		};
++	};
++
++	__overrides__ {
++		audio   = <0>,"!14";
++		audio1   = <0>,"!15";
++		noaudio = <0>,"=14", <0>,"=15";
++		composite = <0>, "!3",
++			    <0>, "!4",
++			    <0>, "!5",
++			    <0>, "!6",
++			    <0>, "!10",
++			    <0>, "!11",
++			    <&frag13>, "status";
++		nohdmi0 =   <0>, "-3-5-10";
++		nohdmi1 =   <0>, "-4-6-11";
++		nohdmi =    <0>, "-3-4-5-6-10-11";
++	};
++};
+--- a/arch/arm/boot/dts/overlays/vc4-kms-vga666-overlay.dts
++++ b/arch/arm/boot/dts/overlays/vc4-kms-vga666-overlay.dts
+@@ -94,7 +94,14 @@
+ 		};
+ 	};
+ 
++	fragment@5 {
++		target = <&i2c_vc>;
++		__dormant__ {
++			status = "okay";
++		};
++	};
++
+ 	__overrides__ {
+-		ddc = <0>,"=2", <0>,"=3", <0>,"=4";
++		ddc = <0>,"=2", <0>,"=3", <0>,"=4", <0>,"=5";
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/wm8960-soundcard-overlay.dts
++++ b/arch/arm/boot/dts/overlays/wm8960-soundcard-overlay.dts
+@@ -6,7 +6,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2s>;
++		target = <&i2s_clk_producer>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -65,7 +65,7 @@
+ 				"RINPUT2", "Mic Jack";
+ 
+ 			simple-audio-card,cpu {
+-				sound-dai = <&i2s>;
++				sound-dai = <&i2s_clk_producer>;
+ 			};
+ 			dailink0_slave: simple-audio-card,codec {
+ 				sound-dai = <&wm8960>;
+--- /dev/null
++++ b/arch/arm/boot/dts/rp1.dtsi
+@@ -0,0 +1,1168 @@
++#include <dt-bindings/clock/rp1.h>
++#include <dt-bindings/interrupt-controller/irq.h>
++#include <dt-bindings/mfd/rp1.h>
++
++&rp1_target {
++	rp1: rp1 {
++		compatible = "simple-bus";
++		#address-cells = <2>;
++		#size-cells = <2>;
++		#interrupt-cells = <2>;
++		interrupt-controller;
++		interrupt-parent = <&rp1>;
++
++		// ranges and dma-ranges must be provided by the includer
++
++		rp1_clocks: clocks@18000 {
++			compatible = "raspberrypi,rp1-clocks";
++			#clock-cells = <1>;
++			reg = <0xc0 0x40018000 0x0 0x10038>;
++			clocks = <&clk_xosc>;
++
++			assigned-clocks = <&rp1_clocks RP1_PLL_SYS_CORE>,
++					  <&rp1_clocks RP1_PLL_AUDIO_CORE>,
++					  // RP1_PLL_VIDEO_CORE and dividers are now managed by VEC,DPI drivers
++					  <&rp1_clocks RP1_PLL_SYS>,
++					  <&rp1_clocks RP1_PLL_SYS_SEC>,
++					  <&rp1_clocks RP1_PLL_AUDIO>,
++					  <&rp1_clocks RP1_PLL_AUDIO_SEC>,
++					  <&rp1_clocks RP1_CLK_SYS>,
++					  <&rp1_clocks RP1_PLL_SYS_PRI_PH>,
++					  // RP1_CLK_SLOW_SYS is used for the frequency counter (FC0)
++					  <&rp1_clocks RP1_CLK_SLOW_SYS>,
++					  <&rp1_clocks RP1_CLK_SDIO_TIMER>,
++					  <&rp1_clocks RP1_CLK_SDIO_ALT_SRC>,
++					  <&rp1_clocks RP1_CLK_ETH_TSU>;
++
++			assigned-clock-rates = <1000000000>, // RP1_PLL_SYS_CORE
++					       <1536000000>, // RP1_PLL_AUDIO_CORE
++					       <200000000>,  // RP1_PLL_SYS
++					       <125000000>,  // RP1_PLL_SYS_SEC
++					       <61440000>,   // RP1_PLL_AUDIO
++					       <192000000>,  // RP1_PLL_AUDIO_SEC
++					       <200000000>,  // RP1_CLK_SYS
++					       <100000000>,  // RP1_PLL_SYS_PRI_PH
++					       // Must match the XOSC frequency
++					       <50000000>, // RP1_CLK_SLOW_SYS
++					       <1000000>, // RP1_CLK_SDIO_TIMER
++					       <200000000>, // RP1_CLK_SDIO_ALT_SRC
++					       <50000000>; // RP1_CLK_ETH_TSU
++		};
++
++		rp1_uart0: serial@30000 {
++			compatible = "arm,pl011-axi";
++			reg = <0xc0 0x40030000  0x0 0x100>;
++			interrupts = <RP1_INT_UART0 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_UART &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++			clock-names = "uartclk", "apb_pclk";
++			dmas = <&rp1_dma RP1_DMA_UART0_TX>,
++			       <&rp1_dma RP1_DMA_UART0_RX>;
++			dma-names = "tx", "rx";
++			pinctrl-names = "default";
++			arm,primecell-periphid = <0x00541011>;
++			uart-has-rtscts;
++			cts-event-workaround;
++			skip-init;
++			status = "disabled";
++		};
++
++		rp1_uart1: serial@34000 {
++			compatible = "arm,pl011-axi";
++			reg = <0xc0 0x40034000  0x0 0x100>;
++			interrupts = <RP1_INT_UART1 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_UART &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++			clock-names = "uartclk", "apb_pclk";
++			// dmas = <&rp1_dma RP1_DMA_UART1_TX>,
++			//        <&rp1_dma RP1_DMA_UART1_RX>;
++			// dma-names = "tx", "rx";
++			pinctrl-names = "default";
++			arm,primecell-periphid = <0x00541011>;
++			uart-has-rtscts;
++			cts-event-workaround;
++			skip-init;
++			status = "disabled";
++		};
++
++		rp1_uart2: serial@38000 {
++			compatible = "arm,pl011-axi";
++			reg = <0xc0 0x40038000  0x0 0x100>;
++			interrupts = <RP1_INT_UART2 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_UART &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++			clock-names = "uartclk", "apb_pclk";
++			// dmas = <&rp1_dma RP1_DMA_UART2_TX>,
++			//        <&rp1_dma RP1_DMA_UART2_RX>;
++			// dma-names = "tx", "rx";
++			pinctrl-names = "default";
++			arm,primecell-periphid = <0x00541011>;
++			uart-has-rtscts;
++			cts-event-workaround;
++			skip-init;
++			status = "disabled";
++		};
++
++		rp1_uart3: serial@3c000 {
++			compatible = "arm,pl011-axi";
++			reg = <0xc0 0x4003c000  0x0 0x100>;
++			interrupts = <RP1_INT_UART3 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_UART &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++			clock-names = "uartclk", "apb_pclk";
++			// dmas = <&rp1_dma RP1_DMA_UART3_TX>,
++			//        <&rp1_dma RP1_DMA_UART3_RX>;
++			// dma-names = "tx", "rx";
++			pinctrl-names = "default";
++			arm,primecell-periphid = <0x00541011>;
++			uart-has-rtscts;
++			cts-event-workaround;
++			skip-init;
++			status = "disabled";
++		};
++
++		rp1_uart4: serial@40000 {
++			compatible = "arm,pl011-axi";
++			reg = <0xc0 0x40040000  0x0 0x100>;
++			interrupts = <RP1_INT_UART4 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_UART &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++			clock-names = "uartclk", "apb_pclk";
++			// dmas = <&rp1_dma RP1_DMA_UART4_TX>,
++			//        <&rp1_dma RP1_DMA_UART4_RX>;
++			// dma-names = "tx", "rx";
++			pinctrl-names = "default";
++			arm,primecell-periphid = <0x00541011>;
++			uart-has-rtscts;
++			cts-event-workaround;
++			skip-init;
++			status = "disabled";
++		};
++
++		rp1_uart5: serial@44000 {
++			compatible = "arm,pl011-axi";
++			reg = <0xc0 0x40044000  0x0 0x100>;
++			interrupts = <RP1_INT_UART5 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_UART &rp1_clocks RP1_PLL_SYS_PRI_PH>;
++			clock-names = "uartclk", "apb_pclk";
++			// dmas = <&rp1_dma RP1_DMA_UART5_TX>,
++			//        <&rp1_dma RP1_DMA_UART5_RX>;
++			// dma-names = "tx", "rx";
++			pinctrl-names = "default";
++			arm,primecell-periphid = <0x00541011>;
++			uart-has-rtscts;
++			cts-event-workaround;
++			skip-init;
++			status = "disabled";
++		};
++
++		rp1_spi8: spi@4c000 {
++			reg = <0xc0 0x4004c000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI8 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			num-cs = <2>;
++			dmas = <&rp1_dma RP1_DMA_SPI8_TX>,
++			       <&rp1_dma RP1_DMA_SPI8_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		rp1_spi0: spi@50000 {
++			reg = <0xc0 0x40050000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI0 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			num-cs = <2>;
++			dmas = <&rp1_dma RP1_DMA_SPI0_TX>,
++			       <&rp1_dma RP1_DMA_SPI0_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		rp1_spi1: spi@54000 {
++			reg = <0xc0 0x40054000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI1 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <0>;
++			#size-cells = <0>;
++			num-cs = <2>;
++			dmas = <&rp1_dma RP1_DMA_SPI1_TX>,
++			       <&rp1_dma RP1_DMA_SPI1_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		rp1_spi2: spi@58000 {
++			reg = <0xc0 0x40058000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI2 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			num-cs = <2>;
++			dmas = <&rp1_dma RP1_DMA_SPI2_TX>,
++			       <&rp1_dma RP1_DMA_SPI2_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		rp1_spi3: spi@5c000 {
++			reg = <0xc0 0x4005c000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI3 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			num-cs = <2>;
++			dmas = <&rp1_dma RP1_DMA_SPI3_TX>,
++			       <&rp1_dma RP1_DMA_SPI3_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		// SPI4 is a target/slave interface
++		rp1_spi4: spi@60000 {
++			reg = <0xc0 0x40060000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI4 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <0>;
++			#size-cells = <0>;
++			num-cs = <1>;
++			spi-slave;
++			dmas = <&rp1_dma RP1_DMA_SPI4_TX>,
++			       <&rp1_dma RP1_DMA_SPI4_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++
++			slave {
++				compatible = "spidev";
++				spi-max-frequency = <1000000>;
++			};
++		};
++
++		rp1_spi5: spi@64000 {
++			reg = <0xc0 0x40064000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI5 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			num-cs = <2>;
++			dmas = <&rp1_dma RP1_DMA_SPI5_TX>,
++			       <&rp1_dma RP1_DMA_SPI5_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		// SPI7 is a target/slave interface
++		rp1_spi7: spi@6c000 {
++			reg = <0xc0 0x4006c000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI7 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <0>;
++			#size-cells = <0>;
++			num-cs = <1>;
++			spi-slave;
++			dmas = <&rp1_dma RP1_DMA_SPI7_TX>,
++			       <&rp1_dma RP1_DMA_SPI7_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++
++			slave {
++				compatible = "spidev";
++				spi-max-frequency = <1000000>;
++			};
++		};
++
++		rp1_i2c0: i2c@70000 {
++			reg = <0xc0 0x40070000  0x0 0x1000>;
++			compatible = "snps,designware-i2c";
++			interrupts = <RP1_INT_I2C0 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			status = "disabled";
++		};
++
++		rp1_i2c1: i2c@74000 {
++			reg = <0xc0 0x40074000  0x0 0x1000>;
++			compatible = "snps,designware-i2c";
++			interrupts = <RP1_INT_I2C1 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			status = "disabled";
++		};
++
++		rp1_i2c2: i2c@78000 {
++			reg = <0xc0 0x40078000  0x0 0x1000>;
++			compatible = "snps,designware-i2c";
++			interrupts = <RP1_INT_I2C2 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			status = "disabled";
++		};
++
++		rp1_i2c3: i2c@7c000 {
++			reg = <0xc0 0x4007c000  0x0 0x1000>;
++			compatible = "snps,designware-i2c";
++			interrupts = <RP1_INT_I2C3 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			status = "disabled";
++		};
++
++		rp1_i2c4: i2c@80000 {
++			reg = <0xc0 0x40080000  0x0 0x1000>;
++			compatible = "snps,designware-i2c";
++			interrupts = <RP1_INT_I2C4 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			status = "disabled";
++		};
++
++		rp1_i2c5: i2c@84000 {
++			reg = <0xc0 0x40084000  0x0 0x1000>;
++			compatible = "snps,designware-i2c";
++			interrupts = <RP1_INT_I2C5 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			status = "disabled";
++		};
++
++		rp1_i2c6: i2c@88000 {
++			reg = <0xc0 0x40088000  0x0 0x1000>;
++			compatible = "snps,designware-i2c";
++			interrupts = <RP1_INT_I2C6 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			status = "disabled";
++		};
++
++		rp1_pwm0: pwm@98000 {
++			compatible = "raspberrypi,rp1-pwm";
++			reg = <0xc0 0x40098000  0x0 0x100>;
++			#pwm-cells = <3>;
++			clocks = <&rp1_clocks RP1_CLK_PWM0>;
++			assigned-clocks = <&rp1_clocks RP1_CLK_PWM0>;
++			assigned-clock-rates = <6144000>;
++			status = "disabled";
++		};
++
++		rp1_pwm1: pwm@9c000 {
++			compatible = "raspberrypi,rp1-pwm";
++			reg = <0xc0 0x4009c000  0x0 0x100>;
++			#pwm-cells = <3>;
++			clocks = <&rp1_clocks RP1_CLK_PWM1>;
++			assigned-clocks = <&rp1_clocks RP1_CLK_PWM1>;
++			assigned-clock-rates = <6144000>;
++			status = "disabled";
++		};
++
++		rp1_i2s0: i2s@a0000 {
++			reg = <0xc0 0x400a0000  0x0 0x1000>;
++			compatible = "snps,designware-i2s";
++			// Providing an interrupt disables DMA
++			// interrupts = <RP1_INT_I2S0 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_I2S>;
++			clock-names = "i2sclk";
++			#sound-dai-cells = <0>;
++			dmas = <&rp1_dma RP1_DMA_I2S0_TX>,<&rp1_dma RP1_DMA_I2S0_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		rp1_i2s1: i2s@a4000 {
++			reg = <0xc0 0x400a4000  0x0 0x1000>;
++			compatible = "snps,designware-i2s";
++			// Providing an interrupt disables DMA
++			// interrupts = <RP1_INT_I2S1 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_I2S>;
++			clock-names = "i2sclk";
++			#sound-dai-cells = <0>;
++			dmas = <&rp1_dma RP1_DMA_I2S1_TX>,<&rp1_dma RP1_DMA_I2S1_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
++		rp1_i2s2: i2s@a8000 {
++			reg = <0xc0 0x400a8000  0x0 0x1000>;
++			compatible = "snps,designware-i2s";
++			// Providing an interrupt disables DMA
++			// interrupts = <RP1_INT_I2S2 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_I2S>;
++			status = "disabled";
++		};
++
++		rp1_sdio_clk0: sdio_clk0@b0004 {
++			compatible = "raspberrypi,rp1-sdio-clk";
++			reg = <0xc0 0x400b0004 0x0 0x1c>;
++			clocks = <&sdio_src &sdhci_core>;
++			clock-names = "src", "base";
++			#clock-cells = <0>;
++			status = "disabled";
++		};
++
++		rp1_sdio_clk1: sdio_clk1@b4004 {
++			compatible = "raspberrypi,rp1-sdio-clk";
++			reg = <0xc0 0x400b4004 0x0 0x1c>;
++			clocks = <&sdio_src &sdhci_core>;
++			clock-names = "src", "base";
++			#clock-cells = <0>;
++			status = "disabled";
++		};
++
++		rp1_adc: adc@c8000 {
++			compatible = "raspberrypi,rp1-adc";
++			reg = <0xc0 0x400c8000 0x0 0x4000>;
++			clocks = <&rp1_clocks RP1_CLK_ADC>;
++			clock-names = "adcclk";
++			#clock-cells = <0>;
++			vref-supply = <&rp1_vdd_3v3>;
++			status = "disabled";
++		};
++
++		rp1_gpio: gpio@d0000 {
++			reg = <0xc0 0x400d0000  0x0 0xc000>,
++			      <0xc0 0x400e0000  0x0 0xc000>,
++			      <0xc0 0x400f0000  0x0 0xc000>;
++			compatible = "raspberrypi,rp1-gpio";
++			interrupts = <RP1_INT_IO_BANK0 IRQ_TYPE_LEVEL_HIGH>,
++				     <RP1_INT_IO_BANK1 IRQ_TYPE_LEVEL_HIGH>,
++			             <RP1_INT_IO_BANK2 IRQ_TYPE_LEVEL_HIGH>;
++			gpio-controller;
++			#gpio-cells = <2>;
++			interrupt-controller;
++			#interrupt-cells = <2>;
++
++			rp1_uart0_14_15: rp1_uart0_14_15 {
++				pin_txd {
++					function = "uart0";
++					pins = "gpio14";
++					bias-disable;
++				};
++				pin_rxd {
++					function = "uart0";
++					pins = "gpio15";
++					bias-pull-up;
++				};
++			};
++			rp1_uart0_ctsrts_16_17: rp1_uart0_ctsrts_16_17 {
++				pin_cts {
++					function = "uart0";
++					pins = "gpio16";
++					bias-pull-up;
++				};
++				pin_rts {
++					function = "uart0";
++					pins = "gpio17";
++					bias-disable;
++				};
++			};
++			rp1_uart1_0_1: rp1_uart1_0_1 {
++				pin_txd {
++					function = "uart1";
++					pins = "gpio0";
++					bias-disable;
++				};
++				pin_rxd {
++					function = "uart1";
++					pins = "gpio1";
++					bias-pull-up;
++				};
++			};
++			rp1_uart1_ctsrts_2_3: rp1_uart1_ctsrts_2_3 {
++				pin_cts {
++					function = "uart1";
++					pins = "gpio2";
++					bias-pull-up;
++				};
++				pin_rts {
++					function = "uart1";
++					pins = "gpio3";
++					bias-disable;
++				};
++			};
++			rp1_uart2_4_5: rp1_uart2_4_5 {
++				pin_txd {
++					function = "uart2";
++					pins = "gpio4";
++					bias-disable;
++				};
++				pin_rxd {
++					function = "uart2";
++					pins = "gpio5";
++					bias-pull-up;
++				};
++			};
++			rp1_uart2_ctsrts_6_7: rp1_uart2_ctsrts_6_7 {
++				pin_cts {
++					function = "uart2";
++					pins = "gpio6";
++					bias-pull-up;
++				};
++				pin_rts {
++					function = "uart2";
++					pins = "gpio7";
++					bias-disable;
++				};
++			};
++			rp1_uart3_8_9: rp1_uart3_8_9 {
++				pin_txd {
++					function = "uart3";
++					pins = "gpio8";
++					bias-disable;
++				};
++				pin_rxd {
++					function = "uart3";
++					pins = "gpio9";
++					bias-pull-up;
++				};
++			};
++			rp1_uart3_ctsrts_10_11: rp1_uart3_ctsrts_10_11 {
++				pin_cts {
++					function = "uart3";
++					pins = "gpio10";
++					bias-pull-up;
++				};
++				pin_rts {
++					function = "uart3";
++					pins = "gpio11";
++					bias-disable;
++				};
++			};
++			rp1_uart4_12_13: rp1_uart4_12_13 {
++				pin_txd {
++					function = "uart4";
++					pins = "gpio12";
++					bias-disable;
++				};
++				pin_rxd {
++					function = "uart4";
++					pins = "gpio13";
++					bias-pull-up;
++				};
++			};
++			rp1_uart4_ctsrts_14_15: rp1_uart4_ctsrts_14_15 {
++				pin_cts {
++					function = "uart4";
++					pins = "gpio14";
++					bias-pull-up;
++				};
++				pin_rts {
++					function = "uart4";
++					pins = "gpio15";
++					bias-disable;
++				};
++			};
++
++			rp1_sdio0_22_27: rp1_sdio0_22_27 {
++				pin_clk {
++					function = "sd0";
++					pins = "gpio22";
++					bias-disable;
++					drive-strength = <12>;
++					slew-rate = <1>;
++				};
++				pin_cmd {
++					function = "sd0";
++					pins = "gpio23";
++					bias-pull-up;
++					drive-strength = <12>;
++					slew-rate = <1>;
++				};
++				pins_dat {
++					function = "sd0";
++					pins = "gpio24", "gpio25", "gpio26", "gpio27";
++					bias-pull-up;
++					drive-strength = <12>;
++					slew-rate = <1>;
++				};
++			};
++
++			rp1_sdio1_28_33: rp1_sdio1_28_33 {
++				pin_clk {
++					function = "sd1";
++					pins = "gpio28";
++					bias-disable;
++					drive-strength = <12>;
++					slew-rate = <1>;
++				};
++				pin_cmd {
++					function = "sd1";
++					pins = "gpio29";
++					bias-pull-up;
++					drive-strength = <12>;
++					slew-rate = <1>;
++				};
++				pins_dat {
++					function = "sd1";
++					pins = "gpio30", "gpio31", "gpio32", "gpio33";
++					bias-pull-up;
++					drive-strength = <12>;
++					slew-rate = <1>;
++				};
++			};
++
++			rp1_i2s0_18_21: rp1_i2s0_18_21 {
++				function = "i2s0";
++				pins = "gpio18", "gpio19", "gpio20", "gpio21";
++				bias-disable;
++			};
++
++			rp1_i2s1_18_21: rp1_i2s1_18_21 {
++				function = "i2s1";
++				pins = "gpio18", "gpio19", "gpio20", "gpio21";
++				bias-disable;
++			};
++
++			rp1_i2c4_34_35: rp1_i2c4_34_35 {
++				function = "i2c4";
++				pins = "gpio34", "gpio35";
++				bias-pull-up;
++			};
++			rp1_i2c6_38_39: rp1_i2c6_38_39 {
++				function = "i2c6";
++				pins = "gpio38", "gpio39";
++				bias-pull-up;
++			};
++			rp1_i2c4_40_41: rp1_i2c4_40_41 {
++				function = "i2c4";
++				pins = "gpio40", "gpio41";
++				bias-pull-up;
++			};
++			rp1_i2c5_44_45: rp1_i2c5_44_45 {
++				function = "i2c5";
++				pins = "gpio44", "gpio45";
++				bias-pull-up;
++			};
++			rp1_i2c0_0_1: rp1_i2c0_0_1 {
++				function = "i2c0";
++				pins = "gpio0", "gpio1";
++				bias-pull-up;
++			};
++			rp1_i2c0_8_9: rp1_i2c0_8_9 {
++				function = "i2c0";
++				pins = "gpio8", "gpio9";
++				bias-pull-up;
++			};
++			rp1_i2c1_2_3: rp1_i2c1_2_3 {
++				function = "i2c1";
++				pins = "gpio2", "gpio3";
++				bias-pull-up;
++			};
++			rp1_i2c1_10_11: rp1_i2c1_10_11 {
++				function = "i2c1";
++				pins = "gpio10", "gpio11";
++				bias-pull-up;
++			};
++			rp1_i2c2_4_5: rp1_i2c2_4_5 {
++				function = "i2c2";
++				pins = "gpio4", "gpio5";
++				bias-pull-up;
++			};
++			rp1_i2c2_12_13: rp1_i2c2_12_13 {
++				function = "i2c2";
++				pins = "gpio12", "gpio13";
++				bias-pull-up;
++			};
++			rp1_i2c3_6_7: rp1_i2c3_6_7 {
++				function = "i2c3";
++				pins = "gpio6", "gpio7";
++				bias-pull-up;
++			};
++			rp1_i2c3_14_15: rp1_i2c3_14_15 {
++				function = "i2c3";
++				pins = "gpio14", "gpio15";
++				bias-pull-up;
++			};
++			rp1_i2c3_22_23: rp1_i2c3_22_23 {
++				function = "i2c3";
++				pins = "gpio22", "gpio23";
++				bias-pull-up;
++			};
++
++			// DPI mappings with HSYNC,VSYNC but without PIXCLK,DE
++			rp1_dpi_16bit_gpio2: rp1_dpi_16bit_gpio2 { /* Mode 2, not fully supported by RP1 */
++				function = "dpi";
++				pins = "gpio2", "gpio3", "gpio4", "gpio5",
++				       "gpio6", "gpio7", "gpio8", "gpio9",
++				       "gpio10", "gpio11", "gpio12", "gpio13",
++				       "gpio14", "gpio15", "gpio16", "gpio17",
++				       "gpio18", "gpio19";
++				bias-disable;
++			};
++			rp1_dpi_16bit_cpadhi_gpio2: rp1_dpi_16bit_cpadhi_gpio2 { /* Mode 3 */
++				function = "dpi";
++				pins = "gpio2", "gpio3", "gpio4", "gpio5",
++				       "gpio6", "gpio7", "gpio8",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17",
++				       "gpio20", "gpio21", "gpio22", "gpio23",
++				       "gpio24";
++				bias-disable;
++			};
++			rp1_dpi_16bit_pad666_gpio2: rp1_dpi_16bit_pad666_gpio2 { /* Mode 4 */
++				function = "dpi";
++				pins = "gpio2", "gpio3",
++				       "gpio5", "gpio6", "gpio7", "gpio8",
++				       "gpio9",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17",
++				       "gpio21", "gpio22", "gpio23", "gpio24",
++				       "gpio25";
++				bias-disable;
++			};
++			rp1_dpi_18bit_gpio2: rp1_dpi_18bit_gpio2 { /* Mode 5, not fully supported by RP1 */
++				function = "dpi";
++				pins = "gpio2", "gpio3", "gpio4", "gpio5",
++				       "gpio6", "gpio7", "gpio8", "gpio9",
++				       "gpio10", "gpio11", "gpio12", "gpio13",
++				       "gpio14", "gpio15", "gpio16", "gpio17",
++				       "gpio18", "gpio19", "gpio20", "gpio21";
++				bias-disable;
++			};
++			rp1_dpi_18bit_cpadhi_gpio2: rp1_dpi_18bit_cpadhi_gpio2 { /* Mode 6 */
++				function = "dpi";
++				pins = "gpio2", "gpio3", "gpio4", "gpio5",
++				       "gpio6", "gpio7", "gpio8", "gpio9",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17",
++				       "gpio20", "gpio21", "gpio22", "gpio23",
++				       "gpio24", "gpio25";
++				bias-disable;
++			};
++			rp1_dpi_24bit_gpio2: rp1_dpi_24bit_gpio2 { /* Mode 7 */
++				function = "dpi";
++				pins = "gpio2", "gpio3", "gpio4", "gpio5",
++				       "gpio6", "gpio7", "gpio8", "gpio9",
++				       "gpio10", "gpio11", "gpio12", "gpio13",
++				       "gpio14", "gpio15", "gpio16", "gpio17",
++				       "gpio18", "gpio19", "gpio20", "gpio21",
++				       "gpio22", "gpio23", "gpio24", "gpio25",
++				       "gpio26", "gpio27";
++				bias-disable;
++			};
++			rp1_dpi_hvsync: rp1_dpi_hvsync { /* Sync only, for use with int VDAC */
++				function = "dpi";
++				pins = "gpio2", "gpio3";
++				bias-disable;
++			};
++
++			// More DPI mappings, including PIXCLK,DE on GPIOs 0,1
++			rp1_dpi_16bit_gpio0: rp1_dpi_16bit_gpio0 { /* Mode 2, not fully supported by RP1 */
++				function = "dpi";
++				pins = "gpio0", "gpio1", "gpio2", "gpio3",
++				       "gpio4", "gpio5", "gpio6", "gpio7",
++				       "gpio8", "gpio9", "gpio10", "gpio11",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17", "gpio18", "gpio19";
++				bias-disable;
++			};
++			rp1_dpi_16bit_cpadhi_gpio0: rp1_dpi_16bit_cpadhi_gpio0 { /* Mode 3 */
++				function = "dpi";
++				pins = "gpio0", "gpio1", "gpio2", "gpio3",
++				       "gpio4", "gpio5", "gpio6", "gpio7",
++				       "gpio8",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17",
++				       "gpio20", "gpio21", "gpio22", "gpio23",
++				       "gpio24";
++				bias-disable;
++			};
++			rp1_dpi_16bit_pad666_gpio0: rp1_dpi_16bit_pad666_gpio0 { /* Mode 4 */
++				function = "dpi";
++				pins = "gpio0", "gpio1", "gpio2", "gpio3",
++				       "gpio5", "gpio6", "gpio7", "gpio8",
++				       "gpio9",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17",
++				       "gpio21", "gpio22", "gpio23", "gpio24",
++				       "gpio25";
++				bias-disable;
++			};
++			rp1_dpi_18bit_gpio0: rp1_dpi_18bit_gpio0 { /* Mode 5, not fully supported by RP1 */
++				function = "dpi";
++				pins = "gpio0", "gpio1", "gpio2", "gpio3",
++				       "gpio4", "gpio5", "gpio6", "gpio7",
++				       "gpio8", "gpio9", "gpio10", "gpio11",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17", "gpio18", "gpio19",
++				       "gpio20", "gpio21";
++				bias-disable;
++			};
++			rp1_dpi_18bit_cpadhi_gpio0: rp1_dpi_18bit_cpadhi_gpio0 { /* Mode 6 */
++				function = "dpi";
++				pins = "gpio0", "gpio1", "gpio2", "gpio3",
++				       "gpio4", "gpio5", "gpio6", "gpio7",
++				       "gpio8", "gpio9",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17",
++				       "gpio20", "gpio21", "gpio22", "gpio23",
++				       "gpio24", "gpio25";
++				bias-disable;
++			};
++			rp1_dpi_24bit_gpio0: rp1_dpi_24bit_gpio0 { /* Mode 7 -- All GPIOs used! */
++				function = "dpi";
++				pins = "gpio0", "gpio1", "gpio2", "gpio3",
++				       "gpio4", "gpio5", "gpio6", "gpio7",
++				       "gpio8", "gpio9", "gpio10", "gpio11",
++				       "gpio12", "gpio13", "gpio14", "gpio15",
++				       "gpio16", "gpio17", "gpio18", "gpio19",
++				       "gpio20", "gpio21", "gpio22", "gpio23",
++				       "gpio24", "gpio25", "gpio26", "gpio27";
++				bias-disable;
++			};
++
++			rp1_pwm1_gpio45: rp1_pwm1_gpio45 {
++				function = "pwm1";
++				pins = "gpio45";
++				bias-pull-down;
++			};
++
++			rp1_spi0_gpio9: rp1_spi0_gpio9 {
++				function = "spi0";
++				pins = "gpio9", "gpio10", "gpio11";
++				bias-disable;
++				drive-strength = <12>;
++				slew-rate = <1>;
++			};
++
++			rp1_spi0_cs_gpio7: rp1_spi0_cs_gpio7 {
++				function = "spi0";
++				pins = "gpio7", "gpio8";
++				bias-pull-up;
++			};
++
++			rp1_spi1_gpio19: rp1_spi1_gpio19 {
++				function = "spi1";
++				pins = "gpio19", "gpio20", "gpio21";
++				bias-disable;
++				drive-strength = <12>;
++				slew-rate = <1>;
++			};
++
++			rp1_spi2_gpio1: rp1_spi2_gpio1 {
++				function = "spi2";
++				pins = "gpio1", "gpio2", "gpio3";
++				bias-disable;
++				drive-strength = <12>;
++				slew-rate = <1>;
++			};
++
++			rp1_spi3_gpio5: rp1_spi3_gpio5 {
++				function = "spi3";
++				pins = "gpio5", "gpio6", "gpio7";
++				bias-disable;
++				drive-strength = <12>;
++				slew-rate = <1>;
++			};
++
++			rp1_spi4_gpio9: rp1_spi4_gpio9 {
++				function = "spi4";
++				pins = "gpio9", "gpio10", "gpio11";
++				bias-disable;
++				drive-strength = <12>;
++				slew-rate = <1>;
++			};
++
++			rp1_spi5_gpio13: rp1_spi5_gpio13 {
++				function = "spi5";
++				pins = "gpio13", "gpio14", "gpio15";
++				bias-disable;
++				drive-strength = <12>;
++				slew-rate = <1>;
++			};
++
++			rp1_spi8_gpio49: rp1_spi8_gpio49 {
++				function = "spi8";
++				pins = "gpio49", "gpio50", "gpio51";
++				bias-disable;
++				drive-strength = <12>;
++				slew-rate = <1>;
++			};
++
++			rp1_spi8_cs_gpio52: rp1_spi8_cs_gpio52 {
++				function = "spi0";
++				pins = "gpio52", "gpio53";
++				bias-pull-up;
++			};
++		};
++
++		rp1_eth: ethernet@100000 {
++			reg = <0xc0 0x40100000  0x0 0x4000>;
++			compatible = "cdns,macb";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			interrupts = <RP1_INT_ETH IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&macb_pclk &macb_hclk &rp1_clocks RP1_CLK_ETH_TSU>;
++			clock-names = "pclk", "hclk", "tsu_clk";
++			phy-mode = "rgmii-id";
++			cdns,aw2w-max-pipe = /bits/ 8 <8>;
++			cdns,ar2r-max-pipe = /bits/ 8 <8>;
++			cdns,use-aw2b-fill;
++			local-mac-address = [00 00 00 00 00 00];
++			status = "disabled";
++		};
++
++		rp1_csi0: csi@110000 {
++			compatible = "raspberrypi,rp1-cfe";
++			reg = <0xc0 0x40110000  0x0 0x100>, // CSI2 DMA address
++			      <0xc0 0x40114000  0x0 0x100>, // PHY/CSI Host address
++			      <0xc0 0x40120000  0x0 0x100>, // MIPI CFG address
++			      <0xc0 0x40124000  0x0 0x1000>; // PiSP FE address
++
++			// interrupts must match rp1_pisp_fe setup
++			interrupts = <RP1_INT_MIPI0 IRQ_TYPE_LEVEL_HIGH>;
++
++			clocks = <&rp1_clocks RP1_CLK_MIPI0_CFG>;
++			assigned-clocks = <&rp1_clocks RP1_CLK_MIPI0_CFG>;
++			assigned-clock-rates = <25000000>;
++
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		rp1_csi1: csi@128000 {
++			compatible = "raspberrypi,rp1-cfe";
++			reg = <0xc0 0x40128000  0x0 0x100>, // CSI2 DMA address
++			      <0xc0 0x4012c000  0x0 0x100>, // PHY/CSI Host address
++			      <0xc0 0x40138000  0x0 0x100>, // MIPI CFG address
++			      <0xc0 0x4013c000  0x0 0x1000>; // PiSP FE address
++
++			// interrupts must match rp1_pisp_fe setup
++			interrupts = <RP1_INT_MIPI1 IRQ_TYPE_LEVEL_HIGH>;
++
++			clocks = <&rp1_clocks RP1_CLK_MIPI1_CFG>;
++			assigned-clocks = <&rp1_clocks RP1_CLK_MIPI1_CFG>;
++			assigned-clock-rates = <25000000>;
++
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "disabled";
++		};
++
++		rp1_mmc0: mmc@180000 {
++			reg = <0xc0 0x40180000  0x0 0x100>;
++			compatible = "snps,dwcmshc-sdhci";
++			interrupts = <RP1_INT_SDIO0 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS &sdhci_core
++			          &rp1_clocks RP1_CLK_SDIO_TIMER
++			          &rp1_sdio_clk0>;
++			clock-names = "bus", "core", "timeout", "sdio";
++			/* Bank 0 VDDIO is fixed */
++			no-1-8-v;
++			bus-width = <4>;
++			vmmc-supply = <&rp1_vdd_3v3>;
++			broken-cd;
++			status = "disabled";
++		};
++
++		rp1_mmc1: mmc@184000 {
++			reg = <0xc0 0x40184000  0x0 0x100>;
++			compatible = "snps,dwcmshc-sdhci";
++			interrupts = <RP1_INT_SDIO1 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS &sdhci_core
++			          &rp1_clocks RP1_CLK_SDIO_TIMER
++			          &rp1_sdio_clk1>;
++			clock-names = "bus", "core", "timeout", "sdio";
++			bus-width = <4>;
++			vmmc-supply = <&rp1_vdd_3v3>;
++			/* Nerf SDR speeds */
++			sdhci-caps-mask = <0x3 0x0>;
++			broken-cd;
++			status = "disabled";
++		};
++
++		rp1_dma: dma@188000 {
++			reg = <0xc0 0x40188000  0x0 0x1000>;
++			compatible = "snps,axi-dma-1.01a";
++			interrupts = <RP1_INT_DMA IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&sdhci_core &rp1_clocks RP1_CLK_SYS>;
++			clock-names = "core-clk", "cfgr-clk";
++
++			#dma-cells = <1>;
++			dma-channels = <8>;
++			snps,dma-masters = <1>;
++			snps,dma-targets = <64>;
++			snps,data-width = <4>; // (8 << 4) == 128 bits
++			snps,block-size = <0x40000 0x40000 0x40000 0x40000 0x40000 0x40000 0x40000 0x40000>;
++			snps,priority = <0 1 2 3 4 5 6 7>;
++			snps,axi-max-burst-len = <8>;
++			status = "disabled";
++		};
++
++		rp1_usb0: usb@200000 {
++			reg = <0xc0 0x40200000  0x0 0x100000>;
++			compatible = "snps,dwc3";
++			dr_mode = "host";
++			usb3-lpm-capable;
++			snps,axi-pipe-limit = /bits/ 8 <8>;
++			snps,dis_rxdet_inp3_quirk;
++			snps,tx-max-burst-prd = <8>;
++			snps,tx-thr-num-pkt-prd = <2>;
++			interrupts = <RP1_INT_USBHOST0_0 IRQ_TYPE_EDGE_RISING>;
++			status = "disabled";
++		};
++
++		rp1_usb1: usb@300000 {
++			reg = <0xc0 0x40300000  0x0 0x100000>;
++			compatible = "snps,dwc3";
++			dr_mode = "host";
++			usb3-lpm-capable;
++			snps,axi-pipe-limit = /bits/ 8 <8>;
++			snps,dis_rxdet_inp3_quirk;
++			snps,tx-max-burst-prd = <8>;
++			snps,tx-thr-num-pkt-prd = <2>;
++			interrupts = <RP1_INT_USBHOST1_0 IRQ_TYPE_EDGE_RISING>;
++			status = "disabled";
++		};
++
++		rp1_dsi0: dsi@110000 {
++			compatible = "raspberrypi,rp1dsi";
++			status = "disabled";
++			reg = <0xc0 0x40118000  0x0 0x1000>,  // MIPI0 DSI DMA (ArgonDPI)
++			      <0xc0 0x4011c000  0x0 0x1000>,  // MIPI0 DSI Host (SNPS)
++			      <0xc0 0x40120000  0x0 0x1000>;  // MIPI0 CFG
++
++			interrupts = <RP1_INT_MIPI0 IRQ_TYPE_LEVEL_HIGH>;
++
++			clocks = <&rp1_clocks RP1_CLK_MIPI0_CFG>,  // required, config bus clock
++				 <&rp1_clocks RP1_CLK_MIPI0_DPI>,  // required, pixel clock
++				 <&clksrc_mipi0_dsi_byteclk>,    // internal, parent for divide
++				 <&clk_xosc>;                    // hardwired to DSI "refclk"
++			clock-names = "cfgclk", "dpiclk", "byteclk", "refclk";
++
++			assigned-clocks = <&rp1_clocks RP1_CLK_MIPI0_CFG>,
++					  <&rp1_clocks RP1_CLK_MIPI0_DPI>;
++			assigned-clock-rates = <25000000>;
++			assigned-clock-parents = <0>, <&clksrc_mipi0_dsi_byteclk>;
++		};
++
++		rp1_dsi1: dsi@128000 {
++			compatible = "raspberrypi,rp1dsi";
++			status = "disabled";
++			reg = <0xc0 0x40130000  0x0 0x1000>,  // MIPI1 DSI DMA (ArgonDPI)
++		              <0xc0 0x40134000  0x0 0x1000>,  // MIPI1 DSI Host (SNPS)
++		              <0xc0 0x40138000  0x0 0x1000>;  // MIPI1 CFG
++
++			interrupts = <RP1_INT_MIPI1 IRQ_TYPE_LEVEL_HIGH>;
++
++			clocks = <&rp1_clocks RP1_CLK_MIPI1_CFG>,  // required, config bus clock
++				 <&rp1_clocks RP1_CLK_MIPI1_DPI>,  // required, pixel clock
++				 <&clksrc_mipi1_dsi_byteclk>,    // internal, parent for divide
++				 <&clk_xosc>;                    // hardwired to DSI "refclk"
++			clock-names = "cfgclk", "dpiclk", "byteclk", "refclk";
++
++			assigned-clocks = <&rp1_clocks RP1_CLK_MIPI1_CFG>,
++					  <&rp1_clocks RP1_CLK_MIPI1_DPI>;
++			assigned-clock-rates = <25000000>;
++			assigned-clock-parents = <0>, <&clksrc_mipi1_dsi_byteclk>;
++		};
++
++		/* VEC and DPI both need to control PLL_VIDEO and cannot work together;   */
++		/* config.txt should enable one or other using dtparam=vec or an overlay. */
++		rp1_vec: vec@144000 {
++			compatible = "raspberrypi,rp1vec";
++			status = "disabled";
++			reg = <0xc0 0x40144000  0x0 0x1000>, // VIDEO_OUT_VEC
++			      <0xc0 0x40140000  0x0 0x1000>; // VIDEO_OUT_CFG
++
++			interrupts = <RP1_INT_VIDEO_OUT IRQ_TYPE_LEVEL_HIGH>;
++
++			clocks = <&rp1_clocks RP1_CLK_VEC>;
++
++			assigned-clocks = <&rp1_clocks RP1_PLL_VIDEO_CORE>,
++					  <&rp1_clocks RP1_PLL_VIDEO_SEC>,
++					  <&rp1_clocks RP1_CLK_VEC>;
++			assigned-clock-rates = <1188000000>,
++					       <108000000>,
++					       <108000000>;
++			assigned-clock-parents = <0>,
++						 <&rp1_clocks RP1_PLL_VIDEO_CORE>,
++						 <&rp1_clocks RP1_PLL_VIDEO_SEC>;
++		};
++
++		rp1_dpi: dpi@148000 {
++			compatible = "raspberrypi,rp1dpi";
++			status = "disabled";
++			reg = <0xc0 0x40148000  0x0 0x1000>, // VIDEO_OUT DPI
++			      <0xc0 0x40140000  0x0 0x1000>; // VIDEO_OUT_CFG
++
++			interrupts = <RP1_INT_VIDEO_OUT IRQ_TYPE_LEVEL_HIGH>;
++
++			clocks = <&rp1_clocks RP1_CLK_DPI>,        // DPI pixel clock
++				 <&rp1_clocks RP1_PLL_VIDEO>,      // PLL primary divider, and
++				 <&rp1_clocks RP1_PLL_VIDEO_CORE>; // VCO, which we also control
++			clock-names = "dpiclk", "plldiv", "pllcore";
++
++			assigned-clocks        = <&rp1_clocks RP1_CLK_DPI>;
++			assigned-clock-parents = <&rp1_clocks RP1_PLL_VIDEO>;
++		};
++	};
++};
++
++&clocks {
++	clk_xosc: clk_xosc {
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		clock-output-names = "xosc";
++		clock-frequency = <50000000>;
++	};
++	macb_pclk: macb_pclk {
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		clock-output-names = "pclk";
++		clock-frequency = <200000000>;
++	};
++	macb_hclk: macb_hclk {
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		clock-output-names = "hclk";
++		clock-frequency = <200000000>;
++	};
++	sdio_src: sdio_src {
++		// 400 MHz on FPGA. PLL sys VCO on asic
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		clock-output-names = "src";
++		clock-frequency = <1000000000>;
++	};
++	sdhci_core: sdhci_core {
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		clock-output-names = "core";
++		clock-frequency = <50000000>;
++	};
++	clksrc_mipi0_dsi_byteclk: clksrc_mipi0_dsi_byteclk {
++		// This clock is synthesized by MIPI0 D-PHY, when DSI is running.
++		// Its frequency is not known a priori (until a panel driver attaches)
++		// so assign a made-up frequency of 72MHz so it can be divided for DPI.
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		clock-output-names = "clksrc_mipi0_dsi_byteclk";
++		clock-frequency = <72000000>;
++	};
++	clksrc_mipi1_dsi_byteclk: clksrc_mipi1_dsi_byteclk {
++		// This clock is synthesized by MIPI1 D-PHY, when DSI is running.
++		// Its frequency is not known a priori (until a panel driver attaches)
++		// so assign a made-up frequency of 72MHz so it can be divided for DPI.
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		clock-output-names = "clksrc_mipi1_dsi_byteclk";
++		clock-frequency = <72000000>;
++	};
++};
++
++/ {
++	rp1_vdd_3v3: rp1_vdd_3v3 {
++		compatible = "regulator-fixed";
++		regulator-name = "vdd-3v3";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-always-on;
++	};
++};
+--- a/arch/arm64/boot/dts/broadcom/Makefile
++++ b/arch/arm64/boot/dts/broadcom/Makefile
+@@ -16,6 +16,7 @@ dtb-$(CONFIG_ARCH_BCM2835) += bcm2710-rp
+ dtb-$(CONFIG_ARCH_BCM2835) += bcm2710-rpi-cm3.dtb
+ dtb-$(CONFIG_ARCH_BCM2835) += bcm2711-rpi-cm4.dtb
+ dtb-$(CONFIG_ARCH_BCM2835) += bcm2711-rpi-cm4s.dtb
++dtb-$(CONFIG_ARCH_BCM2835) += bcm2712-rpi-5-b.dtb
+ 
+ subdir-y	+= bcmbca
+ subdir-y	+= northstar2
+--- /dev/null
++++ b/arch/arm64/boot/dts/broadcom/bcm2712-rpi-5-b.dts
+@@ -0,0 +1 @@
++#include "../../../../arm/boot/dts/bcm2712-rpi-5-b.dts"
diff --git a/target/linux/bcm27xx/patches-6.1/950-0854-bcm2708_fb-Hack-out-dma-support.patch b/target/linux/bcm27xx/patches-6.1/950-0854-bcm2708_fb-Hack-out-dma-support.patch
new file mode 100644
index 0000000000..75295c73c3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0854-bcm2708_fb-Hack-out-dma-support.patch
@@ -0,0 +1,37 @@
+From d60956f30586ced37e2152f2ba338f547e6c64f7 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 24 Sep 2020 20:13:08 +0100
+Subject: [PATCH] bcm2708_fb: Hack out dma support
+
+---
+ drivers/video/fbdev/bcm2708_fb.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/drivers/video/fbdev/bcm2708_fb.c
++++ b/drivers/video/fbdev/bcm2708_fb.c
+@@ -657,6 +657,8 @@ static long vc_mem_copy(struct bcm2708_f
+ 	long rc = 0;
+ 	size_t offset;
+ 
++return -EFAULT;
++
+ 	/* restrict this to root user */
+ 	if (!uid_eq(current_euid(), GLOBAL_ROOT_UID)) {
+ 		rc = -EFAULT;
+@@ -1109,6 +1111,7 @@ static int bcm2708_fb_probe(struct platf
+ 
+ 	dev_info(&dev->dev, "FB found %d display(s)\n", num_displays);
+ 
++#if 0
+ 	/* Set up the DMA information. Note we have just one set of DMA
+ 	 * parameters to work with all the FB's so requires synchronising when
+ 	 * being used
+@@ -1141,7 +1144,7 @@ static int bcm2708_fb_probe(struct platf
+ 			"Failed to request DMA irq\n");
+ 		goto free_dma_chan;
+ 	}
+-
++#endif
+ 	rpi_firmware_property(fbdev->fw,
+ 			      RPI_FIRMWARE_GET_VC_MEMORY,
+ 			      &gpu_mem, sizeof(gpu_mem));
diff --git a/target/linux/bcm27xx/patches-6.1/950-0855-gpio_brcmstb-Allow-to-build-for-ARCH_BCM2835.patch b/target/linux/bcm27xx/patches-6.1/950-0855-gpio_brcmstb-Allow-to-build-for-ARCH_BCM2835.patch
new file mode 100644
index 0000000000..7e39ac8abf
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0855-gpio_brcmstb-Allow-to-build-for-ARCH_BCM2835.patch
@@ -0,0 +1,282 @@
+From fa18902ee1e53ad391a455a01be3ab2ea1c5af5f Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Fri, 21 May 2021 12:33:38 +0100
+Subject: [PATCH] gpio_brcmstb: Allow to build for ARCH_BCM2835
+
+gpio-brcmstb: Report the correct bank width
+
+gpio: brcmstb: Use bank address as gpiochip label
+
+If the path to the device node is used as gpiochip label then
+gpio-brcmstb instances with multiple banks end up with duplicated
+names. Instead, use a combination of the driver name with the physical
+address of the bank, which is both unique and helpful for devmem
+debugging.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+gpio: mmio: Add DIRECT mode for shared access
+
+The generic MMIO GPIO library uses shadow registers for efficiency,
+but this breaks attempts by raspi-gpio to change other GPIOs in the
+same bank. Add a DIRECT mode that makes fewer assumptions about the
+existing register contents, but note that genuinely simultaneous
+accesses are likely to lose updates.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+gpio: brcmstb: Don't always clear interrupt mask
+
+If the GPIO controller is not being used as an interrupt source
+leave the interrupt mask register alone. On BCM2712 it might be used
+to generate interrupts to the VPU firmware, and on other devices it
+doesn't matter since no interrupts will be generated.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/gpio/Kconfig        |   2 +-
+ drivers/gpio/gpio-brcmstb.c |  14 ++--
+ drivers/gpio/gpio-mmio.c    | 124 ++++++++++++++++++++++++++++++++++--
+ include/linux/gpio/driver.h |   1 +
+ 4 files changed, 131 insertions(+), 10 deletions(-)
+
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -203,7 +203,7 @@ config GPIO_BCM_VIRT
+ config GPIO_BRCMSTB
+ 	tristate "BRCMSTB GPIO support"
+ 	default y if (ARCH_BRCMSTB || BMIPS_GENERIC)
+-	depends on OF_GPIO && (ARCH_BRCMSTB || BMIPS_GENERIC || COMPILE_TEST)
++	depends on OF_GPIO && (ARCH_BRCMSTB || BMIPS_GENERIC || ARCH_BCM2835 || COMPILE_TEST)
+ 	select GPIO_GENERIC
+ 	select IRQ_DOMAIN
+ 	help
+--- a/drivers/gpio/gpio-brcmstb.c
++++ b/drivers/gpio/gpio-brcmstb.c
+@@ -640,6 +640,8 @@ static int brcmstb_gpio_probe(struct pla
+ #if defined(CONFIG_MIPS) && defined(__BIG_ENDIAN)
+ 	flags = BGPIOF_BIG_ENDIAN_BYTE_ORDER;
+ #endif
++	if (of_property_read_bool(np, "brcm,gpio-direct"))
++	    flags |= BGPIOF_REG_DIRECT;
+ 
+ 	of_property_for_each_u32(np, "brcm,gpio-bank-widths", prop, p,
+ 			bank_width) {
+@@ -689,7 +691,9 @@ static int brcmstb_gpio_probe(struct pla
+ 		}
+ 
+ 		gc->owner = THIS_MODULE;
+-		gc->label = devm_kasprintf(dev, GFP_KERNEL, "%pOF", np);
++		gc->label = devm_kasprintf(dev, GFP_KERNEL, "gpio-brcmstb@%zx",
++					   (size_t)res->start +
++					   GIO_BANK_OFF(bank->id, 0));
+ 		if (!gc->label) {
+ 			err = -ENOMEM;
+ 			goto fail;
+@@ -698,7 +702,7 @@ static int brcmstb_gpio_probe(struct pla
+ 		gc->of_gpio_n_cells = 2;
+ 		gc->of_xlate = brcmstb_gpio_of_xlate;
+ 		/* not all ngpio lines are valid, will use bank width later */
+-		gc->ngpio = MAX_GPIO_PER_BANK;
++		gc->ngpio = bank_width;
+ 		gc->offset = bank->id * MAX_GPIO_PER_BANK;
+ 		if (priv->parent_irq > 0)
+ 			gc->to_irq = brcmstb_gpio_to_irq;
+@@ -707,8 +711,10 @@ static int brcmstb_gpio_probe(struct pla
+ 		 * Mask all interrupts by default, since wakeup interrupts may
+ 		 * be retained from S5 cold boot
+ 		 */
+-		need_wakeup_event |= !!__brcmstb_gpio_get_active_irqs(bank);
+-		gc->write_reg(reg_base + GIO_MASK(bank->id), 0);
++		if (priv->parent_irq > 0) {
++			need_wakeup_event |= !!__brcmstb_gpio_get_active_irqs(bank);
++			gc->write_reg(reg_base + GIO_MASK(bank->id), 0);
++		}
+ 
+ 		err = gpiochip_add_data(gc, bank);
+ 		if (err) {
+--- a/drivers/gpio/gpio-mmio.c
++++ b/drivers/gpio/gpio-mmio.c
+@@ -232,6 +232,25 @@ static void bgpio_set(struct gpio_chip *
+ 	raw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);
+ }
+ 
++static void bgpio_set_direct(struct gpio_chip *gc, unsigned int gpio, int val)
++{
++	unsigned long mask = bgpio_line2mask(gc, gpio);
++	unsigned long flags;
++
++	raw_spin_lock_irqsave(&gc->bgpio_lock, flags);
++
++	gc->bgpio_data = gc->read_reg(gc->reg_dat);
++
++	if (val)
++		gc->bgpio_data |= mask;
++	else
++		gc->bgpio_data &= ~mask;
++
++	gc->write_reg(gc->reg_dat, gc->bgpio_data);
++
++	raw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);
++}
++
+ static void bgpio_set_with_clear(struct gpio_chip *gc, unsigned int gpio,
+ 				 int val)
+ {
+@@ -324,6 +343,27 @@ static void bgpio_set_multiple_with_clea
+ 		gc->write_reg(gc->reg_clr, clear_mask);
+ }
+ 
++static void bgpio_set_multiple_direct(struct gpio_chip *gc,
++				      unsigned long *mask,
++				      unsigned long *bits)
++{
++	unsigned long flags;
++	unsigned long set_mask, clear_mask;
++
++	raw_spin_lock_irqsave(&gc->bgpio_lock, flags);
++
++	bgpio_multiple_get_masks(gc, mask, bits, &set_mask, &clear_mask);
++
++	gc->bgpio_data = gc->read_reg(gc->reg_dat);
++
++	gc->bgpio_data |= set_mask;
++	gc->bgpio_data &= ~clear_mask;
++
++	gc->write_reg(gc->reg_dat, gc->bgpio_data);
++
++	raw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);
++}
++
+ static int bgpio_simple_dir_in(struct gpio_chip *gc, unsigned int gpio)
+ {
+ 	return 0;
+@@ -361,6 +401,29 @@ static int bgpio_dir_in(struct gpio_chip
+ 	return 0;
+ }
+ 
++static int bgpio_dir_in_direct(struct gpio_chip *gc, unsigned int gpio)
++{
++	unsigned long flags;
++
++	raw_spin_lock_irqsave(&gc->bgpio_lock, flags);
++
++	if (gc->reg_dir_in)
++		gc->bgpio_dir = ~gc->read_reg(gc->reg_dir_in);
++	if (gc->reg_dir_out)
++		gc->bgpio_dir = gc->read_reg(gc->reg_dir_out);
++
++	gc->bgpio_dir &= ~bgpio_line2mask(gc, gpio);
++
++	if (gc->reg_dir_in)
++		gc->write_reg(gc->reg_dir_in, ~gc->bgpio_dir);
++	if (gc->reg_dir_out)
++		gc->write_reg(gc->reg_dir_out, gc->bgpio_dir);
++
++	raw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);
++
++	return 0;
++}
++
+ static int bgpio_get_dir(struct gpio_chip *gc, unsigned int gpio)
+ {
+ 	/* Return 0 if output, 1 if input */
+@@ -399,6 +462,28 @@ static void bgpio_dir_out(struct gpio_ch
+ 	raw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);
+ }
+ 
++static void bgpio_dir_out_direct(struct gpio_chip *gc, unsigned int gpio,
++				 int val)
++{
++	unsigned long flags;
++
++	raw_spin_lock_irqsave(&gc->bgpio_lock, flags);
++
++	if (gc->reg_dir_in)
++		gc->bgpio_dir = ~gc->read_reg(gc->reg_dir_in);
++	if (gc->reg_dir_out)
++		gc->bgpio_dir = gc->read_reg(gc->reg_dir_out);
++
++	gc->bgpio_dir |= bgpio_line2mask(gc, gpio);
++
++	if (gc->reg_dir_in)
++		gc->write_reg(gc->reg_dir_in, ~gc->bgpio_dir);
++	if (gc->reg_dir_out)
++		gc->write_reg(gc->reg_dir_out, gc->bgpio_dir);
++
++	raw_spin_unlock_irqrestore(&gc->bgpio_lock, flags);
++}
++
+ static int bgpio_dir_out_dir_first(struct gpio_chip *gc, unsigned int gpio,
+ 				   int val)
+ {
+@@ -415,6 +500,22 @@ static int bgpio_dir_out_val_first(struc
+ 	return 0;
+ }
+ 
++static int bgpio_dir_out_dir_first_direct(struct gpio_chip *gc,
++					  unsigned int gpio, int val)
++{
++	bgpio_dir_out_direct(gc, gpio, val);
++	gc->set(gc, gpio, val);
++	return 0;
++}
++
++static int bgpio_dir_out_val_first_direct(struct gpio_chip *gc,
++					  unsigned int gpio, int val)
++{
++	gc->set(gc, gpio, val);
++	bgpio_dir_out_direct(gc, gpio, val);
++	return 0;
++}
++
+ static int bgpio_setup_accessors(struct device *dev,
+ 				 struct gpio_chip *gc,
+ 				 bool byte_be)
+@@ -508,6 +609,9 @@ static int bgpio_setup_io(struct gpio_ch
+ 	} else if (flags & BGPIOF_NO_OUTPUT) {
+ 		gc->set = bgpio_set_none;
+ 		gc->set_multiple = NULL;
++	} else if (flags & BGPIOF_REG_DIRECT) {
++		gc->set = bgpio_set_direct;
++		gc->set_multiple = bgpio_set_multiple_direct;
+ 	} else {
+ 		gc->set = bgpio_set;
+ 		gc->set_multiple = bgpio_set_multiple;
+@@ -544,11 +648,21 @@ static int bgpio_setup_direction(struct
+ 	if (dirout || dirin) {
+ 		gc->reg_dir_out = dirout;
+ 		gc->reg_dir_in = dirin;
+-		if (flags & BGPIOF_NO_SET_ON_INPUT)
+-			gc->direction_output = bgpio_dir_out_dir_first;
+-		else
+-			gc->direction_output = bgpio_dir_out_val_first;
+-		gc->direction_input = bgpio_dir_in;
++		if (flags & BGPIOF_REG_DIRECT) {
++			if (flags & BGPIOF_NO_SET_ON_INPUT)
++				gc->direction_output =
++					bgpio_dir_out_dir_first_direct;
++			else
++				gc->direction_output =
++					bgpio_dir_out_val_first_direct;
++			gc->direction_input = bgpio_dir_in_direct;
++		} else {
++			if (flags & BGPIOF_NO_SET_ON_INPUT)
++				gc->direction_output = bgpio_dir_out_dir_first;
++			else
++				gc->direction_output = bgpio_dir_out_val_first;
++			gc->direction_input = bgpio_dir_in;
++		}
+ 		gc->get_direction = bgpio_get_dir;
+ 	} else {
+ 		if (flags & BGPIOF_NO_OUTPUT)
+--- a/include/linux/gpio/driver.h
++++ b/include/linux/gpio/driver.h
+@@ -690,6 +690,7 @@ int bgpio_init(struct gpio_chip *gc, str
+ #define BGPIOF_READ_OUTPUT_REG_SET	BIT(4) /* reg_set stores output value */
+ #define BGPIOF_NO_OUTPUT		BIT(5) /* only input */
+ #define BGPIOF_NO_SET_ON_INPUT		BIT(6)
++#define BGPIOF_REG_DIRECT		BIT(7) /* ignore shadow registers */
+ 
+ int gpiochip_irq_map(struct irq_domain *d, unsigned int irq,
+ 		     irq_hw_number_t hwirq);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0856-Allow-RESET_BRCMSTB-on-ARCH_BCM2835.patch b/target/linux/bcm27xx/patches-6.1/950-0856-Allow-RESET_BRCMSTB-on-ARCH_BCM2835.patch
new file mode 100644
index 0000000000..7e0886d7e6
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0856-Allow-RESET_BRCMSTB-on-ARCH_BCM2835.patch
@@ -0,0 +1,20 @@
+From 22ae3b2ee3293278e647877b269a5aebad3f077d Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 27 May 2021 11:46:30 +0100
+Subject: [PATCH] Allow RESET_BRCMSTB on ARCH_BCM2835
+
+---
+ drivers/reset/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/reset/Kconfig
++++ b/drivers/reset/Kconfig
+@@ -51,7 +51,7 @@ config RESET_BERLIN
+ 
+ config RESET_BRCMSTB
+ 	tristate "Broadcom STB reset controller"
+-	depends on ARCH_BRCMSTB || COMPILE_TEST
++	depends on ARCH_BRCMSTB || ARCH_BCM2835 || COMPILE_TEST
+ 	default ARCH_BRCMSTB
+ 	help
+ 	  This enables the reset controller driver for Broadcom STB SoCs using
diff --git a/target/linux/bcm27xx/patches-6.1/950-0857-pinctrl-bcm2712-pinctrl-pinconf-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0857-pinctrl-bcm2712-pinctrl-pinconf-driver.patch
new file mode 100644
index 0000000000..429c3e2fd2
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0857-pinctrl-bcm2712-pinctrl-pinconf-driver.patch
@@ -0,0 +1,1324 @@
+From af7e60a33f0b5ce84bffb69ba084ba1edd180195 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 9 Jun 2021 15:48:28 +0100
+Subject: [PATCH] pinctrl: bcm2712 pinctrl/pinconf driver
+
+pinctrl: bcm2712: Reject invalid pulls
+
+Reject attempts to set pulls on aon-sgpios, and fix pull shift
+values.
+
+pinctrl: bcm2712: Add 7712 support, fix 2712 count
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+pinctrl-bcm2712: add EMMC pins so pulls can be set
+
+These pins have pad controls but not mux controls. They look enough like
+GPIOs to squeeze in at the end of the list though.
+
+pinctrl: bcm2712: correct BCM2712C0 AON_GPIO pad pull control offset
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+pinctrl: bcm2712: on C0 the regular GPIO pad control register moves too
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+pinctrl: bcm2712: Implement (partially) pinconf_get
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+pinctrl: bcm2712: Convert to generic pinconf
+
+Remove the legacy brcm,* pin configuration support and replace it with
+a proper generic pinconf interface, using named functions instead of
+alt function numbers. This is nicer for users, less error-prone, and
+immune to some of the C0->D0 changes.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+pinctrl: bcm2712: Remove vestigial pull parameter
+
+Now the legacy brcm, pinconf parameters are no longer supported, this
+custom pin config parameter is not needed.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+pinctrl: bcm2712: Guard against bad func numbers
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+pinctrl: bcm2712: A better attempt at D0 support
+
+The BCM2712D0 sparse pinctrl maps play havoc with the old GPIO_REGS
+macro, so make the bit positions explicit. And delete the unwanted
+GPIO and pinmux declarations on D0.
+
+Note that a Pi 5 with D0 requires a separate DTS file with "bcm2712d0"
+compatible strings.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+pinctrl: bcm2712: Delete base register constants
+
+BCM2712D0 deletes many GPIOs and their associated mux and pad bits,
+so much so that the offsets to the start of the pad control registers
+changes. Remove the constant offsets from the *GPIO_REGS macros,
+compensating by adjusting the per-GPIO values.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/pinctrl/bcm/Kconfig           |    9 +
+ drivers/pinctrl/bcm/Makefile          |    1 +
+ drivers/pinctrl/bcm/pinctrl-bcm2712.c | 1216 +++++++++++++++++++++++++
+ 3 files changed, 1226 insertions(+)
+ create mode 100644 drivers/pinctrl/bcm/pinctrl-bcm2712.c
+
+--- a/drivers/pinctrl/bcm/Kconfig
++++ b/drivers/pinctrl/bcm/Kconfig
+@@ -3,6 +3,15 @@
+ # Broadcom pinctrl drivers
+ #
+ 
++config PINCTRL_BCM2712
++	bool "Broadcom BCM2712 PINCONF driver"
++	depends on OF && (ARCH_BCM2835 || ARCH_BRCMSTB || COMPILE_TEST)
++	select PINMUX
++	select PINCONF
++	select GENERIC_PINCONF
++	help
++	   Say Y here to enable the Broadcom BCM2835 GPIO driver.
++
+ config PINCTRL_BCM281XX
+ 	bool "Broadcom BCM281xx pinctrl driver"
+ 	depends on OF && (ARCH_BCM_MOBILE || COMPILE_TEST)
+--- a/drivers/pinctrl/bcm/Makefile
++++ b/drivers/pinctrl/bcm/Makefile
+@@ -1,6 +1,7 @@
+ # SPDX-License-Identifier: GPL-2.0
+ # Broadcom pinctrl support
+ 
++obj-$(CONFIG_PINCTRL_BCM2712)		+= pinctrl-bcm2712.o
+ obj-$(CONFIG_PINCTRL_BCM281XX)		+= pinctrl-bcm281xx.o
+ obj-$(CONFIG_PINCTRL_BCM2835)		+= pinctrl-bcm2835.o
+ obj-$(CONFIG_PINCTRL_BCM4908)		+= pinctrl-bcm4908.o
+--- /dev/null
++++ b/drivers/pinctrl/bcm/pinctrl-bcm2712.c
+@@ -0,0 +1,1216 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Driver for Broadcom BCM2712 GPIO units (pinctrl only)
++ *
++ * Copyright (C) 2021-3 Raspberry Pi Ltd.
++ * Copyright (C) 2012 Chris Boot, Simon Arlott, Stephen Warren
++ *
++ * Based heavily on the BCM2835 GPIO & pinctrl driver, which was inspired by:
++ * pinctrl-nomadik.c, please see original file for copyright information
++ * pinctrl-tegra.c, please see original file for copyright information
++ */
++
++#include <linux/bitmap.h>
++#include <linux/bug.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/err.h>
++#include <linux/io.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++#include <linux/of_address.h>
++#include <linux/of.h>
++#include <linux/pinctrl/consumer.h>
++#include <linux/pinctrl/machine.h>
++#include <linux/pinctrl/pinconf.h>
++#include <linux/pinctrl/pinctrl.h>
++#include <linux/pinctrl/pinmux.h>
++#include <linux/pinctrl/pinconf-generic.h>
++#include <linux/platform_device.h>
++#include <linux/seq_file.h>
++#include <linux/slab.h>
++#include <linux/spinlock.h>
++#include <linux/types.h>
++
++#define MODULE_NAME "pinctrl-bcm2712"
++
++/* Register offsets */
++
++#define BCM2712_PULL_NONE	0
++#define BCM2712_PULL_DOWN	1
++#define BCM2712_PULL_UP		2
++#define BCM2712_PULL_MASK	0x3
++
++#define BCM2712_FSEL_COUNT 9
++#define BCM2712_FSEL_MASK  0xf
++
++#define FUNC(f) \
++	[func_##f] = #f
++#define PIN(i, f1, f2, f3, f4, f5, f6, f7, f8) \
++	[i] = { \
++		.funcs = { \
++			func_##f1, \
++			func_##f2, \
++			func_##f3, \
++			func_##f4, \
++			func_##f5, \
++			func_##f6, \
++			func_##f7, \
++			func_##f8, \
++		}, \
++	}
++
++#define REG_BIT_INVALID 0xffff
++
++#define BIT_TO_REG(b) (((b) >> 5) << 2)
++#define BIT_TO_SHIFT(b) ((b) & 0x1f)
++
++#define GPIO_REGS(n, mr, mb, pr, pb) \
++	[n] = { ((mr)*4)*8 + (mb)*4, ((pr)*4)*8 + (pb)*2 }
++
++#define EMMC_REGS(n, r, b) \
++	[n] = { 0, ((r)*4)*8 + (b)*2 }
++
++#define AGPIO_REGS(n, mr, mb, pr, pb) \
++	[n] = { ((mr)*4)*8 + (mb)*4, ((pr)*4)*8 + (pb)*2 }
++
++#define SGPIO_REGS(n, mr, mb) \
++	[n+32] = { ((mr)*4)*8 + (mb)*4, REG_BIT_INVALID }
++
++#define GPIO_PIN(a) PINCTRL_PIN(a, "gpio" #a)
++#define AGPIO_PIN(a) PINCTRL_PIN(a, "aon_gpio" #a)
++#define SGPIO_PIN(a) PINCTRL_PIN(a+32, "aon_sgpio" #a)
++
++struct pin_regs {
++	u16 mux_bit;
++	u16 pad_bit;
++};
++
++struct bcm2712_pinctrl {
++	struct device *dev;
++	void __iomem *base;
++	struct pinctrl_dev *pctl_dev;
++	struct pinctrl_desc pctl_desc;
++	const struct pin_regs *pin_regs;
++	const struct bcm2712_pin_funcs *pin_funcs;
++	const char *const *gpio_groups;
++	struct pinctrl_gpio_range gpio_range;
++	spinlock_t lock;
++};
++
++struct bcm_plat_data {
++	const struct pinctrl_desc *pctl_desc;
++	const struct pinctrl_gpio_range *gpio_range;
++	const struct pin_regs *pin_regs;
++	const struct bcm2712_pin_funcs *pin_funcs;
++};
++
++struct bcm2712_pin_funcs {
++	u8 funcs[BCM2712_FSEL_COUNT - 1];
++};
++
++enum bcm2712_funcs {
++	func_gpio,
++	func_alt1,
++	func_alt2,
++	func_alt3,
++	func_alt4,
++	func_alt5,
++	func_alt6,
++	func_alt7,
++	func_alt8,
++	func_aon_cpu_standbyb,
++	func_aon_fp_4sec_resetb,
++	func_aon_gpclk,
++	func_aon_pwm,
++	func_arm_jtag,
++	func_aud_fs_clk0,
++	func_avs_pmu_bsc,
++	func_bsc_m0,
++	func_bsc_m1,
++	func_bsc_m2,
++	func_bsc_m3,
++	func_clk_observe,
++	func_ctl_hdmi_5v,
++	func_enet0,
++	func_enet0_mii,
++	func_enet0_rgmii,
++	func_ext_sc_clk,
++	func_fl0,
++	func_fl1,
++	func_gpclk0,
++	func_gpclk1,
++	func_gpclk2,
++	func_hdmi_tx0_auto_i2c,
++	func_hdmi_tx0_bsc,
++	func_hdmi_tx1_auto_i2c,
++	func_hdmi_tx1_bsc,
++	func_i2s_in,
++	func_i2s_out,
++	func_ir_in,
++	func_mtsif,
++	func_mtsif_alt,
++	func_mtsif_alt1,
++	func_pdm,
++	func_pkt,
++	func_pm_led_out,
++	func_sc0,
++	func_sd0,
++	func_sd2,
++	func_sd_card_a,
++	func_sd_card_b,
++	func_sd_card_c,
++	func_sd_card_d,
++	func_sd_card_e,
++	func_sd_card_f,
++	func_sd_card_g,
++	func_spdif_out,
++	func_spi_m,
++	func_spi_s,
++	func_sr_edm_sense,
++	func_te0,
++	func_te1,
++	func_tsio,
++	func_uart0,
++	func_uart1,
++	func_uart2,
++	func_usb_pwr,
++	func_usb_vbus,
++	func_uui,
++	func_vc_i2c0,
++	func_vc_i2c3,
++	func_vc_i2c4,
++	func_vc_i2c5,
++	func_vc_i2csl,
++	func_vc_pcm,
++	func_vc_pwm0,
++	func_vc_pwm1,
++	func_vc_spi0,
++	func_vc_spi3,
++	func_vc_spi4,
++	func_vc_spi5,
++	func_vc_uart0,
++	func_vc_uart2,
++	func_vc_uart3,
++	func_vc_uart4,
++	func__,
++	func_count = func__
++};
++
++static const struct pin_regs bcm2712_c0_gpio_pin_regs[] = {
++	GPIO_REGS(0, 0, 0, 7, 7),
++	GPIO_REGS(1, 0, 1, 7, 8),
++	GPIO_REGS(2, 0, 2, 7, 9),
++	GPIO_REGS(3, 0, 3, 7, 10),
++	GPIO_REGS(4, 0, 4, 7, 11),
++	GPIO_REGS(5, 0, 5, 7, 12),
++	GPIO_REGS(6, 0, 6, 7, 13),
++	GPIO_REGS(7, 0, 7, 7, 14),
++	GPIO_REGS(8, 1, 0, 8, 0),
++	GPIO_REGS(9, 1, 1, 8, 1),
++	GPIO_REGS(10, 1, 2, 8, 2),
++	GPIO_REGS(11, 1, 3, 8, 3),
++	GPIO_REGS(12, 1, 4, 8, 4),
++	GPIO_REGS(13, 1, 5, 8, 5),
++	GPIO_REGS(14, 1, 6, 8, 6),
++	GPIO_REGS(15, 1, 7, 8, 7),
++	GPIO_REGS(16, 2, 0, 8, 8),
++	GPIO_REGS(17, 2, 1, 8, 9),
++	GPIO_REGS(18, 2, 2, 8, 10),
++	GPIO_REGS(19, 2, 3, 8, 11),
++	GPIO_REGS(20, 2, 4, 8, 12),
++	GPIO_REGS(21, 2, 5, 8, 13),
++	GPIO_REGS(22, 2, 6, 8, 14),
++	GPIO_REGS(23, 2, 7, 9, 0),
++	GPIO_REGS(24, 3, 0, 9, 1),
++	GPIO_REGS(25, 3, 1, 9, 2),
++	GPIO_REGS(26, 3, 2, 9, 3),
++	GPIO_REGS(27, 3, 3, 9, 4),
++	GPIO_REGS(28, 3, 4, 9, 5),
++	GPIO_REGS(29, 3, 5, 9, 6),
++	GPIO_REGS(30, 3, 6, 9, 7),
++	GPIO_REGS(31, 3, 7, 9, 8),
++	GPIO_REGS(32, 4, 0, 9, 9),
++	GPIO_REGS(33, 4, 1, 9, 10),
++	GPIO_REGS(34, 4, 2, 9, 11),
++	GPIO_REGS(35, 4, 3, 9, 12),
++	GPIO_REGS(36, 4, 4, 9, 13),
++	GPIO_REGS(37, 4, 5, 9, 14),
++	GPIO_REGS(38, 4, 6, 10, 0),
++	GPIO_REGS(39, 4, 7, 10, 1),
++	GPIO_REGS(40, 5, 0, 10, 2),
++	GPIO_REGS(41, 5, 1, 10, 3),
++	GPIO_REGS(42, 5, 2, 10, 4),
++	GPIO_REGS(43, 5, 3, 10, 5),
++	GPIO_REGS(44, 5, 4, 10, 6),
++	GPIO_REGS(45, 5, 5, 10, 7),
++	GPIO_REGS(46, 5, 6, 10, 8),
++	GPIO_REGS(47, 5, 7, 10, 9),
++	GPIO_REGS(48, 6, 0, 10, 10),
++	GPIO_REGS(49, 6, 1, 10, 11),
++	GPIO_REGS(50, 6, 2, 10, 12),
++	GPIO_REGS(51, 6, 3, 10, 13),
++	GPIO_REGS(52, 6, 4, 10, 14),
++	GPIO_REGS(53, 6, 5, 11, 0),
++	EMMC_REGS(54, 11, 1), /* EMMC_CMD */
++	EMMC_REGS(55, 11, 2), /* EMMC_DS */
++	EMMC_REGS(56, 11, 3), /* EMMC_CLK */
++	EMMC_REGS(57, 11, 4), /* EMMC_DAT0 */
++	EMMC_REGS(58, 11, 5), /* EMMC_DAT1 */
++	EMMC_REGS(59, 11, 6), /* EMMC_DAT2 */
++	EMMC_REGS(60, 11, 7), /* EMMC_DAT3 */
++	EMMC_REGS(61, 11, 8), /* EMMC_DAT4 */
++	EMMC_REGS(62, 11, 9), /* EMMC_DAT5 */
++	EMMC_REGS(63, 11, 10), /* EMMC_DAT6 */
++	EMMC_REGS(64, 11, 11), /* EMMC_DAT7 */
++};
++
++static struct pin_regs bcm2712_c0_aon_gpio_pin_regs[] = {
++	AGPIO_REGS(0, 3, 0, 6, 10),
++	AGPIO_REGS(1, 3, 1, 6, 11),
++	AGPIO_REGS(2, 3, 2, 6, 12),
++	AGPIO_REGS(3, 3, 3, 6, 13),
++	AGPIO_REGS(4, 3, 4, 6, 14),
++	AGPIO_REGS(5, 3, 5, 7, 0),
++	AGPIO_REGS(6, 3, 6, 7, 1),
++	AGPIO_REGS(7, 3, 7, 7, 2),
++	AGPIO_REGS(8, 4, 0, 7, 3),
++	AGPIO_REGS(9, 4, 1, 7, 4),
++	AGPIO_REGS(10, 4, 2, 7, 5),
++	AGPIO_REGS(11, 4, 3, 7, 6),
++	AGPIO_REGS(12, 4, 4, 7, 7),
++	AGPIO_REGS(13, 4, 5, 7, 8),
++	AGPIO_REGS(14, 4, 6, 7, 9),
++	AGPIO_REGS(15, 4, 7, 7, 10),
++	AGPIO_REGS(16, 5, 0, 7, 11),
++	SGPIO_REGS(0, 0, 0),
++	SGPIO_REGS(1, 0, 1),
++	SGPIO_REGS(2, 0, 2),
++	SGPIO_REGS(3, 0, 3),
++	SGPIO_REGS(4, 1, 0),
++	SGPIO_REGS(5, 2, 0),
++};
++
++static const struct pinctrl_pin_desc bcm2712_c0_gpio_pins[] = {
++	GPIO_PIN(0),
++	GPIO_PIN(1),
++	GPIO_PIN(2),
++	GPIO_PIN(3),
++	GPIO_PIN(4),
++	GPIO_PIN(5),
++	GPIO_PIN(6),
++	GPIO_PIN(7),
++	GPIO_PIN(8),
++	GPIO_PIN(9),
++	GPIO_PIN(10),
++	GPIO_PIN(11),
++	GPIO_PIN(12),
++	GPIO_PIN(13),
++	GPIO_PIN(14),
++	GPIO_PIN(15),
++	GPIO_PIN(16),
++	GPIO_PIN(17),
++	GPIO_PIN(18),
++	GPIO_PIN(19),
++	GPIO_PIN(20),
++	GPIO_PIN(21),
++	GPIO_PIN(22),
++	GPIO_PIN(23),
++	GPIO_PIN(24),
++	GPIO_PIN(25),
++	GPIO_PIN(26),
++	GPIO_PIN(27),
++	GPIO_PIN(28),
++	GPIO_PIN(29),
++	GPIO_PIN(30),
++	GPIO_PIN(31),
++	GPIO_PIN(32),
++	GPIO_PIN(33),
++	GPIO_PIN(34),
++	GPIO_PIN(35),
++	GPIO_PIN(36),
++	GPIO_PIN(37),
++	GPIO_PIN(38),
++	GPIO_PIN(39),
++	GPIO_PIN(40),
++	GPIO_PIN(41),
++	GPIO_PIN(42),
++	GPIO_PIN(43),
++	GPIO_PIN(44),
++	GPIO_PIN(45),
++	GPIO_PIN(46),
++	GPIO_PIN(47),
++	GPIO_PIN(48),
++	GPIO_PIN(49),
++	GPIO_PIN(50),
++	GPIO_PIN(51),
++	GPIO_PIN(52),
++	GPIO_PIN(53),
++	PINCTRL_PIN(54, "emmc_cmd"),
++	PINCTRL_PIN(55, "emmc_ds"),
++	PINCTRL_PIN(56, "emmc_clk"),
++	PINCTRL_PIN(57, "emmc_dat0"),
++	PINCTRL_PIN(58, "emmc_dat1"),
++	PINCTRL_PIN(59, "emmc_dat2"),
++	PINCTRL_PIN(60, "emmc_dat3"),
++	PINCTRL_PIN(61, "emmc_dat4"),
++	PINCTRL_PIN(62, "emmc_dat5"),
++	PINCTRL_PIN(63, "emmc_dat6"),
++	PINCTRL_PIN(64, "emmc_dat7"),
++};
++
++static struct pinctrl_pin_desc bcm2712_c0_aon_gpio_pins[] = {
++	AGPIO_PIN(0),
++	AGPIO_PIN(1),
++	AGPIO_PIN(2),
++	AGPIO_PIN(3),
++	AGPIO_PIN(4),
++	AGPIO_PIN(5),
++	AGPIO_PIN(6),
++	AGPIO_PIN(7),
++	AGPIO_PIN(8),
++	AGPIO_PIN(9),
++	AGPIO_PIN(10),
++	AGPIO_PIN(11),
++	AGPIO_PIN(12),
++	AGPIO_PIN(13),
++	AGPIO_PIN(14),
++	AGPIO_PIN(15),
++	AGPIO_PIN(16),
++	SGPIO_PIN(0),
++	SGPIO_PIN(1),
++	SGPIO_PIN(2),
++	SGPIO_PIN(3),
++	SGPIO_PIN(4),
++	SGPIO_PIN(5),
++};
++
++static const struct pin_regs bcm2712_d0_gpio_pin_regs[] = {
++	GPIO_REGS(1, 0, 0, 4, 5),
++	GPIO_REGS(2, 0, 1, 4, 6),
++	GPIO_REGS(3, 0, 2, 4, 7),
++	GPIO_REGS(4, 0, 3, 4, 8),
++	GPIO_REGS(10, 0, 4, 4, 9),
++	GPIO_REGS(11, 0, 5, 4, 10),
++	GPIO_REGS(12, 0, 6, 4, 11),
++	GPIO_REGS(13, 0, 7, 4, 12),
++	GPIO_REGS(14, 1, 0, 4, 13),
++	GPIO_REGS(15, 1, 1, 4, 14),
++	GPIO_REGS(18, 1, 2, 5, 0),
++	GPIO_REGS(19, 1, 3, 5, 1),
++	GPIO_REGS(20, 1, 4, 5, 2),
++	GPIO_REGS(21, 1, 5, 5, 3),
++	GPIO_REGS(22, 1, 6, 5, 4),
++	GPIO_REGS(23, 1, 7, 5, 5),
++	GPIO_REGS(24, 2, 0, 5, 6),
++	GPIO_REGS(25, 2, 1, 5, 7),
++	GPIO_REGS(26, 2, 2, 5, 8),
++	GPIO_REGS(27, 2, 3, 5, 9),
++	GPIO_REGS(28, 2, 4, 5, 10),
++	GPIO_REGS(29, 2, 5, 5, 11),
++	GPIO_REGS(30, 2, 6, 5, 12),
++	GPIO_REGS(31, 2, 7, 5, 13),
++	GPIO_REGS(32, 3, 0, 5, 14),
++	GPIO_REGS(33, 3, 1, 6, 0),
++	GPIO_REGS(34, 3, 2, 6, 1),
++	GPIO_REGS(35, 3, 3, 6, 2),
++};
++
++static struct pin_regs bcm2712_d0_aon_gpio_pin_regs[] = {
++	AGPIO_REGS(0, 3, 0, 5, 9),
++	AGPIO_REGS(1, 3, 1, 5, 10),
++	AGPIO_REGS(2, 3, 2, 5, 11),
++	AGPIO_REGS(3, 3, 3, 5, 12),
++	AGPIO_REGS(4, 3, 4, 5, 13),
++	AGPIO_REGS(5, 3, 5, 5, 14),
++	AGPIO_REGS(6, 3, 6, 6, 0),
++	AGPIO_REGS(8, 3, 7, 6, 1),
++	AGPIO_REGS(9, 4, 0, 6, 2),
++	AGPIO_REGS(12, 4, 1, 6, 3),
++	AGPIO_REGS(13, 4, 2, 6, 4),
++	AGPIO_REGS(14, 4, 3, 6, 5),
++	SGPIO_REGS(0, 0, 0),
++	SGPIO_REGS(1, 0, 1),
++	SGPIO_REGS(2, 0, 2),
++	SGPIO_REGS(3, 0, 3),
++	SGPIO_REGS(4, 1, 0),
++	SGPIO_REGS(5, 2, 0),
++};
++
++static const struct pinctrl_pin_desc bcm2712_d0_gpio_pins[] = {
++	GPIO_PIN(1),
++	GPIO_PIN(2),
++	GPIO_PIN(3),
++	GPIO_PIN(4),
++	GPIO_PIN(10),
++	GPIO_PIN(11),
++	GPIO_PIN(12),
++	GPIO_PIN(13),
++	GPIO_PIN(14),
++	GPIO_PIN(15),
++	GPIO_PIN(18),
++	GPIO_PIN(19),
++	GPIO_PIN(20),
++	GPIO_PIN(21),
++	GPIO_PIN(22),
++	GPIO_PIN(23),
++	GPIO_PIN(24),
++	GPIO_PIN(25),
++	GPIO_PIN(26),
++	GPIO_PIN(27),
++	GPIO_PIN(28),
++	GPIO_PIN(29),
++	GPIO_PIN(30),
++	GPIO_PIN(31),
++	GPIO_PIN(32),
++	GPIO_PIN(33),
++	GPIO_PIN(34),
++	GPIO_PIN(35),
++};
++
++static struct pinctrl_pin_desc bcm2712_d0_aon_gpio_pins[] = {
++	AGPIO_PIN(0),
++	AGPIO_PIN(1),
++	AGPIO_PIN(2),
++	AGPIO_PIN(3),
++	AGPIO_PIN(4),
++	AGPIO_PIN(5),
++	AGPIO_PIN(6),
++	AGPIO_PIN(8),
++	AGPIO_PIN(9),
++	AGPIO_PIN(12),
++	AGPIO_PIN(13),
++	AGPIO_PIN(14),
++	SGPIO_PIN(0),
++	SGPIO_PIN(1),
++	SGPIO_PIN(2),
++	SGPIO_PIN(3),
++	SGPIO_PIN(4),
++	SGPIO_PIN(5),
++};
++
++static const char * const bcm2712_func_names[] = {
++	FUNC(gpio),
++	FUNC(alt1),
++	FUNC(alt2),
++	FUNC(alt3),
++	FUNC(alt4),
++	FUNC(alt5),
++	FUNC(alt6),
++	FUNC(alt7),
++	FUNC(alt8),
++	FUNC(aon_cpu_standbyb),
++	FUNC(aon_fp_4sec_resetb),
++	FUNC(aon_gpclk),
++	FUNC(aon_pwm),
++	FUNC(arm_jtag),
++	FUNC(aud_fs_clk0),
++	FUNC(avs_pmu_bsc),
++	FUNC(bsc_m0),
++	FUNC(bsc_m1),
++	FUNC(bsc_m2),
++	FUNC(bsc_m3),
++	FUNC(clk_observe),
++	FUNC(ctl_hdmi_5v),
++	FUNC(enet0),
++	FUNC(enet0_mii),
++	FUNC(enet0_rgmii),
++	FUNC(ext_sc_clk),
++	FUNC(fl0),
++	FUNC(fl1),
++	FUNC(gpclk0),
++	FUNC(gpclk1),
++	FUNC(gpclk2),
++	FUNC(hdmi_tx0_auto_i2c),
++	FUNC(hdmi_tx0_bsc),
++	FUNC(hdmi_tx1_auto_i2c),
++	FUNC(hdmi_tx1_bsc),
++	FUNC(i2s_in),
++	FUNC(i2s_out),
++	FUNC(ir_in),
++	FUNC(mtsif),
++	FUNC(mtsif_alt),
++	FUNC(mtsif_alt1),
++	FUNC(pdm),
++	FUNC(pkt),
++	FUNC(pm_led_out),
++	FUNC(sc0),
++	FUNC(sd0),
++	FUNC(sd2),
++	FUNC(sd_card_a),
++	FUNC(sd_card_b),
++	FUNC(sd_card_c),
++	FUNC(sd_card_d),
++	FUNC(sd_card_e),
++	FUNC(sd_card_f),
++	FUNC(sd_card_g),
++	FUNC(spdif_out),
++	FUNC(spi_m),
++	FUNC(spi_s),
++	FUNC(sr_edm_sense),
++	FUNC(te0),
++	FUNC(te1),
++	FUNC(tsio),
++	FUNC(uart0),
++	FUNC(uart1),
++	FUNC(uart2),
++	FUNC(usb_pwr),
++	FUNC(usb_vbus),
++	FUNC(uui),
++	FUNC(vc_i2c0),
++	FUNC(vc_i2c3),
++	FUNC(vc_i2c4),
++	FUNC(vc_i2c5),
++	FUNC(vc_i2csl),
++	FUNC(vc_pcm),
++	FUNC(vc_pwm0),
++	FUNC(vc_pwm1),
++	FUNC(vc_spi0),
++	FUNC(vc_spi3),
++	FUNC(vc_spi4),
++	FUNC(vc_spi5),
++	FUNC(vc_uart0),
++	FUNC(vc_uart2),
++	FUNC(vc_uart3),
++	FUNC(vc_uart4),
++};
++
++static const struct bcm2712_pin_funcs bcm2712_c0_aon_gpio_pin_funcs[] = {
++	PIN(0, ir_in, vc_spi0, vc_uart3, vc_i2c3, te0, vc_i2c0, _, _),
++	PIN(1, vc_pwm0, vc_spi0, vc_uart3, vc_i2c3, te1, aon_pwm, vc_i2c0, vc_pwm1),
++	PIN(2, vc_pwm0, vc_spi0, vc_uart3, ctl_hdmi_5v, fl0, aon_pwm, ir_in, vc_pwm1),
++	PIN(3, ir_in, vc_spi0, vc_uart3, aon_fp_4sec_resetb, fl1, sd_card_g, aon_gpclk, _),
++	PIN(4, gpclk0, vc_spi0, vc_i2csl, aon_gpclk, pm_led_out, aon_pwm, sd_card_g, vc_pwm0),
++	PIN(5, gpclk1, ir_in, vc_i2csl, clk_observe, aon_pwm, sd_card_g, vc_pwm0, _),
++	PIN(6, uart1, vc_uart4, gpclk2, ctl_hdmi_5v, vc_uart0, vc_spi3, _, _),
++	PIN(7, uart1, vc_uart4, gpclk0, aon_pwm, vc_uart0, vc_spi3, _, _),
++	PIN(8, uart1, vc_uart4, vc_i2csl, ctl_hdmi_5v, vc_uart0, vc_spi3, _, _),
++	PIN(9, uart1, vc_uart4, vc_i2csl, aon_pwm, vc_uart0, vc_spi3, _, _),
++	PIN(10, tsio, ctl_hdmi_5v, sc0, spdif_out, vc_spi5, usb_pwr, aon_gpclk, sd_card_f),
++	PIN(11, tsio, uart0, sc0, aud_fs_clk0, vc_spi5, usb_vbus, vc_uart2, sd_card_f),
++	PIN(12, tsio, uart0, vc_uart0, tsio, vc_spi5, usb_pwr, vc_uart2, sd_card_f),
++	PIN(13, bsc_m1, uart0, vc_uart0, uui, vc_spi5, arm_jtag, vc_uart2, vc_i2c3),
++	PIN(14, bsc_m1, uart0, vc_uart0, uui, vc_spi5, arm_jtag, vc_uart2, vc_i2c3),
++	PIN(15, ir_in, aon_fp_4sec_resetb, vc_uart0, pm_led_out, ctl_hdmi_5v, aon_pwm, aon_gpclk, _),
++	PIN(16, aon_cpu_standbyb, gpclk0, pm_led_out, ctl_hdmi_5v, vc_pwm0, usb_pwr, aud_fs_clk0, _),
++};
++
++static const struct bcm2712_pin_funcs bcm2712_c0_aon_sgpio_pin_funcs[] = {
++	PIN(0, hdmi_tx0_bsc, hdmi_tx0_auto_i2c, bsc_m0, vc_i2c0, _, _, _, _),
++	PIN(1, hdmi_tx0_bsc, hdmi_tx0_auto_i2c, bsc_m0, vc_i2c0, _, _, _, _),
++	PIN(2, hdmi_tx1_bsc, hdmi_tx1_auto_i2c, bsc_m1, vc_i2c4, ctl_hdmi_5v, _, _, _),
++	PIN(3, hdmi_tx1_bsc, hdmi_tx1_auto_i2c, bsc_m1, vc_i2c4, _, _, _, _),
++	PIN(4, avs_pmu_bsc, bsc_m2, vc_i2c5, ctl_hdmi_5v, _, _, _, _),
++	PIN(5, avs_pmu_bsc, bsc_m2, vc_i2c5, _, _, _, _, _),
++};
++
++static const struct bcm2712_pin_funcs bcm2712_c0_gpio_pin_funcs[] = {
++	PIN(0, bsc_m3, vc_i2c0, gpclk0, enet0, vc_pwm1, vc_spi0, ir_in, _),
++	PIN(1, bsc_m3, vc_i2c0, gpclk1, enet0, vc_pwm1, sr_edm_sense, vc_spi0, vc_uart3),
++	PIN(2, pdm, i2s_in, gpclk2, vc_spi4, pkt, vc_spi0, vc_uart3, _),
++	PIN(3, pdm, i2s_in, vc_spi4, pkt, vc_spi0, vc_uart3, _, _),
++	PIN(4, pdm, i2s_in, arm_jtag, vc_spi4, pkt, vc_spi0, vc_uart3, _),
++	PIN(5, pdm, vc_i2c3, arm_jtag, sd_card_e, vc_spi4, pkt, vc_pcm, vc_i2c5),
++	PIN(6, pdm, vc_i2c3, arm_jtag, sd_card_e, vc_spi4, pkt, vc_pcm, vc_i2c5),
++	PIN(7, i2s_out, spdif_out, arm_jtag, sd_card_e, vc_i2c3, enet0_rgmii, vc_pcm, vc_spi4),
++	PIN(8, i2s_out, aud_fs_clk0, arm_jtag, sd_card_e, vc_i2c3, enet0_mii, vc_pcm, vc_spi4),
++	PIN(9, i2s_out, aud_fs_clk0, arm_jtag, sd_card_e, enet0_mii, sd_card_c, vc_spi4, _),
++	PIN(10, bsc_m3, mtsif_alt1, i2s_in, i2s_out, vc_spi5, enet0_mii, sd_card_c, vc_spi4),
++	PIN(11, bsc_m3, mtsif_alt1, i2s_in, i2s_out, vc_spi5, enet0_mii, sd_card_c, vc_spi4),
++	PIN(12, spi_s, mtsif_alt1, i2s_in, i2s_out, vc_spi5, vc_i2csl, sd0, sd_card_d),
++	PIN(13, spi_s, mtsif_alt1, i2s_out, usb_vbus, vc_spi5, vc_i2csl, sd0, sd_card_d),
++	PIN(14, spi_s, vc_i2csl, enet0_rgmii, arm_jtag, vc_spi5, vc_pwm0, vc_i2c4, sd_card_d),
++	PIN(15, spi_s, vc_i2csl, vc_spi3, arm_jtag, vc_pwm0, vc_i2c4, gpclk0, _),
++	PIN(16, sd_card_b, i2s_out, vc_spi3, i2s_in, sd0, enet0_rgmii, gpclk1, _),
++	PIN(17, sd_card_b, i2s_out, vc_spi3, i2s_in, ext_sc_clk, sd0, enet0_rgmii, gpclk2),
++	PIN(18, sd_card_b, i2s_out, vc_spi3, i2s_in, sd0, enet0_rgmii, vc_pwm1, _),
++	PIN(19, sd_card_b, usb_pwr, vc_spi3, pkt, spdif_out, sd0, ir_in, vc_pwm1),
++	PIN(20, sd_card_b, uui, vc_uart0, arm_jtag, uart2, usb_pwr, vc_pcm, vc_uart4),
++	PIN(21, usb_pwr, uui, vc_uart0, arm_jtag, uart2, sd_card_b, vc_pcm, vc_uart4),
++	PIN(22, usb_pwr, enet0, vc_uart0, mtsif, uart2, usb_vbus, vc_pcm, vc_i2c5),
++	PIN(23, usb_vbus, enet0, vc_uart0, mtsif, uart2, i2s_out, vc_pcm, vc_i2c5),
++	PIN(24, mtsif, pkt, uart0, enet0_rgmii, enet0_rgmii, vc_i2c4, vc_uart3, _),
++	PIN(25, mtsif, pkt, sc0, uart0, enet0_rgmii, enet0_rgmii, vc_i2c4, vc_uart3),
++	PIN(26, mtsif, pkt, sc0, uart0, enet0_rgmii, vc_uart4, vc_spi5, _),
++	PIN(27, mtsif, pkt, sc0, uart0, enet0_rgmii, vc_uart4, vc_spi5, _),
++	PIN(28, mtsif, pkt, sc0, enet0_rgmii, vc_uart4, vc_spi5, _, _),
++	PIN(29, mtsif, pkt, sc0, enet0_rgmii, vc_uart4, vc_spi5, _, _),
++	PIN(30, mtsif, pkt, sc0, sd2, enet0_rgmii, gpclk0, vc_pwm0, _),
++	PIN(31, mtsif, pkt, sc0, sd2, enet0_rgmii, vc_spi3, vc_pwm0, _),
++	PIN(32, mtsif, pkt, sc0, sd2, enet0_rgmii, vc_spi3, vc_uart3, _),
++	PIN(33, mtsif, pkt, sd2, enet0_rgmii, vc_spi3, vc_uart3, _, _),
++	PIN(34, mtsif, pkt, ext_sc_clk, sd2, enet0_rgmii, vc_spi3, vc_i2c5, _),
++	PIN(35, mtsif, pkt, sd2, enet0_rgmii, vc_spi3, vc_i2c5, _, _),
++	PIN(36, sd0, mtsif, sc0, i2s_in, vc_uart3, vc_uart2, _, _),
++	PIN(37, sd0, mtsif, sc0, vc_spi0, i2s_in, vc_uart3, vc_uart2, _),
++	PIN(38, sd0, mtsif_alt, sc0, vc_spi0, i2s_in, vc_uart3, vc_uart2, _),
++	PIN(39, sd0, mtsif_alt, sc0, vc_spi0, vc_uart3, vc_uart2, _, _),
++	PIN(40, sd0, mtsif_alt, sc0, vc_spi0, bsc_m3, _, _, _),
++	PIN(41, sd0, mtsif_alt, sc0, vc_spi0, bsc_m3, _, _, _),
++	PIN(42, vc_spi0, mtsif_alt, vc_i2c0, sd_card_a, mtsif_alt1, arm_jtag, pdm, spi_m),
++	PIN(43, vc_spi0, mtsif_alt, vc_i2c0, sd_card_a, mtsif_alt1, arm_jtag, pdm, spi_m),
++	PIN(44, vc_spi0, mtsif_alt, enet0, sd_card_a, mtsif_alt1, arm_jtag, pdm, spi_m),
++	PIN(45, vc_spi0, mtsif_alt, enet0, sd_card_a, mtsif_alt1, arm_jtag, pdm, spi_m),
++	PIN(46, vc_spi0, mtsif_alt, sd_card_a, mtsif_alt1, arm_jtag, pdm, spi_m, _),
++	PIN(47, enet0, mtsif_alt, i2s_out, mtsif_alt1, arm_jtag, _, _, _),
++	PIN(48, sc0, usb_pwr, spdif_out, mtsif, _, _, _, _),
++	PIN(49, sc0, usb_pwr, aud_fs_clk0, mtsif, _, _, _, _),
++	PIN(50, sc0, usb_vbus, sc0, _, _, _, _, _),
++	PIN(51, sc0, enet0, sc0, sr_edm_sense, _, _, _, _),
++	PIN(52, sc0, enet0, vc_pwm1, _, _, _, _, _),
++	PIN(53, sc0, enet0_rgmii, ext_sc_clk, _, _, _, _, _),
++};
++
++static const struct bcm2712_pin_funcs bcm2712_d0_aon_gpio_pin_funcs[] = {
++	PIN(0, ir_in, vc_spi0, vc_uart0, vc_i2c3, uart0, vc_i2c0, _, _),
++	PIN(1, vc_pwm0, vc_spi0, vc_uart0, vc_i2c3, uart0, aon_pwm, vc_i2c0, vc_pwm1),
++	PIN(2, vc_pwm0, vc_spi0, vc_uart0, ctl_hdmi_5v, uart0, aon_pwm, ir_in, vc_pwm1),
++	PIN(3, ir_in, vc_spi0, vc_uart0, uart0, sd_card_g, aon_gpclk, _, _),
++	PIN(4, gpclk0, vc_spi0, pm_led_out, aon_pwm, sd_card_g, vc_pwm0, _, _),
++	PIN(5, gpclk1, ir_in, aon_pwm, sd_card_g, vc_pwm0, _, _, _),
++	PIN(6, uart1, vc_uart2, ctl_hdmi_5v, gpclk2, vc_spi3, _, _, _),
++	PIN(7, _, _, _, _, _, _, _, _),
++	PIN(8, uart1, vc_uart2, ctl_hdmi_5v, vc_spi0, vc_spi3, _, _, _),
++	PIN(9, uart1, vc_uart2, vc_uart0, aon_pwm, vc_spi0, vc_uart2, vc_spi3, _),
++	PIN(10, _, _, _, _, _, _, _, _),
++	PIN(11, _, _, _, _, _, _, _, _),
++	PIN(12, uart1, vc_uart2, vc_uart0, vc_spi0, usb_pwr, vc_uart2, vc_spi3, _),
++	PIN(13, bsc_m1, vc_uart0, uui, vc_spi0, arm_jtag, vc_uart2, vc_i2c3, _),
++	PIN(14, bsc_m1, aon_gpclk, vc_uart0, uui, vc_spi0, arm_jtag, vc_uart2, vc_i2c3),
++};
++
++static const struct bcm2712_pin_funcs bcm2712_d0_aon_sgpio_pin_funcs[] = {
++	PIN(0, hdmi_tx0_bsc, hdmi_tx0_auto_i2c, bsc_m0, vc_i2c0, _, _, _, _),
++	PIN(1, hdmi_tx0_bsc, hdmi_tx0_auto_i2c, bsc_m0, vc_i2c0, _, _, _, _),
++	PIN(2, hdmi_tx1_bsc, hdmi_tx1_auto_i2c, bsc_m1, vc_i2c0, ctl_hdmi_5v, _, _, _),
++	PIN(3, hdmi_tx1_bsc, hdmi_tx1_auto_i2c, bsc_m1, vc_i2c0, _, _, _, _),
++	PIN(4, avs_pmu_bsc, bsc_m2, vc_i2c3, ctl_hdmi_5v, _, _, _, _),
++	PIN(5, avs_pmu_bsc, bsc_m2, vc_i2c3, _, _, _, _, _),
++};
++
++static const struct bcm2712_pin_funcs bcm2712_d0_gpio_pin_funcs[] = {
++	PIN(1, vc_i2c0, usb_pwr, gpclk0, sd_card_e, vc_spi3, sr_edm_sense, vc_spi0, vc_uart0),
++	PIN(2, vc_i2c0, usb_pwr, gpclk1, sd_card_e, vc_spi3, clk_observe, vc_spi0, vc_uart0),
++	PIN(3, vc_i2c3, usb_vbus, gpclk2, sd_card_e, vc_spi3, vc_spi0, vc_uart0, _),
++	PIN(4, vc_i2c3, vc_pwm1, vc_spi3, sd_card_e, vc_spi3, vc_spi0, vc_uart0, _),
++	PIN(10, bsc_m3, vc_pwm1, vc_spi3, sd_card_e, vc_spi3, gpclk0, _, _),
++	PIN(11, bsc_m3, vc_spi3, clk_observe, sd_card_c, gpclk1, _, _, _),
++	PIN(12, spi_s, vc_spi3, sd_card_c, sd_card_d, _, _, _, _),
++	PIN(13, spi_s, vc_spi3, sd_card_c, sd_card_d, _, _, _, _),
++	PIN(14, spi_s, uui, arm_jtag, vc_pwm0, vc_i2c0, sd_card_d, _, _),
++	PIN(15, spi_s, uui, arm_jtag, vc_pwm0, vc_i2c0, gpclk0, _, _),
++	PIN(18, sd_card_f, vc_pwm1, _, _, _, _, _, _),
++	PIN(19, sd_card_f, usb_pwr, vc_pwm1, _, _, _, _, _),
++	PIN(20, vc_i2c3, uui, vc_uart0, arm_jtag, vc_uart2, _, _, _),
++	PIN(21, vc_i2c3, uui, vc_uart0, arm_jtag, vc_uart2, _, _, _),
++	PIN(22, sd_card_f, vc_uart0, vc_i2c3, _, _, _, _, _),
++	PIN(23, vc_uart0, vc_i2c3, _, _, _, _, _, _),
++	PIN(24, sd_card_b, vc_spi0, arm_jtag, uart0, usb_pwr, vc_uart2, vc_uart0, _),
++	PIN(25, sd_card_b, vc_spi0, arm_jtag, uart0, usb_pwr, vc_uart2, vc_uart0, _),
++	PIN(26, sd_card_b, vc_spi0, arm_jtag, uart0, usb_vbus, vc_uart2, vc_spi0, _),
++	PIN(27, sd_card_b, vc_spi0, arm_jtag, uart0, vc_uart2, vc_spi0, _, _),
++	PIN(28, sd_card_b, vc_spi0, arm_jtag, vc_i2c0, vc_spi0, _, _, _),
++	PIN(29, arm_jtag, vc_i2c0, vc_spi0, _, _, _, _, _),
++	PIN(30, sd2, gpclk0, vc_pwm0, _, _, _, _, _),
++	PIN(31, sd2, vc_spi3, vc_pwm0, _, _, _, _, _),
++	PIN(32, sd2, vc_spi3, vc_uart3, _, _, _, _, _),
++	PIN(33, sd2, vc_spi3, vc_uart3, _, _, _, _, _),
++	PIN(34, sd2, vc_spi3, vc_i2c5, _, _, _, _, _),
++	PIN(35, sd2, vc_spi3, vc_i2c5, _, _, _, _, _),
++};
++
++static inline u32 bcm2712_reg_rd(struct bcm2712_pinctrl *pc, unsigned reg)
++{
++	return readl(pc->base + reg);
++}
++
++static inline void bcm2712_reg_wr(struct bcm2712_pinctrl *pc, unsigned reg,
++		u32 val)
++{
++	writel(val, pc->base + reg);
++}
++
++static enum bcm2712_funcs bcm2712_pinctrl_fsel_get(
++	struct bcm2712_pinctrl *pc, unsigned pin)
++{
++	u32 bit = pc->pin_regs[pin].mux_bit;
++	enum bcm2712_funcs func;
++	int fsel;
++	u32 val;
++
++	if (!bit)
++		return func_gpio;
++
++	val = bcm2712_reg_rd(pc, BIT_TO_REG(bit));
++	fsel = (val >> BIT_TO_SHIFT(bit)) & BCM2712_FSEL_MASK;
++	func = pc->pin_funcs[pin].funcs[fsel];
++	if (func >= func_count)
++		func = (enum bcm2712_funcs)fsel;
++
++	dev_dbg(pc->dev, "get %04x: %08x (%u => %s)\n",
++		BIT_TO_REG(bit), val, pin,
++		bcm2712_func_names[func]);
++
++	return func;
++}
++
++static void bcm2712_pinctrl_fsel_set(
++	struct bcm2712_pinctrl *pc, unsigned pin,
++	enum bcm2712_funcs func)
++{
++	u32 bit = pc->pin_regs[pin].mux_bit, val;
++	const u8 *pin_funcs;
++	unsigned long flags;
++	int fsel;
++	int cur;
++	int i;
++
++	if (!bit || func >= func_count)
++		return;
++
++	fsel = BCM2712_FSEL_COUNT;
++
++	if (func >= BCM2712_FSEL_COUNT) {
++		/* Convert to an fsel number */
++		pin_funcs = pc->pin_funcs[pin].funcs;
++		for (i = 1; i < BCM2712_FSEL_COUNT; i++) {
++			if (pin_funcs[i - 1] == func) {
++				fsel = i;
++				break;
++			}
++		}
++	} else {
++		fsel = (enum bcm2712_funcs)func;
++	}
++	if (fsel >= BCM2712_FSEL_COUNT)
++		return;
++
++	spin_lock_irqsave(&pc->lock, flags);
++
++	val = bcm2712_reg_rd(pc, BIT_TO_REG(bit));
++	cur = (val >> BIT_TO_SHIFT(bit)) & BCM2712_FSEL_MASK;
++
++	dev_dbg(pc->dev, "read %04x: %08x (%u => %s)\n",
++		BIT_TO_REG(bit), val, pin,
++		bcm2712_func_names[cur]);
++
++	if (cur != fsel) {
++		val &= ~(BCM2712_FSEL_MASK << BIT_TO_SHIFT(bit));
++		val |= fsel << BIT_TO_SHIFT(bit);
++
++		dev_dbg(pc->dev, "write %04x: %08x (%u <= %s)\n",
++			BIT_TO_REG(bit), val, pin,
++			bcm2712_func_names[fsel]);
++		bcm2712_reg_wr(pc, BIT_TO_REG(bit), val);
++	}
++
++	spin_unlock_irqrestore(&pc->lock, flags);
++}
++
++static int bcm2712_pctl_get_groups_count(struct pinctrl_dev *pctldev)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++
++	return pc->pctl_desc.npins;
++}
++
++static const char *bcm2712_pctl_get_group_name(struct pinctrl_dev *pctldev,
++		unsigned selector)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++
++	return pc->gpio_groups[selector];
++}
++
++static int bcm2712_pctl_get_group_pins(struct pinctrl_dev *pctldev,
++		unsigned selector,
++		const unsigned **pins,
++		unsigned *num_pins)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++
++	*pins = &pc->pctl_desc.pins[selector].number;
++	*num_pins = 1;
++
++	return 0;
++}
++
++static void bcm2712_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,
++		struct seq_file *s,
++		unsigned offset)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++	enum bcm2712_funcs fsel = bcm2712_pinctrl_fsel_get(pc, offset);
++	const char *fname = bcm2712_func_names[fsel];
++
++	seq_printf(s, "function %s", fname);
++}
++
++static void bcm2712_pctl_dt_free_map(struct pinctrl_dev *pctldev,
++		struct pinctrl_map *maps, unsigned num_maps)
++{
++	int i;
++
++	for (i = 0; i < num_maps; i++)
++		if (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)
++			kfree(maps[i].data.configs.configs);
++
++	kfree(maps);
++}
++
++static const struct pinctrl_ops bcm2712_pctl_ops = {
++	.get_groups_count = bcm2712_pctl_get_groups_count,
++	.get_group_name = bcm2712_pctl_get_group_name,
++	.get_group_pins = bcm2712_pctl_get_group_pins,
++	.pin_dbg_show = bcm2712_pctl_pin_dbg_show,
++	.dt_node_to_map = pinconf_generic_dt_node_to_map_all,
++	.dt_free_map = bcm2712_pctl_dt_free_map,
++};
++
++static int bcm2712_pmx_free(struct pinctrl_dev *pctldev,
++		unsigned offset)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++
++	/* disable by setting to GPIO */
++	bcm2712_pinctrl_fsel_set(pc, offset, func_gpio);
++	return 0;
++}
++
++static int bcm2712_pmx_get_functions_count(struct pinctrl_dev *pctldev)
++{
++	return func_count;
++}
++
++static const char *bcm2712_pmx_get_function_name(struct pinctrl_dev *pctldev,
++		unsigned selector)
++{
++	return (selector < func_count) ? bcm2712_func_names[selector] : NULL;
++}
++
++static int bcm2712_pmx_get_function_groups(struct pinctrl_dev *pctldev,
++		unsigned selector,
++		const char * const **groups,
++		unsigned * const num_groups)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++	/* every pin can do every function */
++	*groups = pc->gpio_groups;
++	*num_groups = pc->pctl_desc.npins;
++
++	return 0;
++}
++
++static int bcm2712_pmx_set(struct pinctrl_dev *pctldev,
++		unsigned func_selector,
++		unsigned group_selector)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++
++	bcm2712_pinctrl_fsel_set(pc, group_selector, func_selector);
++
++	return 0;
++}
++static int bcm2712_pmx_gpio_request_enable(struct pinctrl_dev *pctldev,
++					   struct pinctrl_gpio_range *range,
++					   unsigned pin)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++
++	bcm2712_pinctrl_fsel_set(pc, pin, func_gpio);
++
++	return 0;
++}
++
++static void bcm2712_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,
++		struct pinctrl_gpio_range *range,
++		unsigned offset)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++
++	/* disable by setting to GPIO */
++	bcm2712_pinctrl_fsel_set(pc, offset, func_gpio);
++}
++
++static const struct pinmux_ops bcm2712_pmx_ops = {
++	.free = bcm2712_pmx_free,
++	.get_functions_count = bcm2712_pmx_get_functions_count,
++	.get_function_name = bcm2712_pmx_get_function_name,
++	.get_function_groups = bcm2712_pmx_get_function_groups,
++	.set_mux = bcm2712_pmx_set,
++	.gpio_request_enable = bcm2712_pmx_gpio_request_enable,
++	.gpio_disable_free = bcm2712_pmx_gpio_disable_free,
++};
++
++static unsigned int bcm2712_pull_config_get(struct bcm2712_pinctrl *pc,
++					    unsigned int pin)
++{
++	u32 bit = pc->pin_regs[pin].pad_bit, val;
++
++	if (unlikely(bit == REG_BIT_INVALID))
++	    return BCM2712_PULL_NONE;
++
++	val = bcm2712_reg_rd(pc, BIT_TO_REG(bit));
++	return (val >> BIT_TO_SHIFT(bit)) & BCM2712_PULL_MASK;
++}
++
++static void bcm2712_pull_config_set(struct bcm2712_pinctrl *pc,
++				    unsigned int pin, unsigned int arg)
++{
++	u32 bit = pc->pin_regs[pin].pad_bit, val;
++	unsigned long flags;
++
++	if (unlikely(bit == REG_BIT_INVALID)) {
++	    dev_warn(pc->dev, "can't set pulls for %s\n", pc->gpio_groups[pin]);
++	    return;
++	}
++
++	spin_lock_irqsave(&pc->lock, flags);
++
++	val = bcm2712_reg_rd(pc, BIT_TO_REG(bit));
++	val &= ~(BCM2712_PULL_MASK << BIT_TO_SHIFT(bit));
++	val |= (arg << BIT_TO_SHIFT(bit));
++	bcm2712_reg_wr(pc, BIT_TO_REG(bit), val);
++
++	spin_unlock_irqrestore(&pc->lock, flags);
++}
++
++static int bcm2712_pinconf_get(struct pinctrl_dev *pctldev,
++			unsigned pin, unsigned long *config)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++	enum pin_config_param param = pinconf_to_config_param(*config);
++	u32 arg;
++
++	switch (param) {
++	case PIN_CONFIG_BIAS_DISABLE:
++		arg = (bcm2712_pull_config_get(pc, pin) == BCM2712_PULL_NONE);
++		break;
++	case PIN_CONFIG_BIAS_PULL_DOWN:
++		arg = (bcm2712_pull_config_get(pc, pin) == BCM2712_PULL_DOWN);
++		break;
++	case PIN_CONFIG_BIAS_PULL_UP:
++		arg = (bcm2712_pull_config_get(pc, pin) == BCM2712_PULL_UP);
++		break;
++	default:
++		return -ENOTSUPP;
++	}
++
++	*config = pinconf_to_config_packed(param, arg);
++
++	return -ENOTSUPP;
++}
++
++static int bcm2712_pinconf_set(struct pinctrl_dev *pctldev,
++			       unsigned int pin, unsigned long *configs,
++			       unsigned int num_configs)
++{
++	struct bcm2712_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++	u32 param, arg;
++	int i;
++
++	for (i = 0; i < num_configs; i++) {
++		param = pinconf_to_config_param(configs[i]);
++		arg = pinconf_to_config_argument(configs[i]);
++
++		switch (param) {
++		case PIN_CONFIG_BIAS_DISABLE:
++			bcm2712_pull_config_set(pc, pin, BCM2712_PULL_NONE);
++			break;
++		case PIN_CONFIG_BIAS_PULL_DOWN:
++			bcm2712_pull_config_set(pc, pin, BCM2712_PULL_DOWN);
++			break;
++		case PIN_CONFIG_BIAS_PULL_UP:
++			bcm2712_pull_config_set(pc, pin, BCM2712_PULL_UP);
++			break;
++		default:
++			return -ENOTSUPP;
++		}
++	} /* for each config */
++
++	return 0;
++}
++
++static const struct pinconf_ops bcm2712_pinconf_ops = {
++	.is_generic = true,
++	.pin_config_get = bcm2712_pinconf_get,
++	.pin_config_set = bcm2712_pinconf_set,
++};
++
++static const struct pinctrl_desc bcm2712_c0_pinctrl_desc = {
++	.name = "pinctrl-bcm2712",
++	.pins = bcm2712_c0_gpio_pins,
++	.npins = ARRAY_SIZE(bcm2712_c0_gpio_pins),
++	.pctlops = &bcm2712_pctl_ops,
++	.pmxops = &bcm2712_pmx_ops,
++	.confops = &bcm2712_pinconf_ops,
++	.owner = THIS_MODULE,
++};
++
++static const struct pinctrl_desc bcm2712_c0_aon_pinctrl_desc = {
++	.name = "aon-pinctrl-bcm2712",
++	.pins = bcm2712_c0_aon_gpio_pins,
++	.npins = ARRAY_SIZE(bcm2712_c0_aon_gpio_pins),
++	.pctlops = &bcm2712_pctl_ops,
++	.pmxops = &bcm2712_pmx_ops,
++	.confops = &bcm2712_pinconf_ops,
++	.owner = THIS_MODULE,
++};
++
++static const struct pinctrl_desc bcm2712_d0_pinctrl_desc = {
++	.name = "pinctrl-bcm2712",
++	.pins = bcm2712_d0_gpio_pins,
++	.npins = ARRAY_SIZE(bcm2712_d0_gpio_pins),
++	.pctlops = &bcm2712_pctl_ops,
++	.pmxops = &bcm2712_pmx_ops,
++	.confops = &bcm2712_pinconf_ops,
++	.owner = THIS_MODULE,
++};
++
++static const struct pinctrl_desc bcm2712_d0_aon_pinctrl_desc = {
++	.name = "aon-pinctrl-bcm2712",
++	.pins = bcm2712_d0_aon_gpio_pins,
++	.npins = ARRAY_SIZE(bcm2712_d0_aon_gpio_pins),
++	.pctlops = &bcm2712_pctl_ops,
++	.pmxops = &bcm2712_pmx_ops,
++	.confops = &bcm2712_pinconf_ops,
++	.owner = THIS_MODULE,
++};
++
++static const struct pinctrl_gpio_range bcm2712_c0_pinctrl_gpio_range = {
++	.name = "pinctrl-bcm2712",
++	.npins = ARRAY_SIZE(bcm2712_c0_gpio_pins),
++};
++
++static const struct pinctrl_gpio_range bcm2712_c0_aon_pinctrl_gpio_range = {
++	.name = "aon-pinctrl-bcm2712",
++	.npins = ARRAY_SIZE(bcm2712_c0_aon_gpio_pins),
++};
++
++static const struct pinctrl_gpio_range bcm2712_d0_pinctrl_gpio_range = {
++	.name = "pinctrl-bcm2712",
++	.npins = ARRAY_SIZE(bcm2712_d0_gpio_pins),
++};
++
++static const struct pinctrl_gpio_range bcm2712_d0_aon_pinctrl_gpio_range = {
++	.name = "aon-pinctrl-bcm2712",
++	.npins = ARRAY_SIZE(bcm2712_d0_aon_gpio_pins),
++};
++
++static const struct bcm_plat_data bcm2712_c0_plat_data = {
++	.pctl_desc = &bcm2712_c0_pinctrl_desc,
++	.gpio_range = &bcm2712_c0_pinctrl_gpio_range,
++	.pin_regs = bcm2712_c0_gpio_pin_regs,
++	.pin_funcs = bcm2712_c0_gpio_pin_funcs,
++};
++
++static const struct bcm_plat_data bcm2712_c0_aon_plat_data = {
++	.pctl_desc = &bcm2712_c0_aon_pinctrl_desc,
++	.gpio_range = &bcm2712_c0_aon_pinctrl_gpio_range,
++	.pin_regs = bcm2712_c0_aon_gpio_pin_regs,
++	.pin_funcs = bcm2712_c0_aon_gpio_pin_funcs,
++};
++
++static const struct bcm_plat_data bcm2712_d0_plat_data = {
++	.pctl_desc = &bcm2712_d0_pinctrl_desc,
++	.gpio_range = &bcm2712_d0_pinctrl_gpio_range,
++	.pin_regs = bcm2712_d0_gpio_pin_regs,
++	.pin_funcs = bcm2712_d0_gpio_pin_funcs,
++};
++
++static const struct bcm_plat_data bcm2712_d0_aon_plat_data = {
++	.pctl_desc = &bcm2712_d0_aon_pinctrl_desc,
++	.gpio_range = &bcm2712_d0_aon_pinctrl_gpio_range,
++	.pin_regs = bcm2712_d0_aon_gpio_pin_regs,
++	.pin_funcs = bcm2712_d0_aon_gpio_pin_funcs,
++};
++
++static const struct of_device_id bcm2712_pinctrl_match[] = {
++	{
++		.compatible = "brcm,bcm2712-pinctrl",
++		.data = &bcm2712_c0_plat_data,
++	},
++	{
++		.compatible = "brcm,bcm2712-aon-pinctrl",
++		.data = &bcm2712_c0_aon_plat_data,
++	},
++
++	{
++		.compatible = "brcm,bcm2712c0-pinctrl",
++		.data = &bcm2712_c0_plat_data,
++	},
++	{
++		.compatible = "brcm,bcm2712c0-aon-pinctrl",
++		.data = &bcm2712_c0_aon_plat_data,
++	},
++
++	{
++		.compatible = "brcm,bcm2712d0-pinctrl",
++		.data = &bcm2712_d0_plat_data,
++	},
++	{
++		.compatible = "brcm,bcm2712d0-aon-pinctrl",
++		.data = &bcm2712_d0_aon_plat_data,
++	},
++	{}
++};
++
++static int bcm2712_pinctrl_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++	const struct bcm_plat_data *pdata;
++	const struct of_device_id *match;
++	struct bcm2712_pinctrl *pc;
++	const char **names;
++	int num_pins, i;
++
++	match = of_match_node(bcm2712_pinctrl_match, np);
++	if (!match)
++		return -EINVAL;
++	pdata = match->data;
++
++	pc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);
++	if (!pc)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, pc);
++	pc->dev = dev;
++	spin_lock_init(&pc->lock);
++
++	pc->base = devm_of_iomap(dev, np, 0, NULL);
++	if (IS_ERR(pc->base)) {
++		dev_err(dev, "could not get IO memory\n");
++		return PTR_ERR(pc->base);
++	}
++
++	pc->pctl_desc = *pdata->pctl_desc;
++	num_pins = pc->pctl_desc.npins;
++	names = devm_kmalloc_array(dev, num_pins, sizeof(const char *),
++				   GFP_KERNEL);
++	if (!names)
++		return -ENOMEM;
++	for (i = 0; i < num_pins; i++)
++		names[i] = pc->pctl_desc.pins[i].name;
++	pc->gpio_groups = names;
++	pc->pin_regs = pdata->pin_regs;
++	pc->pin_funcs = pdata->pin_funcs;
++	pc->pctl_dev = devm_pinctrl_register(dev, &pc->pctl_desc, pc);
++	if (IS_ERR(pc->pctl_dev))
++		return PTR_ERR(pc->pctl_dev);
++
++	pc->gpio_range = *pdata->gpio_range;
++	pinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);
++
++	return 0;
++}
++
++static struct platform_driver bcm2712_pinctrl_driver = {
++	.probe = bcm2712_pinctrl_probe,
++	.driver = {
++		.name = MODULE_NAME,
++		.of_match_table = bcm2712_pinctrl_match,
++		.suppress_bind_attrs = true,
++	},
++};
++builtin_platform_driver(bcm2712_pinctrl_driver);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0858-vc4-fkms-Remove-use-of-SMI-peripheral.patch b/target/linux/bcm27xx/patches-6.1/950-0858-vc4-fkms-Remove-use-of-SMI-peripheral.patch
new file mode 100644
index 0000000000..87b746d81d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0858-vc4-fkms-Remove-use-of-SMI-peripheral.patch
@@ -0,0 +1,76 @@
+From 3fb20da9f3bff93f20b1a1fe2c950c6c8f4d1e1e Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Thu, 1 Jul 2021 19:21:10 +0100
+Subject: [PATCH] vc4/fkms: Remove use of SMI peripheral
+
+---
+ drivers/gpu/drm/vc4/vc4_firmware_kms.c | 24 +++++++-----------------
+ 1 file changed, 7 insertions(+), 17 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_firmware_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_firmware_kms.c
+@@ -255,13 +255,6 @@ static const struct vc_image_format *vc4
+ /* The firmware delivers a vblank interrupt to us through the SMI
+  * hardware, which has only this one register.
+  */
+-#define SMICS 0x0
+-#define SMIDSW0 0x14
+-#define SMIDSW1 0x1C
+-#define SMICS_INTERRUPTS (BIT(9) | BIT(10) | BIT(11))
+-
+-/* Flag to denote that the firmware is giving multiple display callbacks */
+-#define SMI_NEW 0xabcd0000
+ 
+ #define vc4_crtc vc4_kms_crtc
+ #define to_vc4_crtc to_vc4_kms_crtc
+@@ -1217,16 +1210,13 @@ static irqreturn_t vc4_crtc_irq_handler(
+ {
+ 	struct vc4_crtc **crtc_list = data;
+ 	int i;
+-	u32 stat = readl(crtc_list[0]->regs + SMICS);
+ 	irqreturn_t ret = IRQ_NONE;
+ 	u32 chan;
++	if (1) {
+ 
+-	if (stat & SMICS_INTERRUPTS) {
+-		writel(0, crtc_list[0]->regs + SMICS);
+-
+-		chan = readl(crtc_list[0]->regs + SMIDSW0);
++		chan = 0;
+ 
+-		if ((chan & 0xFFFF0000) != SMI_NEW) {
++		if (1) {
+ 			/* Older firmware. Treat the one interrupt as vblank/
+ 			 * complete for all crtcs.
+ 			 */
+@@ -1237,7 +1227,7 @@ static irqreturn_t vc4_crtc_irq_handler(
+ 			}
+ 		} else {
+ 			if (chan & 1) {
+-				writel(SMI_NEW, crtc_list[0]->regs + SMIDSW0);
++				//writel(SMI_NEW, crtc_list[0]->regs + SMIDSW0);
+ 				if (crtc_list[0]->vblank_enabled)
+ 					drm_crtc_handle_vblank(&crtc_list[0]->base);
+ 				vc4_crtc_handle_page_flip(crtc_list[0]);
+@@ -1245,10 +1235,10 @@ static irqreturn_t vc4_crtc_irq_handler(
+ 
+ 			if (crtc_list[1]) {
+ 				/* Check for the secondary display too */
+-				chan = readl(crtc_list[0]->regs + SMIDSW1);
++				//chan = readl(crtc_list[0]->regs + SMIDSW1);
+ 
+ 				if (chan & 1) {
+-					writel(SMI_NEW, crtc_list[0]->regs + SMIDSW1);
++					//writel(SMI_NEW, crtc_list[0]->regs + SMIDSW1);
+ 
+ 					if (crtc_list[1]->vblank_enabled)
+ 						drm_crtc_handle_vblank(&crtc_list[1]->base);
+@@ -1988,7 +1978,7 @@ static int vc4_fkms_bind(struct device *
+ 		if (IS_ERR(crtc_list[0]->regs))
+ 			DRM_ERROR("Oh dear, failed to map registers\n");
+ 
+-		writel(0, crtc_list[0]->regs + SMICS);
++		//writel(0, crtc_list[0]->regs + SMICS);
+ 		ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
+ 				       vc4_crtc_irq_handler, 0,
+ 				       "vc4 firmware kms", crtc_list);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0859-mmc-brcmstb-add-support-for-BCM2712.patch b/target/linux/bcm27xx/patches-6.1/950-0859-mmc-brcmstb-add-support-for-BCM2712.patch
new file mode 100644
index 0000000000..05d403a63e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0859-mmc-brcmstb-add-support-for-BCM2712.patch
@@ -0,0 +1,498 @@
+From b627647c4500d39cb026924b608841fdf4d4d7e9 Mon Sep 17 00:00:00 2001
+From: Ulf Hansson <ulf.hansson@linaro.org>
+Date: Thu, 29 Oct 2020 09:57:16 +0800
+Subject: [PATCH] mmc: brcmstb: add support for BCM2712
+
+BCM2712 has an SD Express capable SDHCI implementation and uses
+the SDIO CFG register block present on other STB chips.
+
+Add plumbing for SD Express handover and BCM2712-specific functions.
+
+Due to the common bus infrastructure between BCM2711 and BCM2712,
+the driver also needs to implement 32-bit IO accessors.
+
+mmc: brcmstb: override card presence if broken-cd is set
+
+Not just if the card is declared as nonremovable.
+
+sdhci: brcmstb: align SD express switchover with SD spec v8.00
+
+Part 1 of the Physical specification, figure 3-24, details the switch
+sequence for cards initially probed as SD. Add a missing check for DAT2
+level after switching VDD2 on.
+
+sdhci: brcmstb: clean up SD Express probe and error handling
+
+Refactor to avoid spurious error messages in dmesg if the requisite SD
+Express DT nodes aren't present.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+mmc: sdhci-brcmstb: only use the delay line PHY for tuneable speeds
+
+The MMC core has a 200MHz core clock which allows the use of DDR50 and
+below without incremental phase tuning. SDR50/SDR104 and the EMMC HS200
+speeds require tuning.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/mmc/host/Kconfig         |   2 +
+ drivers/mmc/host/sdhci-brcmstb.c | 356 +++++++++++++++++++++++++++++++
+ 2 files changed, 358 insertions(+)
+
+--- a/drivers/mmc/host/Kconfig
++++ b/drivers/mmc/host/Kconfig
+@@ -1082,7 +1082,9 @@ config MMC_SDHCI_BRCMSTB
+ 	tristate "Broadcom SDIO/SD/MMC support"
+ 	depends on ARCH_BRCMSTB || BMIPS_GENERIC
+ 	depends on MMC_SDHCI_PLTFM
++	select MMC_SDHCI_IO_ACCESSORS
+ 	select MMC_CQHCI
++	select OF_DYNAMIC
+ 	default y
+ 	help
+ 	  This selects support for the SDIO/SD/MMC Host Controller on
+--- a/drivers/mmc/host/sdhci-brcmstb.c
++++ b/drivers/mmc/host/sdhci-brcmstb.c
+@@ -11,6 +11,8 @@
+ #include <linux/of.h>
+ #include <linux/bitops.h>
+ #include <linux/delay.h>
++#include <linux/pinctrl/consumer.h>
++#include <linux/regulator/consumer.h>
+ 
+ #include "sdhci-cqhci.h"
+ #include "sdhci-pltfm.h"
+@@ -26,18 +28,43 @@
+ 
+ #define BRCMSTB_PRIV_FLAGS_HAS_CQE		BIT(0)
+ #define BRCMSTB_PRIV_FLAGS_GATE_CLOCK		BIT(1)
++#define BRCMSTB_PRIV_FLAGS_HAS_SD_EXPRESS	BIT(2)
+ 
+ #define SDHCI_ARASAN_CQE_BASE_ADDR		0x200
+ 
++#define SDIO_CFG_CTRL				0x0
++#define  SDIO_CFG_CTRL_SDCD_N_TEST_EN		BIT(31)
++#define  SDIO_CFG_CTRL_SDCD_N_TEST_LEV		BIT(30)
++
++#define SDIO_CFG_SD_PIN_SEL			0x44
++#define  SDIO_CFG_SD_PIN_SEL_MASK		0x3
++#define  SDIO_CFG_SD_PIN_SEL_CARD		BIT(1)
++
++#define SDIO_CFG_MAX_50MHZ_MODE			0x1ac
++#define  SDIO_CFG_MAX_50MHZ_MODE_STRAP_OVERRIDE	BIT(31)
++#define  SDIO_CFG_MAX_50MHZ_MODE_ENABLE		BIT(0)
++
+ struct sdhci_brcmstb_priv {
+ 	void __iomem *cfg_regs;
+ 	unsigned int flags;
+ 	struct clk *base_clk;
+ 	u32 base_freq_hz;
++	u32 shadow_cmd;
++	u32 shadow_blk;
++	bool is_cmd_shadowed;
++	bool is_blk_shadowed;
++	struct regulator *sde_1v8;
++	struct device_node *sde_pcie;
++	void *__iomem sde_ioaddr;
++	void *__iomem sde_ioaddr2;
++	struct pinctrl *pinctrl;
++	struct pinctrl_state *pins_default;
++	struct pinctrl_state *pins_sdex;
+ };
+ 
+ struct brcmstb_match_priv {
+ 	void (*hs400es)(struct mmc_host *mmc, struct mmc_ios *ios);
++	void (*cfginit)(struct sdhci_host *host);
+ 	struct sdhci_ops *ops;
+ 	const unsigned int flags;
+ };
+@@ -94,6 +121,124 @@ static void sdhci_brcmstb_set_clock(stru
+ 	sdhci_enable_clk(host, clk);
+ }
+ 
++#define REG_OFFSET_IN_BITS(reg) ((reg) << 3 & 0x18)
++
++static inline u32 sdhci_brcmstb_32only_readl(struct sdhci_host *host, int reg)
++{
++	u32 val = readl(host->ioaddr + reg);
++
++	pr_debug("%s: readl [0x%02x] 0x%08x\n",
++		 mmc_hostname(host->mmc), reg, val);
++	return val;
++}
++
++static u16 sdhci_brcmstb_32only_readw(struct sdhci_host *host, int reg)
++{
++	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
++	struct sdhci_brcmstb_priv *brcmstb_priv = sdhci_pltfm_priv(pltfm_host);
++	u32 val;
++	u16 word;
++
++	if ((reg == SDHCI_TRANSFER_MODE) && brcmstb_priv->is_cmd_shadowed) {
++		/* Get the saved transfer mode */
++		val = brcmstb_priv->shadow_cmd;
++	} else if ((reg == SDHCI_BLOCK_SIZE || reg == SDHCI_BLOCK_COUNT) &&
++		   brcmstb_priv->is_blk_shadowed) {
++		/* Get the saved block info */
++		val = brcmstb_priv->shadow_blk;
++	} else {
++		val = sdhci_brcmstb_32only_readl(host, (reg & ~3));
++	}
++	word = val >> REG_OFFSET_IN_BITS(reg) & 0xffff;
++	return word;
++}
++
++static u8 sdhci_brcmstb_32only_readb(struct sdhci_host *host, int reg)
++{
++	u32 val = sdhci_brcmstb_32only_readl(host, (reg & ~3));
++	u8 byte = val >> REG_OFFSET_IN_BITS(reg) & 0xff;
++	return byte;
++}
++
++static inline void sdhci_brcmstb_32only_writel(struct sdhci_host *host, u32 val, int reg)
++{
++	pr_debug("%s: writel [0x%02x] 0x%08x\n",
++		 mmc_hostname(host->mmc), reg, val);
++
++	writel(val, host->ioaddr + reg);
++}
++
++/*
++ * BCM2712 unfortunately carries with it a perennial bug with the SD controller
++ * register interface present on previous chips (2711/2709/2708). Accesses must
++ * be dword-sized and a read-modify-write cycle to the 32-bit registers
++ * containing the COMMAND, TRANSFER_MODE, BLOCK_SIZE and BLOCK_COUNT registers
++ * tramples the upper/lower 16 bits of data written. BCM2712 does not seem to
++ * need the extreme delay between each write as on previous chips, just the
++ * serialisation of writes to these registers in a single 32-bit operation.
++ */
++static void sdhci_brcmstb_32only_writew(struct sdhci_host *host, u16 val, int reg)
++{
++	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
++	struct sdhci_brcmstb_priv *brcmstb_priv = sdhci_pltfm_priv(pltfm_host);
++	u32 word_shift = REG_OFFSET_IN_BITS(reg);
++	u32 mask = 0xffff << word_shift;
++	u32 oldval, newval;
++
++	if (reg == SDHCI_COMMAND) {
++		/* Write the block now as we are issuing a command */
++		if (brcmstb_priv->is_blk_shadowed) {
++			sdhci_brcmstb_32only_writel(host, brcmstb_priv->shadow_blk,
++				SDHCI_BLOCK_SIZE);
++			brcmstb_priv->is_blk_shadowed = false;
++		}
++		oldval = brcmstb_priv->shadow_cmd;
++		brcmstb_priv->is_cmd_shadowed = false;
++	} else if ((reg == SDHCI_BLOCK_SIZE || reg == SDHCI_BLOCK_COUNT) &&
++		   brcmstb_priv->is_blk_shadowed) {
++		/* Block size and count are stored in shadow reg */
++		oldval = brcmstb_priv->shadow_blk;
++	} else {
++		/* Read reg, all other registers are not shadowed */
++		oldval = sdhci_brcmstb_32only_readl(host, (reg & ~3));
++	}
++	newval = (oldval & ~mask) | (val << word_shift);
++
++	if (reg == SDHCI_TRANSFER_MODE) {
++		/* Save the transfer mode until the command is issued */
++		brcmstb_priv->shadow_cmd = newval;
++		brcmstb_priv->is_cmd_shadowed = true;
++	} else if (reg == SDHCI_BLOCK_SIZE || reg == SDHCI_BLOCK_COUNT) {
++		/* Save the block info until the command is issued */
++		brcmstb_priv->shadow_blk = newval;
++		brcmstb_priv->is_blk_shadowed = true;
++	} else {
++		/* Command or other regular 32-bit write */
++		sdhci_brcmstb_32only_writel(host, newval, reg & ~3);
++	}
++}
++
++static void sdhci_brcmstb_32only_writeb(struct sdhci_host *host, u8 val, int reg)
++{
++	u32 oldval = sdhci_brcmstb_32only_readl(host, (reg & ~3));
++	u32 byte_shift = REG_OFFSET_IN_BITS(reg);
++	u32 mask = 0xff << byte_shift;
++	u32 newval = (oldval & ~mask) | (val << byte_shift);
++
++	sdhci_brcmstb_32only_writel(host, newval, reg & ~3);
++}
++
++static void sdhci_brcmstb_set_power(struct sdhci_host *host, unsigned char mode,
++				  unsigned short vdd)
++{
++	if (!IS_ERR(host->mmc->supply.vmmc)) {
++		struct mmc_host *mmc = host->mmc;
++
++		mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);
++	}
++	sdhci_set_power_noreg(host, mode, vdd);
++}
++
+ static void sdhci_brcmstb_set_uhs_signaling(struct sdhci_host *host,
+ 					    unsigned int timing)
+ {
+@@ -123,6 +268,146 @@ static void sdhci_brcmstb_set_uhs_signal
+ 	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+ }
+ 
++static void sdhci_brcmstb_cfginit_2712(struct sdhci_host *host)
++{
++	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
++	struct sdhci_brcmstb_priv *brcmstb_priv = sdhci_pltfm_priv(pltfm_host);
++	bool want_dll = false;
++	u32 uhs_mask = (MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104);
++	u32 hsemmc_mask = (MMC_CAP2_HS200_1_8V_SDR | MMC_CAP2_HS200_1_2V_SDR |
++			   MMC_CAP2_HS400_1_8V | MMC_CAP2_HS400_1_2V);
++	u32 reg;
++
++	if (!(host->quirks2 & SDHCI_QUIRK2_NO_1_8_V)) {
++	    if((host->mmc->caps & uhs_mask) || (host->mmc->caps2 & hsemmc_mask))
++		want_dll = true;
++	}
++
++	/*
++	 * If we want a speed that requires tuning,
++	 * then select the delay line PHY as the clock source.
++	 */
++	if (want_dll) {
++		reg = readl(brcmstb_priv->cfg_regs + SDIO_CFG_MAX_50MHZ_MODE);
++		reg &= ~SDIO_CFG_MAX_50MHZ_MODE_ENABLE;
++		reg |= SDIO_CFG_MAX_50MHZ_MODE_STRAP_OVERRIDE;
++		writel(reg, brcmstb_priv->cfg_regs + SDIO_CFG_MAX_50MHZ_MODE);
++	}
++
++	if ((host->mmc->caps & MMC_CAP_NONREMOVABLE) ||
++	    (host->mmc->caps & MMC_CAP_NEEDS_POLL)) {
++		/* Force presence */
++		reg = readl(brcmstb_priv->cfg_regs + SDIO_CFG_CTRL);
++		reg &= ~SDIO_CFG_CTRL_SDCD_N_TEST_LEV;
++		reg |= SDIO_CFG_CTRL_SDCD_N_TEST_EN;
++		writel(reg, brcmstb_priv->cfg_regs + SDIO_CFG_CTRL);
++	} else {
++		/* Enable card detection line */
++		reg = readl(brcmstb_priv->cfg_regs + SDIO_CFG_SD_PIN_SEL);
++		reg &= ~SDIO_CFG_SD_PIN_SEL_MASK;
++		reg |= SDIO_CFG_SD_PIN_SEL_CARD;
++		writel(reg, brcmstb_priv->cfg_regs + SDIO_CFG_SD_PIN_SEL);
++	}
++}
++
++static int bcm2712_init_sd_express(struct sdhci_host *host, struct mmc_ios *ios)
++{
++	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
++	struct sdhci_brcmstb_priv *brcmstb_priv = sdhci_pltfm_priv(pltfm_host);
++	struct device *dev = host->mmc->parent;
++	u32 ctrl_val;
++	u32 present_state;
++	int ret;
++
++	if (!brcmstb_priv->sde_ioaddr || !brcmstb_priv->sde_ioaddr2)
++		return -EINVAL;
++
++	if (!brcmstb_priv->pinctrl)
++		return -EINVAL;
++
++	/* Turn off the SD clock first */
++	sdhci_set_clock(host, 0);
++
++	/* Disable SD DAT0-3 pulls */
++	pinctrl_select_state(brcmstb_priv->pinctrl, brcmstb_priv->pins_sdex);
++
++	ctrl_val = readl(brcmstb_priv->sde_ioaddr);
++	dev_dbg(dev, "ctrl_val 1 %08x\n", ctrl_val);
++
++	/* Tri-state the SD pins */
++	ctrl_val |= 0x1ff8;
++	writel(ctrl_val, brcmstb_priv->sde_ioaddr);
++	dev_dbg(dev, "ctrl_val 1->%08x (%08x)\n", ctrl_val, readl(brcmstb_priv->sde_ioaddr));
++	/* Let voltages settle */
++	udelay(100);
++
++	/* Enable the PCIe sideband pins */
++	ctrl_val &= ~0x6000;
++	writel(ctrl_val, brcmstb_priv->sde_ioaddr);
++	dev_dbg(dev, "ctrl_val 1->%08x (%08x)\n", ctrl_val, readl(brcmstb_priv->sde_ioaddr));
++	/* Let voltages settle */
++	udelay(100);
++
++	/* Turn on the 1v8 VDD2 regulator */
++	ret = regulator_enable(brcmstb_priv->sde_1v8);
++	if (ret)
++		return ret;
++
++	/* Wait for Tpvcrl */
++	msleep(1);
++
++	/* Sample DAT2 (CLKREQ#) - if low, card is in PCIe mode */
++	present_state = sdhci_readl(host, SDHCI_PRESENT_STATE);
++	present_state = (present_state & SDHCI_DATA_LVL_MASK) >> SDHCI_DATA_LVL_SHIFT;
++	dev_dbg(dev, "state = 0x%08x\n", present_state);
++
++	if (present_state & BIT(2)) {
++		dev_err(dev, "DAT2 still high, abandoning SDex switch\n");
++		return -ENODEV;
++	}
++
++	/* Turn on the LCPLL PTEST mux */
++	ctrl_val = readl(brcmstb_priv->sde_ioaddr2 + 20); // misc5
++	ctrl_val &= ~(0x7 << 7);
++	ctrl_val |= 3 << 7;
++	writel(ctrl_val, brcmstb_priv->sde_ioaddr2 + 20);
++	dev_dbg(dev, "misc 5->%08x (%08x)\n", ctrl_val, readl(brcmstb_priv->sde_ioaddr2 + 20));
++
++	/* PTEST diff driver enable */
++	ctrl_val = readl(brcmstb_priv->sde_ioaddr2);
++	ctrl_val |= BIT(21);
++	writel(ctrl_val, brcmstb_priv->sde_ioaddr2);
++
++	dev_dbg(dev, "misc 0->%08x (%08x)\n", ctrl_val, readl(brcmstb_priv->sde_ioaddr2));
++
++	/* Wait for more than the minimum Tpvpgl time */
++	msleep(100);
++
++	if (brcmstb_priv->sde_pcie) {
++		struct of_changeset changeset;
++		static struct property okay_property = {
++			.name = "status",
++			.value = "okay",
++			.length = 5,
++		};
++
++		/* Enable the pcie controller */
++		of_changeset_init(&changeset);
++		ret = of_changeset_update_property(&changeset,
++						   brcmstb_priv->sde_pcie,
++						   &okay_property);
++		if (ret) {
++			dev_err(dev, "%s: failed to update property - %d\n", __func__,
++			       ret);
++			return -ENODEV;
++		}
++		ret = of_changeset_apply(&changeset);
++	}
++
++	dev_dbg(dev, "%s -> %d\n", __func__, ret);
++	return ret;
++}
++
+ static void sdhci_brcmstb_dumpregs(struct mmc_host *mmc)
+ {
+ 	sdhci_dumpregs(mmc_priv(mmc));
+@@ -155,6 +440,21 @@ static struct sdhci_ops sdhci_brcmstb_op
+ 	.set_uhs_signaling = sdhci_set_uhs_signaling,
+ };
+ 
++static struct sdhci_ops sdhci_brcmstb_ops_2712 = {
++	.read_l = sdhci_brcmstb_32only_readl,
++	.read_w = sdhci_brcmstb_32only_readw,
++	.read_b = sdhci_brcmstb_32only_readb,
++	.write_l = sdhci_brcmstb_32only_writel,
++	.write_w = sdhci_brcmstb_32only_writew,
++	.write_b = sdhci_brcmstb_32only_writeb,
++	.set_clock = sdhci_set_clock,
++	.set_power = sdhci_brcmstb_set_power,
++	.set_bus_width = sdhci_set_bus_width,
++	.reset = sdhci_reset,
++	.set_uhs_signaling = sdhci_set_uhs_signaling,
++	.init_sd_express = bcm2712_init_sd_express,
++};
++
+ static struct sdhci_ops sdhci_brcmstb_ops_7216 = {
+ 	.set_clock = sdhci_brcmstb_set_clock,
+ 	.set_bus_width = sdhci_set_bus_width,
+@@ -179,10 +479,16 @@ static const struct brcmstb_match_priv m
+ 	.ops = &sdhci_brcmstb_ops_7216,
+ };
+ 
++static const struct brcmstb_match_priv match_priv_2712 = {
++	.cfginit = sdhci_brcmstb_cfginit_2712,
++	.ops = &sdhci_brcmstb_ops_2712,
++};
++
+ static const struct of_device_id sdhci_brcm_of_match[] = {
+ 	{ .compatible = "brcm,bcm7425-sdhci", .data = &match_priv_7425 },
+ 	{ .compatible = "brcm,bcm7445-sdhci", .data = &match_priv_7445 },
+ 	{ .compatible = "brcm,bcm7216-sdhci", .data = &match_priv_7216 },
++	{ .compatible = "brcm,bcm2712-sdhci", .data = &match_priv_2712 },
+ 	{},
+ };
+ 
+@@ -256,6 +562,7 @@ static int sdhci_brcmstb_probe(struct pl
+ 	u32 actual_clock_mhz;
+ 	struct sdhci_host *host;
+ 	struct resource *iomem;
++	bool no_pinctrl = false;
+ 	struct clk *clk;
+ 	struct clk *base_clk = NULL;
+ 	int res;
+@@ -290,6 +597,11 @@ static int sdhci_brcmstb_probe(struct pl
+ 		match_priv->ops->irq = sdhci_brcmstb_cqhci_irq;
+ 	}
+ 
++	priv->sde_pcie = of_parse_phandle(pdev->dev.of_node,
++					  "sde-pcie", 0);
++	if (priv->sde_pcie)
++		priv->flags |= BRCMSTB_PRIV_FLAGS_HAS_SD_EXPRESS;
++
+ 	/* Map in the non-standard CFG registers */
+ 	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+ 	priv->cfg_regs = devm_ioremap_resource(&pdev->dev, iomem);
+@@ -303,6 +615,43 @@ static int sdhci_brcmstb_probe(struct pl
+ 	if (res)
+ 		goto err;
+ 
++	priv->sde_1v8 = devm_regulator_get_optional(&pdev->dev, "sde-1v8");
++	if (IS_ERR(priv->sde_1v8))
++		priv->flags &= ~BRCMSTB_PRIV_FLAGS_HAS_SD_EXPRESS;
++
++	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 2);
++	if (iomem) {
++		priv->sde_ioaddr = devm_ioremap_resource(&pdev->dev, iomem);
++		if (IS_ERR(priv->sde_ioaddr))
++			priv->sde_ioaddr = NULL;
++	}
++
++	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 3);
++	if (iomem) {
++		priv->sde_ioaddr2 = devm_ioremap_resource(&pdev->dev, iomem);
++		if (IS_ERR(priv->sde_ioaddr2))
++			priv->sde_ioaddr = NULL;
++	}
++
++	priv->pinctrl = devm_pinctrl_get(&pdev->dev);
++	if (IS_ERR(priv->pinctrl)) {
++			no_pinctrl = true;
++	}
++	priv->pins_default = pinctrl_lookup_state(priv->pinctrl, "default");
++	if (IS_ERR(priv->pins_default)) {
++			dev_dbg(&pdev->dev, "No pinctrl default state\n");
++			no_pinctrl = true;
++	}
++	priv->pins_sdex = pinctrl_lookup_state(priv->pinctrl, "sd-express");
++	if (IS_ERR(priv->pins_sdex)) {
++			dev_dbg(&pdev->dev, "No pinctrl sd-express state\n");
++			no_pinctrl = true;
++	}
++	if (no_pinctrl || !priv->sde_ioaddr || !priv->sde_ioaddr2) {
++		priv->pinctrl = NULL;
++		priv->flags &= ~BRCMSTB_PRIV_FLAGS_HAS_SD_EXPRESS;
++	}
++
+ 	/*
+ 	 * Automatic clock gating does not work for SD cards that may
+ 	 * voltage switch so only enable it for non-removable devices.
+@@ -319,6 +668,13 @@ static int sdhci_brcmstb_probe(struct pl
+ 	    (host->mmc->caps2 & MMC_CAP2_HS400_ES))
+ 		host->mmc_host_ops.hs400_enhanced_strobe = match_priv->hs400es;
+ 
++	if (host->ops->init_sd_express &&
++	    (priv->flags & BRCMSTB_PRIV_FLAGS_HAS_SD_EXPRESS))
++		host->mmc->caps2 |= MMC_CAP2_SD_EXP;
++
++	if(match_priv->cfginit)
++		match_priv->cfginit(host);
++
+ 	/*
+ 	 * Supply the existing CAPS, but clear the UHS modes. This
+ 	 * will allow these modes to be specified by device tree
diff --git a/target/linux/bcm27xx/patches-6.1/950-0860-sdhci-Add-SD-Express-hook.patch b/target/linux/bcm27xx/patches-6.1/950-0860-sdhci-Add-SD-Express-hook.patch
new file mode 100644
index 0000000000..1aea0b3bcd
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0860-sdhci-Add-SD-Express-hook.patch
@@ -0,0 +1,90 @@
+From 9564939f1a92e5f9807461539de28c50e5bee440 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 6 Jul 2021 09:45:36 +0100
+Subject: [PATCH] sdhci: Add SD Express hook
+
+sdhci: remove PYA0_INTR_BUG quirk. Add quirks to disable some of the higher SDR speeds at 1.8v.
+---
+ drivers/mmc/host/sdhci-of-dwcmshc.c |  5 ++++-
+ drivers/mmc/host/sdhci.c            | 19 +++++++++++++++++++
+ drivers/mmc/host/sdhci.h            |  6 ++++++
+ 3 files changed, 29 insertions(+), 1 deletion(-)
+
+--- a/drivers/mmc/host/sdhci-of-dwcmshc.c
++++ b/drivers/mmc/host/sdhci-of-dwcmshc.c
+@@ -363,7 +363,10 @@ static const struct sdhci_pltfm_data sdh
+ 	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |
+ 		  SDHCI_QUIRK_BROKEN_TIMEOUT_VAL,
+ 	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+-		   SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN,
++		   SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN |
++	            SDHCI_QUIRK2_NO_SDR50 |
++	            SDHCI_QUIRK2_NO_SDR104 |
++	            SDHCI_QUIRK2_NO_SDR25,
+ };
+ 
+ static int dwcmshc_rk35xx_init(struct sdhci_host *host, struct dwcmshc_priv *dwc_priv)
+--- a/drivers/mmc/host/sdhci.c
++++ b/drivers/mmc/host/sdhci.c
+@@ -3071,6 +3071,15 @@ static void sdhci_card_event(struct mmc_
+ 	spin_unlock_irqrestore(&host->lock, flags);
+ }
+ 
++static int sdhci_init_sd_express(struct mmc_host *mmc, struct mmc_ios *ios)
++{
++	struct sdhci_host *host = mmc_priv(mmc);
++
++	if (!host->ops->init_sd_express)
++		return -EOPNOTSUPP;
++	return host->ops->init_sd_express(host, ios);
++}
++
+ static const struct mmc_host_ops sdhci_ops = {
+ 	.request	= sdhci_request,
+ 	.post_req	= sdhci_post_req,
+@@ -3086,6 +3095,7 @@ static const struct mmc_host_ops sdhci_o
+ 	.execute_tuning			= sdhci_execute_tuning,
+ 	.card_event			= sdhci_card_event,
+ 	.card_busy	= sdhci_card_busy,
++	.init_sd_express = sdhci_init_sd_express,
+ };
+ 
+ /*****************************************************************************\
+@@ -4605,6 +4615,15 @@ int sdhci_setup_host(struct sdhci_host *
+ 	    !(host->quirks2 & SDHCI_QUIRK2_BROKEN_DDR50))
+ 		mmc->caps |= MMC_CAP_UHS_DDR50;
+ 
++	if (host->quirks2 & SDHCI_QUIRK2_NO_SDR25)
++		mmc->caps &= ~MMC_CAP_UHS_SDR25;
++
++	if (host->quirks2 & SDHCI_QUIRK2_NO_SDR50)
++		mmc->caps &= ~MMC_CAP_UHS_SDR50;
++
++	if (host->quirks2 & SDHCI_QUIRK2_NO_SDR104)
++		mmc->caps &= ~MMC_CAP_UHS_SDR104;
++
+ 	/* Does the host need tuning for SDR50? */
+ 	if (host->caps1 & SDHCI_USE_SDR50_TUNING)
+ 		host->flags |= SDHCI_SDR50_NEEDS_TUNING;
+--- a/drivers/mmc/host/sdhci.h
++++ b/drivers/mmc/host/sdhci.h
+@@ -481,6 +481,11 @@ struct sdhci_host {
+ /* Issue CMD and DATA reset together */
+ #define SDHCI_QUIRK2_ISSUE_CMD_DAT_RESET_TOGETHER	(1<<19)
+ 
++/* Quirks to ignore a speed if a that speed is unreliable */
++#define SDHCI_QUIRK2_NO_SDR25	(1<<19)
++#define SDHCI_QUIRK2_NO_SDR50  (1<<20)
++#define SDHCI_QUIRK2_NO_SDR104	(1<<21)
++
+ 	int irq;		/* Device IRQ */
+ 	void __iomem *ioaddr;	/* Mapped address */
+ 	phys_addr_t mapbase;	/* physical address base */
+@@ -663,6 +668,7 @@ struct sdhci_ops {
+ 	void	(*request_done)(struct sdhci_host *host,
+ 				struct mmc_request *mrq);
+ 	void    (*dump_vendor_regs)(struct sdhci_host *host);
++	int	(*init_sd_express)(struct sdhci_host *host, struct mmc_ios *ios);
+ };
+ 
+ #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
diff --git a/target/linux/bcm27xx/patches-6.1/950-0861-Add-new-pispbe-driver-though-not-yet-the-Makesfiles-.patch b/target/linux/bcm27xx/patches-6.1/950-0861-Add-new-pispbe-driver-though-not-yet-the-Makesfiles-.patch
new file mode 100644
index 0000000000..2ac7b7830c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0861-Add-new-pispbe-driver-though-not-yet-the-Makesfiles-.patch
@@ -0,0 +1,3788 @@
+From ce14be51d71bf39893786d380cbb82e81d2a10d5 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.org>
+Date: Wed, 14 Jul 2021 09:32:49 +0100
+Subject: [PATCH] Add new "pispbe" driver (though not yet the Makesfiles or DT
+ required to use it)
+
+media: bcm2712: Initial commit of the PiSP BE driver
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: bcm2712_pisp_be: PiSP driver updates.
+
+- Start registering video nodes from /dev/video20
+- Formatting fixes
+- Define MODULE_DEVICE_TABLE() to probe correctly
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: pisp_be: Improve image format support
+
+Add a new format table that lists the V4L2 format enums and their properties.
+Keep the exising 'RPBP' format to support the userland verification tools.
+This format requires userland to fill all plane properties. Standard V4L2
+formats will derive these properties from the format table.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: pisp_be: Advertise the meta output format explictily.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+drivers: pisp_be: Various updates and cleanups
+
+- Switch to a single node group for now.
+- Add a node description table to simplify node handling.
+- Switch HoG output to V4L2_CAP_META_CAPTURE type.
+- Use string descriptions for node names in logging messages.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+pisp_be: Updates for libcamera usage:
+
+- Remove indexes from device entity names
+- Add enumframesize and enumfmts ioctls
+- Add default format to all nodes.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+v4l2: pisp_be: Move format definitions into v4l2 core
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: raspberrypi: Move PiSP common headers to a single location
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: raspberrypi: Remove old pispbe driver.
+
+This is now supersede by the driver in drivers/media/platform/raspberrypi/
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+PISP-BE Driver: Automate buffer-cycling for TDN and Stitch state.
+Remove "tdn-input" and "stitch-input" nodes altogether (the output
+nodes must still be opened and REQBUFS called with 1 or 2 buffers).
+Also, a bit of tidying of buffer address handling and locking.
+
+PISP-BE driver: Turn debug level right down to reduce overly-chatty messages
+
+media: bcm2712: Depend on CONFIG_PM
+
+Depend on CONFIG_PM as the driver uses the runtime_pm infrastructure.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+drivers: media: pisp_be: Move BE driver to a raspberrypi directory
+
+Move the pisp_be driver from drivers/media/platform/raspberrypi/ to
+drivers/media/platform/raspberrypi/pisp_be/. This seems the accepted
+convention in the drivers/media/platform/ directory structure.
+
+Also rename the driver module from bcm2712_pisp_be to pisp_be.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+pisp_be: Updates for libcamera streaming:
+
+- Add some required v4l2 formats
+- Add buf_prepare ioctl
+- Set plane offsets correctly before reprogramming
+
+pisp_be: Reduce logging verbosity
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+pisp_be: Add buffer timestamps
+
+While at it, remove duplicate code when checking if the HW has completed
+multiple jobs.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+pisp_be: Remove queue size allocation constraint
+
+PISP-BE driver: Fix ISR to handle multiple done/start events.
+
+PISP-BE: Fix variable-name shadowing bugette
+
+PISP-BE: Support for two node groups. Reorganize the driver.
+
+To support 2 concurrent libcamera applications, we need 2 node groups,
+need to allow multiple opens of each node (because libcamera does this)
+and create a separate media device per group (to support file-locking).
+
+This triggered significant rearrangement of the driver. Some calls
+that we formerly intercepted have been delegated back to v4l2/vb2.
+Logging changes arising from multiple v4l2_dev. Refactored probe()
+and initialization. Avoid dynamically-allocated entity name strings.
+
+drivers: media: pisp_be: Add vidioc_enum_fmt_meta_out
+
+This was missing in the struct v4l2_ioctl_ops definition.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+drivers: media: pispe_be: Add Bayer compressed formats
+
+Add PiSP Bayer compressed formats to the list of supported pixel formats
+for the PiSP backend driver.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+drivers: meida: pisp_be: Fix overflow in plane size calculations
+
+The calculations for buffer plane sizes can overflow because of the
+plane factor shift. Fix this by using u64 integers for the calculations.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+drivers: media: pisp_be: Use 0P3 for plane factors
+
+Use less precision for the plane factors to avoid any nasty overflows.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: pisp: Checkpatch and coding style fixups
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+
+media: pisp_be: More coding style fixups
+
+media: platform: bcm2712: pisp_be: Fix crash when buffer format not set
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+
+media: platform: bcm2712: pisp_be: Allow non-SRGB colour spaces on RGB outputs
+
+Allow colour spaces other than SRGB when the output format in question
+is an RGB output. This commit merely ports over existing changes from
+the vc4 ISP driver.
+
+Signed-off-by: David Plowman <david.plowman@raspberrypi.com>
+
+media: platform: bcm2712: Tweak list of BE supported image formats
+
+Remove RGB565 and 10- and 12-bit packed raw formats, which ISP-BE
+can't support for input or output. Add NV12M and NV21M which it can.
+(I didn't bother adding YUV422P, which apparently is not widely used.)
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+
+pisp_be: Fill the hardware revision in the media entity struct
+
+This can be used by userland to determine the hardware capabilities.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+bcm2712: Use BIT() macro
+
+Use the BIT() macro instead of plain bit shifting.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+bcm2712: Invert condition in pispbe_schedule_internal()
+
+Return earlier and save one indentation level
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+bcm2712: Invert condition in for loop
+
+Save one indentation level by continuing if the node is not streaming.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+bcm2712: Do not declare a local variable
+
+There already is a truct pispbe_node *node in the function scope.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+bcm21712: Siplify pispbe_schedule_one()
+
+A little more verbose but easier to follow ?
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+bcm2712: Rename pispbe_schedule_all() to pispbe_schedule_any()
+
+The pispbe_schedule_all() function name is misleading, as the function
+schedule a single job from any of the node groups. Rename it.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: platform: bcm2712: Remove buffer auto-cycling from ISP-BE
+
+Previously, the ISP-BE driver tried to automate "ping pong" buffers
+for TDN and HDR state, but did not fully conceal them from users.
+
+The automation has been removed: there are now separate output and
+capture queues for each of TDN and Stitch, which must be managed by
+user code (DMABUFs may be used to circulate buffers between queues).
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+
+drivers: media: pisp_be: Cache BE config buffer vaddr
+
+When programming a new job, we access at the config buffer, possibly
+from ISR context. So fetch and the virtual address when queuing the
+buffer.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+drivers: media: pisp_be: Remove all traces of ctrls and request API
+
+These APIs are not (and will not) be used by the driver, so remove them.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: bcm2712: Replace v4l2_dbg with dev_dbg
+
+Replace the v4l2 debug helpers with the device debug once, which are
+preferred.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Remove of_match_ptr()
+
+The of_match_ptr() usage could cause a compiler warning if
+CONFIG_OF is not enabled, as the pispbe_of_match variable would
+result unused.
+
+As the of_match_table field of struct platform_driver exists
+unconditionally, drop of_match_ptr() to avoid a warning.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+drivers: media: pispbe: Add local config buffer DMA allocation
+
+When initialiasing the driver, allocate a number of tiles + config
+structures used for storing hardware config internally in the driver.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+drivers: media: pispbe: Use local config buffers
+
+Store a copy of the config + tiles buffer locally when the buffer gets
+queued. This resolves the security issue where a userland process may
+modify the config buffer after it has been queued.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+drivers: media: pispbe: Validate config buffers
+
+Perform a basic config validation on the device output nodes to ensure
+the buffer size and stride values do not result in a buffer overrun.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: bcm2712: Rework probe sequence order
+
+Rework the probe sequence to:
+1) Use dev_err_probe() when failing to get clocks
+2) Disable clock on error path
+3) Disable the node groups if they have been enabled and
+   propagate the error up
+
+Also disable clocks in the remove() function.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Use pm_runtime_ops
+
+Introduce usage of runtime resume and suspend operations.
+
+The diver only uses a single clock source which is enable/disabled
+at resume and suspend time.
+
+Implement file open and release operations to control enablement of
+the clock provider.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Demote info message
+
+Demote info message about clock enablement to dev_dbg()
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Move pm_runtime calls to streamon/streamoff
+
+Move the calls to pm_runtime_resume_and_get() and pm_runtime_put()
+to the streamon and streamoff ioctl handlers.
+
+Remove custom handlers for the open and close file operations and use
+the framework provided helpers.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Use pm_runtime_autosuspend()
+
+Use the _autosuspend() version of runtime_pm_put() in order to avoid
+resuming and suspending the peripheral in between streaming sessions
+closely apart one from the other.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+drivers: media: pisp_be: Conditionally check buffers when preparing jobs
+
+When preparing a job, check the global enables in the config structure
+to see if the Output0/1, Tdn and Stitch blocks are enabled, and only
+test for a buffer queued if they are.
+
+This will allow userland to control the outputs selectively without
+disabling/re-enabling the respective device nodes.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: bcm2712: Rework media controller registration
+
+The current implementation register the v4l2_device and the video
+devices first, then creates the media controller and manually registers
+entities there.
+
+Rework the registration procedure to first create the v4l2_device and
+register the media_device with it. Then create the video nodes which
+gets automatically registered in the media graph by the core.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Create v4l2_subdev for ISP entity
+
+Create a v4l2 subdevice to represent the PISPBE ISP entity.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Fix v4l2-compliance warn on QUERYCAP
+
+Fix:
+
+warn: v4l2-compliance.cpp(669): media bus_info
+'platform:1000880000.pisp_be' differs from V4L2 bus_info
+'platform:pispbe'
+
+by populating the driver caps bus_info by using dev_name().
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Fix v4l2-compliance warn on invalid pixfmt
+
+The V4L2 API for the TRY_FMT/S_FMT ioctl allows the ioctl handler to
+return an error code only in specific conditions. If an invalid pixel
+format is supplied it should be adjusted instead of an error being
+returned.
+
+Albeit, v4l2-compliance treats this situation as a warning and not as
+an error because the behaviour has been discussed in length in the past.
+
+warn: v4l2-test-formats.cpp(794): TRY_FMT cannot handle an invalid pixelformat.
+warn: v4l2-test-formats.cpp(795): This may or may not be a problem. For more information see:
+warn: v4l2-test-formats.cpp(796): http://www.mail-archive.com/linux-media@vger.kernel.org/msg56550.html
+VIDIOC_TRY_FMT returned -1 (Invalid argument)
+
+Regardless of the warning vs failure decision, adjust the try_format()
+function implementation to use V4L2_PIX_FMT_YUV420M as default pixel
+format if the supplied one is invalid.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Fix v4l2-compliance warn on HOG pix format
+
+The try_format() implementation for the HOG video device node returns
+an error if the supplied pixel format is not correct.
+
+As per the video device output and capture video nodes, this contradicts
+the V4L2 specification even if it is treated as a warning by
+v4l2-compliance.
+
+Fix this by forcing the buffer pixel format and size to the default
+supported one. While at here, use the BIT() macro in the format
+initialization function.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Fix formats enumeration
+
+Right now a single implementation of enum_fmt() is used for all nodes
+in a group. This means that all the BE supported formats are listed for
+all the nodes. This is incorrect as the meta capture and output node
+formats should be restricted, and the meta formats should not be
+enumerated for video output and capture devices.
+
+Fix this by restricting the enumeration of META formats to the config
+and hog nodes. Split out from the list of supported_formats the
+V4L2_META_FMT_RPI_BE_CFG which is only used for the meta_out node, while
+V4L2_PIX_FMT_RPI_BE is kept in the list of supported_formats as it can
+be used as an opaque format for both meta_cap, video_cap and video_out
+nodes.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+
+media: bcm2712: Minor fixes to support PiSP regression tests
+
+Allow RGB input, not just Bayer (but only of those at once);
+Allow Wallpaper image formats. XXX They are not yet size-checked;
+Set "chicken bits" to test BURST_TRIM and AXI AWID/BID variation.
+Convert some v4l2_err() to dev_err()
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+
+drivers: media: pisp_be: Use the maximum number of config buffers
+
+Set PISP_BE_NUM_CONFIG_BUFFERS the the maximum number of possible
+buffers.  In the worst case, this overallocates config buffers, but
+given their size, it's not too much of a problem.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+
+media: pisp_be: Fix extra PM runtime put
+
+vidioc_streamoff callback can be called even if vidioc_streamon was
+never called. The driver currently does PM runtime get/put in these
+callbacks, which may lead to a put without a matching get.
+
+Fix this by moving the PM runtime get/put to vb2_ops's start_streaming &
+stop_streaming, which the framework makes sure won't get extra calls.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+
+drivers: media: pisp_be: Don't report V4L2_PIX_FMT_RPI_BE format
+
+This is an internal opaque format, not to be reported in enum_fmt.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/platform/Kconfig                |    1 +
+ drivers/media/platform/Makefile               |    1 +
+ drivers/media/platform/raspberrypi/Kconfig    |    5 +
+ drivers/media/platform/raspberrypi/Makefile   |    3 +
+ .../platform/raspberrypi/pisp_be/Kconfig      |   12 +
+ .../platform/raspberrypi/pisp_be/Makefile     |    6 +
+ .../platform/raspberrypi/pisp_be/pisp_be.c    | 1985 +++++++++++++++++
+ .../raspberrypi/pisp_be/pisp_be_config.h      |  533 +++++
+ .../raspberrypi/pisp_be/pisp_be_formats.h     |  469 ++++
+ drivers/media/v4l2-core/v4l2-ioctl.c          |    2 +
+ include/media/raspberrypi/pisp_common.h       |   65 +
+ include/media/raspberrypi/pisp_types.h        |  144 ++
+ include/uapi/linux/videodev2.h                |    6 +
+ 13 files changed, 3232 insertions(+)
+ create mode 100644 drivers/media/platform/raspberrypi/Kconfig
+ create mode 100644 drivers/media/platform/raspberrypi/Makefile
+ create mode 100644 drivers/media/platform/raspberrypi/pisp_be/Kconfig
+ create mode 100644 drivers/media/platform/raspberrypi/pisp_be/Makefile
+ create mode 100644 drivers/media/platform/raspberrypi/pisp_be/pisp_be.c
+ create mode 100644 drivers/media/platform/raspberrypi/pisp_be/pisp_be_config.h
+ create mode 100644 drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
+ create mode 100644 include/media/raspberrypi/pisp_common.h
+ create mode 100644 include/media/raspberrypi/pisp_types.h
+
+--- a/drivers/media/platform/Kconfig
++++ b/drivers/media/platform/Kconfig
+@@ -76,6 +76,7 @@ source "drivers/media/platform/mediatek/
+ source "drivers/media/platform/nvidia/Kconfig"
+ source "drivers/media/platform/nxp/Kconfig"
+ source "drivers/media/platform/qcom/Kconfig"
++source "drivers/media/platform/raspberrypi/Kconfig"
+ source "drivers/media/platform/renesas/Kconfig"
+ source "drivers/media/platform/rockchip/Kconfig"
+ source "drivers/media/platform/samsung/Kconfig"
+--- a/drivers/media/platform/Makefile
++++ b/drivers/media/platform/Makefile
+@@ -19,6 +19,7 @@ obj-y += mediatek/
+ obj-y += nvidia/
+ obj-y += nxp/
+ obj-y += qcom/
++obj-y += raspberrypi/
+ obj-y += renesas/
+ obj-y += rockchip/
+ obj-y += samsung/
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/Kconfig
+@@ -0,0 +1,5 @@
++# SPDX-License-Identifier: GPL-2.0-only
++
++comment "Raspberry Pi media platform drivers"
++
++source "drivers/media/platform/raspberrypi/pisp_be/Kconfig"
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/Makefile
+@@ -0,0 +1,3 @@
++# SPDX-License-Identifier: GPL-2.0
++
++obj-y += pisp_be/
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/pisp_be/Kconfig
+@@ -0,0 +1,12 @@
++config VIDEO_RASPBERRYPI_PISP_BE
++	tristate "Raspberry Pi PiSP Backend (BE) ISP driver"
++	depends on VIDEO_DEV && PM
++	select VIDEO_V4L2_SUBDEV_API
++	select MEDIA_CONTROLLER
++	select VIDEOBUF2_DMA_CONTIG
++	select V4L2_FWNODE
++	help
++	  Say Y here to enable support for the PiSP Backend (BE) ISP driver.
++
++	  To compile this driver as a module, choose M here. The module will be
++	  called pisp-be.
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/pisp_be/Makefile
+@@ -0,0 +1,6 @@
++# SPDX-License-Identifier: GPL-2.0
++#
++# Makefile for Raspberry Pi PiSP Backend driver
++#
++pisp-be-objs := pisp_be.o
++obj-$(CONFIG_VIDEO_RASPBERRYPI_PISP_BE) += pisp-be.o
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be.c
+@@ -0,0 +1,1985 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * PiSP Back End driver.
++ * Copyright (c) 2021-2022 Raspberry Pi Limited.
++ *
++ */
++#include <linux/clk.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/pm_runtime.h>
++#include <media/v4l2-device.h>
++#include <media/v4l2-ioctl.h>
++#include <media/videobuf2-dma-contig.h>
++#include <media/videobuf2-vmalloc.h>
++
++#include "pisp_be_config.h"
++#include "pisp_be_formats.h"
++
++MODULE_DESCRIPTION("PiSP Back End driver");
++MODULE_AUTHOR("David Plowman <david.plowman@raspberrypi.com>");
++MODULE_AUTHOR("Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>");
++MODULE_LICENSE("GPL v2");
++
++/* Offset to use when registering the /dev/videoX node */
++#define PISPBE_VIDEO_NODE_OFFSET 20
++
++/* Maximum number of config buffers possible */
++#define PISP_BE_NUM_CONFIG_BUFFERS VB2_MAX_FRAME
++
++/*
++ * We want to support 2 independent instances allowing 2 simultaneous users
++ * of the ISP-BE (of course they share hardware, platform resources and mutex).
++ * Each such instance comprises a group of device nodes representing input
++ * and output queues, and a media controller device node to describe them.
++ */
++#define PISPBE_NUM_NODE_GROUPS 2
++
++#define PISPBE_NAME "pispbe"
++
++/* Some ISP-BE registers */
++#define PISP_BE_VERSION_OFFSET (0x0)
++#define PISP_BE_CONTROL_OFFSET (0x4)
++#define PISP_BE_TILE_ADDR_LO_OFFSET (0x8)
++#define PISP_BE_TILE_ADDR_HI_OFFSET (0xc)
++#define PISP_BE_STATUS_OFFSET (0x10)
++#define PISP_BE_BATCH_STATUS_OFFSET (0x14)
++#define PISP_BE_INTERRUPT_EN_OFFSET (0x18)
++#define PISP_BE_INTERRUPT_STATUS_OFFSET (0x1c)
++#define PISP_BE_AXI_OFFSET (0x20)
++#define PISP_BE_CONFIG_BASE_OFFSET (0x40)
++#define PISP_BE_IO_INPUT_ADDR0_LO_OFFSET (PISP_BE_CONFIG_BASE_OFFSET)
++#define PISP_BE_GLOBAL_BAYER_ENABLE_OFFSET (PISP_BE_CONFIG_BASE_OFFSET + 0x70)
++#define PISP_BE_GLOBAL_RGB_ENABLE_OFFSET (PISP_BE_CONFIG_BASE_OFFSET + 0x74)
++#define N_HW_ADDRESSES 14
++#define N_HW_ENABLES 2
++
++#define PISP_BE_VERSION_2712C1 0x02252700
++#define PISP_BE_VERSION_MINOR_BITS 0xF
++
++/*
++ * This maps our nodes onto the inputs/outputs of the actual PiSP Back End.
++ * Be wary of the word "OUTPUT" which is used ambiguously here. In a V4L2
++ * context it means an input to the hardware (source image or metadata).
++ * Elsewhere it means an output from the hardware.
++ */
++enum node_ids {
++	MAIN_INPUT_NODE,
++	TDN_INPUT_NODE,
++	STITCH_INPUT_NODE,
++	HOG_OUTPUT_NODE,
++	OUTPUT0_NODE,
++	OUTPUT1_NODE,
++	TDN_OUTPUT_NODE,
++	STITCH_OUTPUT_NODE,
++	CONFIG_NODE,
++	PISPBE_NUM_NODES
++};
++
++struct node_description {
++	const char *ent_name;
++	enum v4l2_buf_type buf_type;
++	unsigned int caps;
++};
++
++static const struct node_description node_desc[PISPBE_NUM_NODES] = {
++	/* MAIN_INPUT_NODE */
++	{
++		.ent_name = PISPBE_NAME "-input",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
++		.caps = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
++	},
++	/* TDN_INPUT_NODE */
++	{
++		.ent_name = PISPBE_NAME "-tdn_input",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
++		.caps = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
++	},
++	/* STITCH_INPUT_NODE */
++	{
++		.ent_name = PISPBE_NAME "-stitch_input",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
++		.caps = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
++	},
++	/* HOG_OUTPUT_NODE */
++	{
++		.ent_name = PISPBE_NAME "-hog_output",
++		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
++		.caps = V4L2_CAP_META_CAPTURE,
++	},
++	/* OUTPUT0_NODE */
++	{
++		.ent_name = PISPBE_NAME "-output0",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
++	},
++	/* OUTPUT1_NODE */
++	{
++		.ent_name = PISPBE_NAME "-output1",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
++	},
++	/* TDN_OUTPUT_NODE */
++	{
++		.ent_name = PISPBE_NAME "-tdn_output",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
++	},
++	/* STITCH_OUTPUT_NODE */
++	{
++		.ent_name = PISPBE_NAME "-stitch_output",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
++	},
++	/* CONFIG_NODE */
++	{
++		.ent_name = PISPBE_NAME "-config",
++		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
++		.caps = V4L2_CAP_META_OUTPUT,
++	}
++};
++
++#define NODE_DESC_IS_OUTPUT(desc) ( \
++	((desc)->buf_type == V4L2_BUF_TYPE_META_OUTPUT) || \
++	((desc)->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT) || \
++	((desc)->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE))
++
++#define NODE_IS_META(node) ( \
++	((node)->buf_type == V4L2_BUF_TYPE_META_OUTPUT) || \
++	((node)->buf_type == V4L2_BUF_TYPE_META_CAPTURE))
++#define NODE_IS_OUTPUT(node) ( \
++	((node)->buf_type == V4L2_BUF_TYPE_META_OUTPUT) || \
++	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT) || \
++	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE))
++#define NODE_IS_CAPTURE(node) ( \
++	((node)->buf_type == V4L2_BUF_TYPE_META_CAPTURE) || \
++	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE) || \
++	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE))
++#define NODE_IS_MPLANE(node) ( \
++	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) || \
++	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE))
++
++/*
++ * Structure to describe a single node /dev/video<N> which represents a single
++ * input or output queue to the PiSP Back End device.
++ */
++struct pispbe_node {
++	unsigned int id;
++	int vfl_dir;
++	enum v4l2_buf_type buf_type;
++	struct video_device vfd;
++	struct media_pad pad;
++	struct media_intf_devnode *intf_devnode;
++	struct media_link *intf_link;
++	struct pispbe_node_group *node_group;
++	struct mutex node_lock;
++	struct mutex queue_lock;
++	spinlock_t ready_lock;
++	struct list_head ready_queue;
++	struct vb2_queue queue;
++	struct v4l2_format format;
++	const struct pisp_be_format *pisp_format;
++};
++
++/* For logging only, use the entity name with "pispbe" and separator removed */
++#define NODE_NAME(node) \
++		(node_desc[(node)->id].ent_name + sizeof(PISPBE_NAME))
++#define NODE_GET_V4L2(node) ((node)->node_group->v4l2_dev)
++
++/*
++ * Node group structure, which comprises all the input and output nodes that a
++ * single PiSP client will need, along with its own v4l2 and media devices.
++ */
++struct pispbe_node_group {
++	unsigned int id;
++	struct v4l2_device v4l2_dev;
++	struct v4l2_subdev sd;
++	struct pispbe_dev *pispbe;
++	struct media_device mdev;
++	struct pispbe_node node[PISPBE_NUM_NODES];
++	u32 streaming_map; /* bitmap of which nodes are streaming */
++	struct media_pad pad[PISPBE_NUM_NODES]; /* output pads first */
++	struct pisp_be_tiles_config *config;
++	dma_addr_t config_dma_addr;
++};
++
++/* Records details of the jobs currently running or queued on the h/w. */
++struct pispbe_job {
++	struct pispbe_node_group *node_group;
++	/*
++	 * An array of buffer pointers - remember it's source buffers first,
++	 * then captures, then metadata last.
++	 */
++	struct pispbe_buffer *buf[PISPBE_NUM_NODES];
++};
++
++/*
++ * Structure representing the entire PiSP Back End device, comprising several
++ * node groups which share platform resources and a mutex for the actual HW.
++ */
++struct pispbe_dev {
++	struct device *dev;
++	struct pispbe_node_group node_group[PISPBE_NUM_NODE_GROUPS];
++	int hw_busy; /* non-zero if a job is queued or is being started */
++	struct pispbe_job queued_job, running_job;
++	void __iomem *be_reg_base;
++	struct clk *clk;
++	int irq;
++	u32 hw_version;
++	u8 done, started;
++	spinlock_t hw_lock; /* protects "hw_busy" flag and streaming_map */
++};
++
++static inline u32 read_reg(struct pispbe_dev *pispbe, unsigned int offset)
++{
++	return readl(pispbe->be_reg_base + offset);
++}
++
++static inline void write_reg(struct pispbe_dev *pispbe, unsigned int offset,
++			     u32 val)
++{
++	writel(val, pispbe->be_reg_base + offset);
++}
++
++/* Check and initialize hardware. */
++static int hw_init(struct pispbe_dev *pispbe)
++{
++	u32 u;
++
++	/* Check the HW is present and has a known version */
++	u = read_reg(pispbe, PISP_BE_VERSION_OFFSET);
++	dev_info(pispbe->dev, "pispbe_probe: HW version:  0x%08x", u);
++	pispbe->hw_version = u;
++	if ((u & ~PISP_BE_VERSION_MINOR_BITS) != PISP_BE_VERSION_2712C1)
++		return -ENODEV;
++
++	/* Clear leftover interrupts */
++	write_reg(pispbe, PISP_BE_INTERRUPT_STATUS_OFFSET, 0xFFFFFFFFu);
++	u = read_reg(pispbe, PISP_BE_BATCH_STATUS_OFFSET);
++	dev_info(pispbe->dev, "pispbe_probe: BatchStatus: 0x%08x", u);
++	pispbe->done = (uint8_t)u;
++	pispbe->started = (uint8_t)(u >> 8);
++	u = read_reg(pispbe, PISP_BE_STATUS_OFFSET);
++	dev_info(pispbe->dev, "pispbe_probe: Status:      0x%08x", u);
++	if (u != 0 || pispbe->done != pispbe->started) {
++		dev_err(pispbe->dev, "pispbe_probe: HW is stuck or busy\n");
++		return -EBUSY;
++	}
++	/*
++	 * AXI QOS=0, CACHE=4'b0010, PROT=3'b011
++	 * Also set "chicken bits" 22:20 which enable sub-64-byte bursts
++	 * and AXI AWID/BID variability (on versions which support this).
++	 */
++	write_reg(pispbe, PISP_BE_AXI_OFFSET, 0x32703200u);
++
++	/* Enable both interrupt flags */
++	write_reg(pispbe, PISP_BE_INTERRUPT_EN_OFFSET, 0x00000003u);
++	return 0;
++}
++
++/*
++ * Queue a job to the h/w. If the h/w is idle it will begin immediately.
++ * Caller must ensure it is "safe to queue", i.e. we don't already have a
++ * queued, unstarted job.
++ */
++static void hw_queue_job(struct pispbe_dev *pispbe,
++			 dma_addr_t hw_dma_addrs[N_HW_ADDRESSES],
++			 u32 hw_enables[N_HW_ENABLES],
++			 struct pisp_be_config *config, dma_addr_t tiles,
++			 unsigned int num_tiles)
++{
++	unsigned int begin, end;
++	unsigned int u;
++
++	if (read_reg(pispbe, PISP_BE_STATUS_OFFSET) & 1)
++		dev_err(pispbe->dev, "ERROR: not safe to queue new job!\n");
++
++	/*
++	 * Write configuration to hardware. DMA addresses and enable flags
++	 * are passed separately, because the driver needs to sanitize them,
++	 * and we don't want to modify (or be vulnerable to modifications of)
++	 * the mmap'd buffer.
++	 */
++	for (u = 0; u < N_HW_ADDRESSES; ++u) {
++		write_reg(pispbe, PISP_BE_IO_INPUT_ADDR0_LO_OFFSET + 8 * u,
++			  (u32)(hw_dma_addrs[u]));
++		write_reg(pispbe, PISP_BE_IO_INPUT_ADDR0_LO_OFFSET + 8 * u + 4,
++			  (u32)(hw_dma_addrs[u] >> 32));
++	}
++	write_reg(pispbe, PISP_BE_GLOBAL_BAYER_ENABLE_OFFSET, hw_enables[0]);
++	write_reg(pispbe, PISP_BE_GLOBAL_RGB_ENABLE_OFFSET, hw_enables[1]);
++
++	/*
++	 * Everything else is as supplied by the user. XXX Buffer sizes not
++	 * checked!
++	 */
++	begin =	offsetof(struct pisp_be_config, global.bayer_order) /
++								sizeof(u32);
++	end = offsetof(struct pisp_be_config, axi) / sizeof(u32);
++	for (u = begin; u < end; u++) {
++		unsigned int val = ((u32 *)config)[u];
++
++		write_reg(pispbe, PISP_BE_CONFIG_BASE_OFFSET + 4 * u, val);
++	}
++
++	/* Read back the addresses -- an error here could be fatal */
++	for (u = 0; u < N_HW_ADDRESSES; ++u) {
++		unsigned int offset = PISP_BE_IO_INPUT_ADDR0_LO_OFFSET + 8 * u;
++		u64 along = read_reg(pispbe, offset);
++
++		along += ((u64)read_reg(pispbe, offset + 4)) << 32;
++		if (along != (u64)(hw_dma_addrs[u])) {
++			dev_err(pispbe->dev,
++				"ISP BE config error: check if ISP RAMs enabled?\n");
++			return;
++		}
++	}
++
++	/*
++	 * Write tile pointer to hardware. XXX Tile offsets and sizes not
++	 * checked (and even if checked, the user could subsequently modify
++	 * them)!
++	 */
++	write_reg(pispbe, PISP_BE_TILE_ADDR_LO_OFFSET, (u32)tiles);
++	write_reg(pispbe, PISP_BE_TILE_ADDR_HI_OFFSET, (u32)(tiles >> 32));
++
++	/* Enqueue the job */
++	write_reg(pispbe, PISP_BE_CONTROL_OFFSET, 3 + 65536 * num_tiles);
++}
++
++struct pispbe_buffer {
++	struct vb2_v4l2_buffer vb;
++	struct list_head ready_list;
++	unsigned int config_index;
++};
++
++static int get_addr_3(dma_addr_t addr[3], struct pispbe_buffer *buf,
++		      struct pispbe_node *node)
++{
++	unsigned int num_planes = node->format.fmt.pix_mp.num_planes;
++	unsigned int plane_factor = 0;
++	unsigned int size;
++	unsigned int p;
++
++	if (!buf || !node->pisp_format)
++		return 0;
++
++	WARN_ON(!NODE_IS_MPLANE(node));
++
++	/*
++	 * Determine the base plane size. This will not be the same
++	 * as node->format.fmt.pix_mp.plane_fmt[0].sizeimage for a single
++	 * plane buffer in an mplane format.
++	 */
++	size = node->format.fmt.pix_mp.plane_fmt[0].bytesperline *
++					node->format.fmt.pix_mp.height;
++
++	for (p = 0; p < num_planes && p < 3; p++) {
++		addr[p] = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, p);
++		plane_factor += node->pisp_format->plane_factor[p];
++	}
++
++	for (; p < MAX_PLANES && node->pisp_format->plane_factor[p]; p++) {
++		/*
++		 * Calculate the address offset of this plane as needed
++		 * by the hardware. This is specifically for non-mplane
++		 * buffer formats, where there are 3 image planes, e.g.
++		 * for the V4L2_PIX_FMT_YUV420 format.
++		 */
++		addr[p] = addr[0] + ((size * plane_factor) >> 3);
++		plane_factor += node->pisp_format->plane_factor[p];
++	}
++
++	return num_planes;
++}
++
++static dma_addr_t get_addr(struct pispbe_buffer *buf)
++{
++	if (buf)
++		return vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
++	return 0;
++}
++
++static void
++fixup_addrs_enables(dma_addr_t addrs[N_HW_ADDRESSES],
++		    u32 hw_enables[N_HW_ENABLES],
++		    struct pisp_be_tiles_config *config,
++		    struct pispbe_buffer *buf[PISPBE_NUM_NODES],
++		    struct pispbe_node_group *node_group)
++{
++	int ret, i;
++
++	/* Take a copy of the "enable" bitmaps so we can modify them. */
++	hw_enables[0] = config->config.global.bayer_enables;
++	hw_enables[1] = config->config.global.rgb_enables;
++
++	/*
++	 * Main input first. There are 3 address pointers, corresponding to up
++	 * to 3 planes.
++	 */
++	ret = get_addr_3(addrs, buf[MAIN_INPUT_NODE],
++			 &node_group->node[MAIN_INPUT_NODE]);
++	if (ret <= 0) {
++		/*
++		 * This shouldn't happen; pispbe_schedule_internal should insist
++		 * on an input.
++		 */
++		dev_warn(node_group->pispbe->dev,
++			"ISP-BE missing input\n");
++		hw_enables[0] = 0;
++		hw_enables[1] = 0;
++		return;
++	}
++
++	/*
++	 * Now TDN/Stitch inputs and outputs. These are single-plane and only
++	 * used with Bayer input. Input enables must match the requirements
++	 * of the processing stages, otherwise the hardware can lock up!
++	 */
++	if (hw_enables[0] & PISP_BE_BAYER_ENABLE_INPUT) {
++		addrs[3] = get_addr(buf[TDN_INPUT_NODE]);
++		if (addrs[3] == 0 ||
++		    !(hw_enables[0] & PISP_BE_BAYER_ENABLE_TDN_INPUT) ||
++		    !(hw_enables[0] & PISP_BE_BAYER_ENABLE_TDN) ||
++		    (config->config.tdn.reset & 1)) {
++			hw_enables[0] &= ~(PISP_BE_BAYER_ENABLE_TDN_INPUT |
++					   PISP_BE_BAYER_ENABLE_TDN_DECOMPRESS);
++			if (!(config->config.tdn.reset & 1))
++				hw_enables[0] &= ~PISP_BE_BAYER_ENABLE_TDN;
++		}
++
++		addrs[4] = get_addr(buf[STITCH_INPUT_NODE]);
++		if (addrs[4] == 0 ||
++		    !(hw_enables[0] & PISP_BE_BAYER_ENABLE_STITCH_INPUT) ||
++		    !(hw_enables[0] & PISP_BE_BAYER_ENABLE_STITCH)) {
++			hw_enables[0] &=
++				~(PISP_BE_BAYER_ENABLE_STITCH_INPUT |
++				  PISP_BE_BAYER_ENABLE_STITCH_DECOMPRESS |
++				  PISP_BE_BAYER_ENABLE_STITCH);
++		}
++
++		addrs[5] = get_addr(buf[TDN_OUTPUT_NODE]);
++		if (addrs[5] == 0)
++			hw_enables[0] &= ~(PISP_BE_BAYER_ENABLE_TDN_COMPRESS |
++					   PISP_BE_BAYER_ENABLE_TDN_OUTPUT);
++
++		addrs[6] = get_addr(buf[STITCH_OUTPUT_NODE]);
++		if (addrs[6] == 0)
++			hw_enables[0] &=
++				~(PISP_BE_BAYER_ENABLE_STITCH_COMPRESS |
++				  PISP_BE_BAYER_ENABLE_STITCH_OUTPUT);
++	} else {
++		/* No Bayer input? Disable entire Bayer pipe (else lockup) */
++		hw_enables[0] = 0;
++	}
++
++	/* Main image output channels. */
++	for (i = 0; i < PISP_BACK_END_NUM_OUTPUTS; i++) {
++		ret = get_addr_3(addrs + 7 + 3 * i, buf[OUTPUT0_NODE + i],
++				 &node_group->node[OUTPUT0_NODE + i]);
++		if (ret <= 0)
++			hw_enables[1] &= ~(PISP_BE_RGB_ENABLE_OUTPUT0 << i);
++	}
++
++	/* HoG output (always single plane). */
++	addrs[13] = get_addr(buf[HOG_OUTPUT_NODE]);
++	if (addrs[13] == 0)
++		hw_enables[1] &= ~PISP_BE_RGB_ENABLE_HOG;
++}
++
++/*
++ * Internal function. Called from pispbe_schedule_one/all. Returns non-zero if
++ * we started a job.
++ *
++ * Warning: needs to be called with hw_lock taken, and releases it if it
++ * schedules a job.
++ */
++static int pispbe_schedule_internal(struct pispbe_node_group *node_group,
++				    unsigned long flags)
++{
++	struct pisp_be_tiles_config *config_tiles_buffer;
++	struct pispbe_dev *pispbe = node_group->pispbe;
++	struct pispbe_buffer *buf[PISPBE_NUM_NODES];
++	dma_addr_t hw_dma_addrs[N_HW_ADDRESSES];
++	dma_addr_t tiles;
++	u32 hw_enables[N_HW_ENABLES];
++	struct pispbe_node *node;
++	unsigned long flags1;
++	unsigned int config_index;
++	int i;
++
++	/*
++	 * To schedule a job, we need all streaming nodes (apart from Output0,
++	 * Output1, Tdn and Stitch) to have a buffer ready, which must
++	 * include at least a config buffer and a main input image.
++	 *
++	 * For Output0, Output1, Tdn and Stitch, a buffer only needs to be
++	 * available if the blocks are enabled in the config.
++	 *
++	 * (Note that streaming_map is protected by hw_lock, which is held.)
++	 */
++	if (((BIT(CONFIG_NODE) | BIT(MAIN_INPUT_NODE)) &
++		node_group->streaming_map) !=
++			(BIT(CONFIG_NODE) | BIT(MAIN_INPUT_NODE))) {
++		dev_dbg(pispbe->dev, "Nothing to do\n");
++		return 0;
++	}
++
++	node = &node_group->node[CONFIG_NODE];
++	spin_lock_irqsave(&node->ready_lock, flags1);
++	buf[CONFIG_NODE] =
++	   list_first_entry_or_null(&node->ready_queue, struct pispbe_buffer,
++				    ready_list);
++	spin_unlock_irqrestore(&node->ready_lock, flags1);
++
++	/* Exit early if no config buffer has been queued. */
++	if (!buf[CONFIG_NODE])
++		return 0;
++
++	config_index = buf[CONFIG_NODE]->vb.vb2_buf.index;
++	config_tiles_buffer = &node_group->config[config_index];
++	tiles = (dma_addr_t)node_group->config_dma_addr +
++			config_index * sizeof(struct pisp_be_tiles_config) +
++			offsetof(struct pisp_be_tiles_config, tiles);
++
++	/* remember: srcimages, captures then metadata */
++	for (i = 0; i < PISPBE_NUM_NODES; i++) {
++		unsigned int bayer_en =
++			config_tiles_buffer->config.global.bayer_enables;
++		unsigned int rgb_en =
++			config_tiles_buffer->config.global.rgb_enables;
++		bool ignore_buffers = false;
++
++		/* Config node is handled outside the loop above. */
++		if (i == CONFIG_NODE)
++			continue;
++
++		buf[i] = NULL;
++		if (!(node_group->streaming_map & BIT(i)))
++			continue;
++
++		if ((!(rgb_en & PISP_BE_RGB_ENABLE_OUTPUT0) &&
++		     i == OUTPUT0_NODE) ||
++		    (!(rgb_en & PISP_BE_RGB_ENABLE_OUTPUT1) &&
++		     i == OUTPUT1_NODE) ||
++		    (!(bayer_en & PISP_BE_BAYER_ENABLE_TDN_INPUT) &&
++		     i == TDN_INPUT_NODE) ||
++		    (!(bayer_en & PISP_BE_BAYER_ENABLE_TDN_OUTPUT) &&
++		     i == TDN_OUTPUT_NODE) ||
++		    (!(bayer_en & PISP_BE_BAYER_ENABLE_STITCH_INPUT) &&
++		     i == STITCH_INPUT_NODE) ||
++		    (!(bayer_en & PISP_BE_BAYER_ENABLE_STITCH_OUTPUT) &&
++		     i == STITCH_OUTPUT_NODE)) {
++			/*
++			 * Ignore Output0/Output1/Tdn/Stitch buffer check if the
++			 * global enables aren't set for these blocks. If a
++			 * buffer has been provided, we dequeue it back to the
++			 * user with the other in-use buffers.
++			 *
++			 */
++			ignore_buffers = true;
++		}
++
++		node = &node_group->node[i];
++
++		spin_lock_irqsave(&node->ready_lock, flags1);
++		buf[i] = list_first_entry_or_null(&node->ready_queue,
++						  struct pispbe_buffer,
++						  ready_list);
++		spin_unlock_irqrestore(&node->ready_lock, flags1);
++		if (!buf[i] && !ignore_buffers) {
++			dev_dbg(pispbe->dev, "Nothing to do\n");
++			return 0;
++		}
++	}
++
++	/* Pull a buffer from each V4L2 queue to form the queued job */
++	for (i = 0; i < PISPBE_NUM_NODES; i++) {
++		if (buf[i]) {
++			node = &node_group->node[i];
++
++			spin_lock_irqsave(&node->ready_lock, flags1);
++			list_del(&buf[i]->ready_list);
++			spin_unlock_irqrestore(&node->ready_lock,
++					       flags1);
++		}
++		pispbe->queued_job.buf[i] = buf[i];
++	}
++
++	pispbe->queued_job.node_group = node_group;
++	pispbe->hw_busy = 1;
++	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
++
++	/*
++	 * We can kick the job off without the hw_lock, as this can
++	 * never run again until hw_busy is cleared, which will happen
++	 * only when the following job has been queued.
++	 */
++	dev_dbg(pispbe->dev, "Have buffers - starting hardware\n");
++
++	/* Convert buffers to DMA addresses for the hardware */
++	fixup_addrs_enables(hw_dma_addrs, hw_enables,
++			    config_tiles_buffer, buf, node_group);
++	/*
++	 * This could be a spot to fill in the
++	 * buf[i]->vb.vb2_buf.planes[j].bytesused fields?
++	 */
++	i = config_tiles_buffer->num_tiles;
++	if (i <= 0 || i > PISP_BACK_END_NUM_TILES ||
++	    !((hw_enables[0] | hw_enables[1]) &
++	      PISP_BE_BAYER_ENABLE_INPUT)) {
++		/*
++		 * Bad job. We can't let it proceed as it could lock up
++		 * the hardware, or worse!
++		 *
++		 * XXX How to deal with this most cleanly? For now, just
++		 * force num_tiles to 0, which causes the H/W to do
++		 * something bizarre but survivable. It increments
++		 * (started,done) counters by more than 1, but we seem
++		 * to survive...
++		 */
++		dev_err(pispbe->dev, "PROBLEM: Bad job");
++		i = 0;
++	}
++	hw_queue_job(pispbe, hw_dma_addrs, hw_enables,
++		     &config_tiles_buffer->config, tiles, i);
++
++	return 1;
++}
++
++/* Try and schedule a job for just a single node group. */
++static void pispbe_schedule_one(struct pispbe_node_group *node_group)
++{
++	struct pispbe_dev *pispbe = node_group->pispbe;
++	unsigned long flags;
++	int ret;
++
++	spin_lock_irqsave(&pispbe->hw_lock, flags);
++	if (pispbe->hw_busy) {
++		spin_unlock_irqrestore(&pispbe->hw_lock, flags);
++		return;
++	}
++
++	/* A non-zero return means the lock was released. */
++	ret = pispbe_schedule_internal(node_group, flags);
++	if (!ret)
++		spin_unlock_irqrestore(&pispbe->hw_lock, flags);
++}
++
++/* Try and schedule a job for any of the node groups. */
++static void pispbe_schedule_any(struct pispbe_dev *pispbe, int clear_hw_busy)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&pispbe->hw_lock, flags);
++
++	if (clear_hw_busy)
++		pispbe->hw_busy = 0;
++	if (pispbe->hw_busy == 0) {
++		unsigned int i;
++
++		for (i = 0; i < PISPBE_NUM_NODE_GROUPS; i++) {
++			/*
++			 * A non-zero return from pispbe_schedule_internal means
++			 * the lock was released.
++			 */
++			if (pispbe_schedule_internal(&pispbe->node_group[i],
++						     flags))
++				return;
++		}
++	}
++	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
++}
++
++static void pispbe_isr_jobdone(struct pispbe_dev *pispbe,
++			       struct pispbe_job *job)
++{
++	struct pispbe_buffer **buf = job->buf;
++	u64 ts = ktime_get_ns();
++	int i;
++
++	for (i = 0; i < PISPBE_NUM_NODES; i++) {
++		if (buf[i]) {
++			buf[i]->vb.vb2_buf.timestamp = ts;
++			vb2_buffer_done(&buf[i]->vb.vb2_buf,
++					VB2_BUF_STATE_DONE);
++		}
++	}
++}
++
++static irqreturn_t pispbe_isr(int irq, void *dev)
++{
++	struct pispbe_dev *pispbe = (struct pispbe_dev *)dev;
++	u8 started, done;
++	int can_queue_another = 0;
++	u32 u;
++
++	u = read_reg(pispbe, PISP_BE_INTERRUPT_STATUS_OFFSET);
++	if (u == 0)
++		return IRQ_NONE;
++
++	write_reg(pispbe, PISP_BE_INTERRUPT_STATUS_OFFSET, u);
++	dev_dbg(pispbe->dev, "Hardware interrupt\n");
++	u = read_reg(pispbe, PISP_BE_BATCH_STATUS_OFFSET);
++	done = (uint8_t)u;
++	started = (uint8_t)(u >> 8);
++	dev_dbg(pispbe->dev,
++		"H/W started %d done %d, previously started %d done %d\n",
++		(int)started, (int)done, (int)pispbe->started,
++		(int)pispbe->done);
++
++	/*
++	 * Be aware that done can go up by 2 and started by 1 when: a job that
++	 * we previously saw "start" now finishes, and we then queued a new job
++	 * which we see both start and finish "simultaneously".
++	 */
++	if (pispbe->running_job.node_group && pispbe->done != done) {
++		pispbe_isr_jobdone(pispbe, &pispbe->running_job);
++		memset(&pispbe->running_job, 0, sizeof(pispbe->running_job));
++		pispbe->done++;
++		dev_dbg(pispbe->dev, "Job done (1)\n");
++	}
++
++	if (pispbe->started != started) {
++		pispbe->started++;
++		can_queue_another = 1;
++		dev_dbg(pispbe->dev, "Job started\n");
++
++		if (pispbe->done != done && pispbe->queued_job.node_group) {
++			pispbe_isr_jobdone(pispbe, &pispbe->queued_job);
++			pispbe->done++;
++			dev_dbg(pispbe->dev, "Job done (2)\n");
++		} else {
++			pispbe->running_job = pispbe->queued_job;
++		}
++
++		memset(&pispbe->queued_job, 0, sizeof(pispbe->queued_job));
++	}
++
++	if (pispbe->done != done || pispbe->started != started) {
++		dev_err(pispbe->dev, "PROBLEM: counters not matching!\n");
++		pispbe->started = started;
++		pispbe->done = done;
++	}
++
++	/* check if there's more to do before going to sleep */
++	pispbe_schedule_any(pispbe, can_queue_another);
++
++	return IRQ_HANDLED;
++}
++
++static int pisp_be_validate_config(struct pispbe_node_group *node_group,
++				   struct pisp_be_tiles_config *config)
++{
++	u32 bayer_enables = config->config.global.bayer_enables;
++	u32 rgb_enables = config->config.global.rgb_enables;
++	struct device *dev = node_group->pispbe->dev;
++	struct v4l2_format *fmt;
++	unsigned int bpl, size, i, j;
++
++	if (!(bayer_enables & PISP_BE_BAYER_ENABLE_INPUT) ==
++	    !(rgb_enables & PISP_BE_RGB_ENABLE_INPUT)) {
++		dev_err(dev, "%s: Not one input enabled\n", __func__);
++		return -EIO;
++	}
++
++	/* Ensure output config strides and buffer sizes match the V4L2 formats. */
++	fmt = &node_group->node[TDN_OUTPUT_NODE].format;
++	if (bayer_enables & PISP_BE_BAYER_ENABLE_TDN_OUTPUT) {
++		bpl = config->config.tdn_output_format.stride;
++		size = bpl * config->config.tdn_output_format.height;
++		if (fmt->fmt.pix_mp.plane_fmt[0].bytesperline < bpl) {
++			dev_err(dev, "%s: bpl mismatch on tdn_output\n",
++				__func__);
++			return -EINVAL;
++		}
++		if (fmt->fmt.pix_mp.plane_fmt[0].sizeimage < size) {
++			dev_err(dev, "%s: size mismatch on tdn_output\n",
++				__func__);
++			return -EINVAL;
++		}
++	}
++
++	fmt = &node_group->node[STITCH_OUTPUT_NODE].format;
++	if (bayer_enables & PISP_BE_BAYER_ENABLE_STITCH_OUTPUT) {
++		bpl = config->config.stitch_output_format.stride;
++		size = bpl * config->config.stitch_output_format.height;
++		if (fmt->fmt.pix_mp.plane_fmt[0].bytesperline < bpl) {
++			dev_err(dev, "%s: bpl mismatch on stitch_output\n",
++				__func__);
++			return -EINVAL;
++		}
++		if (fmt->fmt.pix_mp.plane_fmt[0].sizeimage < size) {
++			dev_err(dev, "%s: size mismatch on stitch_output\n",
++				__func__);
++			return -EINVAL;
++		}
++	}
++
++	for (j = 0; j < PISP_BACK_END_NUM_OUTPUTS; j++) {
++		if (!(rgb_enables & PISP_BE_RGB_ENABLE_OUTPUT(j)))
++			continue;
++		if (config->config.output_format[j].image.format &
++		    PISP_IMAGE_FORMAT_WALLPAPER_ROLL)
++			continue; /* TODO: Size checks for wallpaper formats */
++
++		fmt = &node_group->node[OUTPUT0_NODE + j].format;
++		for (i = 0; i < fmt->fmt.pix_mp.num_planes; i++) {
++			bpl = !i ? config->config.output_format[j].image.stride
++			    : config->config.output_format[j].image.stride2;
++			size = bpl * config->config.output_format[j].image.height;
++
++			if (config->config.output_format[j].image.format &
++						PISP_IMAGE_FORMAT_SAMPLING_420)
++				size >>= 1;
++			if (fmt->fmt.pix_mp.plane_fmt[i].bytesperline < bpl) {
++				dev_err(dev, "%s: bpl mismatch on output %d\n",
++					__func__, j);
++				return -EINVAL;
++			}
++			if (fmt->fmt.pix_mp.plane_fmt[i].sizeimage < size) {
++				dev_err(dev, "%s: size mismatch on output\n",
++					__func__);
++				return -EINVAL;
++			}
++		}
++	}
++
++	return 0;
++}
++
++static int pispbe_node_queue_setup(struct vb2_queue *q, unsigned int *nbuffers,
++				   unsigned int *nplanes, unsigned int sizes[],
++				   struct device *alloc_devs[])
++{
++	struct pispbe_node *node = vb2_get_drv_priv(q);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	*nplanes = 1;
++	if (NODE_IS_MPLANE(node)) {
++		unsigned int i;
++
++		*nplanes = node->format.fmt.pix_mp.num_planes;
++		for (i = 0; i < *nplanes; i++) {
++			unsigned int size =
++				node->format.fmt.pix_mp.plane_fmt[i].sizeimage;
++			if (sizes[i] && sizes[i] < size) {
++				dev_err(pispbe->dev, "%s: size %u < %u\n",
++					__func__, sizes[i], size);
++				return -EINVAL;
++			}
++			sizes[i] = size;
++		}
++	} else if (NODE_IS_META(node)) {
++		sizes[0] = node->format.fmt.meta.buffersize;
++		/*
++		 * Limit the config node buffer count to the number of internal
++		 * buffers allocated.
++		 */
++		if (node->id == CONFIG_NODE)
++			*nbuffers = min_t(unsigned int, *nbuffers,
++					  PISP_BE_NUM_CONFIG_BUFFERS);
++	}
++
++	dev_dbg(pispbe->dev,
++		"Image (or metadata) size %u, nbuffers %u for node %s\n",
++		sizes[0], *nbuffers, NODE_NAME(node));
++
++	return 0;
++}
++
++static int pispbe_node_buffer_prepare(struct vb2_buffer *vb)
++{
++	struct pispbe_node *node = vb2_get_drv_priv(vb->vb2_queue);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	unsigned long size = 0;
++	unsigned int num_planes = NODE_IS_MPLANE(node) ?
++					node->format.fmt.pix_mp.num_planes : 1;
++	unsigned int i;
++
++	for (i = 0; i < num_planes; i++) {
++		size = NODE_IS_MPLANE(node)
++			? node->format.fmt.pix_mp.plane_fmt[i].sizeimage
++			: node->format.fmt.meta.buffersize;
++
++		if (vb2_plane_size(vb, i) < size) {
++			dev_err(pispbe->dev,
++				"data will not fit into plane %d (%lu < %lu)\n",
++				i, vb2_plane_size(vb, i), size);
++			return -EINVAL;
++		}
++
++		vb2_set_plane_payload(vb, i, size);
++	}
++
++	if (node->id == CONFIG_NODE) {
++		void *dst = &node->node_group->config[vb->index];
++		void *src = vb2_plane_vaddr(vb, 0);
++
++		memcpy(dst, src, sizeof(struct pisp_be_tiles_config));
++		return pisp_be_validate_config(node->node_group, dst);
++	}
++
++	return 0;
++}
++
++static void pispbe_node_buffer_queue(struct vb2_buffer *buf)
++{
++	struct vb2_v4l2_buffer *vbuf =
++		container_of(buf, struct vb2_v4l2_buffer, vb2_buf);
++	struct pispbe_buffer *buffer =
++		container_of(vbuf, struct pispbe_buffer, vb);
++	struct pispbe_node *node = vb2_get_drv_priv(buf->vb2_queue);
++	struct pispbe_node_group *node_group = node->node_group;
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	unsigned long flags;
++
++	dev_dbg(pispbe->dev, "%s: for node %s\n", __func__, NODE_NAME(node));
++	spin_lock_irqsave(&node->ready_lock, flags);
++	list_add_tail(&buffer->ready_list, &node->ready_queue);
++	spin_unlock_irqrestore(&node->ready_lock, flags);
++
++	/*
++	 * Every time we add a buffer, check if there's now some work for the hw
++	 * to do, but only for this client.
++	 */
++	pispbe_schedule_one(node_group);
++}
++
++static int pispbe_node_start_streaming(struct vb2_queue *q, unsigned int count)
++{
++	unsigned long flags;
++	struct pispbe_node *node = vb2_get_drv_priv(q);
++	struct pispbe_node_group *node_group = node->node_group;
++	struct pispbe_dev *pispbe = node_group->pispbe;
++	int ret;
++
++	ret = pm_runtime_resume_and_get(pispbe->dev);
++	if (ret < 0)
++		return ret;
++
++	spin_lock_irqsave(&pispbe->hw_lock, flags);
++	node->node_group->streaming_map |=  BIT(node->id);
++	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
++
++	dev_dbg(pispbe->dev, "%s: for node %s (count %u)\n",
++		__func__, NODE_NAME(node), count);
++	dev_dbg(pispbe->dev, "Nodes streaming for this group now 0x%x\n",
++		node->node_group->streaming_map);
++
++	/* Maybe we're ready to run. */
++	pispbe_schedule_one(node_group);
++
++	return 0;
++}
++
++static void pispbe_node_stop_streaming(struct vb2_queue *q)
++{
++	struct pispbe_node *node = vb2_get_drv_priv(q);
++	struct pispbe_node_group *node_group = node->node_group;
++	struct pispbe_dev *pispbe = node_group->pispbe;
++	struct pispbe_buffer *buf;
++	unsigned long flags;
++
++	/*
++	 * Now this is a bit awkward. In a simple M2M device we could just wait
++	 * for all queued jobs to complete, but here there's a risk that a
++	 * partial set of buffers was queued and cannot be run. For now, just
++	 * cancel all buffers stuck in the "ready queue", then wait for any
++	 * running job.
++	 * XXX This may return buffers out of order.
++	 */
++	dev_dbg(pispbe->dev, "%s: for node %s\n", __func__, NODE_NAME(node));
++	spin_lock_irqsave(&pispbe->hw_lock, flags);
++	do {
++		unsigned long flags1;
++
++		spin_lock_irqsave(&node->ready_lock, flags1);
++		buf = list_first_entry_or_null(&node->ready_queue,
++					       struct pispbe_buffer,
++					       ready_list);
++		if (buf) {
++			list_del(&buf->ready_list);
++			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
++		}
++		spin_unlock_irqrestore(&node->ready_lock, flags1);
++	} while (buf);
++	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
++
++	vb2_wait_for_all_buffers(&node->queue);
++
++	spin_lock_irqsave(&pispbe->hw_lock, flags);
++	node_group->streaming_map &= ~BIT(node->id);
++	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
++
++	pm_runtime_mark_last_busy(pispbe->dev);
++	pm_runtime_put_autosuspend(pispbe->dev);
++
++	dev_dbg(pispbe->dev, "Nodes streaming for this group now 0x%x\n",
++		node_group->streaming_map);
++}
++
++static const struct vb2_ops pispbe_node_queue_ops = {
++	.queue_setup = pispbe_node_queue_setup,
++	.buf_prepare = pispbe_node_buffer_prepare,
++	.buf_queue = pispbe_node_buffer_queue,
++	.start_streaming = pispbe_node_start_streaming,
++	.stop_streaming = pispbe_node_stop_streaming,
++};
++
++static const struct v4l2_file_operations pispbe_fops = {
++	.owner          = THIS_MODULE,
++	.open           = v4l2_fh_open,
++	.release        = vb2_fop_release,
++	.poll           = vb2_fop_poll,
++	.unlocked_ioctl = video_ioctl2,
++	.mmap           = vb2_fop_mmap
++};
++
++static int pispbe_node_querycap(struct file *file, void *priv,
++				struct v4l2_capability *cap)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	strscpy(cap->driver, PISPBE_NAME, sizeof(cap->driver));
++	strscpy(cap->card, PISPBE_NAME, sizeof(cap->card));
++	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
++		 dev_name(pispbe->dev));
++
++	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE_MPLANE |
++			    V4L2_CAP_VIDEO_OUTPUT_MPLANE |
++			    V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS |
++			    V4L2_CAP_META_OUTPUT | V4L2_CAP_META_CAPTURE;
++	cap->device_caps = node->vfd.device_caps;
++
++	dev_dbg(pispbe->dev, "Caps for node %s: %x and %x (dev %x)\n",
++		NODE_NAME(node), cap->capabilities, cap->device_caps,
++		node->vfd.device_caps);
++	return 0;
++}
++
++static int pispbe_node_g_fmt_vid_cap(struct file *file, void *priv,
++				     struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	if (!NODE_IS_CAPTURE(node) || NODE_IS_META(node)) {
++		dev_err(pispbe->dev,
++			"Cannot get capture fmt for output node %s\n",
++			NODE_NAME(node));
++		return -EINVAL;
++	}
++	*f = node->format;
++	dev_dbg(pispbe->dev, "Get capture format for node %s\n",
++		NODE_NAME(node));
++	return 0;
++}
++
++static int pispbe_node_g_fmt_vid_out(struct file *file, void *priv,
++				     struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	if (NODE_IS_CAPTURE(node) || NODE_IS_META(node)) {
++		dev_err(pispbe->dev,
++			"Cannot get capture fmt for output node %s\n",
++			 NODE_NAME(node));
++		return -EINVAL;
++	}
++	*f = node->format;
++	dev_dbg(pispbe->dev, "Get output format for node %s\n",
++		NODE_NAME(node));
++	return 0;
++}
++
++static int pispbe_node_g_fmt_meta_out(struct file *file, void *priv,
++				      struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	if (!NODE_IS_META(node) || NODE_IS_CAPTURE(node)) {
++		dev_err(pispbe->dev,
++			"Cannot get capture fmt for meta output node %s\n",
++			NODE_NAME(node));
++		return -EINVAL;
++	}
++	*f = node->format;
++	dev_dbg(pispbe->dev, "Get output format for meta node %s\n",
++		NODE_NAME(node));
++	return 0;
++}
++
++static int pispbe_node_g_fmt_meta_cap(struct file *file, void *priv,
++				      struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	if (!NODE_IS_META(node) || NODE_IS_OUTPUT(node)) {
++		dev_err(pispbe->dev,
++			"Cannot get capture fmt for meta output node %s\n",
++			NODE_NAME(node));
++		return -EINVAL;
++	}
++	*f = node->format;
++	dev_dbg(pispbe->dev, "Get output format for meta node %s\n",
++		NODE_NAME(node));
++	return 0;
++}
++
++static int verify_be_pix_format(const struct v4l2_format *f,
++				struct pispbe_node *node)
++{
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	unsigned int nplanes = f->fmt.pix_mp.num_planes;
++	unsigned int i;
++
++	if (f->fmt.pix_mp.width == 0 || f->fmt.pix_mp.height == 0) {
++		dev_err(pispbe->dev, "Details incorrect for output node %s\n",
++			NODE_NAME(node));
++		return -EINVAL;
++	}
++
++	if (nplanes == 0 || nplanes > MAX_PLANES) {
++		dev_err(pispbe->dev,
++			"Bad number of planes for output node %s, req =%d\n",
++			NODE_NAME(node), nplanes);
++		return -EINVAL;
++	}
++
++	for (i = 0; i < nplanes; i++) {
++		const struct v4l2_plane_pix_format *p;
++
++		p = &f->fmt.pix_mp.plane_fmt[i];
++		if (p->bytesperline == 0 || p->sizeimage == 0) {
++			dev_err(pispbe->dev,
++				"Invalid plane %d for output node %s\n",
++				i, NODE_NAME(node));
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static const struct pisp_be_format *find_format(unsigned int fourcc)
++{
++	const struct pisp_be_format *fmt;
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(supported_formats); i++) {
++		fmt = &supported_formats[i];
++		if (fmt->fourcc == fourcc)
++			return fmt;
++	}
++
++	return NULL;
++}
++
++static void set_plane_params(struct v4l2_format *f,
++			     const struct pisp_be_format *fmt)
++{
++	unsigned int nplanes = f->fmt.pix_mp.num_planes;
++	unsigned int total_plane_factor = 0;
++	unsigned int i;
++
++	for (i = 0; i < MAX_PLANES; i++)
++		total_plane_factor += fmt->plane_factor[i];
++
++	for (i = 0; i < nplanes; i++) {
++		struct v4l2_plane_pix_format *p = &f->fmt.pix_mp.plane_fmt[i];
++		unsigned int bpl, plane_size;
++
++		bpl = (f->fmt.pix_mp.width * fmt->bit_depth) >> 3;
++		bpl = ALIGN(max(p->bytesperline, bpl), fmt->align);
++
++		plane_size = bpl * f->fmt.pix_mp.height *
++		      (nplanes > 1 ? fmt->plane_factor[i] : total_plane_factor);
++		/*
++		 * The shift is to divide out the plane_factor fixed point
++		 * scaling of 8.
++		 */
++		plane_size = max(p->sizeimage, plane_size >> 3);
++
++		p->bytesperline = bpl;
++		p->sizeimage = plane_size;
++	}
++}
++
++static int try_format(struct v4l2_format *f, struct pispbe_node *node)
++{
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	const struct pisp_be_format *fmt;
++	unsigned int i;
++	bool is_rgb;
++	u32 pixfmt = f->fmt.pix_mp.pixelformat;
++
++	dev_dbg(pispbe->dev,
++		"%s: [%s] req %ux%u " V4L2_FOURCC_CONV ", planes %d\n",
++		__func__, NODE_NAME(node), f->fmt.pix_mp.width,
++		f->fmt.pix_mp.height, V4L2_FOURCC_CONV_ARGS(pixfmt),
++		f->fmt.pix_mp.num_planes);
++
++	if (pixfmt == V4L2_PIX_FMT_RPI_BE)
++		return verify_be_pix_format(f, node);
++
++	fmt = find_format(pixfmt);
++	if (!fmt)
++		fmt = find_format(V4L2_PIX_FMT_YUV420M);
++
++	f->fmt.pix_mp.pixelformat = fmt->fourcc;
++	f->fmt.pix_mp.num_planes = fmt->num_planes;
++	f->fmt.pix_mp.field = V4L2_FIELD_NONE;
++	f->fmt.pix_mp.width = max(min(f->fmt.pix_mp.width, 65536u),
++				  PISP_BACK_END_MIN_TILE_WIDTH);
++	f->fmt.pix_mp.height = max(min(f->fmt.pix_mp.height, 65536u),
++				   PISP_BACK_END_MIN_TILE_HEIGHT);
++
++	/*
++	 * Fill in the actual colour space when the requested one was
++	 * not supported. This also catches the case when the "default"
++	 * colour space was requested (as that's never in the mask).
++	 */
++	if (!(V4L2_COLORSPACE_MASK(f->fmt.pix_mp.colorspace) & fmt->colorspace_mask))
++		f->fmt.pix_mp.colorspace = fmt->colorspace_default;
++
++	/* In all cases, we only support the defaults for these: */
++	f->fmt.pix_mp.ycbcr_enc =
++		V4L2_MAP_YCBCR_ENC_DEFAULT(f->fmt.pix_mp.colorspace);
++	f->fmt.pix_mp.xfer_func =
++		V4L2_MAP_XFER_FUNC_DEFAULT(f->fmt.pix_mp.colorspace);
++
++	is_rgb = f->fmt.pix_mp.colorspace == V4L2_COLORSPACE_SRGB;
++	f->fmt.pix_mp.quantization =
++		V4L2_MAP_QUANTIZATION_DEFAULT(is_rgb, f->fmt.pix_mp.colorspace,
++					      f->fmt.pix_mp.ycbcr_enc);
++
++	/* Set plane size and bytes/line for each plane. */
++	set_plane_params(f, fmt);
++
++	for (i = 0; i < f->fmt.pix_mp.num_planes; i++) {
++		dev_dbg(pispbe->dev,
++			"%s: [%s] calc plane %d, %ux%u, depth %u, bpl %u size %u\n",
++			__func__, NODE_NAME(node), i, f->fmt.pix_mp.width,
++			f->fmt.pix_mp.height, fmt->bit_depth,
++			f->fmt.pix_mp.plane_fmt[i].bytesperline,
++			f->fmt.pix_mp.plane_fmt[i].sizeimage);
++	}
++
++	return 0;
++}
++
++static int pispbe_node_try_fmt_vid_cap(struct file *file, void *priv,
++				       struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	int ret;
++
++	if (!NODE_IS_CAPTURE(node) || NODE_IS_META(node)) {
++		dev_err(pispbe->dev,
++			"Cannot set capture fmt for output node %s\n",
++			NODE_NAME(node));
++		return -EINVAL;
++	}
++
++	ret = try_format(f, node);
++	if (ret < 0)
++		return ret;
++
++	return 0;
++}
++
++static int pispbe_node_try_fmt_vid_out(struct file *file, void *priv,
++				       struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	int ret;
++
++	if (!NODE_IS_OUTPUT(node) || NODE_IS_META(node)) {
++		dev_err(pispbe->dev,
++			"Cannot set capture fmt for output node %s\n",
++			NODE_NAME(node));
++		return -EINVAL;
++	}
++
++	ret = try_format(f, node);
++	if (ret < 0)
++		return ret;
++
++	return 0;
++}
++
++static int pispbe_node_try_fmt_meta_out(struct file *file, void *priv,
++					struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	if (!NODE_IS_META(node) || NODE_IS_CAPTURE(node)) {
++		dev_err(pispbe->dev,
++			"Cannot set capture fmt for meta output node %s\n",
++			NODE_NAME(node));
++		return -EINVAL;
++	}
++
++	f->fmt.meta.dataformat = V4L2_META_FMT_RPI_BE_CFG;
++	f->fmt.meta.buffersize = sizeof(struct pisp_be_tiles_config);
++
++	return 0;
++}
++
++static int pispbe_node_try_fmt_meta_cap(struct file *file, void *priv,
++					struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	if (!NODE_IS_META(node) || NODE_IS_OUTPUT(node)) {
++		dev_err(pispbe->dev,
++			"Cannot set capture fmt for meta output node %s\n",
++			NODE_NAME(node));
++		return -EINVAL;
++	}
++
++	f->fmt.meta.dataformat = V4L2_PIX_FMT_RPI_BE;
++	if (!f->fmt.meta.buffersize)
++		f->fmt.meta.buffersize = BIT(20);
++
++	return 0;
++}
++
++static int pispbe_node_s_fmt_vid_cap(struct file *file, void *priv,
++				     struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	int ret = pispbe_node_try_fmt_vid_cap(file, priv, f);
++
++	if (ret < 0)
++		return ret;
++
++	node->format = *f;
++	node->pisp_format = find_format(f->fmt.pix_mp.pixelformat);
++
++	dev_dbg(pispbe->dev,
++		"Set capture format for node %s to " V4L2_FOURCC_CONV "\n",
++		NODE_NAME(node),
++		V4L2_FOURCC_CONV_ARGS(f->fmt.pix_mp.pixelformat));
++	return 0;
++}
++
++static int pispbe_node_s_fmt_vid_out(struct file *file, void *priv,
++				     struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	int ret = pispbe_node_try_fmt_vid_out(file, priv, f);
++
++	if (ret < 0)
++		return ret;
++
++	node->format = *f;
++	node->pisp_format = find_format(f->fmt.pix_mp.pixelformat);
++
++	dev_dbg(pispbe->dev,
++		"Set output format for node %s to " V4L2_FOURCC_CONV "\n",
++		NODE_NAME(node),
++		V4L2_FOURCC_CONV_ARGS(f->fmt.pix_mp.pixelformat));
++	return 0;
++}
++
++static int pispbe_node_s_fmt_meta_out(struct file *file, void *priv,
++				      struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	int ret = pispbe_node_try_fmt_meta_out(file, priv, f);
++
++	if (ret < 0)
++		return ret;
++
++	node->format = *f;
++	node->pisp_format = &meta_out_supported_formats[0];
++
++	dev_dbg(pispbe->dev,
++		"Set output format for meta node %s to " V4L2_FOURCC_CONV "\n",
++		NODE_NAME(node),
++		V4L2_FOURCC_CONV_ARGS(f->fmt.meta.dataformat));
++	return 0;
++}
++
++static int pispbe_node_s_fmt_meta_cap(struct file *file, void *priv,
++				      struct v4l2_format *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++	int ret = pispbe_node_try_fmt_meta_cap(file, priv, f);
++
++	if (ret < 0)
++		return ret;
++
++	node->format = *f;
++	node->pisp_format = find_format(f->fmt.meta.dataformat);
++
++	dev_dbg(pispbe->dev,
++		"Set capture format for meta node %s to " V4L2_FOURCC_CONV "\n",
++		NODE_NAME(node),
++		V4L2_FOURCC_CONV_ARGS(f->fmt.meta.dataformat));
++	return 0;
++}
++
++static int pispbe_node_enum_fmt(struct file *file, void  *priv,
++				struct v4l2_fmtdesc *f)
++{
++	struct pispbe_node *node = video_drvdata(file);
++
++	if (f->type != node->queue.type)
++		return -EINVAL;
++
++	if (NODE_IS_META(node)) {
++		if (f->index)
++			return -EINVAL;
++
++		if (NODE_IS_OUTPUT(node))
++			f->pixelformat = V4L2_META_FMT_RPI_BE_CFG;
++		else
++			f->pixelformat = V4L2_PIX_FMT_RPI_BE;
++		f->flags = 0;
++		return 0;
++	}
++
++	if (f->index >= ARRAY_SIZE(supported_formats))
++		return -EINVAL;
++
++	f->pixelformat = supported_formats[f->index].fourcc;
++	f->flags = 0;
++
++	return 0;
++}
++
++static int pispbe_enum_framesizes(struct file *file, void *priv,
++				  struct v4l2_frmsizeenum *fsize)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	if (NODE_IS_META(node) || fsize->index)
++		return -EINVAL;
++
++	if (!find_format(fsize->pixel_format)) {
++		dev_err(pispbe->dev, "Invalid pixel code: %x\n",
++			fsize->pixel_format);
++		return -EINVAL;
++	}
++
++	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
++	fsize->stepwise.min_width = 32;
++	fsize->stepwise.max_width = 65535;
++	fsize->stepwise.step_width = 2;
++
++	fsize->stepwise.min_height = 32;
++	fsize->stepwise.max_height = 65535;
++	fsize->stepwise.step_height = 2;
++
++	return 0;
++}
++
++static int pispbe_node_streamon(struct file *file, void *priv,
++				enum v4l2_buf_type type)
++{
++	struct pispbe_node *node = video_drvdata(file);
++	struct pispbe_dev *pispbe = node->node_group->pispbe;
++
++	/* Do we need a node->stream_lock mutex? */
++
++	dev_dbg(pispbe->dev, "Stream on for node %s\n", NODE_NAME(node));
++
++	/* Do we care about the type? Each node has only one queue. */
++
++	INIT_LIST_HEAD(&node->ready_queue);
++
++	/* locking should be handled by the queue->lock? */
++	return vb2_streamon(&node->queue, type);
++}
++
++static int pispbe_node_streamoff(struct file *file, void *priv,
++				 enum v4l2_buf_type type)
++{
++	struct pispbe_node *node = video_drvdata(file);
++
++	return vb2_streamoff(&node->queue, type);
++}
++
++static const struct v4l2_ioctl_ops pispbe_node_ioctl_ops = {
++	.vidioc_querycap = pispbe_node_querycap,
++	.vidioc_g_fmt_vid_cap_mplane = pispbe_node_g_fmt_vid_cap,
++	.vidioc_g_fmt_vid_out_mplane = pispbe_node_g_fmt_vid_out,
++	.vidioc_g_fmt_meta_out = pispbe_node_g_fmt_meta_out,
++	.vidioc_g_fmt_meta_cap = pispbe_node_g_fmt_meta_cap,
++	.vidioc_try_fmt_vid_cap_mplane = pispbe_node_try_fmt_vid_cap,
++	.vidioc_try_fmt_vid_out_mplane = pispbe_node_try_fmt_vid_out,
++	.vidioc_try_fmt_meta_out = pispbe_node_try_fmt_meta_out,
++	.vidioc_try_fmt_meta_cap = pispbe_node_try_fmt_meta_cap,
++	.vidioc_s_fmt_vid_cap_mplane = pispbe_node_s_fmt_vid_cap,
++	.vidioc_s_fmt_vid_out_mplane = pispbe_node_s_fmt_vid_out,
++	.vidioc_s_fmt_meta_out = pispbe_node_s_fmt_meta_out,
++	.vidioc_s_fmt_meta_cap = pispbe_node_s_fmt_meta_cap,
++	.vidioc_enum_fmt_vid_cap = pispbe_node_enum_fmt,
++	.vidioc_enum_fmt_vid_out = pispbe_node_enum_fmt,
++	.vidioc_enum_fmt_meta_cap = pispbe_node_enum_fmt,
++	.vidioc_enum_fmt_meta_out = pispbe_node_enum_fmt,
++	.vidioc_enum_framesizes = pispbe_enum_framesizes,
++	.vidioc_create_bufs = vb2_ioctl_create_bufs,
++	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
++	.vidioc_querybuf = vb2_ioctl_querybuf,
++	.vidioc_qbuf = vb2_ioctl_qbuf,
++	.vidioc_dqbuf = vb2_ioctl_dqbuf,
++	.vidioc_expbuf = vb2_ioctl_expbuf,
++	.vidioc_reqbufs = vb2_ioctl_reqbufs,
++	.vidioc_streamon = pispbe_node_streamon,
++	.vidioc_streamoff = pispbe_node_streamoff,
++};
++
++static const struct video_device pispbe_videodev = {
++	.name = PISPBE_NAME,
++	.vfl_dir = VFL_DIR_M2M, /* gets overwritten */
++	.fops = &pispbe_fops,
++	.ioctl_ops = &pispbe_node_ioctl_ops,
++	.minor = -1,
++	.release = video_device_release_empty,
++};
++
++static void node_set_default_format(struct pispbe_node *node)
++{
++	if (NODE_IS_META(node) && NODE_IS_OUTPUT(node)) {
++		/* Config node */
++		struct v4l2_format *f = &node->format;
++
++		f->fmt.meta.dataformat = V4L2_META_FMT_RPI_BE_CFG;
++		f->fmt.meta.buffersize = sizeof(struct pisp_be_tiles_config);
++		f->type = node->buf_type;
++	} else if (NODE_IS_META(node) && NODE_IS_CAPTURE(node)) {
++		/* HOG output node */
++		struct v4l2_format *f = &node->format;
++
++		f->fmt.meta.dataformat = V4L2_PIX_FMT_RPI_BE;
++		f->fmt.meta.buffersize = BIT(20);
++		f->type = node->buf_type;
++	} else {
++		struct v4l2_format f = {0};
++
++		f.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420M;
++		f.fmt.pix_mp.width = 1920;
++		f.fmt.pix_mp.height = 1080;
++		f.type = node->buf_type;
++		try_format(&f, node);
++		node->format = f;
++	}
++
++	node->pisp_format = find_format(node->format.fmt.pix_mp.pixelformat);
++}
++
++/*
++ * Initialise a struct pispbe_node and register it as /dev/video<N>
++ * to represent one of the PiSP Back End's input or output streams.
++ */
++static int
++pispbe_init_node(struct pispbe_node_group *node_group, unsigned int id)
++{
++	bool output = NODE_DESC_IS_OUTPUT(&node_desc[id]);
++	struct pispbe_node *node = &node_group->node[id];
++	struct pispbe_dev *pispbe = node_group->pispbe;
++	struct media_entity *entity = &node->vfd.entity;
++	struct video_device *vdev = &node->vfd;
++	struct vb2_queue *q = &node->queue;
++	int ret;
++
++	node->id = id;
++	node->node_group = node_group;
++	node->buf_type = node_desc[id].buf_type;
++
++	mutex_init(&node->node_lock);
++	mutex_init(&node->queue_lock);
++	INIT_LIST_HEAD(&node->ready_queue);
++	spin_lock_init(&node->ready_lock);
++
++	node->format.type = node->buf_type;
++	node_set_default_format(node);
++
++	q->type = node->buf_type;
++	q->io_modes = VB2_MMAP | VB2_DMABUF;
++	q->mem_ops = &vb2_dma_contig_memops;
++	q->drv_priv = node;
++	q->ops = &pispbe_node_queue_ops;
++	q->buf_struct_size = sizeof(struct pispbe_buffer);
++	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
++	q->dev = node->node_group->pispbe->dev;
++	/* get V4L2 to handle node->queue locking */
++	q->lock = &node->queue_lock;
++
++	ret = vb2_queue_init(q);
++	if (ret < 0) {
++		dev_err(pispbe->dev, "vb2_queue_init failed\n");
++		return ret;
++	}
++
++	*vdev = pispbe_videodev; /* default initialization */
++	strscpy(vdev->name, node_desc[id].ent_name, sizeof(vdev->name));
++	vdev->v4l2_dev = &node_group->v4l2_dev;
++	vdev->vfl_dir = output ? VFL_DIR_TX : VFL_DIR_RX;
++	/* get V4L2 to serialise our ioctls */
++	vdev->lock = &node->node_lock;
++	vdev->queue = &node->queue;
++	vdev->device_caps = V4L2_CAP_STREAMING | node_desc[id].caps;
++
++	node->pad.flags = output ? MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
++	ret = media_entity_pads_init(entity, 1, &node->pad);
++	if (ret) {
++		dev_err(pispbe->dev,
++			"Failed to register media pads for %s device node\n",
++			NODE_NAME(node));
++		goto err_unregister_queue;
++	}
++
++	ret = video_register_device(vdev, VFL_TYPE_VIDEO,
++				    PISPBE_VIDEO_NODE_OFFSET);
++	if (ret) {
++		dev_err(pispbe->dev,
++			"Failed to register video %s device node\n",
++			NODE_NAME(node));
++		goto err_unregister_queue;
++	}
++	video_set_drvdata(vdev, node);
++
++	if (output)
++		ret = media_create_pad_link(entity, 0, &node_group->sd.entity,
++					    id, MEDIA_LNK_FL_IMMUTABLE |
++					    MEDIA_LNK_FL_ENABLED);
++	else
++		ret = media_create_pad_link(&node_group->sd.entity, id, entity,
++					    0, MEDIA_LNK_FL_IMMUTABLE |
++					    MEDIA_LNK_FL_ENABLED);
++	if (ret)
++		goto err_unregister_video_dev;
++
++	dev_info(pispbe->dev,
++		 "%s device node registered as /dev/video%d\n",
++		 NODE_NAME(node), node->vfd.num);
++	return 0;
++
++err_unregister_video_dev:
++	video_unregister_device(&node->vfd);
++err_unregister_queue:
++	vb2_queue_release(&node->queue);
++	return ret;
++}
++
++static const struct v4l2_subdev_pad_ops pispbe_pad_ops = {
++	.link_validate = v4l2_subdev_link_validate_default,
++};
++
++static const struct v4l2_subdev_ops pispbe_sd_ops = {
++	.pad = &pispbe_pad_ops,
++};
++
++static int pispbe_init_subdev(struct pispbe_node_group *node_group)
++{
++	struct pispbe_dev *pispbe = node_group->pispbe;
++	struct v4l2_subdev *sd = &node_group->sd;
++	unsigned int i;
++	int ret;
++
++	v4l2_subdev_init(sd, &pispbe_sd_ops);
++	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
++	sd->owner = THIS_MODULE;
++	sd->dev = pispbe->dev;
++	strscpy(sd->name, PISPBE_NAME, sizeof(sd->name));
++
++	for (i = 0; i < PISPBE_NUM_NODES; i++)
++		node_group->pad[i].flags =
++			NODE_DESC_IS_OUTPUT(&node_desc[i]) ?
++			MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
++
++	ret = media_entity_pads_init(&sd->entity, PISPBE_NUM_NODES,
++				     node_group->pad);
++	if (ret)
++		goto error;
++
++	ret = v4l2_device_register_subdev(&node_group->v4l2_dev, sd);
++	if (ret)
++		goto error;
++
++	return 0;
++
++error:
++	media_entity_cleanup(&sd->entity);
++	return ret;
++}
++
++static int pispbe_init_group(struct pispbe_dev *pispbe, unsigned int id)
++{
++	struct pispbe_node_group *node_group = &pispbe->node_group[id];
++	struct v4l2_device *v4l2_dev;
++	struct media_device *mdev;
++	unsigned int num_registered = 0;
++	int ret;
++
++	node_group->id = id;
++	node_group->pispbe = pispbe;
++	node_group->streaming_map = 0;
++
++	dev_info(pispbe->dev, "Register nodes for group %u\n", id);
++
++	/* Register v4l2_device and media_device */
++	mdev = &node_group->mdev;
++	mdev->hw_revision = node_group->pispbe->hw_version;
++	mdev->dev = node_group->pispbe->dev;
++	strscpy(mdev->model, PISPBE_NAME, sizeof(mdev->model));
++	snprintf(mdev->bus_info, sizeof(mdev->bus_info),
++		 "platform:%s", dev_name(node_group->pispbe->dev));
++	media_device_init(mdev);
++
++	v4l2_dev = &node_group->v4l2_dev;
++	v4l2_dev->mdev = &node_group->mdev;
++	strscpy(v4l2_dev->name, PISPBE_NAME, sizeof(v4l2_dev->name));
++
++	ret = v4l2_device_register(pispbe->dev, &node_group->v4l2_dev);
++	if (ret)
++		goto err_media_dev_cleanup;
++
++	/* Register the PISPBE subdevice. */
++	ret = pispbe_init_subdev(node_group);
++	if (ret)
++		goto err_unregister_v4l2;
++
++	/* Create device video nodes */
++	for (; num_registered < PISPBE_NUM_NODES; num_registered++) {
++		ret = pispbe_init_node(node_group, num_registered);
++		if (ret)
++			goto err_unregister_nodes;
++	}
++
++	ret = media_device_register(mdev);
++	if (ret)
++		goto err_unregister_nodes;
++
++	node_group->config =
++		dma_alloc_coherent(pispbe->dev,
++				   sizeof(struct pisp_be_tiles_config) *
++					PISP_BE_NUM_CONFIG_BUFFERS,
++				   &node_group->config_dma_addr, GFP_KERNEL);
++	if (!node_group->config) {
++		dev_err(pispbe->dev, "Unable to allocate cached config buffers.\n");
++		ret = -ENOMEM;
++		goto err_unregister_mdev;
++	}
++
++	return 0;
++
++err_unregister_mdev:
++	media_device_unregister(mdev);
++err_unregister_nodes:
++	while (num_registered-- > 0) {
++		video_unregister_device(&node_group->node[num_registered].vfd);
++		vb2_queue_release(&node_group->node[num_registered].queue);
++	}
++	v4l2_device_unregister_subdev(&node_group->sd);
++	media_entity_cleanup(&node_group->sd.entity);
++err_unregister_v4l2:
++	v4l2_device_unregister(v4l2_dev);
++err_media_dev_cleanup:
++	media_device_cleanup(mdev);
++	return ret;
++}
++
++static void pispbe_destroy_node_group(struct pispbe_node_group *node_group)
++{
++	struct pispbe_dev *pispbe = node_group->pispbe;
++	int i;
++
++	if (node_group->config) {
++		dma_free_coherent(node_group->pispbe->dev,
++				  sizeof(struct pisp_be_tiles_config) *
++					PISP_BE_NUM_CONFIG_BUFFERS,
++				  node_group->config,
++				  node_group->config_dma_addr);
++	}
++
++	dev_info(pispbe->dev, "Unregister from media controller\n");
++
++	v4l2_device_unregister_subdev(&node_group->sd);
++	media_entity_cleanup(&node_group->sd.entity);
++	media_device_unregister(&node_group->mdev);
++
++	for (i = PISPBE_NUM_NODES - 1; i >= 0; i--) {
++		video_unregister_device(&node_group->node[i].vfd);
++		vb2_queue_release(&node_group->node[i].queue);
++	}
++
++	media_device_cleanup(&node_group->mdev);
++	v4l2_device_unregister(&node_group->v4l2_dev);
++}
++
++static int pispbe_runtime_suspend(struct device *dev)
++{
++	struct pispbe_dev *pispbe = dev_get_drvdata(dev);
++
++	clk_disable_unprepare(pispbe->clk);
++
++	return 0;
++}
++
++static int pispbe_runtime_resume(struct device *dev)
++{
++	struct pispbe_dev *pispbe = dev_get_drvdata(dev);
++	int ret;
++
++	ret = clk_prepare_enable(pispbe->clk);
++	if (ret) {
++		dev_err(dev, "Unable to enable clock\n");
++		return ret;
++	}
++
++	dev_dbg(dev, "%s: Enabled clock, rate=%lu\n",
++		__func__, clk_get_rate(pispbe->clk));
++
++	return 0;
++}
++
++/*
++ * Probe the ISP-BE hardware block, as a single platform device.
++ * This will instantiate multiple "node groups" each with many device nodes.
++ */
++static int pispbe_probe(struct platform_device *pdev)
++{
++	unsigned int num_groups = 0;
++	struct pispbe_dev *pispbe;
++	int ret;
++
++	pispbe = devm_kzalloc(&pdev->dev, sizeof(*pispbe), GFP_KERNEL);
++	if (!pispbe)
++		return -ENOMEM;
++
++	dev_set_drvdata(&pdev->dev, pispbe);
++	pispbe->dev = &pdev->dev;
++	platform_set_drvdata(pdev, pispbe);
++
++	pispbe->be_reg_base = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(pispbe->be_reg_base)) {
++		dev_err(&pdev->dev, "Failed to get ISP-BE registers address\n");
++		return PTR_ERR(pispbe->be_reg_base);
++	}
++
++	pispbe->irq = platform_get_irq(pdev, 0);
++	if (pispbe->irq <= 0) {
++		dev_err(&pdev->dev, "No IRQ resource\n");
++		return -EINVAL;
++	}
++
++	ret = devm_request_irq(&pdev->dev, pispbe->irq, pispbe_isr, 0,
++			       PISPBE_NAME, pispbe);
++	if (ret) {
++		dev_err(&pdev->dev, "Unable to request interrupt\n");
++		return ret;
++	}
++
++	ret = dma_set_mask_and_coherent(pispbe->dev, DMA_BIT_MASK(36));
++	if (ret)
++		return ret;
++
++	pispbe->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(pispbe->clk))
++		return dev_err_probe(&pdev->dev, PTR_ERR(pispbe->clk),
++				     "Failed to get clock");
++
++	/* Hardware initialisation */
++	pm_runtime_set_autosuspend_delay(pispbe->dev, 200);
++	pm_runtime_use_autosuspend(pispbe->dev);
++	pm_runtime_enable(pispbe->dev);
++
++	ret = pm_runtime_resume_and_get(pispbe->dev);
++	if (ret)
++		goto pm_runtime_disable_err;
++
++	pispbe->hw_busy = 0;
++	spin_lock_init(&pispbe->hw_lock);
++	ret = hw_init(pispbe);
++	if (ret)
++		goto pm_runtime_put_err;
++
++	/*
++	 * Initialise and register devices for each node_group, including media
++	 * device
++	 */
++	for (num_groups = 0;
++	     num_groups < PISPBE_NUM_NODE_GROUPS;
++	     num_groups++) {
++		ret = pispbe_init_group(pispbe, num_groups);
++		if (ret)
++			goto disable_nodes_err;
++	}
++
++	pm_runtime_mark_last_busy(pispbe->dev);
++	pm_runtime_put_autosuspend(pispbe->dev);
++
++	return 0;
++
++disable_nodes_err:
++	while (num_groups-- > 0)
++		pispbe_destroy_node_group(&pispbe->node_group[num_groups]);
++pm_runtime_put_err:
++	pm_runtime_put(pispbe->dev);
++pm_runtime_disable_err:
++	pm_runtime_dont_use_autosuspend(pispbe->dev);
++	pm_runtime_disable(pispbe->dev);
++
++	dev_err(&pdev->dev, "%s: returning %d", __func__, ret);
++
++	return ret;
++}
++
++static int pispbe_remove(struct platform_device *pdev)
++{
++	struct pispbe_dev *pispbe = platform_get_drvdata(pdev);
++	int i;
++
++	for (i = PISPBE_NUM_NODE_GROUPS - 1; i >= 0; i--)
++		pispbe_destroy_node_group(&pispbe->node_group[i]);
++
++	pm_runtime_dont_use_autosuspend(pispbe->dev);
++	pm_runtime_disable(pispbe->dev);
++
++	return 0;
++}
++
++static const struct dev_pm_ops pispbe_pm_ops = {
++	SET_RUNTIME_PM_OPS(pispbe_runtime_suspend, pispbe_runtime_resume, NULL)
++};
++
++static const struct of_device_id pispbe_of_match[] = {
++	{
++		.compatible = "raspberrypi,pispbe",
++	},
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, pispbe_of_match);
++
++static struct platform_driver pispbe_pdrv = {
++	.probe		= pispbe_probe,
++	.remove		= pispbe_remove,
++	.driver		= {
++		.name	= PISPBE_NAME,
++		.of_match_table = pispbe_of_match,
++		.pm = &pispbe_pm_ops,
++	},
++};
++
++module_platform_driver(pispbe_pdrv);
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be_config.h
+@@ -0,0 +1,533 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * PiSP Back End configuration definitions.
++ *
++ * Copyright (C) 2021 - Raspberry Pi Ltd
++ *
++ */
++#ifndef _PISP_BE_CONFIG_H_
++#define _PISP_BE_CONFIG_H_
++
++#include <linux/types.h>
++
++#include <media/raspberrypi/pisp_common.h>
++
++/* byte alignment for inputs */
++#define PISP_BACK_END_INPUT_ALIGN 4u
++/* alignment for compressed inputs */
++#define PISP_BACK_END_COMPRESSED_ALIGN 8u
++/* minimum required byte alignment for outputs */
++#define PISP_BACK_END_OUTPUT_MIN_ALIGN 16u
++/* preferred byte alignment for outputs */
++#define PISP_BACK_END_OUTPUT_MAX_ALIGN 64u
++
++/* minimum allowed tile width anywhere in the pipeline */
++#define PISP_BACK_END_MIN_TILE_WIDTH 16u
++/* minimum allowed tile width anywhere in the pipeline */
++#define PISP_BACK_END_MIN_TILE_HEIGHT 16u
++
++#define PISP_BACK_END_NUM_OUTPUTS 2
++#define PISP_BACK_END_HOG_OUTPUT 1
++
++#define PISP_BACK_END_NUM_TILES 64
++
++enum pisp_be_bayer_enable {
++	PISP_BE_BAYER_ENABLE_INPUT = 0x000001,
++	PISP_BE_BAYER_ENABLE_DECOMPRESS = 0x000002,
++	PISP_BE_BAYER_ENABLE_DPC = 0x000004,
++	PISP_BE_BAYER_ENABLE_GEQ = 0x000008,
++	PISP_BE_BAYER_ENABLE_TDN_INPUT = 0x000010,
++	PISP_BE_BAYER_ENABLE_TDN_DECOMPRESS = 0x000020,
++	PISP_BE_BAYER_ENABLE_TDN = 0x000040,
++	PISP_BE_BAYER_ENABLE_TDN_COMPRESS = 0x000080,
++	PISP_BE_BAYER_ENABLE_TDN_OUTPUT = 0x000100,
++	PISP_BE_BAYER_ENABLE_SDN = 0x000200,
++	PISP_BE_BAYER_ENABLE_BLC = 0x000400,
++	PISP_BE_BAYER_ENABLE_STITCH_INPUT = 0x000800,
++	PISP_BE_BAYER_ENABLE_STITCH_DECOMPRESS = 0x001000,
++	PISP_BE_BAYER_ENABLE_STITCH = 0x002000,
++	PISP_BE_BAYER_ENABLE_STITCH_COMPRESS = 0x004000,
++	PISP_BE_BAYER_ENABLE_STITCH_OUTPUT = 0x008000,
++	PISP_BE_BAYER_ENABLE_WBG = 0x010000,
++	PISP_BE_BAYER_ENABLE_CDN = 0x020000,
++	PISP_BE_BAYER_ENABLE_LSC = 0x040000,
++	PISP_BE_BAYER_ENABLE_TONEMAP = 0x080000,
++	PISP_BE_BAYER_ENABLE_CAC = 0x100000,
++	PISP_BE_BAYER_ENABLE_DEBIN = 0x200000,
++	PISP_BE_BAYER_ENABLE_DEMOSAIC = 0x400000,
++};
++
++enum pisp_be_rgb_enable {
++	PISP_BE_RGB_ENABLE_INPUT = 0x000001,
++	PISP_BE_RGB_ENABLE_CCM = 0x000002,
++	PISP_BE_RGB_ENABLE_SAT_CONTROL = 0x000004,
++	PISP_BE_RGB_ENABLE_YCBCR = 0x000008,
++	PISP_BE_RGB_ENABLE_FALSE_COLOUR = 0x000010,
++	PISP_BE_RGB_ENABLE_SHARPEN = 0x000020,
++	/* Preferred colours would occupy 0x000040 */
++	PISP_BE_RGB_ENABLE_YCBCR_INVERSE = 0x000080,
++	PISP_BE_RGB_ENABLE_GAMMA = 0x000100,
++	PISP_BE_RGB_ENABLE_CSC0 = 0x000200,
++	PISP_BE_RGB_ENABLE_CSC1 = 0x000400,
++	PISP_BE_RGB_ENABLE_DOWNSCALE0 = 0x001000,
++	PISP_BE_RGB_ENABLE_DOWNSCALE1 = 0x002000,
++	PISP_BE_RGB_ENABLE_RESAMPLE0 = 0x008000,
++	PISP_BE_RGB_ENABLE_RESAMPLE1 = 0x010000,
++	PISP_BE_RGB_ENABLE_OUTPUT0 = 0x040000,
++	PISP_BE_RGB_ENABLE_OUTPUT1 = 0x080000,
++	PISP_BE_RGB_ENABLE_HOG = 0x200000
++};
++
++#define PISP_BE_RGB_ENABLE_CSC(i) (PISP_BE_RGB_ENABLE_CSC0 << (i))
++#define PISP_BE_RGB_ENABLE_DOWNSCALE(i) (PISP_BE_RGB_ENABLE_DOWNSCALE0 << (i))
++#define PISP_BE_RGB_ENABLE_RESAMPLE(i) (PISP_BE_RGB_ENABLE_RESAMPLE0 << (i))
++#define PISP_BE_RGB_ENABLE_OUTPUT(i) (PISP_BE_RGB_ENABLE_OUTPUT0 << (i))
++
++/*
++ * We use the enable flags to show when blocks are "dirty", but we need some
++ * extra ones too.
++ */
++enum pisp_be_dirty {
++	PISP_BE_DIRTY_GLOBAL = 0x0001,
++	PISP_BE_DIRTY_SH_FC_COMBINE = 0x0002,
++	PISP_BE_DIRTY_CROP = 0x0004
++};
++
++struct pisp_be_global_config {
++	u32 bayer_enables;
++	u32 rgb_enables;
++	u8 bayer_order;
++	u8 pad[3];
++};
++
++struct pisp_be_input_buffer_config {
++	/* low 32 bits followed by high 32 bits (for each of up to 3 planes) */
++	u32 addr[3][2];
++};
++
++struct pisp_be_dpc_config {
++	u8 coeff_level;
++	u8 coeff_range;
++	u8 pad;
++#define PISP_BE_DPC_FLAG_FOLDBACK 1
++	u8 flags;
++};
++
++struct pisp_be_geq_config {
++	u16 offset;
++#define PISP_BE_GEQ_SHARPER BIT(15)
++#define PISP_BE_GEQ_SLOPE ((1 << 10) - 1)
++	/* top bit is the "sharper" flag, slope value is bottom 10 bits */
++	u16 slope_sharper;
++	u16 min;
++	u16 max;
++};
++
++struct pisp_be_tdn_input_buffer_config {
++	/* low 32 bits followed by high 32 bits */
++	u32 addr[2];
++};
++
++struct pisp_be_tdn_config {
++	u16 black_level;
++	u16 ratio;
++	u16 noise_constant;
++	u16 noise_slope;
++	u16 threshold;
++	u8 reset;
++	u8 pad;
++};
++
++struct pisp_be_tdn_output_buffer_config {
++	/* low 32 bits followed by high 32 bits */
++	u32 addr[2];
++};
++
++struct pisp_be_sdn_config {
++	u16 black_level;
++	u8 leakage;
++	u8 pad;
++	u16 noise_constant;
++	u16 noise_slope;
++	u16 noise_constant2;
++	u16 noise_slope2;
++};
++
++struct pisp_be_stitch_input_buffer_config {
++	/* low 32 bits followed by high 32 bits */
++	u32 addr[2];
++};
++
++#define PISP_BE_STITCH_STREAMING_LONG 0x8000
++#define PISP_BE_STITCH_EXPOSURE_RATIO_MASK 0x7fff
++
++struct pisp_be_stitch_config {
++	u16 threshold_lo;
++	u8 threshold_diff_power;
++	u8 pad;
++
++	/* top bit indicates whether streaming input is the long exposure */
++	u16 exposure_ratio;
++
++	u8 motion_threshold_256;
++	u8 motion_threshold_recip;
++};
++
++struct pisp_be_stitch_output_buffer_config {
++	/* low 32 bits followed by high 32 bits */
++	u32 addr[2];
++};
++
++struct pisp_be_cdn_config {
++	u16 thresh;
++	u8 iir_strength;
++	u8 g_adjust;
++};
++
++#define PISP_BE_LSC_LOG_GRID_SIZE 5
++#define PISP_BE_LSC_GRID_SIZE (1 << PISP_BE_LSC_LOG_GRID_SIZE)
++#define PISP_BE_LSC_STEP_PRECISION 18
++
++struct pisp_be_lsc_config {
++	/* (1<<18) / grid_cell_width */
++	u16 grid_step_x;
++	/* (1<<18) / grid_cell_height */
++	u16 grid_step_y;
++	/* RGB gains jointly encoded in 32 bits */
++	u32 lut_packed[PISP_BE_LSC_GRID_SIZE + 1]
++			   [PISP_BE_LSC_GRID_SIZE + 1];
++};
++
++struct pisp_be_lsc_extra {
++	u16 offset_x;
++	u16 offset_y;
++};
++
++#define PISP_BE_CAC_LOG_GRID_SIZE 3
++#define PISP_BE_CAC_GRID_SIZE (1 << PISP_BE_CAC_LOG_GRID_SIZE)
++#define PISP_BE_CAC_STEP_PRECISION 20
++
++struct pisp_be_cac_config {
++	/* (1<<20) / grid_cell_width */
++	u16 grid_step_x;
++	/* (1<<20) / grid_cell_height */
++	u16 grid_step_y;
++	/* [gridy][gridx][rb][xy] */
++	s8 lut[PISP_BE_CAC_GRID_SIZE + 1][PISP_BE_CAC_GRID_SIZE + 1][2][2];
++};
++
++struct pisp_be_cac_extra {
++	u16 offset_x;
++	u16 offset_y;
++};
++
++#define PISP_BE_DEBIN_NUM_COEFFS 4
++
++struct pisp_be_debin_config {
++	s8 coeffs[PISP_BE_DEBIN_NUM_COEFFS];
++	s8 h_enable;
++	s8 v_enable;
++	s8 pad[2];
++};
++
++#define PISP_BE_TONEMAP_LUT_SIZE 64
++
++struct pisp_be_tonemap_config {
++	u16 detail_constant;
++	u16 detail_slope;
++	u16 iir_strength;
++	u16 strength;
++	u32 lut[PISP_BE_TONEMAP_LUT_SIZE];
++};
++
++struct pisp_be_demosaic_config {
++	u8 sharper;
++	u8 fc_mode;
++	u8 pad[2];
++};
++
++struct pisp_be_ccm_config {
++	s16 coeffs[9];
++	u8 pad[2];
++	s32 offsets[3];
++};
++
++struct pisp_be_sat_control_config {
++	u8 shift_r;
++	u8 shift_g;
++	u8 shift_b;
++	u8 pad;
++};
++
++struct pisp_be_false_colour_config {
++	u8 distance;
++	u8 pad[3];
++};
++
++#define PISP_BE_SHARPEN_SIZE 5
++#define PISP_BE_SHARPEN_FUNC_NUM_POINTS 9
++
++struct pisp_be_sharpen_config {
++	s8 kernel0[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
++	s8 pad0[3];
++	s8 kernel1[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
++	s8 pad1[3];
++	s8 kernel2[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
++	s8 pad2[3];
++	s8 kernel3[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
++	s8 pad3[3];
++	s8 kernel4[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
++	s8 pad4[3];
++	u16 threshold_offset0;
++	u16 threshold_slope0;
++	u16 scale0;
++	u16 pad5;
++	u16 threshold_offset1;
++	u16 threshold_slope1;
++	u16 scale1;
++	u16 pad6;
++	u16 threshold_offset2;
++	u16 threshold_slope2;
++	u16 scale2;
++	u16 pad7;
++	u16 threshold_offset3;
++	u16 threshold_slope3;
++	u16 scale3;
++	u16 pad8;
++	u16 threshold_offset4;
++	u16 threshold_slope4;
++	u16 scale4;
++	u16 pad9;
++	u16 positive_strength;
++	u16 positive_pre_limit;
++	u16 positive_func[PISP_BE_SHARPEN_FUNC_NUM_POINTS];
++	u16 positive_limit;
++	u16 negative_strength;
++	u16 negative_pre_limit;
++	u16 negative_func[PISP_BE_SHARPEN_FUNC_NUM_POINTS];
++	u16 negative_limit;
++	u8 enables;
++	u8 white;
++	u8 black;
++	u8 grey;
++};
++
++struct pisp_be_sh_fc_combine_config {
++	u8 y_factor;
++	u8 c1_factor;
++	u8 c2_factor;
++	u8 pad;
++};
++
++#define PISP_BE_GAMMA_LUT_SIZE 64
++
++struct pisp_be_gamma_config {
++	u32 lut[PISP_BE_GAMMA_LUT_SIZE];
++};
++
++struct pisp_be_crop_config {
++	u16 offset_x, offset_y;
++	u16 width, height;
++};
++
++#define PISP_BE_RESAMPLE_FILTER_SIZE 96
++
++struct pisp_be_resample_config {
++	u16 scale_factor_h, scale_factor_v;
++	s16 coef[PISP_BE_RESAMPLE_FILTER_SIZE];
++};
++
++struct pisp_be_resample_extra {
++	u16 scaled_width;
++	u16 scaled_height;
++	s16 initial_phase_h[3];
++	s16 initial_phase_v[3];
++};
++
++struct pisp_be_downscale_config {
++	u16 scale_factor_h;
++	u16 scale_factor_v;
++	u16 scale_recip_h;
++	u16 scale_recip_v;
++};
++
++struct pisp_be_downscale_extra {
++	u16 scaled_width;
++	u16 scaled_height;
++};
++
++struct pisp_be_hog_config {
++	u8 compute_signed;
++	u8 channel_mix[3];
++	u32 stride;
++};
++
++struct pisp_be_axi_config {
++	u8 r_qos; /* Read QoS */
++	u8 r_cache_prot; /* Read { prot[2:0], cache[3:0] } */
++	u8 w_qos; /* Write QoS */
++	u8 w_cache_prot; /* Write { prot[2:0], cache[3:0] } */
++};
++
++enum pisp_be_transform {
++	PISP_BE_TRANSFORM_NONE = 0x0,
++	PISP_BE_TRANSFORM_HFLIP = 0x1,
++	PISP_BE_TRANSFORM_VFLIP = 0x2,
++	PISP_BE_TRANSFORM_ROT180 =
++		(PISP_BE_TRANSFORM_HFLIP | PISP_BE_TRANSFORM_VFLIP)
++};
++
++struct pisp_be_output_format_config {
++	struct pisp_image_format_config image;
++	u8 transform;
++	u8 pad[3];
++	u16 lo;
++	u16 hi;
++	u16 lo2;
++	u16 hi2;
++};
++
++struct pisp_be_output_buffer_config {
++	/* low 32 bits followed by high 32 bits (for each of 3 planes) */
++	u32 addr[3][2];
++};
++
++struct pisp_be_hog_buffer_config {
++	/* low 32 bits followed by high 32 bits */
++	u32 addr[2];
++};
++
++struct pisp_be_config {
++	/* I/O configuration: */
++	struct pisp_be_input_buffer_config input_buffer;
++	struct pisp_be_tdn_input_buffer_config tdn_input_buffer;
++	struct pisp_be_stitch_input_buffer_config stitch_input_buffer;
++	struct pisp_be_tdn_output_buffer_config tdn_output_buffer;
++	struct pisp_be_stitch_output_buffer_config stitch_output_buffer;
++	struct pisp_be_output_buffer_config
++				output_buffer[PISP_BACK_END_NUM_OUTPUTS];
++	struct pisp_be_hog_buffer_config hog_buffer;
++	/* Processing configuration: */
++	struct pisp_be_global_config global;
++	struct pisp_image_format_config input_format;
++	struct pisp_decompress_config decompress;
++	struct pisp_be_dpc_config dpc;
++	struct pisp_be_geq_config geq;
++	struct pisp_image_format_config tdn_input_format;
++	struct pisp_decompress_config tdn_decompress;
++	struct pisp_be_tdn_config tdn;
++	struct pisp_compress_config tdn_compress;
++	struct pisp_image_format_config tdn_output_format;
++	struct pisp_be_sdn_config sdn;
++	struct pisp_bla_config blc;
++	struct pisp_compress_config stitch_compress;
++	struct pisp_image_format_config stitch_output_format;
++	struct pisp_image_format_config stitch_input_format;
++	struct pisp_decompress_config stitch_decompress;
++	struct pisp_be_stitch_config stitch;
++	struct pisp_be_lsc_config lsc;
++	struct pisp_wbg_config wbg;
++	struct pisp_be_cdn_config cdn;
++	struct pisp_be_cac_config cac;
++	struct pisp_be_debin_config debin;
++	struct pisp_be_tonemap_config tonemap;
++	struct pisp_be_demosaic_config demosaic;
++	struct pisp_be_ccm_config ccm;
++	struct pisp_be_sat_control_config sat_control;
++	struct pisp_be_ccm_config ycbcr;
++	struct pisp_be_sharpen_config sharpen;
++	struct pisp_be_false_colour_config false_colour;
++	struct pisp_be_sh_fc_combine_config sh_fc_combine;
++	struct pisp_be_ccm_config ycbcr_inverse;
++	struct pisp_be_gamma_config gamma;
++	struct pisp_be_ccm_config csc[PISP_BACK_END_NUM_OUTPUTS];
++	struct pisp_be_downscale_config downscale[PISP_BACK_END_NUM_OUTPUTS];
++	struct pisp_be_resample_config resample[PISP_BACK_END_NUM_OUTPUTS];
++	struct pisp_be_output_format_config
++				output_format[PISP_BACK_END_NUM_OUTPUTS];
++	struct pisp_be_hog_config hog;
++	struct pisp_be_axi_config axi;
++	/* Non-register fields: */
++	struct pisp_be_lsc_extra lsc_extra;
++	struct pisp_be_cac_extra cac_extra;
++	struct pisp_be_downscale_extra
++				downscale_extra[PISP_BACK_END_NUM_OUTPUTS];
++	struct pisp_be_resample_extra resample_extra[PISP_BACK_END_NUM_OUTPUTS];
++	struct pisp_be_crop_config crop;
++	struct pisp_image_format_config hog_format;
++	u32 dirty_flags_bayer; /* these use pisp_be_bayer_enable */
++	u32 dirty_flags_rgb; /* use pisp_be_rgb_enable */
++	u32 dirty_flags_extra; /* these use pisp_be_dirty_t */
++};
++
++/*
++ * We also need a tile structure to describe the size of the tiles going
++ * through the pipeline.
++ */
++
++enum pisp_tile_edge {
++	PISP_LEFT_EDGE = (1 << 0),
++	PISP_RIGHT_EDGE = (1 << 1),
++	PISP_TOP_EDGE = (1 << 2),
++	PISP_BOTTOM_EDGE = (1 << 3)
++};
++
++struct pisp_tile {
++	u8 edge; // enum pisp_tile_edge
++	u8 pad0[3];
++	// 4 bytes
++	u32 input_addr_offset;
++	u32 input_addr_offset2;
++	u16 input_offset_x;
++	u16 input_offset_y;
++	u16 input_width;
++	u16 input_height;
++	// 20 bytes
++	u32 tdn_input_addr_offset;
++	u32 tdn_output_addr_offset;
++	u32 stitch_input_addr_offset;
++	u32 stitch_output_addr_offset;
++	// 36 bytes
++	u32 lsc_grid_offset_x;
++	u32 lsc_grid_offset_y;
++	// 44 bytes
++	u32 cac_grid_offset_x;
++	u32 cac_grid_offset_y;
++	// 52 bytes
++	u16 crop_x_start[PISP_BACK_END_NUM_OUTPUTS];
++	u16 crop_x_end[PISP_BACK_END_NUM_OUTPUTS];
++	u16 crop_y_start[PISP_BACK_END_NUM_OUTPUTS];
++	u16 crop_y_end[PISP_BACK_END_NUM_OUTPUTS];
++	// 68 bytes
++	/* Ordering is planes then branches */
++	u16 downscale_phase_x[3 * PISP_BACK_END_NUM_OUTPUTS];
++	u16 downscale_phase_y[3 * PISP_BACK_END_NUM_OUTPUTS];
++	// 92 bytes
++	u16 resample_in_width[PISP_BACK_END_NUM_OUTPUTS];
++	u16 resample_in_height[PISP_BACK_END_NUM_OUTPUTS];
++	// 100 bytes
++	/* Ordering is planes then branches */
++	u16 resample_phase_x[3 * PISP_BACK_END_NUM_OUTPUTS];
++	u16 resample_phase_y[3 * PISP_BACK_END_NUM_OUTPUTS];
++	// 124 bytes
++	u16 output_offset_x[PISP_BACK_END_NUM_OUTPUTS];
++	u16 output_offset_y[PISP_BACK_END_NUM_OUTPUTS];
++	u16 output_width[PISP_BACK_END_NUM_OUTPUTS];
++	u16 output_height[PISP_BACK_END_NUM_OUTPUTS];
++	// 140 bytes
++	u32 output_addr_offset[PISP_BACK_END_NUM_OUTPUTS];
++	u32 output_addr_offset2[PISP_BACK_END_NUM_OUTPUTS];
++	// 156 bytes
++	u32 output_hog_addr_offset;
++	// 160 bytes
++};
++
++static_assert(sizeof(struct pisp_tile) == 160);
++
++struct pisp_be_tiles_config {
++	struct pisp_be_config config;
++	struct pisp_tile tiles[PISP_BACK_END_NUM_TILES];
++	int num_tiles;
++};
++
++#endif /* _PISP_BE_CONFIG_H_ */
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
+@@ -0,0 +1,469 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * PiSP Back End driver image format definitions.
++ *
++ * Copyright (c) 2021 Raspberry Pi Ltd
++ */
++
++#ifndef _PISP_BE_FORMATS_
++#define _PISP_BE_FORMATS_
++
++#include <linux/bits.h>
++#include <linux/videodev2.h>
++
++#define MAX_PLANES 3
++#define P3(x) ((x) * 8)
++
++struct pisp_be_format {
++	unsigned int fourcc;
++	unsigned int align;
++	unsigned int bit_depth;
++	/* 0P3 factor for plane sizing */
++	unsigned int plane_factor[MAX_PLANES];
++	unsigned int num_planes;
++	unsigned int colorspace_mask;
++	enum v4l2_colorspace colorspace_default;
++};
++
++#define V4L2_COLORSPACE_MASK(colorspace) BIT(colorspace)
++
++#define V4L2_COLORSPACE_MASK_JPEG V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_JPEG)
++#define V4L2_COLORSPACE_MASK_SMPTE170M V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_SMPTE170M)
++#define V4L2_COLORSPACE_MASK_REC709 V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_REC709)
++#define V4L2_COLORSPACE_MASK_SRGB V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_SRGB)
++#define V4L2_COLORSPACE_MASK_RAW V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_RAW)
++
++/*
++ * All three colour spaces JPEG, SMPTE170M and REC709 are fundamentally sRGB
++ * underneath (as near as makes no difference to us), just with different YCbCr
++ * encodings. Therefore the ISP can generate sRGB on its main output and any of
++ * the others on its low resolution output. Applications should, when using both
++ * outputs, program the colour spaces on them to be the same, matching whatever
++ * is requested for the low resolution output, even if the main output is
++ * producing an RGB format. In turn this requires us to allow all these colour
++ * spaces for every YUV/RGB output format.
++ */
++#define V4L2_COLORSPACE_MASK_ALL_SRGB (V4L2_COLORSPACE_MASK_JPEG |	\
++				       V4L2_COLORSPACE_MASK_SRGB |	\
++				       V4L2_COLORSPACE_MASK_SMPTE170M |	\
++				       V4L2_COLORSPACE_MASK_REC709)
++
++static const struct pisp_be_format supported_formats[] = {
++	/* Single plane YUV formats */
++	{
++		.fourcc		    = V4L2_PIX_FMT_YUV420,
++		/* 128 alignment to ensure U/V planes are 64 byte aligned. */
++		.align		    = 128,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.25), P3(0.25) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_JPEG,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_YVU420,
++		/* 128 alignment to ensure U/V planes are 64 byte aligned. */
++		.align		    = 128,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.25), P3(0.25) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_NV12,
++		.align		    = 32,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.5) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_NV21,
++		.align		    = 32,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.5) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_YUYV,
++		.align		    = 64,
++		.bit_depth	    = 16,
++		.plane_factor	    = { P3(1) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_UYVY,
++		.align		    = 64,
++		.bit_depth	    = 16,
++		.plane_factor	    = { P3(1) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_YVYU,
++		.align		    = 64,
++		.bit_depth	    = 16,
++		.plane_factor	    = { P3(1) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_VYUY,
++		.align		    = 64,
++		.bit_depth	    = 16,
++		.plane_factor	    = { P3(1) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	/* Multiplane YUV formats */
++	{
++		.fourcc		    = V4L2_PIX_FMT_YUV420M,
++		.align		    = 64,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.25), P3(0.25) },
++		.num_planes	    = 3,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_JPEG,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_NV12M,
++		.align		    = 32,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.5) },
++		.num_planes	    = 2,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_NV21M,
++		.align		    = 32,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.5) },
++		.num_planes	    = 2,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_YVU420M,
++		.align		    = 64,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.25), P3(0.25) },
++		.num_planes	    = 3,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_YUV422M,
++		.align		    = 64,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.5), P3(0.5) },
++		.num_planes	    = 3,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_JPEG,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_YVU422M,
++		.align		    = 64,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(0.5), P3(0.5) },
++		.num_planes	    = 3,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_YUV444M,
++		.align		    = 64,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(1), P3(1) },
++		.num_planes	    = 3,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_JPEG,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_YVU444M,
++		.align		    = 64,
++		.bit_depth	    = 8,
++		.plane_factor	    = { P3(1), P3(1), P3(1) },
++		.num_planes	    = 3,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
++	},
++	/* RGB formats */
++	{
++		.fourcc		    = V4L2_PIX_FMT_RGB24,
++		.align		    = 32,
++		.bit_depth	    = 24,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SRGB,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_BGR24,
++		.align		    = 32,
++		.bit_depth	    = 24,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SRGB,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_XBGR32,
++		.align		    = 64,
++		.bit_depth	    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SRGB,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_RGBX32,
++		.align		    = 64,
++		.bit_depth	    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SRGB,
++	},
++	/* Bayer formats - 8-bit */
++	{
++		.fourcc		    = V4L2_PIX_FMT_SRGGB8,
++		.bit_depth	    = 8,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SBGGR8,
++		.bit_depth	    = 8,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGRBG8,
++		.bit_depth	    = 8,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGBRG8,
++		.bit_depth	    = 8,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	/* Bayer formats - 16-bit */
++	{
++		.fourcc		    = V4L2_PIX_FMT_SRGGB16,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SBGGR16,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGRBG16,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGBRG16,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		/* Bayer formats unpacked to 16bpp */
++		/* 10 bit */
++		.fourcc		    = V4L2_PIX_FMT_SRGGB10,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SBGGR10,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGRBG10,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGBRG10,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		/* 12 bit */
++		.fourcc		    = V4L2_PIX_FMT_SRGGB12,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SBGGR12,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGRBG12,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGBRG12,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		/* 14 bit */
++		.fourcc		    = V4L2_PIX_FMT_SRGGB14,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SBGGR14,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGRBG14,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_SGBRG14,
++		.bit_depth	    = 16,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	/* Bayer formats - 16-bit PiSP Compressed */
++	{
++		.fourcc		    = V4L2_PIX_FMT_PISP_COMP1_BGGR,
++		.bit_depth	    = 8,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_PISP_COMP1_RGGB,
++		.bit_depth	    = 8,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_PISP_COMP1_GRBG,
++		.bit_depth	    = 8,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_PISP_COMP1_GBRG,
++		.bit_depth	    = 8,
++		.align		    = 32,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++};
++
++static const struct pisp_be_format meta_out_supported_formats[] = {
++	/* Configuration buffer format. */
++	{
++		.fourcc		    = V4L2_META_FMT_RPI_BE_CFG,
++	},
++};
++
++#endif /* _PISP_BE_FORMATS_ */
+--- a/drivers/media/v4l2-core/v4l2-ioctl.c
++++ b/drivers/media/v4l2-core/v4l2-ioctl.c
+@@ -1452,6 +1452,7 @@ static void v4l_fill_fmtdesc(struct v4l2
+ 	case V4L2_PIX_FMT_NV12M_10BE_8L128:	descr = "10-bit NV12M (8x128 Linear, BE)"; break;
+ 	case V4L2_META_FMT_SENSOR_DATA:	descr = "Sensor Ancillary Metadata"; break;
+ 	case V4L2_META_FMT_BCM2835_ISP_STATS: descr = "BCM2835 ISP Image Statistics"; break;
++	case V4L2_META_FMT_RPI_BE_CFG: descr = "PiSP Config format"; break;
+ 
+ 	default:
+ 		/* Compressed formats */
+@@ -1503,6 +1504,7 @@ static void v4l_fill_fmtdesc(struct v4l2
+ 		case V4L2_PIX_FMT_MT21C:	descr = "Mediatek Compressed Format"; break;
+ 		case V4L2_PIX_FMT_QC08C:	descr = "QCOM Compressed 8-bit Format"; break;
+ 		case V4L2_PIX_FMT_QC10C:	descr = "QCOM Compressed 10-bit Format"; break;
++		case V4L2_PIX_FMT_RPI_BE: descr = "PiSP Opaque Format"; break;
+ 		default:
+ 			if (fmt->description[0])
+ 				return;
+--- /dev/null
++++ b/include/media/raspberrypi/pisp_common.h
+@@ -0,0 +1,65 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Raspberry Pi PiSP common configuration definitions.
++ *
++ * Copyright (C) 2021 - Raspberry Pi (Trading) Ltd.
++ *
++ */
++#ifndef _PISP_COMMON_H_
++#define _PISP_COMMON_H_
++
++#include <linux/types.h>
++
++#include "pisp_types.h"
++
++struct pisp_bla_config {
++	uint16_t black_level_r;
++	uint16_t black_level_gr;
++	uint16_t black_level_gb;
++	uint16_t black_level_b;
++	uint16_t output_black_level;
++	uint8_t pad[2];
++};
++
++struct pisp_wbg_config {
++	uint16_t gain_r;
++	uint16_t gain_g;
++	uint16_t gain_b;
++	uint8_t pad[2];
++};
++
++struct pisp_compress_config {
++	/* value subtracted from incoming data */
++	uint16_t offset;
++	uint8_t pad;
++	/* 1 => Companding; 2 => Delta (recommended); 3 => Combined (for HDR) */
++	uint8_t mode;
++};
++
++struct pisp_decompress_config {
++	/* value added to reconstructed data */
++	uint16_t offset;
++	uint8_t pad;
++	/* 1 => Companding; 2 => Delta (recommended); 3 => Combined (for HDR) */
++	uint8_t mode;
++};
++
++enum pisp_axi_flags {
++	/* round down bursts to end at a 32-byte boundary, to align following bursts */
++	PISP_AXI_FLAG_ALIGN = 128,
++	 /* for FE writer: force WSTRB high, to pad output to 16-byte boundary */
++	PISP_AXI_FLAG_PAD = 64,
++	/* for FE writer: Use Output FIFO level to trigger "panic" */
++	PISP_AXI_FLAG_PANIC = 32
++};
++
++struct pisp_axi_config {
++	/* burst length minus one, which must be in the range 0:15; OR'd with flags */
++	uint8_t maxlen_flags;
++	/* { prot[2:0], cache[3:0] } fields, echoed on AXI bus */
++	uint8_t cache_prot;
++	/* QoS field(s) (4x4 bits for FE writer; 4 bits for other masters) */
++	uint16_t qos;
++};
++
++#endif /* _PISP_COMMON_H_ */
+--- /dev/null
++++ b/include/media/raspberrypi/pisp_types.h
+@@ -0,0 +1,144 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Raspberry Pi PiSP common types.
++ *
++ * Copyright (C) 2021 - Raspberry Pi (Trading) Ltd.
++ *
++ */
++#ifndef _PISP_TYPES_H_
++#define _PISP_TYPES_H_
++
++/* This definition must match the format description in the hardware exactly! */
++struct pisp_image_format_config {
++	/* size in pixels */
++	uint16_t width, height;
++	/* must match struct pisp_image_format below */
++	uint32_t format;
++	int32_t stride;
++	/* some planar image formats will need a second stride */
++	int32_t stride2;
++};
++
++static_assert(sizeof(struct pisp_image_format_config) == 16);
++
++enum pisp_bayer_order {
++	/*
++	 * Note how bayer_order&1 tells you if G is on the even pixels of the
++	 * checkerboard or not, and bayer_order&2 tells you if R is on the even
++	 * rows or is swapped with B. Note that if the top (of the 8) bits is
++	 * set, this denotes a monochrome or greyscale image, and the lower bits
++	 * should all be ignored.
++	 */
++	PISP_BAYER_ORDER_RGGB = 0,
++	PISP_BAYER_ORDER_GBRG = 1,
++	PISP_BAYER_ORDER_BGGR = 2,
++	PISP_BAYER_ORDER_GRBG = 3,
++	PISP_BAYER_ORDER_GREYSCALE = 128
++};
++
++enum pisp_image_format {
++	/*
++	 * Precise values are mostly tbd. Generally these will be portmanteau
++	 * values comprising bit fields and flags. This format must be shared
++	 * throughout the PiSP.
++	 */
++	PISP_IMAGE_FORMAT_BPS_8 = 0x00000000,
++	PISP_IMAGE_FORMAT_BPS_10 = 0x00000001,
++	PISP_IMAGE_FORMAT_BPS_12 = 0x00000002,
++	PISP_IMAGE_FORMAT_BPS_16 = 0x00000003,
++	PISP_IMAGE_FORMAT_BPS_MASK = 0x00000003,
++
++	PISP_IMAGE_FORMAT_PLANARITY_INTERLEAVED = 0x00000000,
++	PISP_IMAGE_FORMAT_PLANARITY_SEMI_PLANAR = 0x00000010,
++	PISP_IMAGE_FORMAT_PLANARITY_PLANAR = 0x00000020,
++	PISP_IMAGE_FORMAT_PLANARITY_MASK = 0x00000030,
++
++	PISP_IMAGE_FORMAT_SAMPLING_444 = 0x00000000,
++	PISP_IMAGE_FORMAT_SAMPLING_422 = 0x00000100,
++	PISP_IMAGE_FORMAT_SAMPLING_420 = 0x00000200,
++	PISP_IMAGE_FORMAT_SAMPLING_MASK = 0x00000300,
++
++	PISP_IMAGE_FORMAT_ORDER_NORMAL = 0x00000000,
++	PISP_IMAGE_FORMAT_ORDER_SWAPPED = 0x00001000,
++
++	PISP_IMAGE_FORMAT_SHIFT_0 = 0x00000000,
++	PISP_IMAGE_FORMAT_SHIFT_1 = 0x00010000,
++	PISP_IMAGE_FORMAT_SHIFT_2 = 0x00020000,
++	PISP_IMAGE_FORMAT_SHIFT_3 = 0x00030000,
++	PISP_IMAGE_FORMAT_SHIFT_4 = 0x00040000,
++	PISP_IMAGE_FORMAT_SHIFT_5 = 0x00050000,
++	PISP_IMAGE_FORMAT_SHIFT_6 = 0x00060000,
++	PISP_IMAGE_FORMAT_SHIFT_7 = 0x00070000,
++	PISP_IMAGE_FORMAT_SHIFT_8 = 0x00080000,
++	PISP_IMAGE_FORMAT_SHIFT_MASK = 0x000f0000,
++
++	PISP_IMAGE_FORMAT_UNCOMPRESSED = 0x00000000,
++	PISP_IMAGE_FORMAT_COMPRESSION_MODE_1 = 0x01000000,
++	PISP_IMAGE_FORMAT_COMPRESSION_MODE_2 = 0x02000000,
++	PISP_IMAGE_FORMAT_COMPRESSION_MODE_3 = 0x03000000,
++	PISP_IMAGE_FORMAT_COMPRESSION_MASK = 0x03000000,
++
++	PISP_IMAGE_FORMAT_HOG_SIGNED = 0x04000000,
++	PISP_IMAGE_FORMAT_HOG_UNSIGNED = 0x08000000,
++	PISP_IMAGE_FORMAT_INTEGRAL_IMAGE = 0x10000000,
++	PISP_IMAGE_FORMAT_WALLPAPER_ROLL = 0x20000000,
++	PISP_IMAGE_FORMAT_THREE_CHANNEL = 0x40000000,
++
++	/* Lastly a few specific instantiations of the above. */
++	PISP_IMAGE_FORMAT_SINGLE_16 = PISP_IMAGE_FORMAT_BPS_16,
++	PISP_IMAGE_FORMAT_THREE_16 =
++		PISP_IMAGE_FORMAT_BPS_16 | PISP_IMAGE_FORMAT_THREE_CHANNEL
++};
++
++#define PISP_IMAGE_FORMAT_bps_8(fmt)                                           \
++	(((fmt)&PISP_IMAGE_FORMAT_BPS_MASK) == PISP_IMAGE_FORMAT_BPS_8)
++#define PISP_IMAGE_FORMAT_bps_10(fmt)                                          \
++	(((fmt)&PISP_IMAGE_FORMAT_BPS_MASK) == PISP_IMAGE_FORMAT_BPS_10)
++#define PISP_IMAGE_FORMAT_bps_12(fmt)                                          \
++	(((fmt)&PISP_IMAGE_FORMAT_BPS_MASK) == PISP_IMAGE_FORMAT_BPS_12)
++#define PISP_IMAGE_FORMAT_bps_16(fmt)                                          \
++	(((fmt)&PISP_IMAGE_FORMAT_BPS_MASK) == PISP_IMAGE_FORMAT_BPS_16)
++#define PISP_IMAGE_FORMAT_bps(fmt)                                             \
++	(((fmt)&PISP_IMAGE_FORMAT_BPS_MASK) ?                                  \
++		       8 + (2 << (((fmt)&PISP_IMAGE_FORMAT_BPS_MASK) - 1)) :   \
++		       8)
++#define PISP_IMAGE_FORMAT_shift(fmt)                                           \
++	(((fmt)&PISP_IMAGE_FORMAT_SHIFT_MASK) / PISP_IMAGE_FORMAT_SHIFT_1)
++#define PISP_IMAGE_FORMAT_three_channel(fmt)                                   \
++	((fmt)&PISP_IMAGE_FORMAT_THREE_CHANNEL)
++#define PISP_IMAGE_FORMAT_single_channel(fmt)                                  \
++	(!((fmt)&PISP_IMAGE_FORMAT_THREE_CHANNEL))
++#define PISP_IMAGE_FORMAT_compressed(fmt)                                      \
++	(((fmt)&PISP_IMAGE_FORMAT_COMPRESSION_MASK) !=                         \
++	 PISP_IMAGE_FORMAT_UNCOMPRESSED)
++#define PISP_IMAGE_FORMAT_sampling_444(fmt)                                    \
++	(((fmt)&PISP_IMAGE_FORMAT_SAMPLING_MASK) ==                            \
++	 PISP_IMAGE_FORMAT_SAMPLING_444)
++#define PISP_IMAGE_FORMAT_sampling_422(fmt)                                    \
++	(((fmt)&PISP_IMAGE_FORMAT_SAMPLING_MASK) ==                            \
++	 PISP_IMAGE_FORMAT_SAMPLING_422)
++#define PISP_IMAGE_FORMAT_sampling_420(fmt)                                    \
++	(((fmt)&PISP_IMAGE_FORMAT_SAMPLING_MASK) ==                            \
++	 PISP_IMAGE_FORMAT_SAMPLING_420)
++#define PISP_IMAGE_FORMAT_order_normal(fmt)                                    \
++	(!((fmt)&PISP_IMAGE_FORMAT_ORDER_SWAPPED))
++#define PISP_IMAGE_FORMAT_order_swapped(fmt)                                   \
++	((fmt)&PISP_IMAGE_FORMAT_ORDER_SWAPPED)
++#define PISP_IMAGE_FORMAT_interleaved(fmt)                                     \
++	(((fmt)&PISP_IMAGE_FORMAT_PLANARITY_MASK) ==                           \
++	 PISP_IMAGE_FORMAT_PLANARITY_INTERLEAVED)
++#define PISP_IMAGE_FORMAT_semiplanar(fmt)                                      \
++	(((fmt)&PISP_IMAGE_FORMAT_PLANARITY_MASK) ==                           \
++	 PISP_IMAGE_FORMAT_PLANARITY_SEMI_PLANAR)
++#define PISP_IMAGE_FORMAT_planar(fmt)                                          \
++	(((fmt)&PISP_IMAGE_FORMAT_PLANARITY_MASK) ==                           \
++	 PISP_IMAGE_FORMAT_PLANARITY_PLANAR)
++#define PISP_IMAGE_FORMAT_wallpaper(fmt)                                       \
++	((fmt)&PISP_IMAGE_FORMAT_WALLPAPER_ROLL)
++#define PISP_IMAGE_FORMAT_HOG(fmt)                                             \
++	((fmt) &                                                               \
++	 (PISP_IMAGE_FORMAT_HOG_SIGNED | PISP_IMAGE_FORMAT_HOG_UNSIGNED))
++
++#define PISP_WALLPAPER_WIDTH 128 // in bytes
++
++#endif /* _PISP_TYPES_H_ */
+--- a/include/uapi/linux/videodev2.h
++++ b/include/uapi/linux/videodev2.h
+@@ -793,6 +793,9 @@ struct v4l2_pix_format {
+ #define V4L2_PIX_FMT_IPU3_SGRBG10	v4l2_fourcc('i', 'p', '3', 'G') /* IPU3 packed 10-bit GRBG bayer */
+ #define V4L2_PIX_FMT_IPU3_SRGGB10	v4l2_fourcc('i', 'p', '3', 'r') /* IPU3 packed 10-bit RGGB bayer */
+ 
++/* The pixel format for all our buffers (the precise format is found in the config buffer). */
++#define V4L2_PIX_FMT_RPI_BE v4l2_fourcc('R', 'P', 'B', 'P')
++
+ /* SDR formats - used only for Software Defined Radio devices */
+ #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
+ #define V4L2_SDR_FMT_CU16LE       v4l2_fourcc('C', 'U', '1', '6') /* IQ u16le */
+@@ -822,6 +825,9 @@ struct v4l2_pix_format {
+ #define V4L2_META_FMT_RK_ISP1_PARAMS	v4l2_fourcc('R', 'K', '1', 'P') /* Rockchip ISP1 3A Parameters */
+ #define V4L2_META_FMT_RK_ISP1_STAT_3A	v4l2_fourcc('R', 'K', '1', 'S') /* Rockchip ISP1 3A Statistics */
+ 
++/* The metadata format identifier for our configuration buffers. */
++#define V4L2_META_FMT_RPI_BE_CFG v4l2_fourcc('R', 'P', 'B', 'C')
++
+ /* priv field value to indicates that subsequent fields are valid. */
+ #define V4L2_PIX_FMT_PRIV_MAGIC		0xfeedcafe
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0862-irqchip-irq-bcm2712-mip-Support-for-2712-s-MIP.patch b/target/linux/bcm27xx/patches-6.1/950-0862-irqchip-irq-bcm2712-mip-Support-for-2712-s-MIP.patch
new file mode 100644
index 0000000000..022a94af1c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0862-irqchip-irq-bcm2712-mip-Support-for-2712-s-MIP.patch
@@ -0,0 +1,386 @@
+From 89b748416358e4e04765b9a4f20e1c3d256b9d9e Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 28 Jul 2021 11:13:39 +0100
+Subject: [PATCH] irqchip: irq-bcm2712-mip: Support for 2712's MIP
+
+irqchip: irq-bcm2712-mip: specify bitmap search size as ilog2(N) not N
+
+Freeing also has the same interface.
+
+irqchip: irq-bcm2712-mip: Fix build warnings
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+irqchip: bcm2712-mip: add a quick hack to optionally shift MSI vectors
+
+There are two MIP peripherals in bcm2712, the first gets a first-class
+treatment where 64 consecutive GIC SPIs are assigned to all 64 output
+vectors. The second gets an agglomeration of 17 GIC SPIs, but only 8 of
+these are consecutive starting at the 8th output vector.
+
+For now, allow the use of this smaller contiguous range within a larger
+whole.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/irqchip/Kconfig           |   8 +
+ drivers/irqchip/Makefile          |   1 +
+ drivers/irqchip/irq-bcm2712-mip.c | 325 ++++++++++++++++++++++++++++++
+ 3 files changed, 334 insertions(+)
+ create mode 100644 drivers/irqchip/irq-bcm2712-mip.c
+
+--- a/drivers/irqchip/Kconfig
++++ b/drivers/irqchip/Kconfig
+@@ -109,6 +109,14 @@ config I8259
+ 	bool
+ 	select IRQ_DOMAIN
+ 
++config BCM2712_MIP
++	bool "Broadcom 2712 MSI-X Interrupt Peripheral support"
++	depends on ARM_GIC
++	select GENERIC_IRQ_CHIP
++	select IRQ_DOMAIN
++	help
++	  Enable support for the Broadcom BCM2712 MSI-X target peripheral.
++
+ config BCM6345_L1_IRQ
+ 	bool
+ 	select GENERIC_IRQ_CHIP
+--- a/drivers/irqchip/Makefile
++++ b/drivers/irqchip/Makefile
+@@ -63,6 +63,7 @@ obj-$(CONFIG_XTENSA_MX)			+= irq-xtensa-
+ obj-$(CONFIG_XILINX_INTC)		+= irq-xilinx-intc.o
+ obj-$(CONFIG_IRQ_CROSSBAR)		+= irq-crossbar.o
+ obj-$(CONFIG_SOC_VF610)			+= irq-vf610-mscm-ir.o
++obj-$(CONFIG_BCM2712_MIP)		+= irq-bcm2712-mip.o
+ obj-$(CONFIG_BCM6345_L1_IRQ)		+= irq-bcm6345-l1.o
+ obj-$(CONFIG_BCM7038_L1_IRQ)		+= irq-bcm7038-l1.o
+ obj-$(CONFIG_BCM7120_L2_IRQ)		+= irq-bcm7120-l2.o
+--- /dev/null
++++ b/drivers/irqchip/irq-bcm2712-mip.c
+@@ -0,0 +1,325 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (C) 2021 Raspberry Pi Ltd., All Rights Reserved.
++ */
++
++#include <linux/pci.h>
++#include <linux/msi.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_irq.h>
++#include <linux/of_pci.h>
++
++#include <linux/irqchip.h>
++
++#define MIP_INT_RAISED		0x00
++#define MIP_INT_CLEARED		0x10
++#define MIP_INT_CFGL_HOST	0x20
++#define MIP_INT_CFGH_HOST	0x30
++#define MIP_INT_MASKL_HOST	0x40
++#define MIP_INT_MASKH_HOST	0x50
++#define MIP_INT_MASKL_VPU	0x60
++#define MIP_INT_MASKH_VPU	0x70
++#define MIP_INT_STATUSL_HOST	0x80
++#define MIP_INT_STATUSH_HOST	0x90
++#define MIP_INT_STATUSL_VPU	0xa0
++#define MIP_INT_STATUSH_VPU	0xb0
++
++struct mip_priv {
++	spinlock_t msi_map_lock;
++	spinlock_t hw_lock;
++	void * __iomem base;
++	phys_addr_t msg_addr;
++	u32 msi_base;		/* The SGI number that MSIs start */
++	u32 num_msis;		/* The number of SGIs for MSIs */
++	u32 msi_offset;		/* Shift the allocated msi up by N */
++	unsigned long *msi_map;
++};
++
++static void mip_mask_msi_irq(struct irq_data *d)
++{
++	pci_msi_mask_irq(d);
++	irq_chip_mask_parent(d);
++}
++
++static void mip_unmask_msi_irq(struct irq_data *d)
++{
++	pci_msi_unmask_irq(d);
++	irq_chip_unmask_parent(d);
++}
++
++static void mip_compose_msi_msg(struct irq_data *d, struct msi_msg *msg)
++{
++	struct mip_priv *priv = irq_data_get_irq_chip_data(d);
++
++	msg->address_hi = upper_32_bits(priv->msg_addr);
++	msg->address_lo = lower_32_bits(priv->msg_addr);
++	msg->data = d->hwirq;
++}
++
++// The "bus-specific" irq_chip (the MIP doesn't _have_ to be used with PCIe)
++
++static struct irq_chip mip_msi_irq_chip = {
++	.name			= "MIP-MSI",
++	.irq_unmask		= mip_unmask_msi_irq,
++	.irq_mask		= mip_mask_msi_irq,
++	.irq_eoi		= irq_chip_eoi_parent,
++	.irq_set_affinity	= irq_chip_set_affinity_parent,
++};
++
++static struct msi_domain_info mip_msi_domain_info = {
++	.flags	= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
++		   MSI_FLAG_PCI_MSIX),
++	.chip	= &mip_msi_irq_chip,
++};
++
++// The "middle" irq_chip (the hardware control part)
++
++static struct irq_chip mip_irq_chip = {
++	.name			= "MIP",
++	.irq_mask		= irq_chip_mask_parent,
++	.irq_unmask		= irq_chip_unmask_parent,
++	.irq_eoi		= irq_chip_eoi_parent,
++	.irq_set_affinity	= irq_chip_set_affinity_parent,
++	.irq_set_type		= irq_chip_set_type_parent,
++	.irq_compose_msi_msg	= mip_compose_msi_msg,
++};
++
++
++// And a domain to connect it to its parent (the GIC)
++
++static int mip_irq_domain_alloc(struct irq_domain *domain,
++				unsigned int virq, unsigned int nr_irqs,
++				void *args)
++{
++	struct mip_priv *priv = domain->host_data;
++	struct irq_fwspec fwspec;
++	struct irq_data *irqd;
++	int hwirq, ret, i;
++
++	spin_lock(&priv->msi_map_lock);
++
++	hwirq = bitmap_find_free_region(priv->msi_map, priv->num_msis, ilog2(nr_irqs));
++
++	spin_unlock(&priv->msi_map_lock);
++
++	if (hwirq < 0)
++		return -ENOSPC;
++
++	hwirq += priv->msi_offset;
++	fwspec.fwnode = domain->parent->fwnode;
++	fwspec.param_count = 3;
++	fwspec.param[0] = 0;
++	fwspec.param[1] = hwirq + priv->msi_base;
++	fwspec.param[2] = IRQ_TYPE_EDGE_RISING;
++
++	ret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &fwspec);
++	if (ret)
++	    return ret;
++
++	for (i = 0; i < nr_irqs; i++) {
++		irqd = irq_domain_get_irq_data(domain->parent, virq + i);
++		irqd->chip->irq_set_type(irqd, IRQ_TYPE_EDGE_RISING);
++
++		irq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,
++					      &mip_irq_chip, priv);
++		irqd = irq_get_irq_data(virq + i);
++		irqd_set_single_target(irqd);
++		irqd_set_affinity_on_activate(irqd);
++	}
++
++	return 0;
++}
++
++static void mip_irq_domain_free(struct irq_domain *domain,
++				unsigned int virq, unsigned int nr_irqs)
++{
++	struct irq_data *d = irq_domain_get_irq_data(domain, virq);
++	struct mip_priv *priv = irq_data_get_irq_chip_data(d);
++
++	irq_domain_free_irqs_parent(domain, virq, nr_irqs);
++	d->hwirq -= priv->msi_offset;
++
++	spin_lock(&priv->msi_map_lock);
++
++	bitmap_release_region(priv->msi_map, d->hwirq, ilog2(nr_irqs));
++
++	spin_unlock(&priv->msi_map_lock);
++}
++
++#if 0
++static int mip_irq_domain_activate(struct irq_domain *domain,
++				   struct irq_data *d, bool reserve)
++{
++	struct mip_priv *priv = irq_data_get_irq_chip_data(d);
++	unsigned long flags;
++	unsigned int irq = d->hwirq;
++	void *__iomem reg = priv->base +
++		((irq < 32) ? MIP_INT_MASKL_HOST : MIP_INT_MASKH_HOST);
++	u32 val;
++
++	spin_lock_irqsave(&priv->hw_lock, flags);
++	val = readl(reg);
++	val &= ~(1 << (irq % 32)); // Clear the mask
++	writel(val, reg);
++	spin_unlock_irqrestore(&priv->hw_lock, flags);
++	return 0;
++}
++
++static void mip_irq_domain_deactivate(struct irq_domain *domain,
++				      struct irq_data *d)
++{
++	struct mip_priv *priv = irq_data_get_irq_chip_data(d);
++	unsigned long flags;
++	unsigned int irq = d->hwirq - priv->msi_base;
++	void *__iomem reg = priv->base +
++		((irq < 32) ? MIP_INT_MASKL_HOST : MIP_INT_MASKH_HOST);
++	u32 val;
++
++	spin_lock_irqsave(&priv->hw_lock, flags);
++	val = readl(reg);
++	val |= (1 << (irq % 32)); // Mask it out
++	writel(val, reg);
++	spin_unlock_irqrestore(&priv->hw_lock, flags);
++}
++#endif
++
++static const struct irq_domain_ops mip_irq_domain_ops = {
++	.alloc		= mip_irq_domain_alloc,
++	.free		= mip_irq_domain_free,
++	//.activate	= mip_irq_domain_activate,
++	//.deactivate	= mip_irq_domain_deactivate,
++};
++
++static int mip_init_domains(struct mip_priv *priv,
++			    struct device_node *node)
++{
++	struct irq_domain *middle_domain, *msi_domain, *gic_domain;
++	struct device_node *gic_node;
++
++	gic_node = of_irq_find_parent(node);
++	if (!gic_node) {
++		pr_err("Failed to find the GIC node\n");
++		return -ENODEV;
++	}
++
++	gic_domain = irq_find_host(gic_node);
++	if (!gic_domain) {
++		pr_err("Failed to find the GIC domain\n");
++		return -ENXIO;
++	}
++
++	middle_domain = irq_domain_add_tree(NULL,
++					    &mip_irq_domain_ops,
++					    priv);
++	if (!middle_domain) {
++		pr_err("Failed to create the MIP middle domain\n");
++		return -ENOMEM;
++	}
++
++	middle_domain->parent = gic_domain;
++
++	msi_domain = pci_msi_create_irq_domain(of_node_to_fwnode(node),
++					       &mip_msi_domain_info,
++					       middle_domain);
++	if (!msi_domain) {
++		pr_err("Failed to create MSI domain\n");
++		irq_domain_remove(middle_domain);
++		return -ENOMEM;
++	}
++
++	return 0;
++}
++
++static int __init mip_of_msi_init(struct device_node *node,
++				  struct device_node *parent)
++{
++	struct mip_priv *priv;
++	struct resource res;
++	int ret;
++
++	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++
++	spin_lock_init(&priv->msi_map_lock);
++	spin_lock_init(&priv->hw_lock);
++
++	ret = of_address_to_resource(node, 0, &res);
++	if (ret) {
++		pr_err("Failed to allocate resource\n");
++		goto err_priv;
++	}
++
++	if (of_property_read_u32(node, "brcm,msi-base-spi", &priv->msi_base)) {
++		pr_err("Unable to parse MSI base\n");
++		ret = -EINVAL;
++		goto err_priv;
++	}
++
++	if (of_property_read_u32(node, "brcm,msi-num-spis", &priv->num_msis)) {
++		pr_err("Unable to parse MSI numbers\n");
++		ret = -EINVAL;
++		goto err_priv;
++	}
++
++	if (of_property_read_u32(node, "brcm,msi-offset", &priv->msi_offset))
++		priv->msi_offset = 0;
++
++	if (of_property_read_u64(node, "brcm,msi-pci-addr", &priv->msg_addr)) {
++		pr_err("Unable to parse MSI address\n");
++		ret = -EINVAL;
++		goto err_priv;
++	}
++
++	priv->base = ioremap(res.start, resource_size(&res));
++	if (!priv->base) {
++		pr_err("Failed to ioremap regs\n");
++		ret = -ENOMEM;
++		goto err_priv;
++	}
++
++	priv->msi_map = kcalloc(BITS_TO_LONGS(priv->num_msis),
++				sizeof(*priv->msi_map),
++				GFP_KERNEL);
++	if (!priv->msi_map) {
++		ret = -ENOMEM;
++		goto err_base;
++	}
++
++	pr_debug("Registering %d msixs, starting at %d\n",
++		 priv->num_msis, priv->msi_base);
++
++	/*
++	 * Begin with all MSI-Xs masked in for the host, masked out for the
++	 * VPU, and edge-triggered.
++	 */
++	writel(0, priv->base + MIP_INT_MASKL_HOST);
++	writel(0, priv->base + MIP_INT_MASKH_HOST);
++	writel(~0, priv->base + MIP_INT_MASKL_VPU);
++	writel(~0, priv->base + MIP_INT_MASKH_VPU);
++	writel(~0, priv->base + MIP_INT_CFGL_HOST);
++	writel(~0, priv->base + MIP_INT_CFGH_HOST);
++
++	ret = mip_init_domains(priv, node);
++	if (ret) {
++		pr_err("Failed to allocate msi_map\n");
++		goto err_map;
++	}
++
++	return 0;
++
++err_map:
++	kfree(priv->msi_map);
++
++err_base:
++	iounmap(priv->base);
++
++err_priv:
++	kfree(priv);
++
++	pr_err("%s: failed - err %d\n", __func__, ret);
++
++	return ret;
++}
++IRQCHIP_DECLARE(bcm_mip, "brcm,bcm2712-mip-intc", mip_of_msi_init);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0863-reset-reset-brcmstb-rescal-Support-shared-use.patch b/target/linux/bcm27xx/patches-6.1/950-0863-reset-reset-brcmstb-rescal-Support-shared-use.patch
new file mode 100644
index 0000000000..a4328e5bc7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0863-reset-reset-brcmstb-rescal-Support-shared-use.patch
@@ -0,0 +1,47 @@
+From 87b1126181f79fb2558652af0d7fafd9deaab5f3 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 7 Sep 2021 14:49:00 +0100
+Subject: [PATCH] reset: reset-brcmstb-rescal: Support shared use
+
+reset_control_reset should not be used with shared reset controllers.
+Add support for reset_control_assert and _deassert to get the desired
+behaviour and avoid ugly warnings in the kernel log.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/reset/reset-brcmstb-rescal.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/reset/reset-brcmstb-rescal.c
++++ b/drivers/reset/reset-brcmstb-rescal.c
+@@ -20,6 +20,7 @@ struct brcm_rescal_reset {
+ 	struct reset_controller_dev rcdev;
+ };
+ 
++/* Also doubles a deassert */
+ static int brcm_rescal_reset_set(struct reset_controller_dev *rcdev,
+ 				 unsigned long id)
+ {
+@@ -52,6 +53,13 @@ static int brcm_rescal_reset_set(struct
+ 	return 0;
+ }
+ 
++/* A dummy function - deassert/reset does all the work */
++static int brcm_rescal_reset_assert(struct reset_controller_dev *rcdev,
++				    unsigned long id)
++{
++	return 0;
++}
++
+ static int brcm_rescal_reset_xlate(struct reset_controller_dev *rcdev,
+ 				   const struct of_phandle_args *reset_spec)
+ {
+@@ -61,6 +69,8 @@ static int brcm_rescal_reset_xlate(struc
+ 
+ static const struct reset_control_ops brcm_rescal_reset_ops = {
+ 	.reset = brcm_rescal_reset_set,
++	.deassert = brcm_rescal_reset_set,
++	.assert = brcm_rescal_reset_assert,
+ };
+ 
+ static int brcm_rescal_reset_probe(struct platform_device *pdev)
diff --git a/target/linux/bcm27xx/patches-6.1/950-0864-net-macb-Also-set-DMA-coherent-mask.patch b/target/linux/bcm27xx/patches-6.1/950-0864-net-macb-Also-set-DMA-coherent-mask.patch
new file mode 100644
index 0000000000..88d92fbb20
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0864-net-macb-Also-set-DMA-coherent-mask.patch
@@ -0,0 +1,418 @@
+From bd36586dd9e05bde8e23dc3d99771269b48b65f8 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 10 Sep 2021 17:20:45 +0100
+Subject: [PATCH] net: macb: Also set DMA coherent mask
+
+macb: Add device tree properties that allow configuration of the AXI max pipeline register
+
+net: macb: add support for ethtool interrupt moderation configuration
+
+Only global throttling of rx or tx by time quanta is supported.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+macb: add platform device shutdown function. Prevents AXI master over PCIE from hanging when the host is rebooted.
+
+net: macb: increase polling interval for MDIO completion
+
+MDIO is a slow bus (single-digit MHz). Polling at 1us intervals
+is a bit aggressive, so increase to 100us as the transaction
+usually takes 100-200us to complete.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+net: macb: Several patches for RP1
+
+64-bit RX fix
+
+Also set DMA coherent mask
+
+Add device tree properties that allow configuration of the AXI max
+pipeline register
+
+Add support for ethtool interrupt moderation configuration
+
+Only global throttling of rx or tx by time quanta is supported.
+
+Add platform device shutdown function. Prevents AXI master over PCIE
+from hanging when the host is rebooted.
+
+Increase polling interval for MDIO completion
+
+MDIO is a slow bus (single-digit MHz). Polling at 1us intervals
+is a bit aggressive, so increase to 100us as the transaction
+usually takes 100-200us to complete.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+net: macb: Support the phy-reset-gpios property
+
+Allow a PHY to be reset with an optional GPIO. The reset duration can
+be specified in milliseconds - the default is 10ms.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+drivers: net: macb: close device on driver shutdown
+
+Fix some suspicious locking and instead call into macb_close, which
+deregisters and frees all resources the corresponding macb_open
+claimed.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+net: macb: add hack to prevent TX stalls in a quiet system
+
+See https://github.com/raspberrypi/linux-2712/issues/89
+
+There is some critical window during TX where a further write to the
+TSTART bit while TX is active does not cause newly queued TX descriptors
+to be consumed.
+
+For now "wait a bit, then try anyway" seems to work.
+
+Requires further investigation, but this unsticks NFS reliably.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+net: macb: set default interrupt moderation for GEM hardware
+
+Defaulting to intmod = 0 is antisocial, as the MAC can generate over
+130,000 interrupts per second. 50us is a sensible default.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/net/ethernet/cadence/macb.h      |  25 ++++
+ drivers/net/ethernet/cadence/macb_main.c | 151 ++++++++++++++++++++++-
+ 2 files changed, 174 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ethernet/cadence/macb.h
++++ b/drivers/net/ethernet/cadence/macb.h
+@@ -84,6 +84,8 @@
+ #define GEM_DMACFG		0x0010 /* DMA Configuration */
+ #define GEM_JML			0x0048 /* Jumbo Max Length */
+ #define GEM_HS_MAC_CONFIG	0x0050 /* GEM high speed config */
++#define GEM_AMP			0x0054 /* AXI Max Pipeline */
++#define GEM_INTMOD		0x005c /* Interrupt moderation */
+ #define GEM_HRB			0x0080 /* Hash Bottom */
+ #define GEM_HRT			0x0084 /* Hash Top */
+ #define GEM_SA1B		0x0088 /* Specific1 Bottom */
+@@ -346,6 +348,21 @@
+ #define GEM_ADDR64_OFFSET	30 /* Address bus width - 64b or 32b */
+ #define GEM_ADDR64_SIZE		1
+ 
++/* Bitfields in AMP */
++#define GEM_AR2R_MAX_PIPE_OFFSET	0  /* Maximum number of outstanding AXI read requests */
++#define GEM_AR2R_MAX_PIPE_SIZE		8
++#define GEM_AW2W_MAX_PIPE_OFFSET	8  /* Maximum number of outstanding AXI write requests */
++#define GEM_AW2W_MAX_PIPE_SIZE		8
++#define GEM_AW2B_FILL_OFFSET		16 /* Select wether the max AW2W transactions operates between: */
++#define GEM_AW2B_FILL_AW2W		0  /*   0: the AW to W AXI channel */
++#define GEM_AW2B_FILL_AW2B		1  /*   1: AW to B channel */
++#define GEM_AW2B_FILL_SIZE              1
++
++/* Bitfields in INTMOD */
++#define GEM_RX_MODERATION_OFFSET	0  /* RX interrupt moderation */
++#define GEM_RX_MODERATION_SIZE		8
++#define GEM_TX_MODERATION_OFFSET	16 /* TX interrupt moderation */
++#define GEM_TX_MODERATION_SIZE		8
+ 
+ /* Bitfields in NSR */
+ #define MACB_NSR_LINK_OFFSET	0 /* pcs_link_state */
+@@ -798,6 +815,7 @@
+ 	})
+ 
+ #define MACB_READ_NSR(bp)	macb_readl(bp, NSR)
++#define MACB_READ_TSR(bp)	macb_readl(bp, TSR)
+ 
+ /* struct macb_dma_desc - Hardware DMA descriptor
+  * @addr: DMA address of data buffer
+@@ -1217,6 +1235,7 @@ struct macb_queue {
+ 	dma_addr_t		tx_ring_dma;
+ 	struct work_struct	tx_error_task;
+ 	bool			txubr_pending;
++	bool			tx_pending;
+ 	struct napi_struct	napi_tx;
+ 
+ 	dma_addr_t		rx_ring_dma;
+@@ -1286,9 +1305,15 @@ struct macb {
+ 
+ 	u32			caps;
+ 	unsigned int		dma_burst_length;
++	u8			aw2w_max_pipe;
++	u8			ar2r_max_pipe;
++	bool			use_aw2b_fill;
+ 
+ 	phy_interface_t		phy_interface;
+ 
++	struct gpio_desc	*phy_reset_gpio;
++	int			phy_reset_ms;
++
+ 	/* AT91RM9200 transmit queue (1 on wire + 1 queued) */
+ 	struct macb_tx_skb	rm9200_txq[2];
+ 	unsigned int		max_tx_length;
+--- a/drivers/net/ethernet/cadence/macb_main.c
++++ b/drivers/net/ethernet/cadence/macb_main.c
+@@ -41,6 +41,9 @@
+ #include <linux/firmware/xlnx-zynqmp.h>
+ #include "macb.h"
+ 
++static unsigned int txdelay = 35;
++module_param(txdelay, uint, 0644);
++
+ /* This structure is only used for MACB on SiFive FU540 devices */
+ struct sifive_fu540_macb_mgmt {
+ 	void __iomem *reg;
+@@ -336,7 +339,7 @@ static int macb_mdio_wait_for_idle(struc
+ 	u32 val;
+ 
+ 	return readx_poll_timeout(MACB_READ_NSR, bp, val, val & MACB_BIT(IDLE),
+-				  1, MACB_MDIO_TIMEOUT);
++				  100, MACB_MDIO_TIMEOUT);
+ }
+ 
+ static int macb_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
+@@ -442,6 +445,19 @@ mdio_pm_exit:
+ 	return status;
+ }
+ 
++static int macb_mdio_reset(struct mii_bus *bus)
++{
++	struct macb *bp = bus->priv;
++
++	if (bp->phy_reset_gpio) {
++		gpiod_set_value_cansleep(bp->phy_reset_gpio, 1);
++		msleep(bp->phy_reset_ms);
++		gpiod_set_value_cansleep(bp->phy_reset_gpio, 0);
++	}
++
++	return 0;
++}
++
+ static void macb_init_buffers(struct macb *bp)
+ {
+ 	struct macb_queue *queue;
+@@ -915,6 +931,7 @@ static int macb_mii_init(struct macb *bp
+ 	bp->mii_bus->name = "MACB_mii_bus";
+ 	bp->mii_bus->read = &macb_mdio_read;
+ 	bp->mii_bus->write = &macb_mdio_write;
++	bp->mii_bus->reset = &macb_mdio_reset;
+ 	snprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
+ 		 bp->pdev->name, bp->pdev->id);
+ 	bp->mii_bus->priv = bp;
+@@ -1584,6 +1601,11 @@ static int macb_rx(struct macb_queue *qu
+ 
+ 		macb_init_rx_ring(queue);
+ 		queue_writel(queue, RBQP, queue->rx_ring_dma);
++#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
++		if (bp->hw_dma_cap & HW_DMA_CAP_64B)
++			macb_writel(bp, RBQPH,
++				    upper_32_bits(queue->rx_ring_dma));
++#endif
+ 
+ 		macb_writel(bp, NCR, ctrl | MACB_BIT(RE));
+ 
+@@ -1884,8 +1906,9 @@ static irqreturn_t macb_interrupt(int ir
+ 				queue_writel(queue, ISR, MACB_BIT(TCOMP) |
+ 							 MACB_BIT(TXUBR));
+ 
+-			if (status & MACB_BIT(TXUBR)) {
++			if (status & MACB_BIT(TXUBR) || queue->tx_pending) {
+ 				queue->txubr_pending = true;
++				queue->tx_pending = 0;
+ 				wmb(); // ensure softirq can see update
+ 			}
+ 
+@@ -2332,6 +2355,11 @@ static netdev_tx_t macb_start_xmit(struc
+ 	skb_tx_timestamp(skb);
+ 
+ 	spin_lock_irq(&bp->lock);
++
++	/* TSTART write might get dropped, so make the IRQ retrigger a buffer read */
++	if (macb_readl(bp, TSR) & MACB_BIT(TGO))
++		queue->tx_pending = 1;
++
+ 	macb_writel(bp, NCR, macb_readl(bp, NCR) | MACB_BIT(TSTART));
+ 	spin_unlock_irq(&bp->lock);
+ 
+@@ -2699,6 +2727,37 @@ static void macb_configure_dma(struct ma
+ 	}
+ }
+ 
++static void gem_init_axi(struct macb *bp)
++{
++	u32 amp;
++
++	/* AXI pipeline setup - don't touch values unless specified in device
++	 * tree. Some hardware could have reset values > 1.
++	 */
++	amp = gem_readl(bp, AMP);
++
++	if (bp->use_aw2b_fill)
++		amp = GEM_BFINS(AW2B_FILL, bp->use_aw2b_fill, amp);
++	if (bp->aw2w_max_pipe)
++		amp = GEM_BFINS(AW2W_MAX_PIPE, bp->aw2w_max_pipe, amp);
++	if (bp->ar2r_max_pipe)
++		amp = GEM_BFINS(AR2R_MAX_PIPE, bp->ar2r_max_pipe, amp);
++
++	gem_writel(bp, AMP, amp);
++}
++
++static void gem_init_intmod(struct macb *bp)
++{
++	unsigned int throttle;
++	u32 intmod = 0;
++
++	/* Use sensible interrupt moderation thresholds (50us rx and tx) */
++	throttle = (1000 * 50) / 800;
++	intmod = GEM_BFINS(TX_MODERATION, throttle, intmod);
++	intmod = GEM_BFINS(RX_MODERATION, throttle, intmod);
++	gem_writel(bp, INTMOD, intmod);
++}
++
+ static void macb_init_hw(struct macb *bp)
+ {
+ 	u32 config;
+@@ -2727,6 +2786,11 @@ static void macb_init_hw(struct macb *bp
+ 	if (bp->caps & MACB_CAPS_JUMBO)
+ 		bp->rx_frm_len_mask = MACB_RX_JFRMLEN_MASK;
+ 
++	if (macb_is_gem(bp)) {
++		gem_init_axi(bp);
++		gem_init_intmod(bp);
++	}
++
+ 	macb_configure_dma(bp);
+ }
+ 
+@@ -3072,6 +3136,52 @@ static void gem_get_ethtool_strings(stru
+ 	}
+ }
+ 
++static int gem_set_coalesce(struct net_device *dev,
++			    struct ethtool_coalesce *ec,
++			    struct kernel_ethtool_coalesce *kernel_coal,
++			    struct netlink_ext_ack *extack)
++{
++	struct macb *bp = netdev_priv(dev);
++	unsigned int tx_throttle;
++	unsigned int rx_throttle;
++	u32 intmod = 0;
++
++	/* GEM has simple IRQ throttling support. RX and TX interrupts
++	 * are separately moderated on 800ns quantums, with no support
++	 * for frame coalescing.
++	 */
++
++	/* Max is 255 * 0.8us = 204us. Zero implies no moderation. */
++	if (ec->rx_coalesce_usecs > 204 || ec->tx_coalesce_usecs > 204)
++		return -EINVAL;
++
++	tx_throttle = (1000 * ec->tx_coalesce_usecs) / 800;
++	rx_throttle = (1000 * ec->rx_coalesce_usecs) / 800;
++
++	intmod = GEM_BFINS(TX_MODERATION, tx_throttle, intmod);
++	intmod = GEM_BFINS(RX_MODERATION, rx_throttle, intmod);
++
++	gem_writel(bp, INTMOD, intmod);
++
++	return 0;
++}
++
++static int gem_get_coalesce(struct net_device *dev,
++			    struct ethtool_coalesce *ec,
++			    struct kernel_ethtool_coalesce *kernel_coal,
++			    struct netlink_ext_ack *extack)
++{
++	struct macb *bp = netdev_priv(dev);
++	u32 intmod;
++
++	intmod = gem_readl(bp, INTMOD);
++
++	ec->tx_coalesce_usecs = (GEM_BFEXT(TX_MODERATION, intmod) * 800) / 1000;
++	ec->rx_coalesce_usecs = (GEM_BFEXT(RX_MODERATION, intmod) * 800) / 1000;
++
++	return 0;
++}
++
+ static struct net_device_stats *macb_get_stats(struct net_device *dev)
+ {
+ 	struct macb *bp = netdev_priv(dev);
+@@ -3664,6 +3774,8 @@ static const struct ethtool_ops macb_eth
+ };
+ 
+ static const struct ethtool_ops gem_ethtool_ops = {
++	.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |
++				     ETHTOOL_COALESCE_TX_USECS,
+ 	.get_regs_len		= macb_get_regs_len,
+ 	.get_regs		= macb_get_regs,
+ 	.get_wol		= macb_get_wol,
+@@ -3673,6 +3785,8 @@ static const struct ethtool_ops gem_etht
+ 	.get_ethtool_stats	= gem_get_ethtool_stats,
+ 	.get_strings		= gem_get_ethtool_strings,
+ 	.get_sset_count		= gem_get_sset_count,
++	.get_coalesce		= gem_get_coalesce,
++	.set_coalesce		= gem_set_coalesce,
+ 	.get_link_ksettings     = macb_get_link_ksettings,
+ 	.set_link_ksettings     = macb_set_link_ksettings,
+ 	.get_ringparam		= macb_get_ringparam,
+@@ -4940,6 +5054,10 @@ static int macb_probe(struct platform_de
+ 
+ 	bp->usrio = macb_config->usrio;
+ 
++	device_property_read_u8(&pdev->dev, "cdns,aw2w-max-pipe", &bp->aw2w_max_pipe);
++	device_property_read_u8(&pdev->dev, "cdns,ar2r-max-pipe", &bp->ar2r_max_pipe);
++	bp->use_aw2b_fill = device_property_read_bool(&pdev->dev, "cdns,use-aw2b-fill");
++
+ 	spin_lock_init(&bp->lock);
+ 
+ 	/* setup capabilities */
+@@ -4995,6 +5113,21 @@ static int macb_probe(struct platform_de
+ 	else
+ 		bp->phy_interface = interface;
+ 
++	/* optional PHY reset-related properties */
++	bp->phy_reset_gpio = devm_gpiod_get_optional(&pdev->dev, "phy-reset",
++						     GPIOD_OUT_LOW);
++	if (IS_ERR(bp->phy_reset_gpio)) {
++		dev_err(&pdev->dev, "Failed to obtain phy-reset gpio\n");
++		err = PTR_ERR(bp->phy_reset_gpio);
++		goto err_out_free_netdev;
++	}
++
++	bp->phy_reset_ms = 10;
++	of_property_read_u32(np, "phy-reset-duration", &bp->phy_reset_ms);
++	/* A sane reset duration should not be longer than 1s */
++	if (bp->phy_reset_ms > 1000)
++		bp->phy_reset_ms = 1000;
++
+ 	/* IP specific init */
+ 	err = init(pdev);
+ 	if (err)
+@@ -5071,6 +5204,19 @@ static int macb_remove(struct platform_d
+ 	return 0;
+ }
+ 
++static void macb_shutdown(struct platform_device *pdev)
++{
++	struct net_device *dev;
++
++	dev = platform_get_drvdata(pdev);
++
++	rtnl_lock();
++	netif_device_detach(dev);
++	if (netif_running(dev))
++		dev_close(dev);
++	rtnl_unlock();
++}
++
+ static int __maybe_unused macb_suspend(struct device *dev)
+ {
+ 	struct net_device *netdev = dev_get_drvdata(dev);
+@@ -5285,6 +5431,7 @@ static const struct dev_pm_ops macb_pm_o
+ static struct platform_driver macb_driver = {
+ 	.probe		= macb_probe,
+ 	.remove		= macb_remove,
++	.shutdown	= macb_shutdown,
+ 	.driver		= {
+ 		.name		= "macb",
+ 		.of_match_table	= of_match_ptr(macb_dt_ids),
diff --git a/target/linux/bcm27xx/patches-6.1/950-0865-usb-dwc3-Set-DMA-and-coherent-masks-early.patch b/target/linux/bcm27xx/patches-6.1/950-0865-usb-dwc3-Set-DMA-and-coherent-masks-early.patch
new file mode 100644
index 0000000000..f6944e226f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0865-usb-dwc3-Set-DMA-and-coherent-masks-early.patch
@@ -0,0 +1,384 @@
+From 4ffa5f2c5fc7854683964bb2f2bf23907c18213f Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Mon, 13 Sep 2021 11:14:32 +0100
+Subject: [PATCH] usb: dwc3: Set DMA and coherent masks early
+
+dwc3 allocates scratch and event buffers in the top-level driver. Hack the
+probe function to set the DMA mask before trying to allocate these.
+
+I think the event buffers are only used in device mode, but the scratch
+buffers may be used if core hibernation is enabled.
+
+usb: dwc3: add support for new DT quirks
+
+Apply the optional axi-pipe-limit and dis-in-autoretry-quirk properties
+during driver probe.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+phy: phy-brcm-usb: Add 2712 support
+
+usb: dwc3: if the host controller instance number is present in DT, use it
+
+If two instances of a dwc3 host controller are specified in devicetree,
+then the probe order may be arbitrary which results in the device names
+swapping on a per-boot basis.
+
+If a "usb" alias with the instance number is specified, then use
+that to construct the device name instead of autogenerating one.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+rp1 dwc3 changes
+
+drivers: usb: dwc3: allow setting GTXTHRCFG on dwc_usb3.0 hardware
+
+Equivalent register fields exist in the SuperSpeed Host version of the
+hardware, so allow the use of TX thresholds if specified in devicetree.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+drivers: usb: dwc3: remove downstream quirk dis-in-autoretry
+
+Upstream have unilaterally disabled the feature.
+
+Partially reverts 6e9142a26ee0fdc3a5adc49ed6cedc0b16ec2ed1 (downstream)
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/phy/broadcom/Kconfig                  |  2 +-
+ .../phy/broadcom/phy-brcm-usb-init-synopsys.c | 59 +++++++++++++++++++
+ drivers/phy/broadcom/phy-brcm-usb-init.h      |  2 +
+ drivers/phy/broadcom/phy-brcm-usb.c           | 18 +++++-
+ drivers/usb/dwc3/core.c                       | 52 ++++++++++++++++
+ drivers/usb/dwc3/core.h                       | 10 ++++
+ drivers/usb/dwc3/host.c                       | 17 ++++--
+ 7 files changed, 153 insertions(+), 7 deletions(-)
+
+--- a/drivers/phy/broadcom/Kconfig
++++ b/drivers/phy/broadcom/Kconfig
+@@ -93,7 +93,7 @@ config PHY_BRCM_SATA
+ 
+ config PHY_BRCM_USB
+ 	tristate "Broadcom STB USB PHY driver"
+-	depends on ARCH_BCMBCA || ARCH_BRCMSTB || COMPILE_TEST
++	depends on ARCH_BCMBCA || ARCH_BRCMSTB || ARCH_BCM2835 || COMPILE_TEST
+ 	depends on OF
+ 	select GENERIC_PHY
+ 	select SOC_BRCMSTB if ARCH_BRCMSTB
+--- a/drivers/phy/broadcom/phy-brcm-usb-init-synopsys.c
++++ b/drivers/phy/broadcom/phy-brcm-usb-init-synopsys.c
+@@ -318,6 +318,36 @@ static void usb_init_common_7216(struct
+ 	usb_init_common(params);
+ }
+ 
++static void usb_init_common_2712(struct brcm_usb_init_params *params)
++{
++	void __iomem *ctrl = params->regs[BRCM_REGS_CTRL];
++	void __iomem *bdc_ec = params->regs[BRCM_REGS_BDC_EC];
++	u32 reg;
++
++	if (params->syscon_piarbctl)
++		syscon_piarbctl_init(params->syscon_piarbctl);
++
++	USB_CTRL_UNSET(ctrl, USB_PM, USB_PWRDN);
++
++	usb_wake_enable_7211b0(params, false);
++
++	usb_init_common(params);
++
++	/*
++	 * The BDC controller will get occasional failures with
++	 * the default "Read Transaction Size" of 6 (1024 bytes).
++	 * Set it to 4 (256 bytes).
++	 */
++	if ((params->mode != USB_CTLR_MODE_HOST) && bdc_ec) {
++		reg = brcm_usb_readl(bdc_ec + BDC_EC_AXIRDA);
++		reg &= ~BDC_EC_AXIRDA_RTS_MASK;
++		reg |= (0x4 << BDC_EC_AXIRDA_RTS_SHIFT);
++		brcm_usb_writel(reg, bdc_ec + BDC_EC_AXIRDA);
++	}
++
++	usb2_eye_fix_7211b0(params);
++}
++
+ static void usb_init_xhci(struct brcm_usb_init_params *params)
+ {
+ 	pr_debug("%s\n", __func__);
+@@ -363,6 +393,18 @@ static void usb_uninit_common_7211b0(str
+ 
+ }
+ 
++static void usb_uninit_common_2712(struct brcm_usb_init_params *params)
++{
++	void __iomem *ctrl = params->regs[BRCM_REGS_CTRL];
++
++	if (params->wake_enabled) {
++		USB_CTRL_SET(ctrl, TEST_PORT_CTL, TPOUT_SEL_PME_GEN);
++		usb_wake_enable_7211b0(params, true);
++	} else {
++		USB_CTRL_SET(ctrl, USB_PM, USB_PWRDN);
++	}
++}
++
+ static void usb_uninit_xhci(struct brcm_usb_init_params *params)
+ {
+ 
+@@ -417,6 +459,16 @@ static const struct brcm_usb_init_ops bc
+ 	.set_dual_select = usb_set_dual_select,
+ };
+ 
++static const struct brcm_usb_init_ops bcm2712_ops = {
++	.init_ipp = usb_init_ipp,
++	.init_common = usb_init_common_2712,
++	.init_xhci = usb_init_xhci,
++	.uninit_common = usb_uninit_common_2712,
++	.uninit_xhci = usb_uninit_xhci,
++	.get_dual_select = usb_get_dual_select,
++	.set_dual_select = usb_set_dual_select,
++};
++
+ void brcm_usb_dvr_init_7216(struct brcm_usb_init_params *params)
+ {
+ 
+@@ -434,3 +486,10 @@ void brcm_usb_dvr_init_7211b0(struct brc
+ 	params->family_name = "7211";
+ 	params->ops = &bcm7211b0_ops;
+ }
++
++void brcm_usb_dvr_init_2712(struct brcm_usb_init_params *params)
++{
++	params->family_name = "2712";
++	params->ops = &bcm2712_ops;
++	params->suspend_with_clocks = true;
++}
+--- a/drivers/phy/broadcom/phy-brcm-usb-init.h
++++ b/drivers/phy/broadcom/phy-brcm-usb-init.h
+@@ -61,12 +61,14 @@ struct  brcm_usb_init_params {
+ 	const struct brcm_usb_init_ops *ops;
+ 	struct regmap *syscon_piarbctl;
+ 	bool wake_enabled;
++	bool suspend_with_clocks;
+ };
+ 
+ void brcm_usb_dvr_init_4908(struct brcm_usb_init_params *params);
+ void brcm_usb_dvr_init_7445(struct brcm_usb_init_params *params);
+ void brcm_usb_dvr_init_7216(struct brcm_usb_init_params *params);
+ void brcm_usb_dvr_init_7211b0(struct brcm_usb_init_params *params);
++void brcm_usb_dvr_init_2712(struct brcm_usb_init_params *params);
+ 
+ static inline u32 brcm_usb_readl(void __iomem *addr)
+ {
+--- a/drivers/phy/broadcom/phy-brcm-usb.c
++++ b/drivers/phy/broadcom/phy-brcm-usb.c
+@@ -76,7 +76,7 @@ struct brcm_usb_phy_data {
+ };
+ 
+ static s8 *node_reg_names[BRCM_REGS_MAX] = {
+-	"crtl", "xhci_ec", "xhci_gbl", "usb_phy", "usb_mdio", "bdc_ec"
++	"ctrl", "xhci_ec", "xhci_gbl", "usb_phy", "usb_mdio", "bdc_ec"
+ };
+ 
+ static int brcm_pm_notifier(struct notifier_block *notifier,
+@@ -315,6 +315,18 @@ static const struct match_chip_info chip
+ 	.optional_reg = BRCM_REGS_BDC_EC,
+ };
+ 
++static const struct match_chip_info chip_info_2712 = {
++	.init_func = &brcm_usb_dvr_init_2712,
++	.required_regs = {
++		BRCM_REGS_CTRL,
++		BRCM_REGS_XHCI_EC,
++		BRCM_REGS_XHCI_GBL,
++		BRCM_REGS_USB_MDIO,
++		-1,
++	},
++	.optional_reg = BRCM_REGS_BDC_EC,
++};
++
+ static const struct match_chip_info chip_info_7445 = {
+ 	.init_func = &brcm_usb_dvr_init_7445,
+ 	.required_regs = {
+@@ -338,6 +350,10 @@ static const struct of_device_id brcm_us
+ 		.data = &chip_info_7211b0,
+ 	},
+ 	{
++		.compatible = "brcm,bcm2712-usb-phy",
++		.data = &chip_info_2712,
++	},
++	{
+ 		.compatible = "brcm,brcmstb-usb-phy",
+ 		.data = &chip_info_7445,
+ 	},
+--- a/drivers/usb/dwc3/core.c
++++ b/drivers/usb/dwc3/core.c
+@@ -1216,6 +1216,24 @@ static void dwc3_config_threshold(struct
+ 	}
+ }
+ 
++static void dwc3_set_axi_pipe_limit(struct dwc3 *dwc)
++{
++	struct device *dev = dwc->dev;
++	u32 cfg;
++
++	if (!dwc->axi_pipe_limit)
++		return;
++	if (dwc->axi_pipe_limit > 16) {
++		dev_err(dev, "Invalid axi_pipe_limit property\n");
++		return;
++	}
++	cfg = dwc3_readl(dwc->regs, DWC3_GSBUSCFG1);
++	cfg &= ~DWC3_GSBUSCFG1_PIPETRANSLIMIT(15);
++	cfg |= DWC3_GSBUSCFG1_PIPETRANSLIMIT(dwc->axi_pipe_limit - 1);
++
++	dwc3_writel(dwc->regs, DWC3_GSBUSCFG1, cfg);
++}
++
+ /**
+  * dwc3_core_init - Low-level initialization of DWC3 Core
+  * @dwc: Pointer to our controller context structure
+@@ -1308,6 +1326,8 @@ static int dwc3_core_init(struct dwc3 *d
+ 
+ 	dwc3_set_incr_burst_type(dwc);
+ 
++	dwc3_set_axi_pipe_limit(dwc);
++
+ 	usb_phy_set_suspend(dwc->usb2_phy, 0);
+ 	usb_phy_set_suspend(dwc->usb3_phy, 0);
+ 	ret = phy_power_on(dwc->usb2_generic_phy);
+@@ -1541,6 +1561,7 @@ static void dwc3_get_properties(struct d
+ 	u8			tx_thr_num_pkt_prd = 0;
+ 	u8			tx_max_burst_prd = 0;
+ 	u8			tx_fifo_resize_max_num;
++	u8			axi_pipe_limit;
+ 	const char		*usb_psy_name;
+ 	int			ret;
+ 
+@@ -1563,6 +1584,9 @@ static void dwc3_get_properties(struct d
+ 	 */
+ 	tx_fifo_resize_max_num = 6;
+ 
++	/* Default to 0 (don't override hardware defaults) */
++	axi_pipe_limit = 0;
++
+ 	dwc->maximum_speed = usb_get_maximum_speed(dev);
+ 	dwc->max_ssp_rate = usb_get_maximum_ssp_rate(dev);
+ 	dwc->dr_mode = usb_get_dr_mode(dev);
+@@ -1678,6 +1702,9 @@ static void dwc3_get_properties(struct d
+ 	dwc->dis_split_quirk = device_property_read_bool(dev,
+ 				"snps,dis-split-quirk");
+ 
++	device_property_read_u8(dev, "snps,axi-pipe-limit",
++				   &axi_pipe_limit);
++
+ 	dwc->lpm_nyet_threshold = lpm_nyet_threshold;
+ 	dwc->tx_de_emphasis = tx_de_emphasis;
+ 
+@@ -1695,6 +1722,8 @@ static void dwc3_get_properties(struct d
+ 	dwc->tx_thr_num_pkt_prd = tx_thr_num_pkt_prd;
+ 	dwc->tx_max_burst_prd = tx_max_burst_prd;
+ 
++	dwc->axi_pipe_limit = axi_pipe_limit;
++
+ 	dwc->imod_interval = 0;
+ 
+ 	dwc->tx_fifo_resize_max_num = tx_fifo_resize_max_num;
+@@ -1903,6 +1932,12 @@ static int dwc3_probe(struct platform_de
+ 
+ 	dwc3_get_properties(dwc);
+ 
++	if (!dwc->sysdev_is_parent) {
++		ret = dma_set_mask_and_coherent(dwc->sysdev, DMA_BIT_MASK(64));
++		if (ret)
++			return ret;
++	}
++
+ 	dwc->reset = devm_reset_control_array_get_optional_shared(dev);
+ 	if (IS_ERR(dwc->reset)) {
+ 		ret = PTR_ERR(dwc->reset);
+--- a/drivers/usb/dwc3/core.h
++++ b/drivers/usb/dwc3/core.h
+@@ -183,6 +183,9 @@
+ #define DWC3_GSBUSCFG0_INCRBRSTENA	(1 << 0) /* undefined length enable */
+ #define DWC3_GSBUSCFG0_INCRBRST_MASK	0xff
+ 
++/* Global SoC Bus Configuration Register 1 */
++#define DWC3_GSBUSCFG1_PIPETRANSLIMIT(n)	(((n) & 0xf) << 8)
++
+ /* Global Debug LSP MUX Select */
+ #define DWC3_GDBGLSPMUX_ENDBC		BIT(15)	/* Host only */
+ #define DWC3_GDBGLSPMUX_HOSTSELECT(n)	((n) & 0x3fff)
+@@ -1056,6 +1059,7 @@ struct dwc3_scratchpad_array {
+  * @tx_max_burst_prd: max periodic ESS transmit burst size
+  * @tx_fifo_resize_max_num: max number of fifos allocated during txfifo resize
+  * @clear_stall_protocol: endpoint number that requires a delayed status phase
++ * @axi_max_pipe: set to override the maximum number of pipelined AXI transfers
+  * @hsphy_interface: "utmi" or "ulpi"
+  * @connected: true when we're connected to a host, false otherwise
+  * @softconnect: true when gadget connect is called, false when disconnect runs
+@@ -1287,6 +1291,7 @@ struct dwc3 {
+ 	u8			tx_max_burst_prd;
+ 	u8			tx_fifo_resize_max_num;
+ 	u8			clear_stall_protocol;
++	u8			axi_pipe_limit;
+ 
+ 	const char		*hsphy_interface;
+ 
+--- a/drivers/usb/dwc3/host.c
++++ b/drivers/usb/dwc3/host.c
+@@ -30,10 +30,10 @@ static void dwc3_host_fill_xhci_irq_res(
+ 
+ static int dwc3_host_get_irq(struct dwc3 *dwc)
+ {
+-	struct platform_device	*dwc3_pdev = to_platform_device(dwc->dev);
++	struct platform_device	*pdev = to_platform_device(dwc->dev);
+ 	int irq;
+ 
+-	irq = platform_get_irq_byname_optional(dwc3_pdev, "host");
++	irq = platform_get_irq_byname_optional(pdev, "host");
+ 	if (irq > 0) {
+ 		dwc3_host_fill_xhci_irq_res(dwc, irq, "host");
+ 		goto out;
+@@ -42,7 +42,7 @@ static int dwc3_host_get_irq(struct dwc3
+ 	if (irq == -EPROBE_DEFER)
+ 		goto out;
+ 
+-	irq = platform_get_irq_byname_optional(dwc3_pdev, "dwc_usb3");
++	irq = platform_get_irq_byname_optional(pdev, "dwc_usb3");
+ 	if (irq > 0) {
+ 		dwc3_host_fill_xhci_irq_res(dwc, irq, "dwc_usb3");
+ 		goto out;
+@@ -51,7 +51,7 @@ static int dwc3_host_get_irq(struct dwc3
+ 	if (irq == -EPROBE_DEFER)
+ 		goto out;
+ 
+-	irq = platform_get_irq(dwc3_pdev, 0);
++	irq = platform_get_irq(pdev, 0);
+ 	if (irq > 0) {
+ 		dwc3_host_fill_xhci_irq_res(dwc, irq, NULL);
+ 		goto out;
+@@ -66,16 +66,23 @@ out:
+ 
+ int dwc3_host_init(struct dwc3 *dwc)
+ {
++	struct platform_device	*pdev = to_platform_device(dwc->dev);
+ 	struct property_entry	props[4];
+ 	struct platform_device	*xhci;
+ 	int			ret, irq;
+ 	int			prop_idx = 0;
++	int			id;
+ 
+ 	irq = dwc3_host_get_irq(dwc);
+ 	if (irq < 0)
+ 		return irq;
+ 
+-	xhci = platform_device_alloc("xhci-hcd", PLATFORM_DEVID_AUTO);
++	id = of_alias_get_id(pdev->dev.of_node, "usb");
++	if (id >= 0)
++		xhci = platform_device_alloc("xhci-hcd", id);
++	else
++		xhci = platform_device_alloc("xhci-hcd", PLATFORM_DEVID_AUTO);
++
+ 	if (!xhci) {
+ 		dev_err(dwc->dev, "couldn't allocate xHCI device\n");
+ 		return -ENOMEM;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0866-drm-panel-raspberrypi-touchscreen-Insert-more-delays.patch b/target/linux/bcm27xx/patches-6.1/950-0866-drm-panel-raspberrypi-touchscreen-Insert-more-delays.patch
new file mode 100644
index 0000000000..a6f0c1961c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0866-drm-panel-raspberrypi-touchscreen-Insert-more-delays.patch
@@ -0,0 +1,37 @@
+From 480c8e9f48f8a96c457eb3dc0079a73598fb7477 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.org>
+Date: Wed, 1 Dec 2021 19:43:08 +0000
+Subject: [PATCH] drm/panel/raspberrypi-touchscreen: Insert more delays.
+
+This avoids failures in cases where the panel is enabled
+or re-probed very soon after being disabled or probed.
+These can occur because the Atmel device can mis-behave
+over I2C for a few ms after any write to the POWERON register.
+---
+ drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
++++ b/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
+@@ -299,6 +299,13 @@ static int rpi_touchscreen_prepare(struc
+ 	struct rpi_touchscreen *ts = panel_to_ts(panel);
+ 	int i, data;
+ 
++	/*
++	 * Power up the Toshiba bridge. The Atmel device can misbehave
++	 * over I2C for a few ms after writes to REG_POWERON (including the
++	 * write in rpi_touchscreen_disable()), so sleep before and after.
++	 * Also to ensure that the bridge has been off for at least 100ms.
++	 */
++	msleep(100);
+ 	rpi_touchscreen_i2c_write(ts, REG_POWERON, 1);
+ 	usleep_range(20000, 25000);
+ 	/* Wait for nPWRDWN to go low to indicate poweron is done. */
+@@ -431,6 +438,7 @@ static int rpi_touchscreen_probe(struct
+ 
+ 	/* Turn off at boot, so we can cleanly sequence powering on. */
+ 	rpi_touchscreen_i2c_write(ts, REG_POWERON, 0);
++	usleep_range(20000, 25000);
+ 
+ 	/* Look up the DSI host.  It needs to probe before we do. */
+ 	endpoint = of_graph_get_next_endpoint(dev->of_node, NULL);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0867-PCI-brcmstb-Add-BCM2712-support.patch b/target/linux/bcm27xx/patches-6.1/950-0867-PCI-brcmstb-Add-BCM2712-support.patch
new file mode 100644
index 0000000000..179d03733e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0867-PCI-brcmstb-Add-BCM2712-support.patch
@@ -0,0 +1,1108 @@
+From 29702857d1ab71243ea6c247dfe9b5bc43dd422f Mon Sep 17 00:00:00 2001
+From: Jim Quinlan <james.quinlan@broadcom.com>
+Date: Fri, 23 Jun 2023 10:40:57 -0400
+Subject: [PATCH] PCI: brcmstb: Add BCM2712 support
+
+PCI: brcmstb: differing register offsets on 2712
+
+pcie-brcmstb: Add 2712 bridge reset support
+
+pcie: 2712 PORT_MASK and rescal support
+
+pcie-brcmstb: don't alter the L1SS debug register
+
+For reasons unknown, this disables the reference clock
+
+pcie-brcmstb: fix BAR2 enable and window decode
+
+Set UBUS ACCESS_EN to let inbound DMA work. Also BCM2712 has grown
+an index in the inbound window size decode register.
+
+PCIe: brcmstb: Enable support for 64 MSI-Xs
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+pcie-brcmstb: Suppress read error responses
+
+If the link is down or the EP fails to return a read completion, the
+RC's default behaviour is to return an AXI error. This causes fatal
+exceptions on A76, so it's better to respond with all 1s instead.
+
+pcie-brcmstb: increase UBUS timeout to cater for link retrain events
+
+pcie-brcmstb: Handle additional inbound regions
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+pcie-brcmstb: Add support for external MSI controller
+
+pcie-brcmstb: add a reasonable default traffic class to priority map
+
+BCM2712 supports multiple traffic classes (TCs) with independent
+maximally sized transfer queues for each TC. Traffic classes have no
+transaction ordering requirements between them, which facilitates
+out-of-order completions and arbitration between posted writes for
+data streams that have no dependence on each other.
+
+In addition to the above benefits of splitting endpoint traffic into
+individual queues, priorities can be assigned to traffic classes by
+a heuristic or deterministic mechanism. The heuristic elevates AXI
+QOS priority in accordance with the number of pending transfers in
+each TC's queue, but for true priority signalling a forwarding
+mechanism using vendor-defined messages is implemented.
+
+Receipt of a 3 DWORD VDM assigns a priority tag to a TC on-the-fly,
+and this tag corresponds to a configurable AXI QOS value.
+
+As a simple baseline, assign a linear map of AXI QOS to each tag.
+
+pcie: brcmstb: set up the VDM forwarding interface when setting up QoS
+
+pcie-brcmstb: add DT bindings for MPS-size Read Completion Mode
+
+This controller has an optional feature that allows read completion
+TLPs to be sized up to the Maximum Packet Size of a configured link.
+
+This can exceed the Read Completion Boundary of 128B specified in
+the PCIe specification, but depending on endpoint support may increase
+link read bandwidth significantly.
+
+pcie-brcmstb: clean up debug messages
+
+pcie-brcmstb: fix BCM2712A0 PHY PM errata
+
+The power management clock is 54MHz not 50MHz, so adjust the PM clock period
+to suit. Powering off the PHY PLL in L1.2 is unsafe, so force it on.
+
+pcie-brcmstb: set CLKREQ functionality according to link partner support
+
+The RC supports either L1 with clock PM or L1 sub-state control, not both
+at the same time. Examine the link partner's capabilities to determine
+which is the most suitable scheme to use.
+
+pcie: brcmstb: don't reset block bridges in suspend or removal cases
+
+BCM2712 has a single rescal block for all three root complexes, and
+holding PCIE1's bridge in reset will hang the chip if a different
+RC wants to access any of the rescal registers.
+
+pcie: brcmstb: guard 2712-specific setup with a RC type check
+
+BCM2711 doesn't implement the UBUS control registers.
+
+pcie: brcmstb: On 2712 keeping the PLL powered in L1.x is not required
+
+A separate misconfiguration when enabling SSC (the MDIO registers no
+longer do the same thing on BCM2712) had the side-effect of breaking
+PLL powerdown and resume sequencing.
+
+Allow entry into a true L1.2 state where analogue is depowered.
+
+pcie: brcmstb: Fix reset warning on probe failure
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+bcm2712: pcie: adjust PHY PLL setup to use a 54MHz input refclk
+
+Use canned MDIO writes from Broadcom that switch the ref_clk output
+pair to run from the internal fractional PLL, and set the internal PLL
+to expect a 54MHz input reference clock.
+
+Gen3 operation is not guaranteed to be stable in this setup, so default
+to gen2.
+
+This only works if the LCPLL is bypassed (requires latest bootloader).
+
+pcie: brcmstb: add missing register writes
+
+drivers: pcie: brcmstb: cater for BCM2712C0 bug dropping QoS on the floor
+
+The AXI QoS value extracted from the request fifo ends up as zero forever.
+Disabling this means that "panic" signalling doesn't do anything useful,
+but static priorites do work.
+
+Also align the selected TC:QoS map with RP1's expectations of service.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+drivers: pcie: brcmstb: shuffle TC priorities up to 8
+
+Use the range 8-11 which puts the highest below HVS but leaves space
+below for other 2712 masters.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+drivers: pcie: brcmstb: optionally enable QoS features by DT for BCM2712
+
+It's a bad idea to universally enable "realtime" priorities for TCs
+across all the RC instances on the chip. Endpoints other than RP1 may
+make use of these, so you don't want e.g. NVMe descriptor fetches getting
+higher priority than your remote display.
+
+Add two optional DT properties controlling the behaviour - FIFO-based
+backpressure QoS or "message-based". Message-based signalling is
+fundamentally broken due to a chip bug, so it collapses into a set of
+static assignments that RP1 needs.
+
+The default if neither property is specified is to assign everything a
+QoS of 0.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+
+drivers: pcie: brcmstb: adjust completion timeouts for bcm2712
+
+Setting the RC config retry timeout makes CRS auto-polling work, but
+the UBUS timeout will override the config retry. Both need to be large.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/pci/controller/pcie-brcmstb.c | 507 +++++++++++++++++++++++---
+ 1 file changed, 458 insertions(+), 49 deletions(-)
+
+--- a/drivers/pci/controller/pcie-brcmstb.c
++++ b/drivers/pci/controller/pcie-brcmstb.c
+@@ -13,6 +13,7 @@
+ #include <linux/irqchip/chained_irq.h>
+ #include <linux/irqdomain.h>
+ #include <linux/kernel.h>
++#include <linux/kthread.h>
+ #include <linux/list.h>
+ #include <linux/log2.h>
+ #include <linux/module.h>
+@@ -47,11 +48,25 @@
+ #define PCIE_RC_CFG_PRIV1_LINK_CAPABILITY			0x04dc
+ #define  PCIE_RC_CFG_PRIV1_LINK_CAPABILITY_ASPM_SUPPORT_MASK	0xc00
+ 
++#define PCIE_RC_TL_VDM_CTL0				0x0a20
++#define  PCIE_RC_TL_VDM_CTL0_VDM_ENABLED_MASK		0x10000
++#define  PCIE_RC_TL_VDM_CTL0_VDM_IGNORETAG_MASK		0x20000
++#define  PCIE_RC_TL_VDM_CTL0_VDM_IGNOREVNDRID_MASK	0x40000
++
++#define PCIE_RC_TL_VDM_CTL1				0x0a0c
++#define  PCIE_RC_TL_VDM_CTL1_VDM_VNDRID0_MASK		0x0000ffff
++#define  PCIE_RC_TL_VDM_CTL1_VDM_VNDRID1_MASK		0xffff0000
++
+ #define PCIE_RC_DL_MDIO_ADDR				0x1100
+ #define PCIE_RC_DL_MDIO_WR_DATA				0x1104
+ #define PCIE_RC_DL_MDIO_RD_DATA				0x1108
+ 
++#define PCIE_RC_PL_PHY_CTL_15				0x184c
++#define  PCIE_RC_PL_PHY_CTL_15_DIS_PLL_PD_MASK		0x400000
++#define  PCIE_RC_PL_PHY_CTL_15_PM_CLK_PERIOD_MASK	0xff
++
+ #define PCIE_MISC_MISC_CTRL				0x4008
++#define  PCIE_MISC_MISC_CTRL_RCB_MPS_MODE_MASK		0x400
+ #define  PCIE_MISC_MISC_CTRL_SCB_ACCESS_EN_MASK		0x1000
+ #define  PCIE_MISC_MISC_CTRL_CFG_READ_UR_MODE_MASK	0x2000
+ #define  PCIE_MISC_MISC_CTRL_MAX_BURST_SIZE_MASK	0x300000
+@@ -71,6 +86,7 @@
+ 
+ #define PCIE_MISC_RC_BAR1_CONFIG_LO			0x402c
+ #define  PCIE_MISC_RC_BAR1_CONFIG_LO_SIZE_MASK		0x1f
++#define PCIE_MISC_RC_BAR1_CONFIG_HI			0x4030
+ 
+ #define PCIE_MISC_RC_BAR2_CONFIG_LO			0x4034
+ #define  PCIE_MISC_RC_BAR2_CONFIG_LO_SIZE_MASK		0x1f
+@@ -78,6 +94,7 @@
+ 
+ #define PCIE_MISC_RC_BAR3_CONFIG_LO			0x403c
+ #define  PCIE_MISC_RC_BAR3_CONFIG_LO_SIZE_MASK		0x1f
++#define PCIE_MISC_RC_BAR3_CONFIG_HI			0x4040
+ 
+ #define PCIE_MISC_MSI_BAR_CONFIG_LO			0x4044
+ #define PCIE_MISC_MSI_BAR_CONFIG_HI			0x4048
+@@ -86,12 +103,15 @@
+ #define  PCIE_MISC_MSI_DATA_CONFIG_VAL_32		0xffe06540
+ #define  PCIE_MISC_MSI_DATA_CONFIG_VAL_8		0xfff86540
+ 
++#define PCIE_MISC_RC_CONFIG_RETRY_TIMEOUT		0x405c
++
+ #define PCIE_MISC_PCIE_CTRL				0x4064
+ #define  PCIE_MISC_PCIE_CTRL_PCIE_L23_REQUEST_MASK	0x1
+ #define PCIE_MISC_PCIE_CTRL_PCIE_PERSTB_MASK		0x4
+ 
+ #define PCIE_MISC_PCIE_STATUS				0x4068
+ #define  PCIE_MISC_PCIE_STATUS_PCIE_PORT_MASK		0x80
++#define  PCIE_MISC_PCIE_STATUS_PCIE_PORT_MASK_2712	0x40
+ #define  PCIE_MISC_PCIE_STATUS_PCIE_DL_ACTIVE_MASK	0x20
+ #define  PCIE_MISC_PCIE_STATUS_PCIE_PHYLINKUP_MASK	0x10
+ #define  PCIE_MISC_PCIE_STATUS_PCIE_LINK_IN_L23_MASK	0x40
+@@ -116,14 +136,73 @@
+ #define PCIE_MEM_WIN0_LIMIT_HI(win)	\
+ 		PCIE_MISC_CPU_2_PCIE_MEM_WIN0_LIMIT_HI + ((win) * 8)
+ 
+-#define PCIE_MISC_HARD_PCIE_HARD_DEBUG					0x4204
++#define PCIE_MISC_HARD_PCIE_HARD_DEBUG	pcie->reg_offsets[PCIE_HARD_DEBUG]
+ #define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_DEBUG_ENABLE_MASK	0x2
+ #define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK		0x08000000
+ #define  PCIE_BMIPS_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK		0x00800000
+ #define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_L1SS_ENABLE_MASK		0x00200000
+ 
++#define PCIE_MISC_CTRL_1					0x40A0
++#define  PCIE_MISC_CTRL_1_OUTBOUND_TC_MASK			0xf
++#define  PCIE_MISC_CTRL_1_OUTBOUND_NO_SNOOP_MASK		BIT(3)
++#define  PCIE_MISC_CTRL_1_OUTBOUND_RO_MASK			BIT(4)
++#define  PCIE_MISC_CTRL_1_EN_VDM_QOS_CONTROL_MASK		BIT(5)
++
++#define PCIE_MISC_UBUS_CTRL	0x40a4
++#define  PCIE_MISC_UBUS_CTRL_UBUS_PCIE_REPLY_ERR_DIS_MASK	BIT(13)
++#define  PCIE_MISC_UBUS_CTRL_UBUS_PCIE_REPLY_DECERR_DIS_MASK	BIT(19)
++
++#define PCIE_MISC_UBUS_TIMEOUT	0x40A8
++
++#define PCIE_MISC_UBUS_BAR1_CONFIG_REMAP	0x40ac
++#define  PCIE_MISC_UBUS_BAR1_CONFIG_REMAP_ACCESS_ENABLE_MASK	BIT(0)
++#define PCIE_MISC_UBUS_BAR1_CONFIG_REMAP_HI	0x40b0
++
++#define PCIE_MISC_UBUS_BAR2_CONFIG_REMAP	0x40b4
++#define  PCIE_MISC_UBUS_BAR2_CONFIG_REMAP_ACCESS_ENABLE_MASK	BIT(0)
++
++/* Additional RC BARs */
++#define  PCIE_MISC_RC_BAR_CONFIG_LO_SIZE_MASK		0x1f
++#define PCIE_MISC_RC_BAR4_CONFIG_LO			0x40d4
++#define PCIE_MISC_RC_BAR4_CONFIG_HI			0x40d8
++/* ... */
++#define PCIE_MISC_RC_BAR10_CONFIG_LO			0x4104
++#define PCIE_MISC_RC_BAR10_CONFIG_HI			0x4108
++
++#define PCIE_MISC_UBUS_BAR_CONFIG_REMAP_ENABLE		0x1
++#define PCIE_MISC_UBUS_BAR_CONFIG_REMAP_LO_MASK		0xfffff000
++#define PCIE_MISC_UBUS_BAR_CONFIG_REMAP_HI_MASK		0xff
++#define PCIE_MISC_UBUS_BAR4_CONFIG_REMAP_LO		0x410c
++#define PCIE_MISC_UBUS_BAR4_CONFIG_REMAP_HI		0x4110
++/* ... */
++#define PCIE_MISC_UBUS_BAR10_CONFIG_REMAP_LO		0x413c
++#define PCIE_MISC_UBUS_BAR10_CONFIG_REMAP_HI		0x4140
++
++/* AXI priority forwarding - automatic level-based */
++#define PCIE_MISC_TC_QUEUE_TO_QOS_MAP(x)		(0x4160 - (x) * 4)
++/* Defined in quarter-fullness */
++#define  QUEUE_THRESHOLD_34_TO_QOS_MAP_SHIFT		12
++#define  QUEUE_THRESHOLD_23_TO_QOS_MAP_SHIFT		8
++#define  QUEUE_THRESHOLD_12_TO_QOS_MAP_SHIFT		4
++#define  QUEUE_THRESHOLD_01_TO_QOS_MAP_SHIFT		0
++#define  QUEUE_THRESHOLD_MASK				0xf
++
++/* VDM messages indexing TCs to AXI priorities */
++/* Indexes 8-15 */
++#define PCIE_MISC_VDM_PRIORITY_TO_QOS_MAP_HI		0x4164
++/* Indexes 0-7 */
++#define PCIE_MISC_VDM_PRIORITY_TO_QOS_MAP_LO		0x4168
++#define  VDM_PRIORITY_TO_QOS_MAP_SHIFT(x)		(4 * (x))
++#define  VDM_PRIORITY_TO_QOS_MAP_MASK			0xf
++
++#define PCIE_MISC_AXI_INTF_CTRL 0x416C
++#define  AXI_REQFIFO_EN_QOS_PROPAGATION			BIT(7)
++#define  AXI_BRIDGE_LOW_LATENCY_MODE			BIT(6)
++#define  AXI_MASTER_MAX_OUTSTANDING_REQUESTS_MASK	0x3f
+ 
+-#define PCIE_INTR2_CPU_BASE		0x4300
++#define PCIE_MISC_AXI_READ_ERROR_DATA	0x4170
++
++#define PCIE_INTR2_CPU_BASE		(pcie->reg_offsets[INTR2_CPU])
+ #define PCIE_MSI_INTR2_BASE		0x4500
+ /* Offsets from PCIE_INTR2_CPU_BASE and PCIE_MSI_INTR2_BASE */
+ #define  MSI_INT_STATUS			0x0
+@@ -197,6 +276,8 @@ enum {
+ 	RGR1_SW_INIT_1,
+ 	EXT_CFG_INDEX,
+ 	EXT_CFG_DATA,
++	PCIE_HARD_DEBUG,
++	INTR2_CPU,
+ };
+ 
+ enum {
+@@ -211,6 +292,7 @@ enum pcie_type {
+ 	BCM4908,
+ 	BCM7278,
+ 	BCM2711,
++	BCM2712,
+ };
+ 
+ struct pcie_cfg_data {
+@@ -218,6 +300,7 @@ struct pcie_cfg_data {
+ 	const enum pcie_type type;
+ 	void (*perst_set)(struct brcm_pcie *pcie, u32 val);
+ 	void (*bridge_sw_init_set)(struct brcm_pcie *pcie, u32 val);
++	bool (*rc_mode)(struct brcm_pcie *pcie);
+ };
+ 
+ struct subdev_regulators {
+@@ -234,7 +317,7 @@ struct brcm_msi {
+ 	struct mutex		lock; /* guards the alloc/free operations */
+ 	u64			target_addr;
+ 	int			irq;
+-	DECLARE_BITMAP(used, BRCM_INT_PCI_MSI_NR);
++	DECLARE_BITMAP(used, 64);
+ 	bool			legacy;
+ 	/* Some chips have MSIs in bits [31..24] of a shared register. */
+ 	int			legacy_shift;
+@@ -251,6 +334,7 @@ struct brcm_pcie {
+ 	struct device_node	*np;
+ 	bool			ssc;
+ 	bool			l1ss;
++	bool			rcb_mps_mode;
+ 	int			gen;
+ 	u64			msi_target_addr;
+ 	struct brcm_msi		*msi;
+@@ -258,11 +342,14 @@ struct brcm_pcie {
+ 	enum pcie_type		type;
+ 	struct reset_control	*rescal;
+ 	struct reset_control	*perst_reset;
++	struct reset_control	*bridge_reset;
+ 	int			num_memc;
+ 	u64			memc_size[PCIE_BRCM_MAX_MEMC];
+ 	u32			hw_rev;
++	u32			qos_map;
+ 	void			(*perst_set)(struct brcm_pcie *pcie, u32 val);
+ 	void			(*bridge_sw_init_set)(struct brcm_pcie *pcie, u32 val);
++	bool			(*rc_mode)(struct brcm_pcie *pcie);
+ 	struct subdev_regulators *sr;
+ 	bool			ep_wakeup_capable;
+ };
+@@ -283,8 +370,8 @@ static int brcm_pcie_encode_ibar_size(u6
+ 	if (log2_in >= 12 && log2_in <= 15)
+ 		/* Covers 4KB to 32KB (inclusive) */
+ 		return (log2_in - 12) + 0x1c;
+-	else if (log2_in >= 16 && log2_in <= 35)
+-		/* Covers 64KB to 32GB, (inclusive) */
++	else if (log2_in >= 16 && log2_in <= 36)
++		/* Covers 64KB to 64GB, (inclusive) */
+ 		return log2_in - 15;
+ 	/* Something is awry so disable */
+ 	return 0;
+@@ -381,6 +468,35 @@ static int brcm_pcie_set_ssc(struct brcm
+ 	return ssc && pll ? 0 : -EIO;
+ }
+ 
++static void brcm_pcie_munge_pll(struct brcm_pcie *pcie)
++{
++	//print "MDIO block 0x1600 written per Dannys instruction"
++	//tmp = pcie_mdio_write(phyad, &h16&, &h50b9&)
++	//tmp = pcie_mdio_write(phyad, &h17&, &hbd1a&)
++	//tmp = pcie_mdio_write(phyad, &h1b&, &h5030&)
++	//tmp = pcie_mdio_write(phyad, &h1e&, &h0007&)
++
++	u32 tmp;
++	int ret, i;
++	u8 regs[] =  { 0x16,   0x17,   0x18,   0x19,   0x1b,   0x1c,   0x1e };
++	u16 data[] = { 0x50b9, 0xbda1, 0x0094, 0x97b4, 0x5030, 0x5030, 0x0007 };
++
++	ret = brcm_pcie_mdio_write(pcie->base, MDIO_PORT0, SET_ADDR_OFFSET,
++				0x1600);
++	for (i = 0; i < ARRAY_SIZE(regs); i++) {
++		brcm_pcie_mdio_read(pcie->base, MDIO_PORT0, regs[i], &tmp);
++		dev_dbg(pcie->dev, "PCIE MDIO pre_refclk 0x%02x = 0x%04x\n",
++			regs[i], tmp);
++	}
++	for (i = 0; i < ARRAY_SIZE(regs); i++) {
++		brcm_pcie_mdio_write(pcie->base, MDIO_PORT0, regs[i], data[i]);
++		brcm_pcie_mdio_read(pcie->base, MDIO_PORT0, regs[i], &tmp);
++		dev_dbg(pcie->dev, "PCIE MDIO post_refclk 0x%02x = 0x%04x\n",
++			regs[i], tmp);
++	}
++	usleep_range(100, 200);
++}
++
+ /* Limits operation to a specific generation (1, 2, or 3) */
+ static void brcm_pcie_set_gen(struct brcm_pcie *pcie, int gen)
+ {
+@@ -438,6 +554,97 @@ static void brcm_pcie_set_outbound_win(s
+ 	writel(tmp, pcie->base + PCIE_MEM_WIN0_LIMIT_HI(win));
+ }
+ 
++static void brcm_pcie_set_tc_qos(struct brcm_pcie *pcie)
++{
++	int i;
++	u32 reg;
++
++	if (pcie->type != BCM2712)
++		return;
++
++	/* XXX: BCM2712C0 is broken, disable the forwarding search */
++	reg = readl(pcie->base + PCIE_MISC_AXI_INTF_CTRL);
++	reg &= ~AXI_REQFIFO_EN_QOS_PROPAGATION;
++	writel(reg, pcie->base + PCIE_MISC_AXI_INTF_CTRL);
++
++	/* Disable VDM reception by default - QoS map defaults to 0 */
++	reg = readl(pcie->base + PCIE_MISC_CTRL_1);
++	reg &= ~PCIE_MISC_CTRL_1_EN_VDM_QOS_CONTROL_MASK;
++	writel(reg, pcie->base + PCIE_MISC_CTRL_1);
++
++	if (!of_property_read_u32(pcie->np, "brcm,fifo-qos-map", &pcie->qos_map)) {
++		/*
++		 * Backpressure mode - bottom 4 nibbles are QoS for each
++		 * quartile of FIFO level. Each TC gets the same map, because
++		 * this mode is intended for nonrealtime EPs.
++		 */
++
++		pcie->qos_map &= 0x0000ffff;
++		for (i = 0; i < 8; i++)
++			writel(pcie->qos_map, pcie->base + PCIE_MISC_TC_QUEUE_TO_QOS_MAP(i));
++
++		return;
++	}
++
++	if (!of_property_read_u32(pcie->np, "brcm,vdm-qos-map", &pcie->qos_map)) {
++
++		reg = readl(pcie->base + PCIE_MISC_CTRL_1);
++		reg |= PCIE_MISC_CTRL_1_EN_VDM_QOS_CONTROL_MASK;
++		writel(reg, pcie->base + PCIE_MISC_CTRL_1);
++
++		/* No forwarding means no point separating panic priorities from normal */
++		writel(pcie->qos_map, pcie->base + PCIE_MISC_VDM_PRIORITY_TO_QOS_MAP_LO);
++		writel(pcie->qos_map, pcie->base + PCIE_MISC_VDM_PRIORITY_TO_QOS_MAP_HI);
++
++		/* Match Vendor ID of 0 */
++		writel(0, pcie->base + PCIE_RC_TL_VDM_CTL1);
++		/* Forward VDMs to priority interface - at least the rx counters work */
++		reg = readl(pcie->base + PCIE_RC_TL_VDM_CTL0);
++		reg |= PCIE_RC_TL_VDM_CTL0_VDM_ENABLED_MASK |
++			PCIE_RC_TL_VDM_CTL0_VDM_IGNORETAG_MASK |
++			PCIE_RC_TL_VDM_CTL0_VDM_IGNOREVNDRID_MASK;
++		writel(reg, pcie->base + PCIE_RC_TL_VDM_CTL0);
++	}
++}
++
++static void brcm_pcie_config_clkreq(struct brcm_pcie *pcie)
++{
++	void __iomem *base = pcie->base;
++	struct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);
++	int domain = pci_domain_nr(bridge->bus);
++	const struct pci_bus *bus = pci_find_bus(domain, 1);
++	struct pci_dev *pdev = (struct pci_dev *)bus->devices.next;
++	u32 tmp, link_cap = 0;
++	u16 link_ctl = 0;
++	int clkpm = 0;
++	int substates = 0;
++
++	pcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &link_cap);
++	if ((link_cap & PCI_EXP_LNKCAP_CLKPM))
++		clkpm = 1;
++
++	pcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &link_ctl);
++	if (!(link_ctl & PCI_EXP_LNKCTL_CLKREQ_EN))
++		clkpm = 0;
++
++	if (pcie->l1ss && pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_L1SS))
++		substates = 1;
++
++	tmp = readl(base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
++	tmp &= ~PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_DEBUG_ENABLE_MASK;
++	tmp &= ~PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_L1SS_ENABLE_MASK;
++
++	if (substates)
++		tmp |= PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_L1SS_ENABLE_MASK;
++	else if (clkpm)
++		tmp |= PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_DEBUG_ENABLE_MASK;
++
++	writel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
++
++	if (substates || clkpm)
++		dev_info(pcie->dev, "clkreq control enabled\n");
++}
++
+ static struct irq_chip brcm_msi_irq_chip = {
+ 	.name            = "BRCM STB PCIe MSI",
+ 	.irq_ack         = irq_chip_ack_parent,
+@@ -455,7 +662,7 @@ static struct msi_domain_info brcm_msi_d
+ static void brcm_pcie_msi_isr(struct irq_desc *desc)
+ {
+ 	struct irq_chip *chip = irq_desc_get_chip(desc);
+-	unsigned long status;
++	unsigned long status, virq;
+ 	struct brcm_msi *msi;
+ 	struct device *dev;
+ 	u32 bit;
+@@ -467,10 +674,22 @@ static void brcm_pcie_msi_isr(struct irq
+ 	status = readl(msi->intr_base + MSI_INT_STATUS);
+ 	status >>= msi->legacy_shift;
+ 
+-	for_each_set_bit(bit, &status, msi->nr) {
+-		int ret;
+-		ret = generic_handle_domain_irq(msi->inner_domain, bit);
+-		if (ret)
++	for_each_set_bit(bit, &status, BRCM_INT_PCI_MSI_NR/*msi->nr*/) {
++		bool found = false;
++
++		virq = irq_find_mapping(msi->inner_domain, bit);
++		if (virq) {
++			found = true;
++			dev_dbg(dev, "MSI -> %ld\n", virq);
++			generic_handle_irq(virq);
++		}
++		virq = irq_find_mapping(msi->inner_domain, bit + 32);
++		if (virq) {
++			found = true;
++			dev_dbg(dev, "MSI -> %ld\n", virq);
++			generic_handle_irq(virq);
++		}
++		if (!found)
+ 			dev_dbg(dev, "unexpected MSI\n");
+ 	}
+ 
+@@ -483,7 +702,7 @@ static void brcm_msi_compose_msi_msg(str
+ 
+ 	msg->address_lo = lower_32_bits(msi->target_addr);
+ 	msg->address_hi = upper_32_bits(msi->target_addr);
+-	msg->data = (0xffff & PCIE_MISC_MSI_DATA_CONFIG_VAL_32) | data->hwirq;
++	msg->data = (0xffff & PCIE_MISC_MSI_DATA_CONFIG_VAL_32) | (data->hwirq & 0x1f);
+ }
+ 
+ static int brcm_msi_set_affinity(struct irq_data *irq_data,
+@@ -495,7 +714,7 @@ static int brcm_msi_set_affinity(struct
+ static void brcm_msi_ack_irq(struct irq_data *data)
+ {
+ 	struct brcm_msi *msi = irq_data_get_irq_chip_data(data);
+-	const int shift_amt = data->hwirq + msi->legacy_shift;
++	const int shift_amt = (data->hwirq & 0x1f) + msi->legacy_shift;
+ 
+ 	writel(1 << shift_amt, msi->intr_base + MSI_INT_CLR);
+ }
+@@ -653,7 +872,7 @@ static int brcm_pcie_enable_msi(struct b
+ 		msi->legacy_shift = 24;
+ 	} else {
+ 		msi->intr_base = msi->base + PCIE_MSI_INTR2_BASE;
+-		msi->nr = BRCM_INT_PCI_MSI_NR;
++		msi->nr = 64; //BRCM_INT_PCI_MSI_NR;
+ 		msi->legacy_shift = 0;
+ 	}
+ 
+@@ -670,7 +889,7 @@ static int brcm_pcie_enable_msi(struct b
+ }
+ 
+ /* The controller is capable of serving in both RC and EP roles */
+-static bool brcm_pcie_rc_mode(struct brcm_pcie *pcie)
++static bool brcm_pcie_rc_mode_generic(struct brcm_pcie *pcie)
+ {
+ 	void __iomem *base = pcie->base;
+ 	u32 val = readl(base + PCIE_MISC_PCIE_STATUS);
+@@ -678,6 +897,14 @@ static bool brcm_pcie_rc_mode(struct brc
+ 	return !!FIELD_GET(PCIE_MISC_PCIE_STATUS_PCIE_PORT_MASK, val);
+ }
+ 
++static bool brcm_pcie_rc_mode_2712(struct brcm_pcie *pcie)
++{
++	void __iomem *base = pcie->base;
++	u32 val = readl(base + PCIE_MISC_PCIE_STATUS);
++
++	return !!FIELD_GET(PCIE_MISC_PCIE_STATUS_PCIE_PORT_MASK_2712, val) | 1; //XXX
++}
++
+ static bool brcm_pcie_link_up(struct brcm_pcie *pcie)
+ {
+ 	u32 val = readl(pcie->base + PCIE_MISC_PCIE_STATUS);
+@@ -749,6 +976,18 @@ static inline void brcm_pcie_bridge_sw_i
+ 	writel(tmp, pcie->base + PCIE_RGR1_SW_INIT_1(pcie));
+ }
+ 
++static inline void brcm_pcie_bridge_sw_init_set_2712(struct brcm_pcie *pcie, u32 val)
++{
++	if (WARN_ONCE(!pcie->bridge_reset,
++		      "missing bridge reset controller\n"))
++		return;
++
++	if (val)
++		reset_control_assert(pcie->bridge_reset);
++	else
++		reset_control_deassert(pcie->bridge_reset);
++}
++
+ static inline void brcm_pcie_perst_set_4908(struct brcm_pcie *pcie, u32 val)
+ {
+ 	if (WARN_ONCE(!pcie->perst_reset, "missing PERST# reset controller\n"))
+@@ -770,6 +1009,16 @@ static inline void brcm_pcie_perst_set_7
+ 	writel(tmp, pcie->base +  PCIE_MISC_PCIE_CTRL);
+ }
+ 
++static inline void brcm_pcie_perst_set_2712(struct brcm_pcie *pcie, u32 val)
++{
++	u32 tmp;
++
++	/* Perst bit has moved and assert value is 0 */
++	tmp = readl(pcie->base + PCIE_MISC_PCIE_CTRL);
++	u32p_replace_bits(&tmp, !val, PCIE_MISC_PCIE_CTRL_PCIE_PERSTB_MASK);
++	writel(tmp, pcie->base +  PCIE_MISC_PCIE_CTRL);
++}
++
+ static inline void brcm_pcie_perst_set_generic(struct brcm_pcie *pcie, u32 val)
+ {
+ 	u32 tmp;
+@@ -796,6 +1045,8 @@ static inline int brcm_pcie_get_rc_bar2_
+ 		size += entry->res->end - entry->res->start + 1;
+ 		if (pcie_beg < lowest_pcie_addr)
+ 			lowest_pcie_addr = pcie_beg;
++		if (pcie->type == BCM2711 || pcie->type == BCM2712)
++			break; // Only consider the first entry
+ 	}
+ 
+ 	if (lowest_pcie_addr == ~(u64)0) {
+@@ -866,6 +1117,30 @@ static inline int brcm_pcie_get_rc_bar2_
+ 	return 0;
+ }
+ 
++static int brcm_pcie_get_rc_bar_n(struct brcm_pcie *pcie,
++				  int idx,
++				  u64 *rc_bar_cpu,
++				  u64 *rc_bar_size,
++				  u64 *rc_bar_pci)
++{
++	struct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);
++	struct resource_entry *entry;
++	int i = 0;
++
++	resource_list_for_each_entry(entry, &bridge->dma_ranges) {
++		if (i == idx) {
++			*rc_bar_cpu  = entry->res->start;
++			*rc_bar_size = entry->res->end - entry->res->start + 1;
++			*rc_bar_pci = entry->res->start - entry->offset;
++			return 0;
++		}
++
++		i++;
++	}
++
++	return -EINVAL;
++}
++
+ static int brcm_pcie_setup(struct brcm_pcie *pcie)
+ {
+ 	u64 rc_bar2_offset, rc_bar2_size;
+@@ -874,11 +1149,14 @@ static int brcm_pcie_setup(struct brcm_p
+ 	struct resource_entry *entry;
+ 	u32 tmp, burst, aspm_support;
+ 	int num_out_wins = 0;
+-	int ret, memc;
++	int ret, memc, count, i;
+ 
+ 	/* Reset the bridge */
+ 	pcie->bridge_sw_init_set(pcie, 1);
+-	pcie->perst_set(pcie, 1);
++
++	/* Ensure that PERST# is asserted; some bootloaders may deassert it. */
++	if (pcie->type == BCM2711)
++		pcie->perst_set(pcie, 1);
+ 
+ 	usleep_range(100, 200);
+ 
+@@ -894,6 +1172,17 @@ static int brcm_pcie_setup(struct brcm_p
+ 	/* Wait for SerDes to be stable */
+ 	usleep_range(100, 200);
+ 
++	if (pcie->type == BCM2712) {
++		/* Allow a 54MHz (xosc) refclk source */
++		brcm_pcie_munge_pll(pcie);
++		/* Fix for L1SS errata */
++		tmp = readl(base + PCIE_RC_PL_PHY_CTL_15);
++		tmp &= ~PCIE_RC_PL_PHY_CTL_15_PM_CLK_PERIOD_MASK;
++		/* PM clock period is 18.52ns (round down) */
++		tmp |= 0x12;
++		writel(tmp, base + PCIE_RC_PL_PHY_CTL_15);
++	}
++
+ 	/*
+ 	 * SCB_MAX_BURST_SIZE is a two bit field.  For GENERIC chips it
+ 	 * is encoded as 0=128, 1=256, 2=512, 3=Rsvd, for BCM7278 it
+@@ -903,18 +1192,25 @@ static int brcm_pcie_setup(struct brcm_p
+ 		burst = 0x1; /* 256 bytes */
+ 	else if (pcie->type == BCM2711)
+ 		burst = 0x0; /* 128 bytes */
++	else if (pcie->type == BCM2712)
++		burst = 0x1; /* 128 bytes */
+ 	else if (pcie->type == BCM7278)
+ 		burst = 0x3; /* 512 bytes */
+ 	else
+ 		burst = 0x2; /* 512 bytes */
+ 
+-	/* Set SCB_MAX_BURST_SIZE, CFG_READ_UR_MODE, SCB_ACCESS_EN */
++	/* Set SCB_MAX_BURST_SIZE, CFG_READ_UR_MODE, SCB_ACCESS_EN, RCB_MPS_MODE */
+ 	tmp = readl(base + PCIE_MISC_MISC_CTRL);
+ 	u32p_replace_bits(&tmp, 1, PCIE_MISC_MISC_CTRL_SCB_ACCESS_EN_MASK);
+ 	u32p_replace_bits(&tmp, 1, PCIE_MISC_MISC_CTRL_CFG_READ_UR_MODE_MASK);
+ 	u32p_replace_bits(&tmp, burst, PCIE_MISC_MISC_CTRL_MAX_BURST_SIZE_MASK);
++	if (pcie->rcb_mps_mode)
++		u32p_replace_bits(&tmp, 1, PCIE_MISC_MISC_CTRL_RCB_MPS_MODE_MASK);
++	dev_info(pcie->dev, "setting SCB_ACCESS_EN, READ_UR_MODE, MAX_BURST_SIZE\n");
+ 	writel(tmp, base + PCIE_MISC_MISC_CTRL);
+ 
++	brcm_pcie_set_tc_qos(pcie);
++
+ 	ret = brcm_pcie_get_rc_bar2_size_and_offset(pcie, &rc_bar2_size,
+ 						    &rc_bar2_offset);
+ 	if (ret)
+@@ -927,7 +1223,11 @@ static int brcm_pcie_setup(struct brcm_p
+ 	writel(upper_32_bits(rc_bar2_offset),
+ 	       base + PCIE_MISC_RC_BAR2_CONFIG_HI);
+ 
++	tmp = readl(base + PCIE_MISC_UBUS_BAR2_CONFIG_REMAP);
++	u32p_replace_bits(&tmp, 1, PCIE_MISC_UBUS_BAR2_CONFIG_REMAP_ACCESS_ENABLE_MASK);
++	writel(tmp, base + PCIE_MISC_UBUS_BAR2_CONFIG_REMAP);
+ 	tmp = readl(base + PCIE_MISC_MISC_CTRL);
++
+ 	for (memc = 0; memc < pcie->num_memc; memc++) {
+ 		u32 scb_size_val = ilog2(pcie->memc_size[memc]) - 15;
+ 
+@@ -938,8 +1238,32 @@ static int brcm_pcie_setup(struct brcm_p
+ 		else if (memc == 2)
+ 			u32p_replace_bits(&tmp, scb_size_val, SCB_SIZE_MASK(2));
+ 	}
++
+ 	writel(tmp, base + PCIE_MISC_MISC_CTRL);
+ 
++	if (pcie->type == BCM2712) {
++		/* Suppress AXI error responses and return 1s for read failures */
++		tmp = readl(base + PCIE_MISC_UBUS_CTRL);
++		u32p_replace_bits(&tmp, 1, PCIE_MISC_UBUS_CTRL_UBUS_PCIE_REPLY_ERR_DIS_MASK);
++		u32p_replace_bits(&tmp, 1, PCIE_MISC_UBUS_CTRL_UBUS_PCIE_REPLY_DECERR_DIS_MASK);
++		writel(tmp, base + PCIE_MISC_UBUS_CTRL);
++		writel(0xffffffff, base + PCIE_MISC_AXI_READ_ERROR_DATA);
++
++		/*
++		 * Adjust timeouts. The UBUS timeout also affects CRS
++		 * completion retries, as the request will get terminated if
++		 * either timeout expires, so both have to be a large value
++		 * (in clocks of 750MHz).
++		 * Set UBUS timeout to 250ms, then set RC config retry timeout
++		 * to be ~240ms.
++		 *
++		 * Setting CRSVis=1 will stop the core from blocking on a CRS
++		 * response, but does require the device to be well-behaved...
++		 */
++		writel(0xB2D0000, base + PCIE_MISC_UBUS_TIMEOUT);
++		writel(0xABA0000, base + PCIE_MISC_RC_CONFIG_RETRY_TIMEOUT);
++	}
++
+ 	/*
+ 	 * We ideally want the MSI target address to be located in the 32bit
+ 	 * addressable memory area. Some devices might depend on it. This is
+@@ -952,7 +1276,7 @@ static int brcm_pcie_setup(struct brcm_p
+ 	else
+ 		pcie->msi_target_addr = BRCM_MSI_TARGET_ADDR_GT_4GB;
+ 
+-	if (!brcm_pcie_rc_mode(pcie)) {
++	if (!pcie->rc_mode(pcie)) {
+ 		dev_err(pcie->dev, "PCIe RC controller misconfigured as Endpoint\n");
+ 		return -EINVAL;
+ 	}
+@@ -976,6 +1300,38 @@ static int brcm_pcie_setup(struct brcm_p
+ 		PCIE_RC_CFG_PRIV1_LINK_CAPABILITY_ASPM_SUPPORT_MASK);
+ 	writel(tmp, base + PCIE_RC_CFG_PRIV1_LINK_CAPABILITY);
+ 
++	/* program additional inbound windows (RC_BAR4..RC_BAR10) */
++	count = (pcie->type == BCM2712) ? 7 : 0;
++	for (i = 0; i < count; i++) {
++		u64 bar_cpu, bar_size, bar_pci;
++
++		ret = brcm_pcie_get_rc_bar_n(pcie, 1 + i, &bar_cpu, &bar_size,
++					     &bar_pci);
++		if (ret)
++			break;
++
++		tmp = lower_32_bits(bar_pci);
++		u32p_replace_bits(&tmp, brcm_pcie_encode_ibar_size(bar_size),
++				  PCIE_MISC_RC_BAR_CONFIG_LO_SIZE_MASK);
++		writel(tmp, base + PCIE_MISC_RC_BAR4_CONFIG_LO + i * 8);
++		writel(upper_32_bits(bar_pci),
++		       base + PCIE_MISC_RC_BAR4_CONFIG_HI + i * 8);
++
++		tmp = upper_32_bits(bar_cpu) &
++			PCIE_MISC_UBUS_BAR_CONFIG_REMAP_HI_MASK;
++		writel(tmp,
++		       base + PCIE_MISC_UBUS_BAR4_CONFIG_REMAP_HI + i * 8);
++		tmp = lower_32_bits(bar_cpu) &
++			PCIE_MISC_UBUS_BAR_CONFIG_REMAP_LO_MASK;
++		writel(tmp | PCIE_MISC_UBUS_BAR_CONFIG_REMAP_ENABLE,
++		       base + PCIE_MISC_UBUS_BAR4_CONFIG_REMAP_LO + i * 8);
++	}
++
++	if (pcie->gen) {
++		dev_info(pcie->dev, "Forcing gen %d\n", pcie->gen);
++		brcm_pcie_set_gen(pcie, pcie->gen);
++	}
++
+ 	/*
+ 	 * For config space accesses on the RC, show the right class for
+ 	 * a PCIe-PCIe bridge (the default setting is to be EP mode).
+@@ -1031,7 +1387,6 @@ static int brcm_pcie_start_link(struct b
+ 	void __iomem *base = pcie->base;
+ 	u16 nlw, cls, lnksta;
+ 	bool ssc_good = false;
+-	u32 tmp;
+ 	int ret, i;
+ 
+ 	/* Unassert the fundamental reset */
+@@ -1067,6 +1422,7 @@ static int brcm_pcie_start_link(struct b
+ 			dev_err(dev, "failed attempt to enter ssc mode\n");
+ 	}
+ 
++
+ 	lnksta = readw(base + BRCM_PCIE_CAP_REGS + PCI_EXP_LNKSTA);
+ 	cls = FIELD_GET(PCI_EXP_LNKSTA_CLS, lnksta);
+ 	nlw = FIELD_GET(PCI_EXP_LNKSTA_NLW, lnksta);
+@@ -1074,27 +1430,6 @@ static int brcm_pcie_start_link(struct b
+ 		 pci_speed_string(pcie_link_speed[cls]), nlw,
+ 		 ssc_good ? "(SSC)" : "(!SSC)");
+ 
+-	tmp = readl(base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
+-	if (pcie->l1ss) {
+-		/*
+-		 * Enable CLKREQ# signalling include L1 Substate control of
+-		 * the CLKREQ# signal and the external reference clock buffer.
+-		 * meet requirement for Endpoints that require CLKREQ#
+-		 * assertion to clock active within 400ns.
+-		 */
+-		tmp &= ~PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_DEBUG_ENABLE_MASK;
+-		tmp |= PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_L1SS_ENABLE_MASK;
+-	} else {
+-		/*
+-		 * Refclk from RC should be gated with CLKREQ# input when
+-		 * ASPM L0s,L1 is enabled => setting the CLKREQ_DEBUG_ENABLE
+-		 * field to 1.
+-		 */
+-		tmp &= ~PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_L1SS_ENABLE_MASK;
+-		tmp |= PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_DEBUG_ENABLE_MASK;
+-	}
+-	writel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
+-
+ 	return 0;
+ }
+ 
+@@ -1202,6 +1537,7 @@ static void brcm_pcie_enter_l23(struct b
+ 
+ static int brcm_phy_cntl(struct brcm_pcie *pcie, const int start)
+ {
++#if 0
+ 	static const u32 shifts[PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_NFLDS] = {
+ 		PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_PWRDN_SHIFT,
+ 		PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_RESET_SHIFT,
+@@ -1234,6 +1570,9 @@ static int brcm_phy_cntl(struct brcm_pci
+ 		dev_err(pcie->dev, "failed to %s phy\n", (start ? "start" : "stop"));
+ 
+ 	return ret;
++#else
++	return 0;
++#endif
+ }
+ 
+ static inline int brcm_phy_start(struct brcm_pcie *pcie)
+@@ -1266,6 +1605,12 @@ static void brcm_pcie_turn_off(struct br
+ 	u32p_replace_bits(&tmp, 1, PCIE_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK);
+ 	writel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
+ 
++	/*
++	 * Shutting down this bridge on pcie1 means accesses to rescal block
++	 * will hang the chip if another RC wants to assert/deassert rescal.
++	 */
++	if (pcie->type == BCM2712)
++		return;
+ 	/* Shutdown PCIe bridge */
+ 	pcie->bridge_sw_init_set(pcie, 1);
+ }
+@@ -1296,9 +1641,9 @@ static int brcm_pcie_suspend_noirq(struc
+ 	if (brcm_phy_stop(pcie))
+ 		dev_err(dev, "Could not stop phy for suspend\n");
+ 
+-	ret = reset_control_rearm(pcie->rescal);
++	ret = reset_control_assert(pcie->rescal);
+ 	if (ret) {
+-		dev_err(dev, "Could not rearm rescal reset\n");
++		dev_err(dev, "Could not assert rescal reset\n");
+ 		return ret;
+ 	}
+ 
+@@ -1393,7 +1738,7 @@ err_regulator:
+ 	if (pcie->sr)
+ 		regulator_bulk_disable(pcie->sr->num_supplies, pcie->sr->supplies);
+ err_reset:
+-	reset_control_rearm(pcie->rescal);
++	reset_control_assert(pcie->rescal);
+ err_disable_clk:
+ 	clk_disable_unprepare(pcie->clk);
+ 	return ret;
+@@ -1405,8 +1750,8 @@ static void __brcm_pcie_remove(struct br
+ 	brcm_pcie_turn_off(pcie);
+ 	if (brcm_phy_stop(pcie))
+ 		dev_err(pcie->dev, "Could not stop phy\n");
+-	if (reset_control_rearm(pcie->rescal))
+-		dev_err(pcie->dev, "Could not rearm rescal reset\n");
++	if (reset_control_assert(pcie->rescal))
++		dev_err(pcie->dev, "Could not assert rescal reset\n");
+ 	clk_disable_unprepare(pcie->clk);
+ }
+ 
+@@ -1426,12 +1771,16 @@ static const int pcie_offsets[] = {
+ 	[RGR1_SW_INIT_1] = 0x9210,
+ 	[EXT_CFG_INDEX]  = 0x9000,
+ 	[EXT_CFG_DATA]   = 0x9004,
++	[PCIE_HARD_DEBUG] = 0x4204,
++	[INTR2_CPU]      = 0x4300,
+ };
+ 
+ static const int pcie_offsets_bmips_7425[] = {
+ 	[RGR1_SW_INIT_1] = 0x8010,
+ 	[EXT_CFG_INDEX]  = 0x8300,
+ 	[EXT_CFG_DATA]   = 0x8304,
++	[PCIE_HARD_DEBUG] = 0x4204,
++	[INTR2_CPU]      = 0x4300,
+ };
+ 
+ static const struct pcie_cfg_data generic_cfg = {
+@@ -1439,6 +1788,7 @@ static const struct pcie_cfg_data generi
+ 	.type		= GENERIC,
+ 	.perst_set	= brcm_pcie_perst_set_generic,
+ 	.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,
++	.rc_mode	= brcm_pcie_rc_mode_generic,
+ };
+ 
+ static const struct pcie_cfg_data bcm7425_cfg = {
+@@ -1446,6 +1796,7 @@ static const struct pcie_cfg_data bcm742
+ 	.type		= BCM7425,
+ 	.perst_set	= brcm_pcie_perst_set_generic,
+ 	.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,
++	.rc_mode	= brcm_pcie_rc_mode_generic,
+ };
+ 
+ static const struct pcie_cfg_data bcm7435_cfg = {
+@@ -1460,12 +1811,15 @@ static const struct pcie_cfg_data bcm490
+ 	.type		= BCM4908,
+ 	.perst_set	= brcm_pcie_perst_set_4908,
+ 	.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,
++	.rc_mode	= brcm_pcie_rc_mode_generic,
+ };
+ 
+ static const int pcie_offset_bcm7278[] = {
+ 	[RGR1_SW_INIT_1] = 0xc010,
+ 	[EXT_CFG_INDEX] = 0x9000,
+ 	[EXT_CFG_DATA] = 0x9004,
++	[PCIE_HARD_DEBUG] = 0x4204,
++	[INTR2_CPU]      = 0x4300,
+ };
+ 
+ static const struct pcie_cfg_data bcm7278_cfg = {
+@@ -1473,6 +1827,7 @@ static const struct pcie_cfg_data bcm727
+ 	.type		= BCM7278,
+ 	.perst_set	= brcm_pcie_perst_set_7278,
+ 	.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_7278,
++	.rc_mode	= brcm_pcie_rc_mode_generic,
+ };
+ 
+ static const struct pcie_cfg_data bcm2711_cfg = {
+@@ -1480,10 +1835,27 @@ static const struct pcie_cfg_data bcm271
+ 	.type		= BCM2711,
+ 	.perst_set	= brcm_pcie_perst_set_generic,
+ 	.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,
++	.rc_mode	= brcm_pcie_rc_mode_generic,
++};
++
++static const int pcie_offsets_bcm2712[] = {
++	[EXT_CFG_INDEX] = 0x9000,
++	[EXT_CFG_DATA] = 0x9004,
++	[PCIE_HARD_DEBUG] = 0x4304,
++	[INTR2_CPU] = 0x4400,
++};
++
++static const struct pcie_cfg_data bcm2712_cfg = {
++	.offsets	= pcie_offsets_bcm2712,
++	.type		= BCM2712,
++	.perst_set	= brcm_pcie_perst_set_2712,
++	.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_2712,
++	.rc_mode	= brcm_pcie_rc_mode_2712,
+ };
+ 
+ static const struct of_device_id brcm_pcie_match[] = {
+ 	{ .compatible = "brcm,bcm2711-pcie", .data = &bcm2711_cfg },
++	{ .compatible = "brcm,bcm2712-pcie", .data = &bcm2712_cfg },
+ 	{ .compatible = "brcm,bcm4908-pcie", .data = &bcm4908_cfg },
+ 	{ .compatible = "brcm,bcm7211-pcie", .data = &generic_cfg },
+ 	{ .compatible = "brcm,bcm7278-pcie", .data = &bcm7278_cfg },
+@@ -1524,7 +1896,7 @@ static int brcm_pcie_probe(struct platfo
+ 
+ 	data = of_device_get_match_data(&pdev->dev);
+ 	if (!data) {
+-		pr_err("failed to look up compatible string\n");
++		dev_err(&pdev->dev, "failed to look up compatible string\n");
+ 		return -EINVAL;
+ 	}
+ 
+@@ -1535,6 +1907,7 @@ static int brcm_pcie_probe(struct platfo
+ 	pcie->type = data->type;
+ 	pcie->perst_set = data->perst_set;
+ 	pcie->bridge_sw_init_set = data->bridge_sw_init_set;
++	pcie->rc_mode = data->rc_mode;
+ 
+ 	pcie->base = devm_platform_ioremap_resource(pdev, 0);
+ 	if (IS_ERR(pcie->base))
+@@ -1549,6 +1922,7 @@ static int brcm_pcie_probe(struct platfo
+ 
+ 	pcie->ssc = of_property_read_bool(np, "brcm,enable-ssc");
+ 	pcie->l1ss = of_property_read_bool(np, "brcm,enable-l1ss");
++	pcie->rcb_mps_mode = of_property_read_bool(np, "brcm,enable-mps-rcb");
+ 
+ 	ret = clk_prepare_enable(pcie->clk);
+ 	if (ret) {
+@@ -1565,14 +1939,20 @@ static int brcm_pcie_probe(struct platfo
+ 		clk_disable_unprepare(pcie->clk);
+ 		return PTR_ERR(pcie->perst_reset);
+ 	}
++	pcie->bridge_reset =
++		devm_reset_control_get_optional_exclusive(&pdev->dev, "bridge");
++	if (IS_ERR(pcie->bridge_reset)) {
++		clk_disable_unprepare(pcie->clk);
++		return PTR_ERR(pcie->bridge_reset);
++	}
+ 
+-	ret = reset_control_reset(pcie->rescal);
++	ret = reset_control_deassert(pcie->rescal);
+ 	if (ret)
+ 		dev_err(&pdev->dev, "failed to deassert 'rescal'\n");
+ 
+ 	ret = brcm_phy_start(pcie);
+ 	if (ret) {
+-		reset_control_rearm(pcie->rescal);
++		reset_control_assert(pcie->rescal);
+ 		clk_disable_unprepare(pcie->clk);
+ 		return ret;
+ 	}
+@@ -1595,6 +1975,33 @@ static int brcm_pcie_probe(struct platfo
+ 			dev_err(pcie->dev, "probe of internal MSI failed");
+ 			goto fail;
+ 		}
++	} else if (pci_msi_enabled() && msi_np != pcie->np) {
++		/* Use RC_BAR1 for MIP access */
++		u64 msi_pci_addr;
++		u64 msi_phys_addr;
++
++		if (of_property_read_u64(msi_np, "brcm,msi-pci-addr", &msi_pci_addr)) {
++			dev_err(pcie->dev, "Unable to find MSI PCI address\n");
++			ret = -EINVAL;
++			goto fail;
++		}
++
++		if (of_property_read_u64(msi_np, "reg", &msi_phys_addr)) {
++			dev_err(pcie->dev, "Unable to find MSI physical address\n");
++			ret = -EINVAL;
++			goto fail;
++		}
++
++		writel(lower_32_bits(msi_pci_addr) | brcm_pcie_encode_ibar_size(0x1000),
++		       pcie->base + PCIE_MISC_RC_BAR1_CONFIG_LO);
++		writel(upper_32_bits(msi_pci_addr),
++		       pcie->base + PCIE_MISC_RC_BAR1_CONFIG_HI);
++
++		writel(lower_32_bits(msi_phys_addr) |
++		       PCIE_MISC_UBUS_BAR1_CONFIG_REMAP_ACCESS_ENABLE_MASK,
++		       pcie->base + PCIE_MISC_UBUS_BAR1_CONFIG_REMAP);
++		writel(upper_32_bits(msi_phys_addr),
++		       pcie->base + PCIE_MISC_UBUS_BAR1_CONFIG_REMAP_HI);
+ 	}
+ 
+ 	bridge->ops = pcie->type == BCM7425 ? &brcm7425_pcie_ops : &brcm_pcie_ops;
+@@ -1611,6 +2018,8 @@ static int brcm_pcie_probe(struct platfo
+ 		return ret;
+ 	}
+ 
++	brcm_pcie_config_clkreq(pcie);
++
+ 	return 0;
+ 
+ fail:
diff --git a/target/linux/bcm27xx/patches-6.1/950-0868-V4L2-Add-PiSP-opaque-formats-to-V4L2.patch b/target/linux/bcm27xx/patches-6.1/950-0868-V4L2-Add-PiSP-opaque-formats-to-V4L2.patch
new file mode 100644
index 0000000000..3b50329ab1
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0868-V4L2-Add-PiSP-opaque-formats-to-V4L2.patch
@@ -0,0 +1,42 @@
+From 9a11300e46344917226b986a8740e7581d66adf3 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Mon, 7 Feb 2022 09:20:49 +0000
+Subject: [PATCH] V4L2: Add PiSP opaque formats to V4L2
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/v4l2-core/v4l2-ioctl.c | 4 +++-
+ include/uapi/linux/videodev2.h       | 7 +++++++
+ 2 files changed, 10 insertions(+), 1 deletion(-)
+
+--- a/drivers/media/v4l2-core/v4l2-ioctl.c
++++ b/drivers/media/v4l2-core/v4l2-ioctl.c
+@@ -1452,7 +1452,9 @@ static void v4l_fill_fmtdesc(struct v4l2
+ 	case V4L2_PIX_FMT_NV12M_10BE_8L128:	descr = "10-bit NV12M (8x128 Linear, BE)"; break;
+ 	case V4L2_META_FMT_SENSOR_DATA:	descr = "Sensor Ancillary Metadata"; break;
+ 	case V4L2_META_FMT_BCM2835_ISP_STATS: descr = "BCM2835 ISP Image Statistics"; break;
+-	case V4L2_META_FMT_RPI_BE_CFG: descr = "PiSP Config format"; break;
++	case V4L2_META_FMT_RPI_BE_CFG: descr = "PiSP BE Config format"; break;
++	case V4L2_META_FMT_RPI_FE_CFG: descr = "PiSP FE Config format"; break;
++	case V4L2_META_FMT_RPI_FE_STATS: descr = "PiSP FE Statistics format"; break;
+ 
+ 	default:
+ 		/* Compressed formats */
+--- a/include/uapi/linux/videodev2.h
++++ b/include/uapi/linux/videodev2.h
+@@ -826,8 +826,15 @@ struct v4l2_pix_format {
+ #define V4L2_META_FMT_RK_ISP1_STAT_3A	v4l2_fourcc('R', 'K', '1', 'S') /* Rockchip ISP1 3A Statistics */
+ 
+ /* The metadata format identifier for our configuration buffers. */
++/* The metadata format identifier for BE configuration buffers. */
+ #define V4L2_META_FMT_RPI_BE_CFG v4l2_fourcc('R', 'P', 'B', 'C')
+ 
++/* The metadata format identifier for FE configuration buffers. */
++#define V4L2_META_FMT_RPI_FE_CFG v4l2_fourcc('R', 'P', 'F', 'C')
++
++/* The metadata format identifier for FE configuration buffers. */
++#define V4L2_META_FMT_RPI_FE_STATS v4l2_fourcc('R', 'P', 'F', 'S')
++
+ /* priv field value to indicates that subsequent fields are valid. */
+ #define V4L2_PIX_FMT_PRIV_MAGIC		0xfeedcafe
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0869-V4L2-Add-PiSP-compressed-formats-to-V4L2.patch b/target/linux/bcm27xx/patches-6.1/950-0869-V4L2-Add-PiSP-compressed-formats-to-V4L2.patch
new file mode 100644
index 0000000000..6836922b7c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0869-V4L2-Add-PiSP-compressed-formats-to-V4L2.patch
@@ -0,0 +1,39 @@
+From 01f31f4145d49a30eb553c65ea755dde8dba1de0 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Wed, 2 Mar 2022 16:10:50 +0000
+Subject: [PATCH] V4L2: Add PiSP compressed formats to V4L2
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/v4l2-core/v4l2-ioctl.c | 4 ++++
+ include/uapi/linux/videodev2.h       | 6 +++++-
+ 2 files changed, 9 insertions(+), 1 deletion(-)
+
+--- a/drivers/media/v4l2-core/v4l2-ioctl.c
++++ b/drivers/media/v4l2-core/v4l2-ioctl.c
+@@ -1507,6 +1507,10 @@ static void v4l_fill_fmtdesc(struct v4l2
+ 		case V4L2_PIX_FMT_QC08C:	descr = "QCOM Compressed 8-bit Format"; break;
+ 		case V4L2_PIX_FMT_QC10C:	descr = "QCOM Compressed 10-bit Format"; break;
+ 		case V4L2_PIX_FMT_RPI_BE: descr = "PiSP Opaque Format"; break;
++		case V4L2_PIX_FMT_PISP_COMP_RGGB:
++		case V4L2_PIX_FMT_PISP_COMP_GRBG:
++		case V4L2_PIX_FMT_PISP_COMP_GBRG:
++		case V4L2_PIX_FMT_PISP_COMP_BGGR: descr = "PiSP Bayer Compressed Format"; break;
+ 		default:
+ 			if (fmt->description[0])
+ 				return;
+--- a/include/uapi/linux/videodev2.h
++++ b/include/uapi/linux/videodev2.h
+@@ -794,7 +794,11 @@ struct v4l2_pix_format {
+ #define V4L2_PIX_FMT_IPU3_SRGGB10	v4l2_fourcc('i', 'p', '3', 'r') /* IPU3 packed 10-bit RGGB bayer */
+ 
+ /* The pixel format for all our buffers (the precise format is found in the config buffer). */
+-#define V4L2_PIX_FMT_RPI_BE v4l2_fourcc('R', 'P', 'B', 'P')
++#define V4L2_PIX_FMT_RPI_BE		v4l2_fourcc('R', 'P', 'B', 'P')
++#define V4L2_PIX_FMT_PISP_COMP_RGGB	v4l2_fourcc('P', 'C', 'R', 'G')
++#define V4L2_PIX_FMT_PISP_COMP_GRBG	v4l2_fourcc('P', 'C', 'G', 'R')
++#define V4L2_PIX_FMT_PISP_COMP_GBRG	v4l2_fourcc('P', 'C', 'G', 'B')
++#define V4L2_PIX_FMT_PISP_COMP_BGGR	v4l2_fourcc('P', 'C', 'B', 'G')
+ 
+ /* SDR formats - used only for Software Defined Radio devices */
+ #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0870-bcm2708_fb-Fix-more-build-warnings.patch b/target/linux/bcm27xx/patches-6.1/950-0870-bcm2708_fb-Fix-more-build-warnings.patch
new file mode 100644
index 0000000000..693a54db06
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0870-bcm2708_fb-Fix-more-build-warnings.patch
@@ -0,0 +1,43 @@
+From 7b11991e91e65ebeb315986fae05d363663d24c4 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 1 Sep 2022 17:51:54 +0100
+Subject: [PATCH] bcm2708_fb: Fix more build warnings
+
+---
+ drivers/video/fbdev/bcm2708_fb.c | 8 +++++---
+ 1 file changed, 5 insertions(+), 3 deletions(-)
+
+--- a/drivers/video/fbdev/bcm2708_fb.c
++++ b/drivers/video/fbdev/bcm2708_fb.c
+@@ -955,6 +955,7 @@ static void bcm2708_fb_imageblit(struct
+ 	cfb_imageblit(info, image);
+ }
+ 
++#if 0
+ static irqreturn_t bcm2708_fb_dma_irq(int irq, void *cxt)
+ {
+ 	struct bcm2708_fb_dev *fbdev = cxt;
+@@ -972,6 +973,7 @@ static irqreturn_t bcm2708_fb_dma_irq(in
+ 	wake_up(&fbdev->dma_waitq);
+ 	return IRQ_HANDLED;
+ }
++#endif
+ 
+ static struct fb_ops bcm2708_fb_ops = {
+ 	.owner = THIS_MODULE,
+@@ -1195,12 +1197,12 @@ static int bcm2708_fb_probe(struct platf
+ 		return ret;
+ 	}
+ 
+-free_dma_chan:
++//free_dma_chan:
+ 	bcm_dma_chan_free(fbdev->dma_chan);
+-free_cb:
++//free_cb:
+ 	dma_free_wc(&dev->dev, SZ_64K, fbdev->cb_base,
+ 			      fbdev->cb_handle);
+-free_fb:
++//free_fb:
+ 	dev_err(&dev->dev, "probe failed, err %d\n", ret);
+ 
+ 	return ret;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0871-dt-binding-mfd-Add-binding-for-Raspberry-Pi-RP1.patch b/target/linux/bcm27xx/patches-6.1/950-0871-dt-binding-mfd-Add-binding-for-Raspberry-Pi-RP1.patch
new file mode 100644
index 0000000000..9e98dd0345
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0871-dt-binding-mfd-Add-binding-for-Raspberry-Pi-RP1.patch
@@ -0,0 +1,249 @@
+From c93f469dabdbed822e5abeb5283d79fc9faa858c Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 28 Oct 2022 14:10:34 +0100
+Subject: [PATCH] dt-binding: mfd: Add binding for Raspberry Pi RP1
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ include/dt-bindings/mfd/rp1.h | 235 ++++++++++++++++++++++++++++++++++
+ 1 file changed, 235 insertions(+)
+ create mode 100644 include/dt-bindings/mfd/rp1.h
+
+--- /dev/null
++++ b/include/dt-bindings/mfd/rp1.h
+@@ -0,0 +1,235 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * This header provides constants for the PY MFD.
++ */
++
++#ifndef _RP1_H
++#define _RP1_H
++
++/* Address map */
++#define RP1_SYSINFO_BASE 0x000000
++#define RP1_TBMAN_BASE 0x004000
++#define RP1_SYSCFG_BASE 0x008000
++#define RP1_OTP_BASE 0x00c000
++#define RP1_POWER_BASE 0x010000
++#define RP1_RESETS_BASE 0x014000
++#define RP1_CLOCKS_BANK_DEFAULT_BASE 0x018000
++#define RP1_CLOCKS_BANK_VIDEO_BASE 0x01c000
++#define RP1_PLL_SYS_BASE 0x020000
++#define RP1_PLL_AUDIO_BASE 0x024000
++#define RP1_PLL_VIDEO_BASE 0x028000
++#define RP1_UART0_BASE 0x030000
++#define RP1_UART1_BASE 0x034000
++#define RP1_UART2_BASE 0x038000
++#define RP1_UART3_BASE 0x03c000
++#define RP1_UART4_BASE 0x040000
++#define RP1_UART5_BASE 0x044000
++#define RP1_SPI8_BASE 0x04c000
++#define RP1_SPI0_BASE 0x050000
++#define RP1_SPI1_BASE 0x054000
++#define RP1_SPI2_BASE 0x058000
++#define RP1_SPI3_BASE 0x05c000
++#define RP1_SPI4_BASE 0x060000
++#define RP1_SPI5_BASE 0x064000
++#define RP1_SPI6_BASE 0x068000
++#define RP1_SPI7_BASE 0x06c000
++#define RP1_I2C0_BASE 0x070000
++#define RP1_I2C1_BASE 0x074000
++#define RP1_I2C2_BASE 0x078000
++#define RP1_I2C3_BASE 0x07c000
++#define RP1_I2C4_BASE 0x080000
++#define RP1_I2C5_BASE 0x084000
++#define RP1_I2C6_BASE 0x088000
++#define RP1_AUDIO_IN_BASE 0x090000
++#define RP1_AUDIO_OUT_BASE 0x094000
++#define RP1_PWM0_BASE 0x098000
++#define RP1_PWM1_BASE 0x09c000
++#define RP1_I2S0_BASE 0x0a0000
++#define RP1_I2S1_BASE 0x0a4000
++#define RP1_I2S2_BASE 0x0a8000
++#define RP1_TIMER_BASE 0x0ac000
++#define RP1_SDIO0_APBS_BASE 0x0b0000
++#define RP1_SDIO1_APBS_BASE 0x0b4000
++#define RP1_BUSFABRIC_MONITOR_BASE 0x0c0000
++#define RP1_BUSFABRIC_AXISHIM_BASE 0x0c4000
++#define RP1_ADC_BASE 0x0c8000
++#define RP1_IO_BANK0_BASE 0x0d0000
++#define RP1_IO_BANK1_BASE 0x0d4000
++#define RP1_IO_BANK2_BASE 0x0d8000
++#define RP1_SYS_RIO0_BASE 0x0e0000
++#define RP1_SYS_RIO1_BASE 0x0e4000
++#define RP1_SYS_RIO2_BASE 0x0e8000
++#define RP1_PADS_BANK0_BASE 0x0f0000
++#define RP1_PADS_BANK1_BASE 0x0f4000
++#define RP1_PADS_BANK2_BASE 0x0f8000
++#define RP1_PADS_ETH_BASE 0x0fc000
++#define RP1_ETH_IP_BASE 0x100000
++#define RP1_ETH_CFG_BASE 0x104000
++#define RP1_PCIE_APBS_BASE 0x108000
++#define RP1_MIPI0_CSIDMA_BASE 0x110000
++#define RP1_MIPI0_CSIHOST_BASE 0x114000
++#define RP1_MIPI0_DSIDMA_BASE 0x118000
++#define RP1_MIPI0_DSIHOST_BASE 0x11c000
++#define RP1_MIPI0_MIPICFG_BASE 0x120000
++#define RP1_MIPI0_ISP_BASE 0x124000
++#define RP1_MIPI1_CSIDMA_BASE 0x128000
++#define RP1_MIPI1_CSIHOST_BASE 0x12c000
++#define RP1_MIPI1_DSIDMA_BASE 0x130000
++#define RP1_MIPI1_DSIHOST_BASE 0x134000
++#define RP1_MIPI1_MIPICFG_BASE 0x138000
++#define RP1_MIPI1_ISP_BASE 0x13c000
++#define RP1_VIDEO_OUT_CFG_BASE 0x140000
++#define RP1_VIDEO_OUT_VEC_BASE 0x144000
++#define RP1_VIDEO_OUT_DPI_BASE 0x148000
++#define RP1_XOSC_BASE 0x150000
++#define RP1_WATCHDOG_BASE 0x154000
++#define RP1_DMA_TICK_BASE 0x158000
++#define RP1_SDIO_CLOCKS_BASE 0x15c000
++#define RP1_USBHOST0_APBS_BASE 0x160000
++#define RP1_USBHOST1_APBS_BASE 0x164000
++#define RP1_ROSC0_BASE 0x168000
++#define RP1_ROSC1_BASE 0x16c000
++#define RP1_VBUSCTRL_BASE 0x170000
++#define RP1_TICKS_BASE 0x174000
++#define RP1_PIO_APBS_BASE 0x178000
++#define RP1_SDIO0_AHBLS_BASE 0x180000
++#define RP1_SDIO1_AHBLS_BASE 0x184000
++#define RP1_DMA_BASE 0x188000
++#define RP1_RAM_BASE 0x1c0000
++#define RP1_RAM_SIZE 0x020000
++#define RP1_USBHOST0_AXIS_BASE 0x200000
++#define RP1_USBHOST1_AXIS_BASE 0x300000
++#define RP1_EXAC_BASE 0x400000
++
++/* Interrupts */
++
++#define RP1_INT_IO_BANK0 0
++#define RP1_INT_IO_BANK1 1
++#define RP1_INT_IO_BANK2 2
++#define RP1_INT_AUDIO_IN 3
++#define RP1_INT_AUDIO_OUT 4
++#define RP1_INT_PWM0 5
++#define RP1_INT_ETH 6
++#define RP1_INT_I2C0 7
++#define RP1_INT_I2C1 8
++#define RP1_INT_I2C2 9
++#define RP1_INT_I2C3 10
++#define RP1_INT_I2C4 11
++#define RP1_INT_I2C5 12
++#define RP1_INT_I2C6 13
++#define RP1_INT_I2S0 14
++#define RP1_INT_I2S1 15
++#define RP1_INT_I2S2 16
++#define RP1_INT_SDIO0 17
++#define RP1_INT_SDIO1 18
++#define RP1_INT_SPI0 19
++#define RP1_INT_SPI1 20
++#define RP1_INT_SPI2 21
++#define RP1_INT_SPI3 22
++#define RP1_INT_SPI4 23
++#define RP1_INT_SPI5 24
++#define RP1_INT_UART0 25
++#define RP1_INT_TIMER_0 26
++#define RP1_INT_TIMER_1 27
++#define RP1_INT_TIMER_2 28
++#define RP1_INT_TIMER_3 29
++#define RP1_INT_USBHOST0 30
++#define RP1_INT_USBHOST0_0 31
++#define RP1_INT_USBHOST0_1 32
++#define RP1_INT_USBHOST0_2 33
++#define RP1_INT_USBHOST0_3 34
++#define RP1_INT_USBHOST1 35
++#define RP1_INT_USBHOST1_0 36
++#define RP1_INT_USBHOST1_1 37
++#define RP1_INT_USBHOST1_2 38
++#define RP1_INT_USBHOST1_3 39
++#define RP1_INT_DMA 40
++#define RP1_INT_PWM1 41
++#define RP1_INT_UART1 42
++#define RP1_INT_UART2 43
++#define RP1_INT_UART3 44
++#define RP1_INT_UART4 45
++#define RP1_INT_UART5 46
++#define RP1_INT_MIPI0 47
++#define RP1_INT_MIPI1 48
++#define RP1_INT_VIDEO_OUT 49
++#define RP1_INT_PIO_0 50
++#define RP1_INT_PIO_1 51
++#define RP1_INT_ADC_FIFO 52
++#define RP1_INT_PCIE_OUT 53
++#define RP1_INT_SPI6 54
++#define RP1_INT_SPI7 55
++#define RP1_INT_SPI8 56
++#define RP1_INT_SYSCFG 58
++#define RP1_INT_CLOCKS_DEFAULT 59
++#define RP1_INT_VBUSCTRL 60
++#define RP1_INT_PROC_MISC 57
++#define RP1_INT_END 61
++
++/* DMA peripherals (for pacing) */
++#define RP1_DMA_I2C0_RX 0x0
++#define RP1_DMA_I2C0_TX 0x1
++#define RP1_DMA_I2C1_RX 0x2
++#define RP1_DMA_I2C1_TX 0x3
++#define RP1_DMA_I2C2_RX 0x4
++#define RP1_DMA_I2C2_TX 0x5
++#define RP1_DMA_I2C3_RX 0x6
++#define RP1_DMA_I2C3_TX 0x7
++#define RP1_DMA_I2C4_RX 0x8
++#define RP1_DMA_I2C4_TX 0x9
++#define RP1_DMA_I2C5_RX 0xa
++#define RP1_DMA_I2C5_TX 0xb
++#define RP1_DMA_SPI0_RX 0xc
++#define RP1_DMA_SPI0_TX 0xd
++#define RP1_DMA_SPI1_RX 0xe
++#define RP1_DMA_SPI1_TX 0xf
++#define RP1_DMA_SPI2_RX 0x10
++#define RP1_DMA_SPI2_TX 0x11
++#define RP1_DMA_SPI3_RX 0x12
++#define RP1_DMA_SPI3_TX 0x13
++#define RP1_DMA_SPI4_RX 0x14
++#define RP1_DMA_SPI4_TX 0x15
++#define RP1_DMA_SPI5_RX 0x16
++#define RP1_DMA_SPI5_TX 0x17
++#define RP1_DMA_PWM0 0x18
++#define RP1_DMA_UART0_RX 0x19
++#define RP1_DMA_UART0_TX 0x1a
++#define RP1_DMA_AUDIO_IN_CH0 0x1b
++#define RP1_DMA_AUDIO_IN_CH1 0x1c
++#define RP1_DMA_AUDIO_OUT 0x1d
++#define RP1_DMA_PWM1 0x1e
++#define RP1_DMA_I2S0_RX 0x1f
++#define RP1_DMA_I2S0_TX 0x20
++#define RP1_DMA_I2S1_RX 0x21
++#define RP1_DMA_I2S1_TX 0x22
++#define RP1_DMA_I2S2_RX 0x23
++#define RP1_DMA_I2S2_TX 0x24
++#define RP1_DMA_UART1_RX 0x25
++#define RP1_DMA_UART1_TX 0x26
++#define RP1_DMA_UART2_RX 0x27
++#define RP1_DMA_UART2_TX 0x28
++#define RP1_DMA_UART3_RX 0x29
++#define RP1_DMA_UART3_TX 0x2a
++#define RP1_DMA_UART4_RX 0x2b
++#define RP1_DMA_UART4_TX 0x2c
++#define RP1_DMA_UART5_RX 0x2d
++#define RP1_DMA_UART5_TX 0x2e
++#define RP1_DMA_ADC 0x2f
++#define RP1_DMA_DMA_TICK_TICK0 0x30
++#define RP1_DMA_DMA_TICK_TICK1 0x31
++#define RP1_DMA_SPI6_RX 0x32
++#define RP1_DMA_SPI6_TX 0x33
++#define RP1_DMA_SPI7_RX 0x34
++#define RP1_DMA_SPI7_TX 0x35
++#define RP1_DMA_SPI8_RX 0x36
++#define RP1_DMA_SPI8_TX 0x37
++#define RP1_DMA_PIO_CH0_TX 0x38
++#define RP1_DMA_PIO_CH0_RX 0x39
++#define RP1_DMA_PIO_CH1_TX 0x3a
++#define RP1_DMA_PIO_CH1_RX 0x3b
++#define RP1_DMA_PIO_CH2_TX 0x3c
++#define RP1_DMA_PIO_CH2_RX 0x3d
++#define RP1_DMA_PIO_CH3_TX 0x3e
++#define RP1_DMA_PIO_CH3_RX 0x3f
++
++#endif
diff --git a/target/linux/bcm27xx/patches-6.1/950-0872-mfd-Add-rp1-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0872-mfd-Add-rp1-driver.patch
new file mode 100644
index 0000000000..dd252cba36
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0872-mfd-Add-rp1-driver.patch
@@ -0,0 +1,442 @@
+From 7196a12b94e90225686e6c34cdf65a583214f7a5 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 10 Oct 2022 14:21:50 +0100
+Subject: [PATCH] mfd: Add rp1 driver
+
+RP1 is a multifunction PCIe device that exposes a range of
+peripherals.
+Add the parent driver to manage these.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/mfd/Kconfig          |  11 ++
+ drivers/mfd/Makefile         |   1 +
+ drivers/mfd/rp1.c            | 367 +++++++++++++++++++++++++++++++++++
+ include/linux/rp1_platform.h |  20 ++
+ 4 files changed, 399 insertions(+)
+ create mode 100644 drivers/mfd/rp1.c
+ create mode 100644 include/linux/rp1_platform.h
+
+--- a/drivers/mfd/Kconfig
++++ b/drivers/mfd/Kconfig
+@@ -2252,6 +2252,17 @@ config MFD_INTEL_M10_BMC
+ 	  additional drivers must be enabled in order to use the functionality
+ 	  of the device.
+ 
++config MFD_RP1
++	tristate "RP1 MFD driver"
++	depends on PCI
++	select MFD_CORE
++	help
++	  Support for the RP1 peripheral chip.
++
++	  This driver provides support for the Raspberry Pi RP1 peripheral chip.
++	  It is responsible for enabling the Device Tree node once the PCIe endpoint
++	  has been configured, and handling interrupts.
++
+ config MFD_RSMU_I2C
+ 	tristate "Renesas Synchronization Management Unit with I2C"
+ 	depends on I2C && OF
+--- a/drivers/mfd/Makefile
++++ b/drivers/mfd/Makefile
+@@ -273,6 +273,7 @@ obj-$(CONFIG_MFD_RPISENSE_CORE)	+= rpise
+ obj-$(CONFIG_SGI_MFD_IOC3)	+= ioc3.o
+ obj-$(CONFIG_MFD_SIMPLE_MFD_I2C)	+= simple-mfd-i2c.o
+ obj-$(CONFIG_MFD_INTEL_M10_BMC)   += intel-m10-bmc.o
++obj-$(CONFIG_MFD_RP1)		+= rp1.o
+ 
+ obj-$(CONFIG_MFD_ATC260X)	+= atc260x-core.o
+ obj-$(CONFIG_MFD_ATC260X_I2C)	+= atc260x-i2c.o
+--- /dev/null
++++ b/drivers/mfd/rp1.c
+@@ -0,0 +1,367 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2018-22 Raspberry Pi Ltd.
++ * All rights reserved.
++ */
++
++#include <linux/clk.h>
++#include <linux/clkdev.h>
++#include <linux/clk-provider.h>
++#include <linux/completion.h>
++#include <linux/etherdevice.h>
++#include <linux/err.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/irq.h>
++#include <linux/irqchip/chained_irq.h>
++#include <linux/irqdomain.h>
++#include <linux/mfd/core.h>
++#include <linux/mmc/host.h>
++#include <linux/module.h>
++#include <linux/msi.h>
++#include <linux/of_platform.h>
++#include <linux/pci.h>
++#include <linux/platform_device.h>
++#include <linux/rp1_platform.h>
++#include <linux/reset.h>
++#include <linux/slab.h>
++
++#include <dt-bindings/mfd/rp1.h>
++
++/* TO DO:
++ * 1. Occasional shutdown crash - RP1 being closed before its children?
++ * 2. DT mode interrupt handling.
++ */
++
++#define RP1_DRIVER_NAME "rp1"
++
++#define PCI_VENDOR_ID_RPI 0x1de4
++#define PCI_DEVICE_ID_RP1_C0 0x0001
++#define PCI_DEVICE_REV_RP1_C0 2
++
++#define RP1_ACTUAL_IRQS		RP1_INT_END
++#define RP1_IRQS		RP1_ACTUAL_IRQS
++
++#define RP1_SYSCLK_RATE		200000000
++#define RP1_SYSCLK_FPGA_RATE	60000000
++
++// Don't want to include the whole sysinfo reg header
++#define SYSINFO_CHIP_ID_OFFSET	0x00000000
++#define SYSINFO_PLATFORM_OFFSET	0x00000004
++
++#define REG_RW          0x000
++#define REG_SET         0x800
++#define REG_CLR         0xc00
++
++// MSIX CFG registers start at 0x8
++#define MSIX_CFG(x) (0x8 + (4 * (x)))
++
++#define MSIX_CFG_IACK_EN        BIT(3)
++#define MSIX_CFG_IACK           BIT(2)
++#define MSIX_CFG_TEST           BIT(1)
++#define MSIX_CFG_ENABLE         BIT(0)
++
++#define INTSTATL		0x108
++#define INTSTATH		0x10c
++
++struct rp1_dev {
++	struct pci_dev *pdev;
++	struct device *dev;
++	resource_size_t bar_start;
++	resource_size_t bar_end;
++	struct clk *sys_clk;
++	struct irq_domain *domain;
++	struct irq_data *pcie_irqds[64];
++	void __iomem *msix_cfg_regs;
++};
++
++static bool rp1_level_triggered_irq[RP1_ACTUAL_IRQS] = { 0 };
++
++static struct rp1_dev *g_rp1;
++static u32 g_chip_id, g_platform;
++
++static void dump_bar(struct pci_dev *pdev, unsigned int bar)
++{
++	dev_info(&pdev->dev,
++		 "bar%d len 0x%llx, start 0x%llx, end 0x%llx, flags, 0x%lx\n",
++		 bar,
++		 pci_resource_len(pdev, bar),
++		 pci_resource_start(pdev, bar),
++		 pci_resource_end(pdev, bar),
++		 pci_resource_flags(pdev, bar));
++}
++
++static void msix_cfg_set(struct rp1_dev *rp1, unsigned int hwirq, u32 value)
++{
++	writel(value, rp1->msix_cfg_regs + REG_SET + MSIX_CFG(hwirq));
++}
++
++static void msix_cfg_clr(struct rp1_dev *rp1, unsigned int hwirq, u32 value)
++{
++	writel(value, rp1->msix_cfg_regs + REG_CLR + MSIX_CFG(hwirq));
++}
++
++static void rp1_mask_irq(struct irq_data *irqd)
++{
++	struct rp1_dev *rp1 = irqd->domain->host_data;
++	struct irq_data *pcie_irqd = rp1->pcie_irqds[irqd->hwirq];
++
++	pci_msi_mask_irq(pcie_irqd);
++}
++
++static void rp1_unmask_irq(struct irq_data *irqd)
++{
++	struct rp1_dev *rp1 = irqd->domain->host_data;
++	struct irq_data *pcie_irqd = rp1->pcie_irqds[irqd->hwirq];
++
++	pci_msi_unmask_irq(pcie_irqd);
++}
++
++static int rp1_irq_set_type(struct irq_data *irqd, unsigned int type)
++{
++	struct rp1_dev *rp1 = irqd->domain->host_data;
++	unsigned int hwirq = (unsigned int)irqd->hwirq;
++	int ret = 0;
++
++	switch (type) {
++	case IRQ_TYPE_LEVEL_HIGH:
++		dev_dbg(rp1->dev, "MSIX IACK EN for irq %d\n", hwirq);
++		msix_cfg_set(rp1, hwirq, MSIX_CFG_IACK_EN);
++		rp1_level_triggered_irq[hwirq] = true;
++	break;
++	case IRQ_TYPE_EDGE_RISING:
++		msix_cfg_clr(rp1, hwirq, MSIX_CFG_IACK_EN);
++		rp1_level_triggered_irq[hwirq] = false;
++		break;
++	default:
++		ret = -EINVAL;
++		break;
++	}
++
++	return ret;
++}
++
++static struct irq_chip rp1_irq_chip = {
++	.name            = "rp1_irq_chip",
++	.irq_mask        = rp1_mask_irq,
++	.irq_unmask      = rp1_unmask_irq,
++	.irq_set_type    = rp1_irq_set_type,
++};
++
++static void rp1_chained_handle_irq(struct irq_desc *desc)
++{
++	struct irq_chip *chip = irq_desc_get_chip(desc);
++	struct rp1_dev *rp1 = desc->irq_data.chip_data;
++	unsigned int hwirq = desc->irq_data.hwirq & 0x3f;
++	int new_irq;
++
++	rp1 = g_rp1;
++
++	chained_irq_enter(chip, desc);
++
++	new_irq = irq_linear_revmap(rp1->domain, hwirq);
++	generic_handle_irq(new_irq);
++	if (rp1_level_triggered_irq[hwirq])
++		msix_cfg_set(rp1, hwirq, MSIX_CFG_IACK);
++
++	chained_irq_exit(chip, desc);
++}
++
++static int rp1_irq_xlate(struct irq_domain *d, struct device_node *node,
++			 const u32 *intspec, unsigned int intsize,
++			 unsigned long *out_hwirq, unsigned int *out_type)
++{
++	struct rp1_dev *rp1 = d->host_data;
++	struct irq_data *pcie_irqd;
++	unsigned long hwirq;
++	int pcie_irq;
++	int ret;
++
++	ret = irq_domain_xlate_twocell(d, node, intspec, intsize,
++				       &hwirq, out_type);
++	if (!ret) {
++		pcie_irq = pci_irq_vector(rp1->pdev, hwirq);
++		pcie_irqd = irq_get_irq_data(pcie_irq);
++		rp1->pcie_irqds[hwirq] = pcie_irqd;
++		*out_hwirq = hwirq;
++	}
++	return ret;
++}
++
++static int rp1_irq_activate(struct irq_domain *d, struct irq_data *irqd,
++			    bool reserve)
++{
++	struct rp1_dev *rp1 = d->host_data;
++	struct irq_data *pcie_irqd;
++
++	pcie_irqd = rp1->pcie_irqds[irqd->hwirq];
++	msix_cfg_set(rp1, (unsigned int)irqd->hwirq, MSIX_CFG_ENABLE);
++	return irq_domain_activate_irq(pcie_irqd, reserve);
++}
++
++static void rp1_irq_deactivate(struct irq_domain *d, struct irq_data *irqd)
++{
++	struct rp1_dev *rp1 = d->host_data;
++	struct irq_data *pcie_irqd;
++
++	pcie_irqd = rp1->pcie_irqds[irqd->hwirq];
++	msix_cfg_clr(rp1, (unsigned int)irqd->hwirq, MSIX_CFG_ENABLE);
++	return irq_domain_deactivate_irq(pcie_irqd);
++}
++
++static const struct irq_domain_ops rp1_domain_ops = {
++	.xlate      = rp1_irq_xlate,
++	.activate   = rp1_irq_activate,
++	.deactivate = rp1_irq_deactivate,
++};
++
++static inline dma_addr_t rp1_io_to_phys(struct rp1_dev *rp1, unsigned int offset)
++{
++	return rp1->bar_start + offset;
++}
++
++static u32 rp1_reg_read(struct rp1_dev *rp1, unsigned int base_addr, u32 offset)
++{
++	dma_addr_t phys = rp1_io_to_phys(rp1, base_addr);
++	void __iomem *regblock = ioremap(phys, 0x1000);
++	u32 value = readl(regblock + offset);
++
++	iounmap(regblock);
++	return value;
++}
++
++void rp1_get_platform(u32 *chip_id, u32 *platform)
++{
++	if (chip_id)
++		*chip_id = g_chip_id;
++	if (platform)
++		*platform = g_platform;
++}
++EXPORT_SYMBOL_GPL(rp1_get_platform);
++
++static int rp1_probe(struct pci_dev *pdev, const struct pci_device_id *id)
++{
++	struct reset_control *reset;
++	struct platform_device *pcie_pdev;
++	struct device_node *rp1_node;
++	struct rp1_dev *rp1;
++	int err  = 0;
++	int i;
++
++	reset = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);
++	if (IS_ERR(reset))
++		return PTR_ERR(reset);
++	reset_control_reset(reset);
++
++	dump_bar(pdev, 0);
++	dump_bar(pdev, 1);
++
++	if (pci_resource_len(pdev, 1) <= 0x10000) {
++		dev_err(&pdev->dev,
++			"Not initialised - is the firmware running?\n");
++		return -EINVAL;
++	}
++
++	/* enable pci device */
++	err = pcim_enable_device(pdev);
++	if (err < 0) {
++		dev_err(&pdev->dev, "Enabling PCI device has failed: %d",
++			err);
++		return err;
++	}
++
++	pci_set_master(pdev);
++
++	err = pci_alloc_irq_vectors(pdev, RP1_IRQS, RP1_IRQS,
++				    PCI_IRQ_MSIX);
++	if (err != RP1_IRQS) {
++		dev_err(&pdev->dev, "pci_alloc_irq_vectors failed - %d\n", err);
++		return err;
++	}
++
++	rp1 = devm_kzalloc(&pdev->dev, sizeof(*rp1), GFP_KERNEL);
++	if (!rp1)
++		return -ENOMEM;
++
++	rp1->pdev = pdev;
++	rp1->dev = &pdev->dev;
++
++	pci_set_drvdata(pdev, rp1);
++
++	rp1->bar_start = pci_resource_start(pdev, 1);
++	rp1->bar_end = pci_resource_end(pdev, 1);
++
++	// Get chip id
++	g_chip_id = rp1_reg_read(rp1, RP1_SYSINFO_BASE, SYSINFO_CHIP_ID_OFFSET);
++	g_platform = rp1_reg_read(rp1, RP1_SYSINFO_BASE, SYSINFO_PLATFORM_OFFSET);
++	dev_info(&pdev->dev, "chip_id 0x%x%s\n", g_chip_id,
++		 (g_platform & RP1_PLATFORM_FPGA) ? " FPGA" : "");
++	if (g_chip_id != RP1_C0_CHIP_ID) {
++		dev_err(&pdev->dev, "wrong chip id (%x)\n", g_chip_id);
++		return -EINVAL;
++	}
++
++	rp1_node = of_find_node_by_name(NULL, "rp1");
++	if (!rp1_node) {
++		dev_err(&pdev->dev, "failed to find RP1 DT node\n");
++		return -EINVAL;
++	}
++
++	pcie_pdev = of_find_device_by_node(rp1_node->parent);
++	rp1->domain = irq_domain_add_linear(rp1_node, RP1_IRQS,
++					    &rp1_domain_ops, rp1);
++
++	g_rp1 = rp1;
++
++	/* TODO can this go in the rp1 device tree entry? */
++	rp1->msix_cfg_regs = ioremap(rp1_io_to_phys(rp1, RP1_PCIE_APBS_BASE), 0x1000);
++
++	for (i = 0; i < RP1_IRQS; i++) {
++		int irq = irq_create_mapping(rp1->domain, i);
++
++		if (irq < 0) {
++			dev_err(&pdev->dev, "failed to create irq mapping\n");
++			return irq;
++		}
++
++		irq_set_chip_data(irq, rp1);
++		irq_set_chip_and_handler(irq, &rp1_irq_chip, handle_level_irq);
++		irq_set_probe(irq);
++		irq_set_chained_handler(pci_irq_vector(pdev, i),
++					rp1_chained_handle_irq);
++	}
++
++	if (rp1_node)
++		of_platform_populate(rp1_node, NULL, NULL, &pcie_pdev->dev);
++
++	of_node_put(rp1_node);
++
++	return 0;
++}
++
++static void rp1_remove(struct pci_dev *pdev)
++{
++	struct rp1_dev *rp1 = pci_get_drvdata(pdev);
++
++	mfd_remove_devices(&pdev->dev);
++
++	clk_unregister(rp1->sys_clk);
++}
++
++static const struct pci_device_id dev_id_table[] = {
++	{ PCI_DEVICE(PCI_VENDOR_ID_RPI, PCI_DEVICE_ID_RP1_C0), },
++	{ 0, }
++};
++
++static struct pci_driver rp1_driver = {
++	.name		= RP1_DRIVER_NAME,
++	.id_table	= dev_id_table,
++	.probe		= rp1_probe,
++	.remove		= rp1_remove,
++};
++
++module_pci_driver(rp1_driver);
++
++MODULE_AUTHOR("Phil Elwell <phil@raspberrypi.com>");
++MODULE_DESCRIPTION("RP1 wrapper");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/include/linux/rp1_platform.h
+@@ -0,0 +1,20 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Copyright (c) 2021-2022 Raspberry Pi Ltd.
++ * All rights reserved.
++ */
++
++#ifndef _RP1_PLATFORM_H
++#define _RP1_PLATFORM_H
++
++#include <vdso/bits.h>
++
++#define RP1_B0_CHIP_ID 0x10001927
++#define RP1_C0_CHIP_ID 0x20001927
++
++#define RP1_PLATFORM_ASIC BIT(1)
++#define RP1_PLATFORM_FPGA BIT(0)
++
++void rp1_get_platform(u32 *chip_id, u32 *platform);
++
++#endif
diff --git a/target/linux/bcm27xx/patches-6.1/950-0873-dt-bindings-clock-Add-bindings-for-Raspberry-Pi-RP1.patch b/target/linux/bcm27xx/patches-6.1/950-0873-dt-bindings-clock-Add-bindings-for-Raspberry-Pi-RP1.patch
new file mode 100644
index 0000000000..f94782438b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0873-dt-bindings-clock-Add-bindings-for-Raspberry-Pi-RP1.patch
@@ -0,0 +1,65 @@
+From 00ff2819eb852b54fe22e7181646e40d560576dc Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 28 Oct 2022 14:12:18 +0100
+Subject: [PATCH] dt-bindings: clock: Add bindings for Raspberry Pi RP1
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ include/dt-bindings/clock/rp1.h | 51 +++++++++++++++++++++++++++++++++
+ 1 file changed, 51 insertions(+)
+ create mode 100644 include/dt-bindings/clock/rp1.h
+
+--- /dev/null
++++ b/include/dt-bindings/clock/rp1.h
+@@ -0,0 +1,51 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Copyright (C) 2021 Raspberry Pi Ltd.
++ */
++
++#define RP1_PLL_SYS_CORE		0
++#define RP1_PLL_AUDIO_CORE		1
++#define RP1_PLL_VIDEO_CORE		2
++
++#define RP1_PLL_SYS			3
++#define RP1_PLL_AUDIO			4
++#define RP1_PLL_VIDEO			5
++
++#define RP1_PLL_SYS_PRI_PH		6
++#define RP1_PLL_SYS_SEC_PH		7
++
++#define RP1_PLL_SYS_SEC			8
++#define RP1_PLL_AUDIO_SEC		9
++#define RP1_PLL_VIDEO_SEC		10
++
++#define RP1_CLK_SYS			11
++#define RP1_CLK_SLOW_SYS		12
++#define RP1_CLK_DMA			13
++#define RP1_CLK_UART			14
++#define RP1_CLK_ETH			15
++#define RP1_CLK_PWM0			16
++#define RP1_CLK_PWM1			17
++#define RP1_CLK_AUDIO_IN		18
++#define RP1_CLK_AUDIO_OUT		19
++#define RP1_CLK_I2S			20
++#define RP1_CLK_MIPI0_CFG		21
++#define RP1_CLK_MIPI1_CFG		22
++#define RP1_CLK_PCIE_AUX		23
++#define RP1_CLK_USBH0_MICROFRAME	24
++#define RP1_CLK_USBH1_MICROFRAME	25
++#define RP1_CLK_USBH0_SUSPEND		26
++#define RP1_CLK_USBH1_SUSPEND		27
++#define RP1_CLK_ETH_TSU			28
++#define RP1_CLK_ADC			29
++#define RP1_CLK_SDIO_TIMER		30
++#define RP1_CLK_SDIO_ALT_SRC		31
++#define RP1_CLK_GP0			32
++#define RP1_CLK_GP1			33
++#define RP1_CLK_GP2			34
++#define RP1_CLK_GP3			35
++#define RP1_CLK_GP4			36
++#define RP1_CLK_GP5			37
++#define RP1_CLK_VEC			38
++#define RP1_CLK_DPI			39
++#define RP1_CLK_MIPI0_DPI		40
++#define RP1_CLK_MIPI1_DPI		41
diff --git a/target/linux/bcm27xx/patches-6.1/950-0874-clk-Add-rp1-clock-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0874-clk-Add-rp1-clock-driver.patch
new file mode 100644
index 0000000000..2a861d18c7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0874-clk-Add-rp1-clock-driver.patch
@@ -0,0 +1,2208 @@
+From 66517cdfea750b89d86f78af55ef773cbd3e005f Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 10 Oct 2022 14:25:38 +0100
+Subject: [PATCH] clk: Add rp1 clock driver
+
+RP1 contains various PLLs and clocks for driving the hardware
+blocks, so add a driver to configure these.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/clk/Kconfig             |    7 +
+ drivers/clk/Makefile            |    1 +
+ drivers/clk/clk-rp1.c           | 2085 +++++++++++++++++++++++++++++++
+ include/dt-bindings/clock/rp1.h |   69 +-
+ 4 files changed, 2128 insertions(+), 34 deletions(-)
+ create mode 100644 drivers/clk/clk-rp1.c
+
+--- a/drivers/clk/Kconfig
++++ b/drivers/clk/Kconfig
+@@ -89,6 +89,13 @@ config COMMON_CLK_RK808
+ 	  These multi-function devices have two fixed-rate oscillators, clocked at 32KHz each.
+ 	  Clkout1 is always on, Clkout2 can off by control register.
+ 
++config COMMON_CLK_RP1
++	tristate "Raspberry Pi RP1-based clock support"
++	depends on PCI || COMPILE_TEST
++	depends on COMMON_CLK
++	help
++	  Enable common clock framework support for Raspberry Pi RP1
++
+ config COMMON_CLK_HI655X
+ 	tristate "Clock driver for Hi655x" if EXPERT
+ 	depends on (MFD_HI655X_PMIC || COMPILE_TEST)
+--- a/drivers/clk/Makefile
++++ b/drivers/clk/Makefile
+@@ -58,6 +58,7 @@ obj-$(CONFIG_CLK_LS1028A_PLLDIG)	+= clk-
+ obj-$(CONFIG_COMMON_CLK_PWM)		+= clk-pwm.o
+ obj-$(CONFIG_CLK_QORIQ)			+= clk-qoriq.o
+ obj-$(CONFIG_COMMON_CLK_RK808)		+= clk-rk808.o
++obj-$(CONFIG_COMMON_CLK_RP1)		+= clk-rp1.o
+ obj-$(CONFIG_COMMON_CLK_HI655X)		+= clk-hi655x.o
+ obj-$(CONFIG_COMMON_CLK_S2MPS11)	+= clk-s2mps11.o
+ obj-$(CONFIG_COMMON_CLK_SCMI)           += clk-scmi.o
+--- /dev/null
++++ b/drivers/clk/clk-rp1.c
+@@ -0,0 +1,2085 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Copyright (C) 2023 Raspberry Pi Ltd.
++ *
++ * Clock driver for RP1 PCIe multifunction chip.
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/clkdev.h>
++#include <linux/clk.h>
++#include <linux/debugfs.h>
++#include <linux/delay.h>
++#include <linux/io.h>
++#include <linux/math64.h>
++#include <linux/module.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/rp1_platform.h>
++#include <linux/slab.h>
++
++#include <asm/div64.h>
++
++#include <dt-bindings/clock/rp1.h>
++
++#define PLL_SYS_CS			0x08000
++#define PLL_SYS_PWR			0x08004
++#define PLL_SYS_FBDIV_INT		0x08008
++#define PLL_SYS_FBDIV_FRAC		0x0800c
++#define PLL_SYS_PRIM			0x08010
++#define PLL_SYS_SEC			0x08014
++
++#define PLL_AUDIO_CS			0x0c000
++#define PLL_AUDIO_PWR			0x0c004
++#define PLL_AUDIO_FBDIV_INT		0x0c008
++#define PLL_AUDIO_FBDIV_FRAC		0x0c00c
++#define PLL_AUDIO_PRIM			0x0c010
++#define PLL_AUDIO_SEC			0x0c014
++
++#define PLL_VIDEO_CS			0x10000
++#define PLL_VIDEO_PWR			0x10004
++#define PLL_VIDEO_FBDIV_INT		0x10008
++#define PLL_VIDEO_FBDIV_FRAC		0x1000c
++#define PLL_VIDEO_PRIM			0x10010
++#define PLL_VIDEO_SEC			0x10014
++
++#define CLK_SYS_CTRL			0x00014
++#define CLK_SYS_DIV_INT			0x00018
++#define CLK_SYS_SEL			0x00020
++
++#define CLK_SLOW_SYS_CTRL		0x00024
++#define CLK_SLOW_SYS_DIV_INT		0x00028
++#define CLK_SLOW_SYS_SEL		0x00030
++
++#define CLK_DMA_CTRL			0x00044
++#define CLK_DMA_DIV_INT			0x00048
++#define CLK_DMA_SEL			0x00050
++
++#define CLK_UART_CTRL			0x00054
++#define CLK_UART_DIV_INT		0x00058
++#define CLK_UART_SEL			0x00060
++
++#define CLK_ETH_CTRL			0x00064
++#define CLK_ETH_DIV_INT			0x00068
++#define CLK_ETH_SEL			0x00070
++
++#define CLK_PWM0_CTRL			0x00074
++#define CLK_PWM0_DIV_INT		0x00078
++#define CLK_PWM0_DIV_FRAC		0x0007c
++#define CLK_PWM0_SEL			0x00080
++
++#define CLK_PWM1_CTRL			0x00084
++#define CLK_PWM1_DIV_INT		0x00088
++#define CLK_PWM1_DIV_FRAC		0x0008c
++#define CLK_PWM1_SEL			0x00090
++
++#define CLK_AUDIO_IN_CTRL		0x00094
++#define CLK_AUDIO_IN_DIV_INT		0x00098
++#define CLK_AUDIO_IN_SEL		0x000a0
++
++#define CLK_AUDIO_OUT_CTRL		0x000a4
++#define CLK_AUDIO_OUT_DIV_INT		0x000a8
++#define CLK_AUDIO_OUT_SEL		0x000b0
++
++#define CLK_I2S_CTRL			0x000b4
++#define CLK_I2S_DIV_INT			0x000b8
++#define CLK_I2S_SEL			0x000c0
++
++#define CLK_MIPI0_CFG_CTRL		0x000c4
++#define CLK_MIPI0_CFG_DIV_INT		0x000c8
++#define CLK_MIPI0_CFG_SEL		0x000d0
++
++#define CLK_MIPI1_CFG_CTRL		0x000d4
++#define CLK_MIPI1_CFG_DIV_INT		0x000d8
++#define CLK_MIPI1_CFG_SEL		0x000e0
++
++#define CLK_PCIE_AUX_CTRL		0x000e4
++#define CLK_PCIE_AUX_DIV_INT		0x000e8
++#define CLK_PCIE_AUX_SEL		0x000f0
++
++#define CLK_USBH0_MICROFRAME_CTRL	0x000f4
++#define CLK_USBH0_MICROFRAME_DIV_INT	0x000f8
++#define CLK_USBH0_MICROFRAME_SEL	0x00100
++
++#define CLK_USBH1_MICROFRAME_CTRL	0x00104
++#define CLK_USBH1_MICROFRAME_DIV_INT	0x00108
++#define CLK_USBH1_MICROFRAME_SEL	0x00110
++
++#define CLK_USBH0_SUSPEND_CTRL		0x00114
++#define CLK_USBH0_SUSPEND_DIV_INT	0x00118
++#define CLK_USBH0_SUSPEND_SEL		0x00120
++
++#define CLK_USBH1_SUSPEND_CTRL		0x00124
++#define CLK_USBH1_SUSPEND_DIV_INT	0x00128
++#define CLK_USBH1_SUSPEND_SEL		0x00130
++
++#define CLK_ETH_TSU_CTRL		0x00134
++#define CLK_ETH_TSU_DIV_INT		0x00138
++#define CLK_ETH_TSU_SEL			0x00140
++
++#define CLK_ADC_CTRL			0x00144
++#define CLK_ADC_DIV_INT			0x00148
++#define CLK_ADC_SEL			0x00150
++
++#define CLK_SDIO_TIMER_CTRL		0x00154
++#define CLK_SDIO_TIMER_DIV_INT		0x00158
++#define CLK_SDIO_TIMER_SEL		0x00160
++
++#define CLK_SDIO_ALT_SRC_CTRL		0x00164
++#define CLK_SDIO_ALT_SRC_DIV_INT	0x00168
++#define CLK_SDIO_ALT_SRC_SEL		0x00170
++
++#define CLK_GP0_CTRL			0x00174
++#define CLK_GP0_DIV_INT			0x00178
++#define CLK_GP0_DIV_FRAC		0x0017c
++#define CLK_GP0_SEL			0x00180
++
++#define CLK_GP1_CTRL			0x00184
++#define CLK_GP1_DIV_INT			0x00188
++#define CLK_GP1_DIV_FRAC		0x0018c
++#define CLK_GP1_SEL			0x00190
++
++#define CLK_GP2_CTRL			0x00194
++#define CLK_GP2_DIV_INT			0x00198
++#define CLK_GP2_DIV_FRAC		0x0019c
++#define CLK_GP2_SEL			0x001a0
++
++#define CLK_GP3_CTRL			0x001a4
++#define CLK_GP3_DIV_INT			0x001a8
++#define CLK_GP3_DIV_FRAC		0x001ac
++#define CLK_GP3_SEL			0x001b0
++
++#define CLK_GP4_CTRL			0x001b4
++#define CLK_GP4_DIV_INT			0x001b8
++#define CLK_GP4_DIV_FRAC		0x001bc
++#define CLK_GP4_SEL			0x001c0
++
++#define CLK_GP5_CTRL			0x001c4
++#define CLK_GP5_DIV_INT			0x001c8
++#define CLK_GP5_DIV_FRAC		0x001cc
++#define CLK_GP5_SEL			0x001d0
++
++#define CLK_SYS_RESUS_CTRL		0x0020c
++
++#define CLK_SLOW_SYS_RESUS_CTRL		0x00214
++
++#define FC0_REF_KHZ			0x0021c
++#define FC0_MIN_KHZ			0x00220
++#define FC0_MAX_KHZ			0x00224
++#define FC0_DELAY			0x00228
++#define FC0_INTERVAL			0x0022c
++#define FC0_SRC				0x00230
++#define FC0_STATUS			0x00234
++#define FC0_RESULT			0x00238
++#define FC_SIZE				0x20
++#define FC_COUNT			8
++#define FC_NUM(idx, off)		((idx) * 32 + (off))
++
++#define AUX_SEL				1
++
++#define VIDEO_CLOCKS_OFFSET		0x4000
++#define VIDEO_CLK_VEC_CTRL		(VIDEO_CLOCKS_OFFSET + 0x0000)
++#define VIDEO_CLK_VEC_DIV_INT		(VIDEO_CLOCKS_OFFSET + 0x0004)
++#define VIDEO_CLK_VEC_SEL		(VIDEO_CLOCKS_OFFSET + 0x000c)
++#define VIDEO_CLK_DPI_CTRL		(VIDEO_CLOCKS_OFFSET + 0x0010)
++#define VIDEO_CLK_DPI_DIV_INT		(VIDEO_CLOCKS_OFFSET + 0x0014)
++#define VIDEO_CLK_DPI_SEL		(VIDEO_CLOCKS_OFFSET + 0x001c)
++#define VIDEO_CLK_MIPI0_DPI_CTRL	(VIDEO_CLOCKS_OFFSET + 0x0020)
++#define VIDEO_CLK_MIPI0_DPI_DIV_INT	(VIDEO_CLOCKS_OFFSET + 0x0024)
++#define VIDEO_CLK_MIPI0_DPI_DIV_FRAC	(VIDEO_CLOCKS_OFFSET + 0x0028)
++#define VIDEO_CLK_MIPI0_DPI_SEL		(VIDEO_CLOCKS_OFFSET + 0x002c)
++#define VIDEO_CLK_MIPI1_DPI_CTRL	(VIDEO_CLOCKS_OFFSET + 0x0030)
++#define VIDEO_CLK_MIPI1_DPI_DIV_INT	(VIDEO_CLOCKS_OFFSET + 0x0034)
++#define VIDEO_CLK_MIPI1_DPI_DIV_FRAC	(VIDEO_CLOCKS_OFFSET + 0x0038)
++#define VIDEO_CLK_MIPI1_DPI_SEL		(VIDEO_CLOCKS_OFFSET + 0x003c)
++
++#define DIV_INT_8BIT_MAX		0x000000ffu /* max divide for most clocks */
++#define DIV_INT_16BIT_MAX		0x0000ffffu /* max divide for GPx, PWM */
++#define DIV_INT_24BIT_MAX               0x00ffffffu /* max divide for CLK_SYS */
++
++#define FC0_STATUS_DONE			BIT(4)
++#define FC0_STATUS_RUNNING		BIT(8)
++#define FC0_RESULT_FRAC_SHIFT		5
++
++#define PLL_PRIM_DIV1_SHIFT		16
++#define PLL_PRIM_DIV1_MASK		0x00070000
++#define PLL_PRIM_DIV2_SHIFT		12
++#define PLL_PRIM_DIV2_MASK		0x00007000
++
++#define PLL_SEC_DIV_SHIFT		8
++#define PLL_SEC_DIV_WIDTH		5
++#define PLL_SEC_DIV_MASK		0x00001f00
++
++#define PLL_CS_LOCK			BIT(31)
++#define PLL_CS_REFDIV_SHIFT		0
++
++#define PLL_PWR_PD			BIT(0)
++#define PLL_PWR_DACPD			BIT(1)
++#define PLL_PWR_DSMPD			BIT(2)
++#define PLL_PWR_POSTDIVPD		BIT(3)
++#define PLL_PWR_4PHASEPD		BIT(4)
++#define PLL_PWR_VCOPD			BIT(5)
++#define PLL_PWR_MASK			0x0000003f
++
++#define PLL_SEC_RST			BIT(16)
++#define PLL_SEC_IMPL			BIT(31)
++
++/* PLL phase output for both PRI and SEC */
++#define PLL_PH_EN			BIT(4)
++#define PLL_PH_PHASE_SHIFT		0
++
++#define RP1_PLL_PHASE_0			0
++#define RP1_PLL_PHASE_90		1
++#define RP1_PLL_PHASE_180		2
++#define RP1_PLL_PHASE_270		3
++
++/* Clock fields for all clocks */
++#define CLK_CTRL_ENABLE			BIT(11)
++#define CLK_CTRL_AUXSRC_MASK		0x000003e0
++#define CLK_CTRL_AUXSRC_SHIFT		5
++#define CLK_CTRL_SRC_SHIFT		0
++#define CLK_DIV_FRAC_BITS		16
++
++#define KHz				1000
++#define MHz				(KHz * KHz)
++#define LOCK_TIMEOUT_NS			100000000
++#define FC_TIMEOUT_NS			100000000
++
++#define MAX_CLK_PARENTS	8
++
++#define MEASURE_CLOCK_RATE
++const char * const fc0_ref_clk_name = "clk_slow_sys";
++
++#define ABS_DIFF(a, b) ((a) > (b) ? (a) - (b) : (b) - (a))
++#define DIV_U64_NEAREST(a, b) div_u64(((a) + ((b) >> 1)), (b))
++
++/*
++ * Names of the reference clock for the pll cores.  This name must match
++ * the DT reference clock-output-name.
++ */
++static const char *const ref_clock = "xosc";
++
++/*
++ * Secondary PLL channel output divider table.
++ * Divider values range from 8 to 19.
++ * Invalid values default to 19
++ */
++static const struct clk_div_table pll_sec_div_table[] = {
++	{ 0x00, 19 },
++	{ 0x01, 19 },
++	{ 0x02, 19 },
++	{ 0x03, 19 },
++	{ 0x04, 19 },
++	{ 0x05, 19 },
++	{ 0x06, 19 },
++	{ 0x07, 19 },
++	{ 0x08,  8 },
++	{ 0x09,  9 },
++	{ 0x0a, 10 },
++	{ 0x0b, 11 },
++	{ 0x0c, 12 },
++	{ 0x0d, 13 },
++	{ 0x0e, 14 },
++	{ 0x0f, 15 },
++	{ 0x10, 16 },
++	{ 0x11, 17 },
++	{ 0x12, 18 },
++	{ 0x13, 19 },
++	{ 0x14, 19 },
++	{ 0x15, 19 },
++	{ 0x16, 19 },
++	{ 0x17, 19 },
++	{ 0x18, 19 },
++	{ 0x19, 19 },
++	{ 0x1a, 19 },
++	{ 0x1b, 19 },
++	{ 0x1c, 19 },
++	{ 0x1d, 19 },
++	{ 0x1e, 19 },
++	{ 0x1f, 19 },
++	{ 0 }
++};
++
++struct rp1_clockman {
++	struct device *dev;
++	void __iomem *regs;
++	spinlock_t regs_lock; /* spinlock for all clocks */
++
++	/* Must be last */
++	struct clk_hw_onecell_data onecell;
++};
++
++struct rp1_pll_core_data {
++	const char *name;
++	u32 cs_reg;
++	u32 pwr_reg;
++	u32 fbdiv_int_reg;
++	u32 fbdiv_frac_reg;
++	unsigned long flags;
++	u32 fc0_src;
++};
++
++struct rp1_pll_data {
++	const char *name;
++	const char *source_pll;
++	u32 ctrl_reg;
++	unsigned long flags;
++	u32 fc0_src;
++};
++
++struct rp1_pll_ph_data {
++	const char *name;
++	const char *source_pll;
++	unsigned int phase;
++	unsigned int fixed_divider;
++	u32 ph_reg;
++	unsigned long flags;
++	u32 fc0_src;
++};
++
++struct rp1_pll_divider_data {
++	const char *name;
++	const char *source_pll;
++	u32 sec_reg;
++	unsigned long flags;
++	u32 fc0_src;
++};
++
++struct rp1_clock_data {
++	const char *name;
++	const char *const parents[MAX_CLK_PARENTS];
++	int num_std_parents;
++	int num_aux_parents;
++	unsigned long flags;
++	u32 clk_src_mask;
++	u32 ctrl_reg;
++	u32 div_int_reg;
++	u32 div_frac_reg;
++	u32 sel_reg;
++	u32 div_int_max;
++	u32 fc0_src;
++};
++
++struct rp1_pll_core {
++	struct clk_hw hw;
++	struct rp1_clockman *clockman;
++	const struct rp1_pll_core_data *data;
++	unsigned long cached_rate;
++};
++
++struct rp1_pll {
++	struct clk_hw hw;
++	struct clk_divider div;
++	struct rp1_clockman *clockman;
++	const struct rp1_pll_data *data;
++	unsigned long cached_rate;
++};
++
++struct rp1_pll_ph {
++	struct clk_hw hw;
++	struct rp1_clockman *clockman;
++	const struct rp1_pll_ph_data *data;
++};
++
++struct rp1_clock {
++	struct clk_hw hw;
++	struct rp1_clockman *clockman;
++	const struct rp1_clock_data *data;
++	unsigned long cached_rate;
++};
++
++static void rp1_debugfs_regset(struct rp1_clockman *clockman, u32 base,
++			       const struct debugfs_reg32 *regs,
++			       size_t nregs, struct dentry *dentry)
++{
++	struct debugfs_regset32 *regset;
++
++	regset = devm_kzalloc(clockman->dev, sizeof(*regset), GFP_KERNEL);
++	if (!regset)
++		return;
++
++	regset->regs = regs;
++	regset->nregs = nregs;
++	regset->base = clockman->regs + base;
++
++	debugfs_create_regset32("regdump", 0444, dentry, regset);
++}
++
++static inline u32 set_register_field(u32 reg, u32 val, u32 mask, u32 shift)
++{
++	reg &= ~mask;
++	reg |= (val << shift) & mask;
++	return reg;
++}
++
++static inline
++void clockman_write(struct rp1_clockman *clockman, u32 reg, u32 val)
++{
++	writel(val, clockman->regs + reg);
++}
++
++static inline u32 clockman_read(struct rp1_clockman *clockman, u32 reg)
++{
++	return readl(clockman->regs + reg);
++}
++
++#ifdef MEASURE_CLOCK_RATE
++static unsigned long clockman_measure_clock(struct rp1_clockman *clockman,
++					    const char *clk_name,
++					    unsigned int fc0_src)
++{
++	struct clk *ref_clk = __clk_lookup(fc0_ref_clk_name);
++	unsigned long result;
++	ktime_t timeout;
++	unsigned int fc_idx, fc_offset, fc_src;
++
++	fc_idx = fc0_src / 32;
++	fc_src = fc0_src % 32;
++
++	/* fc_src == 0 is invalid. */
++	if (!fc_src || fc_idx >= FC_COUNT)
++		return 0;
++
++	fc_offset = fc_idx * FC_SIZE;
++
++	/* Ensure the frequency counter is idle. */
++	timeout = ktime_add_ns(ktime_get(), FC_TIMEOUT_NS);
++	while (clockman_read(clockman, fc_offset + FC0_STATUS) & FC0_STATUS_RUNNING) {
++		if (ktime_after(ktime_get(), timeout)) {
++			dev_err(clockman->dev, "%s: FC0 busy timeout\n",
++				clk_name);
++			return 0;
++		}
++		cpu_relax();
++	}
++
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, fc_offset + FC0_REF_KHZ,
++		       clk_get_rate(ref_clk) / KHz);
++	clockman_write(clockman, fc_offset + FC0_MIN_KHZ, 0);
++	clockman_write(clockman, fc_offset + FC0_MAX_KHZ, 0x1ffffff);
++	clockman_write(clockman, fc_offset + FC0_INTERVAL, 8);
++	clockman_write(clockman, fc_offset + FC0_DELAY, 7);
++	clockman_write(clockman, fc_offset + FC0_SRC, fc_src);
++	spin_unlock(&clockman->regs_lock);
++
++	/* Ensure the frequency counter is idle. */
++	timeout = ktime_add_ns(ktime_get(), FC_TIMEOUT_NS);
++	while (!(clockman_read(clockman, fc_offset + FC0_STATUS) & FC0_STATUS_DONE)) {
++		if (ktime_after(ktime_get(), timeout)) {
++			dev_err(clockman->dev, "%s: FC0 wait timeout\n",
++				clk_name);
++			return 0;
++		}
++		cpu_relax();
++	}
++
++	result = clockman_read(clockman, fc_offset + FC0_RESULT);
++
++	/* Disable FC0 */
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, fc_offset + FC0_SRC, 0);
++	spin_unlock(&clockman->regs_lock);
++
++	return result;
++}
++#endif
++
++static int rp1_pll_core_is_on(struct clk_hw *hw)
++{
++	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
++	struct rp1_clockman *clockman = pll_core->clockman;
++	const struct rp1_pll_core_data *data = pll_core->data;
++	u32 pwr = clockman_read(clockman, data->pwr_reg);
++
++	return (pwr & PLL_PWR_PD) || (pwr & PLL_PWR_POSTDIVPD);
++}
++
++static int rp1_pll_core_on(struct clk_hw *hw)
++{
++	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
++	struct rp1_clockman *clockman = pll_core->clockman;
++	const struct rp1_pll_core_data *data = pll_core->data;
++	u32 fbdiv_frac;
++	ktime_t timeout;
++
++	spin_lock(&clockman->regs_lock);
++
++	if (!(clockman_read(clockman, data->cs_reg) & PLL_CS_LOCK)) {
++		/* Reset to a known state. */
++		clockman_write(clockman, data->pwr_reg, PLL_PWR_MASK);
++		clockman_write(clockman, data->fbdiv_int_reg, 20);
++		clockman_write(clockman, data->fbdiv_frac_reg, 0);
++		clockman_write(clockman, data->cs_reg, 1 << PLL_CS_REFDIV_SHIFT);
++	}
++
++	/* Come out of reset. */
++	fbdiv_frac = clockman_read(clockman, data->fbdiv_frac_reg);
++	clockman_write(clockman, data->pwr_reg, fbdiv_frac ? 0 : PLL_PWR_DSMPD);
++	spin_unlock(&clockman->regs_lock);
++
++	/* Wait for the PLL to lock. */
++	timeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);
++	while (!(clockman_read(clockman, data->cs_reg) & PLL_CS_LOCK)) {
++		if (ktime_after(ktime_get(), timeout)) {
++			dev_err(clockman->dev, "%s: can't lock PLL\n",
++				clk_hw_get_name(hw));
++			return -ETIMEDOUT;
++		}
++		cpu_relax();
++	}
++
++	return 0;
++}
++
++static void rp1_pll_core_off(struct clk_hw *hw)
++{
++	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
++	struct rp1_clockman *clockman = pll_core->clockman;
++	const struct rp1_pll_core_data *data = pll_core->data;
++
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, data->pwr_reg, 0);
++	spin_unlock(&clockman->regs_lock);
++}
++
++static inline unsigned long get_pll_core_divider(struct clk_hw *hw,
++						 unsigned long rate,
++						 unsigned long parent_rate,
++						 u32 *div_int, u32 *div_frac)
++{
++	unsigned long calc_rate;
++	u32 fbdiv_int, fbdiv_frac;
++	u64 div_fp64; /* 32.32 fixed point fraction. */
++
++	/* Factor of reference clock to VCO frequency. */
++	div_fp64 = (u64)(rate) << 32;
++	div_fp64 = DIV_U64_NEAREST(div_fp64, parent_rate);
++
++	/* Round the fractional component at 24 bits. */
++	div_fp64 += 1 << (32 - 24 - 1);
++
++	fbdiv_int = div_fp64 >> 32;
++	fbdiv_frac = (div_fp64 >> (32 - 24)) & 0xffffff;
++
++	calc_rate =
++		((u64)parent_rate * (((u64)fbdiv_int << 24) + fbdiv_frac) + (1 << 23)) >> 24;
++
++	*div_int = fbdiv_int;
++	*div_frac = fbdiv_frac;
++
++	return calc_rate;
++}
++
++static int rp1_pll_core_set_rate(struct clk_hw *hw,
++				 unsigned long rate, unsigned long parent_rate)
++{
++	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
++	struct rp1_clockman *clockman = pll_core->clockman;
++	const struct rp1_pll_core_data *data = pll_core->data;
++	unsigned long calc_rate;
++	u32 fbdiv_int, fbdiv_frac;
++
++	// todo: is this needed??
++	//rp1_pll_off(hw);
++
++	/* Disable dividers to start with. */
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, data->fbdiv_int_reg, 0);
++	clockman_write(clockman, data->fbdiv_frac_reg, 0);
++	spin_unlock(&clockman->regs_lock);
++
++	calc_rate = get_pll_core_divider(hw, rate, parent_rate,
++					 &fbdiv_int, &fbdiv_frac);
++
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, data->pwr_reg, fbdiv_frac ? 0 : PLL_PWR_DSMPD);
++	clockman_write(clockman, data->fbdiv_int_reg, fbdiv_int);
++	clockman_write(clockman, data->fbdiv_frac_reg, fbdiv_frac);
++	spin_unlock(&clockman->regs_lock);
++
++	/* Check that reference frequency is no greater than VCO / 16. */
++	BUG_ON(parent_rate > (rate / 16));
++
++	pll_core->cached_rate = calc_rate;
++
++	spin_lock(&clockman->regs_lock);
++	/* Don't need to divide ref unless parent_rate > (output freq / 16) */
++	clockman_write(clockman, data->cs_reg,
++		       clockman_read(clockman, data->cs_reg) |
++				     (1 << PLL_CS_REFDIV_SHIFT));
++	spin_unlock(&clockman->regs_lock);
++
++	return 0;
++}
++
++static unsigned long rp1_pll_core_recalc_rate(struct clk_hw *hw,
++					      unsigned long parent_rate)
++{
++	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
++	struct rp1_clockman *clockman = pll_core->clockman;
++	const struct rp1_pll_core_data *data = pll_core->data;
++	u32 fbdiv_int, fbdiv_frac;
++	unsigned long calc_rate;
++
++	fbdiv_int = clockman_read(clockman, data->fbdiv_int_reg);
++	fbdiv_frac = clockman_read(clockman, data->fbdiv_frac_reg);
++	calc_rate =
++		((u64)parent_rate * (((u64)fbdiv_int << 24) + fbdiv_frac) + (1 << 23)) >> 24;
++
++	return calc_rate;
++}
++
++static long rp1_pll_core_round_rate(struct clk_hw *hw, unsigned long rate,
++				    unsigned long *parent_rate)
++{
++	u32 fbdiv_int, fbdiv_frac;
++	long calc_rate;
++
++	calc_rate = get_pll_core_divider(hw, rate, *parent_rate,
++					 &fbdiv_int, &fbdiv_frac);
++	return calc_rate;
++}
++
++static void rp1_pll_core_debug_init(struct clk_hw *hw, struct dentry *dentry)
++{
++	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
++	struct rp1_clockman *clockman = pll_core->clockman;
++	const struct rp1_pll_core_data *data = pll_core->data;
++	struct debugfs_reg32 *regs;
++
++	regs = devm_kcalloc(clockman->dev, 4, sizeof(*regs), GFP_KERNEL);
++	if (!regs)
++		return;
++
++	regs[0].name = "cs";
++	regs[0].offset = data->cs_reg;
++	regs[1].name = "pwr";
++	regs[1].offset = data->pwr_reg;
++	regs[2].name = "fbdiv_int";
++	regs[2].offset = data->fbdiv_int_reg;
++	regs[3].name = "fbdiv_frac";
++	regs[3].offset = data->fbdiv_frac_reg;
++
++	rp1_debugfs_regset(clockman, 0, regs, 4, dentry);
++}
++
++static void get_pll_prim_dividers(unsigned long rate, unsigned long parent_rate,
++				  u32 *divider1, u32 *divider2)
++{
++	unsigned int div1, div2;
++	unsigned int best_div1 = 7, best_div2 = 7;
++	unsigned long best_rate_diff =
++		ABS_DIFF(DIV_ROUND_CLOSEST(parent_rate, best_div1 * best_div2), rate);
++	long rate_diff, calc_rate;
++
++	for (div1 = 1; div1 <= 7; div1++) {
++		for (div2 = 1; div2 <= div1; div2++) {
++			calc_rate = DIV_ROUND_CLOSEST(parent_rate, div1 * div2);
++			rate_diff = ABS_DIFF(calc_rate, rate);
++
++			if (calc_rate == rate) {
++				best_div1 = div1;
++				best_div2 = div2;
++				goto done;
++			} else if (rate_diff < best_rate_diff) {
++				best_div1 = div1;
++				best_div2 = div2;
++				best_rate_diff = rate_diff;
++			}
++		}
++	}
++
++done:
++	*divider1 = best_div1;
++	*divider2 = best_div2;
++}
++
++static int rp1_pll_set_rate(struct clk_hw *hw,
++			    unsigned long rate, unsigned long parent_rate)
++{
++	struct rp1_pll *pll = container_of(hw, struct rp1_pll, hw);
++	struct rp1_clockman *clockman = pll->clockman;
++	const struct rp1_pll_data *data = pll->data;
++	u32 prim, prim_div1, prim_div2;
++
++	get_pll_prim_dividers(rate, parent_rate, &prim_div1, &prim_div2);
++
++	spin_lock(&clockman->regs_lock);
++	prim = clockman_read(clockman, data->ctrl_reg);
++	prim = set_register_field(prim, prim_div1, PLL_PRIM_DIV1_MASK,
++				  PLL_PRIM_DIV1_SHIFT);
++	prim = set_register_field(prim, prim_div2, PLL_PRIM_DIV2_MASK,
++				  PLL_PRIM_DIV2_SHIFT);
++	clockman_write(clockman, data->ctrl_reg, prim);
++	spin_unlock(&clockman->regs_lock);
++
++#ifdef MEASURE_CLOCK_RATE
++	clockman_measure_clock(clockman, data->name, data->fc0_src);
++#endif
++	return 0;
++}
++
++static unsigned long rp1_pll_recalc_rate(struct clk_hw *hw,
++					 unsigned long parent_rate)
++{
++	struct rp1_pll *pll = container_of(hw, struct rp1_pll, hw);
++	struct rp1_clockman *clockman = pll->clockman;
++	const struct rp1_pll_data *data = pll->data;
++	u32 prim, prim_div1, prim_div2;
++
++	prim = clockman_read(clockman, data->ctrl_reg);
++	prim_div1 = (prim & PLL_PRIM_DIV1_MASK) >> PLL_PRIM_DIV1_SHIFT;
++	prim_div2 = (prim & PLL_PRIM_DIV2_MASK) >> PLL_PRIM_DIV2_SHIFT;
++
++	if (!prim_div1 || !prim_div2) {
++		dev_err(clockman->dev, "%s: (%s) zero divider value\n",
++			__func__, data->name);
++		return 0;
++	}
++
++	return DIV_ROUND_CLOSEST(parent_rate, prim_div1 * prim_div2);
++}
++
++static long rp1_pll_round_rate(struct clk_hw *hw, unsigned long rate,
++			       unsigned long *parent_rate)
++{
++	u32 div1, div2;
++
++	get_pll_prim_dividers(rate, *parent_rate, &div1, &div2);
++
++	return DIV_ROUND_CLOSEST(*parent_rate, div1 * div2);
++}
++
++static void rp1_pll_debug_init(struct clk_hw *hw,
++			       struct dentry *dentry)
++{
++	struct rp1_pll *pll = container_of(hw, struct rp1_pll, hw);
++	struct rp1_clockman *clockman = pll->clockman;
++	const struct rp1_pll_data *data = pll->data;
++	struct debugfs_reg32 *regs;
++
++	regs = devm_kcalloc(clockman->dev, 1, sizeof(*regs), GFP_KERNEL);
++	if (!regs)
++		return;
++
++	regs[0].name = "prim";
++	regs[0].offset = data->ctrl_reg;
++
++	rp1_debugfs_regset(clockman, 0, regs, 1, dentry);
++}
++
++static int rp1_pll_ph_is_on(struct clk_hw *hw)
++{
++	struct rp1_pll_ph *pll = container_of(hw, struct rp1_pll_ph, hw);
++	struct rp1_clockman *clockman = pll->clockman;
++	const struct rp1_pll_ph_data *data = pll->data;
++
++	return !!(clockman_read(clockman, data->ph_reg) & PLL_PH_EN);
++}
++
++static int rp1_pll_ph_on(struct clk_hw *hw)
++{
++	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
++	struct rp1_clockman *clockman = pll_ph->clockman;
++	const struct rp1_pll_ph_data *data = pll_ph->data;
++	u32 ph_reg;
++
++	/* todo: ensure pri/sec is enabled! */
++	spin_lock(&clockman->regs_lock);
++	ph_reg = clockman_read(clockman, data->ph_reg);
++	ph_reg |= data->phase << PLL_PH_PHASE_SHIFT;
++	ph_reg |= PLL_PH_EN;
++	clockman_write(clockman, data->ph_reg, ph_reg);
++	spin_unlock(&clockman->regs_lock);
++
++#ifdef MEASURE_CLOCK_RATE
++	clockman_measure_clock(clockman, data->name, data->fc0_src);
++#endif
++	return 0;
++}
++
++static void rp1_pll_ph_off(struct clk_hw *hw)
++{
++	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
++	struct rp1_clockman *clockman = pll_ph->clockman;
++	const struct rp1_pll_ph_data *data = pll_ph->data;
++
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, data->ph_reg,
++		       clockman_read(clockman, data->ph_reg) & ~PLL_PH_EN);
++	spin_unlock(&clockman->regs_lock);
++}
++
++static int rp1_pll_ph_set_rate(struct clk_hw *hw,
++			       unsigned long rate, unsigned long parent_rate)
++{
++	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
++	const struct rp1_pll_ph_data *data = pll_ph->data;
++	struct rp1_clockman *clockman = pll_ph->clockman;
++
++	/* Nothing really to do here! */
++	WARN_ON(data->fixed_divider != 1 && data->fixed_divider != 2);
++	WARN_ON(rate != parent_rate / data->fixed_divider);
++
++#ifdef MEASURE_CLOCK_RATE
++	if (rp1_pll_ph_is_on(hw))
++		clockman_measure_clock(clockman, data->name, data->fc0_src);
++#endif
++	return 0;
++}
++
++static unsigned long rp1_pll_ph_recalc_rate(struct clk_hw *hw,
++					    unsigned long parent_rate)
++{
++	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
++	const struct rp1_pll_ph_data *data = pll_ph->data;
++
++	return parent_rate / data->fixed_divider;
++}
++
++static long rp1_pll_ph_round_rate(struct clk_hw *hw, unsigned long rate,
++				  unsigned long *parent_rate)
++{
++	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
++	const struct rp1_pll_ph_data *data = pll_ph->data;
++
++	return *parent_rate / data->fixed_divider;
++}
++
++static void rp1_pll_ph_debug_init(struct clk_hw *hw,
++				  struct dentry *dentry)
++{
++	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
++	const struct rp1_pll_ph_data *data = pll_ph->data;
++	struct rp1_clockman *clockman = pll_ph->clockman;
++	struct debugfs_reg32 *regs;
++
++	regs = devm_kcalloc(clockman->dev, 1, sizeof(*regs), GFP_KERNEL);
++	if (!regs)
++		return;
++
++	regs[0].name = "ph_reg";
++	regs[0].offset = data->ph_reg;
++
++	rp1_debugfs_regset(clockman, 0, regs, 1, dentry);
++}
++
++static int rp1_pll_divider_is_on(struct clk_hw *hw)
++{
++	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
++	struct rp1_clockman *clockman = divider->clockman;
++	const struct rp1_pll_data *data = divider->data;
++
++	return !(clockman_read(clockman, data->ctrl_reg) & PLL_SEC_RST);
++}
++
++static int rp1_pll_divider_on(struct clk_hw *hw)
++{
++	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
++	struct rp1_clockman *clockman = divider->clockman;
++	const struct rp1_pll_data *data = divider->data;
++
++	spin_lock(&clockman->regs_lock);
++	/* Check the implementation bit is set! */
++	WARN_ON(!(clockman_read(clockman, data->ctrl_reg) & PLL_SEC_IMPL));
++	clockman_write(clockman, data->ctrl_reg,
++		       clockman_read(clockman, data->ctrl_reg) & ~PLL_SEC_RST);
++	spin_unlock(&clockman->regs_lock);
++
++#ifdef MEASURE_CLOCK_RATE
++	clockman_measure_clock(clockman, data->name, data->fc0_src);
++#endif
++	return 0;
++}
++
++static void rp1_pll_divider_off(struct clk_hw *hw)
++{
++	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
++	struct rp1_clockman *clockman = divider->clockman;
++	const struct rp1_pll_data *data = divider->data;
++
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, data->ctrl_reg, PLL_SEC_RST);
++	spin_unlock(&clockman->regs_lock);
++}
++
++static int rp1_pll_divider_set_rate(struct clk_hw *hw,
++				    unsigned long rate,
++				    unsigned long parent_rate)
++{
++	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
++	struct rp1_clockman *clockman = divider->clockman;
++	const struct rp1_pll_data *data = divider->data;
++	u32 div, sec;
++
++	div = DIV_ROUND_UP_ULL(parent_rate, rate);
++	div = clamp(div, 8u, 19u);
++
++	spin_lock(&clockman->regs_lock);
++	sec = clockman_read(clockman, data->ctrl_reg);
++	sec = set_register_field(sec, div, PLL_SEC_DIV_MASK, PLL_SEC_DIV_SHIFT);
++
++	/* Must keep the divider in reset to change the value. */
++	sec |= PLL_SEC_RST;
++	clockman_write(clockman, data->ctrl_reg, sec);
++
++	// todo: must sleep 10 pll vco cycles
++	sec &= ~PLL_SEC_RST;
++	clockman_write(clockman, data->ctrl_reg, sec);
++	spin_unlock(&clockman->regs_lock);
++
++#ifdef MEASURE_CLOCK_RATE
++	if (rp1_pll_divider_is_on(hw))
++		clockman_measure_clock(clockman, data->name, data->fc0_src);
++#endif
++	return 0;
++}
++
++static unsigned long rp1_pll_divider_recalc_rate(struct clk_hw *hw,
++						 unsigned long parent_rate)
++{
++	return clk_divider_ops.recalc_rate(hw, parent_rate);
++}
++
++static long rp1_pll_divider_round_rate(struct clk_hw *hw,
++				       unsigned long rate,
++				       unsigned long *parent_rate)
++{
++	return clk_divider_ops.round_rate(hw, rate, parent_rate);
++}
++
++static void rp1_pll_divider_debug_init(struct clk_hw *hw, struct dentry *dentry)
++{
++	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
++	struct rp1_clockman *clockman = divider->clockman;
++	const struct rp1_pll_data *data = divider->data;
++	struct debugfs_reg32 *regs;
++
++	regs = devm_kcalloc(clockman->dev, 1, sizeof(*regs), GFP_KERNEL);
++	if (!regs)
++		return;
++
++	regs[0].name = "sec";
++	regs[0].offset = data->ctrl_reg;
++
++	rp1_debugfs_regset(clockman, 0, regs, 1, dentry);
++}
++
++static int rp1_clock_is_on(struct clk_hw *hw)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	struct rp1_clockman *clockman = clock->clockman;
++	const struct rp1_clock_data *data = clock->data;
++
++	return !!(clockman_read(clockman, data->ctrl_reg) & CLK_CTRL_ENABLE);
++}
++
++static unsigned long rp1_clock_recalc_rate(struct clk_hw *hw,
++					   unsigned long parent_rate)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	struct rp1_clockman *clockman = clock->clockman;
++	const struct rp1_clock_data *data = clock->data;
++	u64 calc_rate;
++	u64 div;
++
++	u32 frac;
++
++	div = clockman_read(clockman, data->div_int_reg);
++	frac = (data->div_frac_reg != 0) ?
++		clockman_read(clockman, data->div_frac_reg) : 0;
++
++	/* If the integer portion of the divider is 0, treat it as 2^16 */
++	if (!div)
++		div = 1 << 16;
++
++	div = (div << CLK_DIV_FRAC_BITS) | (frac >> (32 - CLK_DIV_FRAC_BITS));
++
++	calc_rate = (u64)parent_rate << CLK_DIV_FRAC_BITS;
++	calc_rate = div64_u64(calc_rate, div);
++
++	return calc_rate;
++}
++
++static int rp1_clock_on(struct clk_hw *hw)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	struct rp1_clockman *clockman = clock->clockman;
++	const struct rp1_clock_data *data = clock->data;
++
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, data->ctrl_reg,
++		       clockman_read(clockman, data->ctrl_reg) | CLK_CTRL_ENABLE);
++	spin_unlock(&clockman->regs_lock);
++
++#ifdef MEASURE_CLOCK_RATE
++	clockman_measure_clock(clockman, data->name, data->fc0_src);
++#endif
++	return 0;
++}
++
++static void rp1_clock_off(struct clk_hw *hw)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	struct rp1_clockman *clockman = clock->clockman;
++	const struct rp1_clock_data *data = clock->data;
++
++	spin_lock(&clockman->regs_lock);
++	clockman_write(clockman, data->ctrl_reg,
++		       clockman_read(clockman, data->ctrl_reg) & ~CLK_CTRL_ENABLE);
++	spin_unlock(&clockman->regs_lock);
++}
++
++static u32 rp1_clock_choose_div(unsigned long rate, unsigned long parent_rate,
++				const struct rp1_clock_data *data)
++{
++	u64 div;
++
++	/*
++	 * Due to earlier rounding, calculated parent_rate may differ from
++	 * expected value. Don't fail on a small discrepancy near unity divide.
++	 */
++	if (!rate || rate > parent_rate + (parent_rate >> CLK_DIV_FRAC_BITS))
++		return 0;
++
++	/*
++	 * Always express div in fixed-point format for fractional division;
++	 * If no fractional divider is present, the fraction part will be zero.
++	 */
++	if (data->div_frac_reg) {
++		div = (u64)parent_rate << CLK_DIV_FRAC_BITS;
++		div = DIV_U64_NEAREST(div, rate);
++	} else {
++		div = DIV_U64_NEAREST(parent_rate, rate);
++		div <<= CLK_DIV_FRAC_BITS;
++	}
++
++	div = clamp(div,
++		    1ull << CLK_DIV_FRAC_BITS,
++		    (u64)data->div_int_max << CLK_DIV_FRAC_BITS);
++
++	return div;
++}
++
++static u8 rp1_clock_get_parent(struct clk_hw *hw)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	struct rp1_clockman *clockman = clock->clockman;
++	const struct rp1_clock_data *data = clock->data;
++	u32 sel, ctrl;
++	u8 parent;
++
++	/* Sel is one-hot, so find the first bit set */
++	sel = clockman_read(clockman, data->sel_reg);
++	parent = ffs(sel) - 1;
++
++	/* sel == 0 implies the parent clock is not enabled yet. */
++	if (!sel) {
++		/* Read the clock src from the CTRL register instead */
++		ctrl = clockman_read(clockman, data->ctrl_reg);
++		parent = (ctrl & data->clk_src_mask) >> CLK_CTRL_SRC_SHIFT;
++	}
++
++	if (parent >= data->num_std_parents)
++		parent = AUX_SEL;
++
++	if (parent == AUX_SEL) {
++		/*
++		 * Clock parent is an auxiliary source, so get the parent from
++		 * the AUXSRC register field.
++		 */
++		ctrl = clockman_read(clockman, data->ctrl_reg);
++		parent = (ctrl & CLK_CTRL_AUXSRC_MASK) >> CLK_CTRL_AUXSRC_SHIFT;
++		parent += data->num_std_parents;
++	}
++
++	return parent;
++}
++
++static int rp1_clock_set_parent(struct clk_hw *hw, u8 index)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	struct rp1_clockman *clockman = clock->clockman;
++	const struct rp1_clock_data *data = clock->data;
++	u32 ctrl, sel;
++
++	spin_lock(&clockman->regs_lock);
++	ctrl = clockman_read(clockman, data->ctrl_reg);
++
++	if (index >= data->num_std_parents) {
++		/* This is an aux source request */
++		if (index >= data->num_std_parents + data->num_aux_parents)
++			return -EINVAL;
++
++		/* Select parent from aux list */
++		ctrl = set_register_field(ctrl, index - data->num_std_parents,
++					  CLK_CTRL_AUXSRC_MASK,
++					  CLK_CTRL_AUXSRC_SHIFT);
++		/* Set src to aux list */
++		ctrl = set_register_field(ctrl, AUX_SEL, data->clk_src_mask,
++					  CLK_CTRL_SRC_SHIFT);
++	} else {
++		ctrl = set_register_field(ctrl, index, data->clk_src_mask,
++					  CLK_CTRL_SRC_SHIFT);
++	}
++
++	clockman_write(clockman, data->ctrl_reg, ctrl);
++	spin_unlock(&clockman->regs_lock);
++
++	sel = rp1_clock_get_parent(hw);
++	WARN(sel != index, "(%s): Parent index req %u returned back %u\n",
++	     data->name, index, sel);
++
++	return 0;
++}
++
++static int rp1_clock_set_rate_and_parent(struct clk_hw *hw,
++					 unsigned long rate,
++					 unsigned long parent_rate,
++					 u8 parent)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	struct rp1_clockman *clockman = clock->clockman;
++	const struct rp1_clock_data *data = clock->data;
++	u32 div = rp1_clock_choose_div(rate, parent_rate, data);
++
++	WARN(rate > 4000000000ll, "rate is -ve (%d)\n", (int)rate);
++
++	if (WARN(!div,
++		 "clk divider calculated as 0! (%s, rate %ld, parent rate %ld)\n",
++		 data->name, rate, parent_rate))
++		div = 1 << CLK_DIV_FRAC_BITS;
++
++	spin_lock(&clockman->regs_lock);
++
++	clockman_write(clockman, data->div_int_reg, div >> CLK_DIV_FRAC_BITS);
++	if (data->div_frac_reg)
++		clockman_write(clockman, data->div_frac_reg, div << (32 - CLK_DIV_FRAC_BITS));
++
++	spin_unlock(&clockman->regs_lock);
++
++	if (parent != 0xff)
++		rp1_clock_set_parent(hw, parent);
++
++#ifdef MEASURE_CLOCK_RATE
++	if (rp1_clock_is_on(hw))
++		clockman_measure_clock(clockman, data->name, data->fc0_src);
++#endif
++	return 0;
++}
++
++static int rp1_clock_set_rate(struct clk_hw *hw, unsigned long rate,
++			      unsigned long parent_rate)
++{
++	return rp1_clock_set_rate_and_parent(hw, rate, parent_rate, 0xff);
++}
++
++static void rp1_clock_choose_div_and_prate(struct clk_hw *hw,
++					   int parent_idx,
++					   unsigned long rate,
++					   unsigned long *prate,
++					   unsigned long *calc_rate)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	const struct rp1_clock_data *data = clock->data;
++	struct clk_hw *parent;
++	u32 div;
++	u64 tmp;
++
++	parent = clk_hw_get_parent_by_index(hw, parent_idx);
++	*prate = clk_hw_get_rate(parent);
++	div = rp1_clock_choose_div(rate, *prate, data);
++
++	if (!div) {
++		*calc_rate = 0;
++		return;
++	}
++
++	/* Recalculate to account for rounding errors */
++	tmp = (u64)*prate << CLK_DIV_FRAC_BITS;
++	tmp = div_u64(tmp, div);
++	*calc_rate = tmp;
++}
++
++static int rp1_clock_determine_rate(struct clk_hw *hw,
++				    struct clk_rate_request *req)
++{
++	struct clk_hw *parent, *best_parent = NULL;
++	unsigned long best_rate = 0;
++	unsigned long best_prate = 0;
++	unsigned long best_rate_diff = ULONG_MAX;
++	unsigned long prate, calc_rate;
++	size_t i;
++
++	/*
++	 * If the NO_REPARENT flag is set, try to use existing parent.
++	 */
++	if ((clk_hw_get_flags(hw) & CLK_SET_RATE_NO_REPARENT)) {
++		i = rp1_clock_get_parent(hw);
++		parent = clk_hw_get_parent_by_index(hw, i);
++		if (parent) {
++			rp1_clock_choose_div_and_prate(hw, i, req->rate, &prate,
++						       &calc_rate);
++			if (calc_rate > 0) {
++				req->best_parent_hw = parent;
++				req->best_parent_rate = prate;
++				req->rate = calc_rate;
++				return 0;
++			}
++		}
++	}
++
++	/*
++	 * Select parent clock that results in the closest rate (lower or
++	 * higher)
++	 */
++	for (i = 0; i < clk_hw_get_num_parents(hw); i++) {
++		parent = clk_hw_get_parent_by_index(hw, i);
++		if (!parent)
++			continue;
++
++		rp1_clock_choose_div_and_prate(hw, i, req->rate, &prate,
++					       &calc_rate);
++
++		if (ABS_DIFF(calc_rate, req->rate) < best_rate_diff) {
++			best_parent = parent;
++			best_prate = prate;
++			best_rate = calc_rate;
++			best_rate_diff = ABS_DIFF(calc_rate, req->rate);
++
++			if (best_rate_diff == 0)
++				break;
++		}
++	}
++
++	if (best_rate == 0)
++		return -EINVAL;
++
++	req->best_parent_hw = best_parent;
++	req->best_parent_rate = best_prate;
++	req->rate = best_rate;
++
++	return 0;
++}
++
++static void rp1_clk_debug_init(struct clk_hw *hw, struct dentry *dentry)
++{
++	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
++	struct rp1_clockman *clockman = clock->clockman;
++	const struct rp1_clock_data *data = clock->data;
++	struct debugfs_reg32 *regs;
++	int i;
++
++	regs = devm_kcalloc(clockman->dev, 4, sizeof(*regs), GFP_KERNEL);
++	if (!regs)
++		return;
++
++	i = 0;
++	regs[i].name = "ctrl";
++	regs[i++].offset = data->ctrl_reg;
++	regs[i].name = "div_int";
++	regs[i++].offset = data->div_int_reg;
++	regs[i].name = "div_frac";
++	regs[i++].offset = data->div_frac_reg;
++	regs[i].name = "sel";
++	regs[i++].offset = data->sel_reg;
++
++	rp1_debugfs_regset(clockman, 0, regs, i, dentry);
++}
++
++static const struct clk_ops rp1_pll_core_ops = {
++	.is_prepared = rp1_pll_core_is_on,
++	.prepare = rp1_pll_core_on,
++	.unprepare = rp1_pll_core_off,
++	.set_rate = rp1_pll_core_set_rate,
++	.recalc_rate = rp1_pll_core_recalc_rate,
++	.round_rate = rp1_pll_core_round_rate,
++	.debug_init = rp1_pll_core_debug_init,
++};
++
++static const struct clk_ops rp1_pll_ops = {
++	.set_rate = rp1_pll_set_rate,
++	.recalc_rate = rp1_pll_recalc_rate,
++	.round_rate = rp1_pll_round_rate,
++	.debug_init = rp1_pll_debug_init,
++};
++
++static const struct clk_ops rp1_pll_ph_ops = {
++	.is_prepared = rp1_pll_ph_is_on,
++	.prepare = rp1_pll_ph_on,
++	.unprepare = rp1_pll_ph_off,
++	.set_rate = rp1_pll_ph_set_rate,
++	.recalc_rate = rp1_pll_ph_recalc_rate,
++	.round_rate = rp1_pll_ph_round_rate,
++	.debug_init = rp1_pll_ph_debug_init,
++};
++
++static const struct clk_ops rp1_pll_divider_ops = {
++	.is_prepared = rp1_pll_divider_is_on,
++	.prepare = rp1_pll_divider_on,
++	.unprepare = rp1_pll_divider_off,
++	.set_rate = rp1_pll_divider_set_rate,
++	.recalc_rate = rp1_pll_divider_recalc_rate,
++	.round_rate = rp1_pll_divider_round_rate,
++	.debug_init = rp1_pll_divider_debug_init,
++};
++
++static const struct clk_ops rp1_clk_ops = {
++	.is_prepared = rp1_clock_is_on,
++	.prepare = rp1_clock_on,
++	.unprepare = rp1_clock_off,
++	.recalc_rate = rp1_clock_recalc_rate,
++	.get_parent = rp1_clock_get_parent,
++	.set_parent = rp1_clock_set_parent,
++	.set_rate_and_parent = rp1_clock_set_rate_and_parent,
++	.set_rate = rp1_clock_set_rate,
++	.determine_rate = rp1_clock_determine_rate,
++	.debug_init = rp1_clk_debug_init,
++};
++
++static bool rp1_clk_is_claimed(const char *name);
++
++static struct clk_hw *rp1_register_pll_core(struct rp1_clockman *clockman,
++					    const void *data)
++{
++	const struct rp1_pll_core_data *pll_core_data = data;
++	struct rp1_pll_core *pll_core;
++	struct clk_init_data init;
++	int ret;
++
++	memset(&init, 0, sizeof(init));
++
++	/* All of the PLL cores derive from the external oscillator. */
++	init.parent_names = &ref_clock;
++	init.num_parents = 1;
++	init.name = pll_core_data->name;
++	init.ops = &rp1_pll_core_ops;
++	init.flags = pll_core_data->flags | CLK_IGNORE_UNUSED | CLK_IS_CRITICAL;
++
++	pll_core = kzalloc(sizeof(*pll_core), GFP_KERNEL);
++	if (!pll_core)
++		return NULL;
++
++	pll_core->clockman = clockman;
++	pll_core->data = pll_core_data;
++	pll_core->hw.init = &init;
++
++	ret = devm_clk_hw_register(clockman->dev, &pll_core->hw);
++	if (ret) {
++		kfree(pll_core);
++		return NULL;
++	}
++
++	return &pll_core->hw;
++}
++
++static struct clk_hw *rp1_register_pll(struct rp1_clockman *clockman,
++				       const void *data)
++{
++	const struct rp1_pll_data *pll_data = data;
++	struct rp1_pll *pll;
++	struct clk_init_data init;
++	int ret;
++
++	memset(&init, 0, sizeof(init));
++
++	init.parent_names = &pll_data->source_pll;
++	init.num_parents = 1;
++	init.name = pll_data->name;
++	init.ops = &rp1_pll_ops;
++	init.flags = pll_data->flags | CLK_IGNORE_UNUSED | CLK_IS_CRITICAL;
++
++	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
++	if (!pll)
++		return NULL;
++
++	pll->clockman = clockman;
++	pll->data = pll_data;
++	pll->hw.init = &init;
++
++	ret = devm_clk_hw_register(clockman->dev, &pll->hw);
++	if (ret) {
++		kfree(pll);
++		return NULL;
++	}
++
++	return &pll->hw;
++}
++
++static struct clk_hw *rp1_register_pll_ph(struct rp1_clockman *clockman,
++					  const void *data)
++{
++	const struct rp1_pll_ph_data *ph_data = data;
++	struct rp1_pll_ph *ph;
++	struct clk_init_data init;
++	int ret;
++
++	memset(&init, 0, sizeof(init));
++
++	/* All of the PLLs derive from the external oscillator. */
++	init.parent_names = &ph_data->source_pll;
++	init.num_parents = 1;
++	init.name = ph_data->name;
++	init.ops = &rp1_pll_ph_ops;
++	init.flags = ph_data->flags | CLK_IGNORE_UNUSED;
++
++	ph = kzalloc(sizeof(*ph), GFP_KERNEL);
++	if (!ph)
++		return NULL;
++
++	ph->clockman = clockman;
++	ph->data = ph_data;
++	ph->hw.init = &init;
++
++	ret = devm_clk_hw_register(clockman->dev, &ph->hw);
++	if (ret) {
++		kfree(ph);
++		return NULL;
++	}
++
++	return &ph->hw;
++}
++
++static struct clk_hw *rp1_register_pll_divider(struct rp1_clockman *clockman,
++					       const void *data)
++{
++	const struct rp1_pll_data *divider_data = data;
++	struct rp1_pll *divider;
++	struct clk_init_data init;
++	int ret;
++
++	memset(&init, 0, sizeof(init));
++
++	init.parent_names = &divider_data->source_pll;
++	init.num_parents = 1;
++	init.name = divider_data->name;
++	init.ops = &rp1_pll_divider_ops;
++	init.flags = divider_data->flags | CLK_IGNORE_UNUSED;
++
++	divider = devm_kzalloc(clockman->dev, sizeof(*divider), GFP_KERNEL);
++	if (!divider)
++		return NULL;
++
++	divider->div.reg = clockman->regs + divider_data->ctrl_reg;
++	divider->div.shift = PLL_SEC_DIV_SHIFT;
++	divider->div.width = PLL_SEC_DIV_WIDTH;
++	divider->div.flags = CLK_DIVIDER_ROUND_CLOSEST;
++	divider->div.lock = &clockman->regs_lock;
++	divider->div.hw.init = &init;
++	divider->div.table = pll_sec_div_table;
++
++	if (!rp1_clk_is_claimed(divider_data->source_pll))
++		init.flags |= CLK_IS_CRITICAL;
++	if (!rp1_clk_is_claimed(divider_data->name))
++		divider->div.flags |= CLK_IS_CRITICAL;
++
++	divider->clockman = clockman;
++	divider->data = divider_data;
++
++	ret = devm_clk_hw_register(clockman->dev, &divider->div.hw);
++	if (ret)
++		return ERR_PTR(ret);
++
++	return &divider->div.hw;
++}
++
++static struct clk_hw *rp1_register_clock(struct rp1_clockman *clockman,
++					 const void *data)
++{
++	const struct rp1_clock_data *clock_data = data;
++	struct rp1_clock *clock;
++	struct clk_init_data init;
++	int ret;
++
++	BUG_ON(MAX_CLK_PARENTS <
++	       clock_data->num_std_parents + clock_data->num_aux_parents);
++	/* There must be a gap for the AUX selector */
++	BUG_ON((clock_data->num_std_parents > AUX_SEL) &&
++	       strcmp("-", clock_data->parents[AUX_SEL]));
++
++	memset(&init, 0, sizeof(init));
++	init.parent_names = clock_data->parents;
++	init.num_parents =
++		clock_data->num_std_parents + clock_data->num_aux_parents;
++	init.name = clock_data->name;
++	init.flags = clock_data->flags | CLK_IGNORE_UNUSED;
++	init.ops = &rp1_clk_ops;
++
++	clock = devm_kzalloc(clockman->dev, sizeof(*clock), GFP_KERNEL);
++	if (!clock)
++		return NULL;
++
++	clock->clockman = clockman;
++	clock->data = clock_data;
++	clock->hw.init = &init;
++
++	ret = devm_clk_hw_register(clockman->dev, &clock->hw);
++	if (ret)
++		return ERR_PTR(ret);
++
++	return &clock->hw;
++}
++
++struct rp1_clk_desc {
++	struct clk_hw *(*clk_register)(struct rp1_clockman *clockman,
++				       const void *data);
++	const void *data;
++};
++
++/* Assignment helper macros for different clock types. */
++#define _REGISTER(f, ...) { .clk_register = f, .data = __VA_ARGS__ }
++
++#define REGISTER_PLL_CORE(...)	_REGISTER(&rp1_register_pll_core,	\
++					  &(struct rp1_pll_core_data)	\
++					  {__VA_ARGS__})
++
++#define REGISTER_PLL(...)	_REGISTER(&rp1_register_pll,		\
++					  &(struct rp1_pll_data)		\
++					  {__VA_ARGS__})
++
++#define REGISTER_PLL_PH(...)	_REGISTER(&rp1_register_pll_ph,		\
++					  &(struct rp1_pll_ph_data)	\
++					  {__VA_ARGS__})
++
++#define REGISTER_PLL_DIV(...)	_REGISTER(&rp1_register_pll_divider,	\
++					  &(struct rp1_pll_data)	\
++					  {__VA_ARGS__})
++
++#define REGISTER_CLK(...)	_REGISTER(&rp1_register_clock,		\
++					  &(struct rp1_clock_data)	\
++					  {__VA_ARGS__})
++
++static const struct rp1_clk_desc clk_desc_array[] = {
++	[RP1_PLL_SYS_CORE] = REGISTER_PLL_CORE(
++				.name = "pll_sys_core",
++				.cs_reg = PLL_SYS_CS,
++				.pwr_reg = PLL_SYS_PWR,
++				.fbdiv_int_reg = PLL_SYS_FBDIV_INT,
++				.fbdiv_frac_reg = PLL_SYS_FBDIV_FRAC,
++				),
++
++	[RP1_PLL_AUDIO_CORE] = REGISTER_PLL_CORE(
++				.name = "pll_audio_core",
++				.cs_reg = PLL_AUDIO_CS,
++				.pwr_reg = PLL_AUDIO_PWR,
++				.fbdiv_int_reg = PLL_AUDIO_FBDIV_INT,
++				.fbdiv_frac_reg = PLL_AUDIO_FBDIV_FRAC,
++				),
++
++	[RP1_PLL_VIDEO_CORE] = REGISTER_PLL_CORE(
++				.name = "pll_video_core",
++				.cs_reg = PLL_VIDEO_CS,
++				.pwr_reg = PLL_VIDEO_PWR,
++				.fbdiv_int_reg = PLL_VIDEO_FBDIV_INT,
++				.fbdiv_frac_reg = PLL_VIDEO_FBDIV_FRAC,
++				),
++
++	[RP1_PLL_SYS] = REGISTER_PLL(
++				.name = "pll_sys",
++				.source_pll = "pll_sys_core",
++				.ctrl_reg = PLL_SYS_PRIM,
++				.fc0_src = FC_NUM(0, 2),
++				),
++
++	[RP1_PLL_AUDIO] = REGISTER_PLL(
++				.name = "pll_audio",
++				.source_pll = "pll_audio_core",
++				.ctrl_reg = PLL_AUDIO_PRIM,
++				.fc0_src = FC_NUM(4, 2),
++				),
++
++	[RP1_PLL_VIDEO] = REGISTER_PLL(
++				.name = "pll_video",
++				.source_pll = "pll_video_core",
++				.ctrl_reg = PLL_VIDEO_PRIM,
++				.fc0_src = FC_NUM(3, 2),
++				),
++
++	[RP1_PLL_SYS_PRI_PH] = REGISTER_PLL_PH(
++				.name = "pll_sys_pri_ph",
++				.source_pll = "pll_sys",
++				.ph_reg = PLL_SYS_PRIM,
++				.fixed_divider = 2,
++				.phase = RP1_PLL_PHASE_0,
++				.fc0_src = FC_NUM(1, 2),
++				),
++
++	[RP1_PLL_AUDIO_PRI_PH] = REGISTER_PLL_PH(
++				.name = "pll_audio_pri_ph",
++				.source_pll = "pll_audio",
++				.ph_reg = PLL_AUDIO_PRIM,
++				.fixed_divider = 2,
++				.phase = RP1_PLL_PHASE_0,
++				.fc0_src = FC_NUM(5, 1),
++				),
++
++	[RP1_PLL_SYS_SEC] = REGISTER_PLL_DIV(
++				.name = "pll_sys_sec",
++				.source_pll = "pll_sys_core",
++				.ctrl_reg = PLL_SYS_SEC,
++				.fc0_src = FC_NUM(2, 2),
++				),
++
++	[RP1_PLL_AUDIO_SEC] = REGISTER_PLL_DIV(
++				.name = "pll_audio_sec",
++				.source_pll = "pll_audio_core",
++				.ctrl_reg = PLL_AUDIO_SEC,
++				.fc0_src = FC_NUM(6, 2),
++				),
++
++	[RP1_PLL_VIDEO_SEC] = REGISTER_PLL_DIV(
++				.name = "pll_video_sec",
++				.source_pll = "pll_video_core",
++				.ctrl_reg = PLL_VIDEO_SEC,
++				.fc0_src = FC_NUM(5, 3),
++				),
++
++	[RP1_CLK_SYS] = REGISTER_CLK(
++				.name = "clk_sys",
++				.parents = {"xosc", "-", "pll_sys"},
++				.num_std_parents = 3,
++				.num_aux_parents = 0,
++				.ctrl_reg = CLK_SYS_CTRL,
++				.div_int_reg = CLK_SYS_DIV_INT,
++				.sel_reg = CLK_SYS_SEL,
++				.div_int_max = DIV_INT_24BIT_MAX,
++				.fc0_src = FC_NUM(0, 4),
++				.clk_src_mask = 0x3,
++				),
++
++	[RP1_CLK_SLOW_SYS] = REGISTER_CLK(
++				.name = "clk_slow_sys",
++				.parents = {"xosc"},
++				.num_std_parents = 1,
++				.num_aux_parents = 0,
++				.ctrl_reg = CLK_SLOW_SYS_CTRL,
++				.div_int_reg = CLK_SLOW_SYS_DIV_INT,
++				.sel_reg = CLK_SLOW_SYS_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(1, 4),
++				.clk_src_mask = 0x1,
++				),
++
++	[RP1_CLK_UART] = REGISTER_CLK(
++				.name = "clk_uart",
++				.parents = {"pll_sys_pri_ph",
++					    "pll_video",
++					    "xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 3,
++				.ctrl_reg = CLK_UART_CTRL,
++				.div_int_reg = CLK_UART_DIV_INT,
++				.sel_reg = CLK_UART_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(6, 7),
++				),
++
++	[RP1_CLK_ETH] = REGISTER_CLK(
++				.name = "clk_eth",
++				.parents = {"-"},
++				.num_std_parents = 1,
++				.num_aux_parents = 0,
++				.ctrl_reg = CLK_ETH_CTRL,
++				.div_int_reg = CLK_ETH_DIV_INT,
++				.sel_reg = CLK_ETH_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(4, 6),
++				),
++
++	[RP1_CLK_PWM0] = REGISTER_CLK(
++				.name = "clk_pwm0",
++				.parents = {"pll_audio_pri_ph",
++					    "pll_video_sec",
++					    "xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 3,
++				.ctrl_reg = CLK_PWM0_CTRL,
++				.div_int_reg = CLK_PWM0_DIV_INT,
++				.div_frac_reg = CLK_PWM0_DIV_FRAC,
++				.sel_reg = CLK_PWM0_SEL,
++				.div_int_max = DIV_INT_16BIT_MAX,
++				.fc0_src = FC_NUM(0, 5),
++				),
++
++	[RP1_CLK_PWM1] = REGISTER_CLK(
++				.name = "clk_pwm1",
++				.parents = {"pll_audio_pri_ph",
++					    "pll_video_sec",
++					    "xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 3,
++				.ctrl_reg = CLK_PWM1_CTRL,
++				.div_int_reg = CLK_PWM1_DIV_INT,
++				.div_frac_reg = CLK_PWM1_DIV_FRAC,
++				.sel_reg = CLK_PWM1_SEL,
++				.div_int_max = DIV_INT_16BIT_MAX,
++				.fc0_src = FC_NUM(1, 5),
++				),
++
++	[RP1_CLK_AUDIO_IN] = REGISTER_CLK(
++				.name = "clk_audio_in",
++				.parents = {"-"},
++				.num_std_parents = 1,
++				.num_aux_parents = 0,
++				.ctrl_reg = CLK_AUDIO_IN_CTRL,
++				.div_int_reg = CLK_AUDIO_IN_DIV_INT,
++				.sel_reg = CLK_AUDIO_IN_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(2, 5),
++				),
++
++	[RP1_CLK_AUDIO_OUT] = REGISTER_CLK(
++				.name = "clk_audio_out",
++				.parents = {"-"},
++				.num_std_parents = 1,
++				.num_aux_parents = 0,
++				.ctrl_reg = CLK_AUDIO_OUT_CTRL,
++				.div_int_reg = CLK_AUDIO_OUT_DIV_INT,
++				.sel_reg = CLK_AUDIO_OUT_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(3, 5),
++				),
++
++	[RP1_CLK_I2S] = REGISTER_CLK(
++				.name = "clk_i2s",
++				.parents = {"xosc",
++					    "pll_audio",
++					    "pll_audio_sec"},
++				.num_std_parents = 0,
++				.num_aux_parents = 3,
++				.ctrl_reg = CLK_I2S_CTRL,
++				.div_int_reg = CLK_I2S_DIV_INT,
++				.sel_reg = CLK_I2S_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(4, 4),
++				),
++
++	[RP1_CLK_MIPI0_CFG] = REGISTER_CLK(
++				.name = "clk_mipi0_cfg",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_MIPI0_CFG_CTRL,
++				.div_int_reg = CLK_MIPI0_CFG_DIV_INT,
++				.sel_reg = CLK_MIPI0_CFG_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(4, 5),
++				),
++
++	[RP1_CLK_MIPI1_CFG] = REGISTER_CLK(
++				.name = "clk_mipi1_cfg",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_MIPI1_CFG_CTRL,
++				.div_int_reg = CLK_MIPI1_CFG_DIV_INT,
++				.sel_reg = CLK_MIPI1_CFG_SEL,
++				.clk_src_mask = 1,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(5, 6),
++				),
++
++	[RP1_CLK_ETH_TSU] = REGISTER_CLK(
++				.name = "clk_eth_tsu",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_ETH_TSU_CTRL,
++				.div_int_reg = CLK_ETH_TSU_DIV_INT,
++				.sel_reg = CLK_ETH_TSU_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(5, 7),
++				),
++
++	[RP1_CLK_ADC] = REGISTER_CLK(
++				.name = "clk_adc",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_ADC_CTRL,
++				.div_int_reg = CLK_ADC_DIV_INT,
++				.sel_reg = CLK_ADC_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(5, 5),
++				),
++
++	[RP1_CLK_SDIO_TIMER] = REGISTER_CLK(
++				.name = "clk_sdio_timer",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_SDIO_TIMER_CTRL,
++				.div_int_reg = CLK_SDIO_TIMER_DIV_INT,
++				.sel_reg = CLK_SDIO_TIMER_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(3, 4),
++				),
++
++	[RP1_CLK_SDIO_ALT_SRC] = REGISTER_CLK(
++				.name = "clk_sdio_alt_src",
++				.parents = {"pll_sys"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_SDIO_ALT_SRC_CTRL,
++				.div_int_reg = CLK_SDIO_ALT_SRC_DIV_INT,
++				.sel_reg = CLK_SDIO_ALT_SRC_SEL,
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(5, 4),
++				),
++
++	[RP1_CLK_GP0] = REGISTER_CLK(
++				.name = "clk_gp0",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_GP0_CTRL,
++				.div_int_reg = CLK_GP0_DIV_INT,
++				.div_frac_reg = CLK_GP0_DIV_FRAC,
++				.sel_reg = CLK_GP0_SEL,
++				.div_int_max = DIV_INT_16BIT_MAX,
++				.fc0_src = FC_NUM(0, 1),
++				),
++
++	[RP1_CLK_GP1] = REGISTER_CLK(
++				.name = "clk_gp1",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_GP1_CTRL,
++				.div_int_reg = CLK_GP1_DIV_INT,
++				.div_frac_reg = CLK_GP1_DIV_FRAC,
++				.sel_reg = CLK_GP1_SEL,
++				.div_int_max = DIV_INT_16BIT_MAX,
++				.fc0_src = FC_NUM(1, 1),
++				),
++
++	[RP1_CLK_GP2] = REGISTER_CLK(
++				.name = "clk_gp2",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_GP2_CTRL,
++				.div_int_reg = CLK_GP2_DIV_INT,
++				.div_frac_reg = CLK_GP2_DIV_FRAC,
++				.sel_reg = CLK_GP2_SEL,
++				.div_int_max = DIV_INT_16BIT_MAX,
++				.fc0_src = FC_NUM(2, 1),
++				),
++
++	[RP1_CLK_GP3] = REGISTER_CLK(
++				.name = "clk_gp3",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_GP3_CTRL,
++				.div_int_reg = CLK_GP3_DIV_INT,
++				.div_frac_reg = CLK_GP3_DIV_FRAC,
++				.sel_reg = CLK_GP3_SEL,
++				.div_int_max = DIV_INT_16BIT_MAX,
++				.fc0_src = FC_NUM(3, 1),
++				),
++
++	[RP1_CLK_GP4] = REGISTER_CLK(
++				.name = "clk_gp4",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_GP4_CTRL,
++				.div_int_reg = CLK_GP4_DIV_INT,
++				.div_frac_reg = CLK_GP4_DIV_FRAC,
++				.sel_reg = CLK_GP4_SEL,
++				.div_int_max = DIV_INT_16BIT_MAX,
++				.fc0_src = FC_NUM(4, 1),
++				),
++
++	[RP1_CLK_GP5] = REGISTER_CLK(
++				.name = "clk_gp5",
++				.parents = {"xosc"},
++				.num_std_parents = 0,
++				.num_aux_parents = 1,
++				.ctrl_reg = CLK_GP5_CTRL,
++				.div_int_reg = CLK_GP5_DIV_INT,
++				.div_frac_reg = CLK_GP5_DIV_FRAC,
++				.sel_reg = CLK_GP5_SEL,
++				.div_int_max = DIV_INT_16BIT_MAX,
++				.fc0_src = FC_NUM(5, 1),
++				),
++
++	[RP1_CLK_VEC] = REGISTER_CLK(
++				.name = "clk_vec",
++				.parents = {"pll_sys_pri_ph",
++					    "pll_video_sec",
++					    "pll_video",
++					    "clk_gp0",
++					    "clk_gp1",
++					    "clk_gp2",
++					    "clk_gp3",
++					    "clk_gp4"},
++				.num_std_parents = 0,
++				.num_aux_parents = 8, /* XXX in fact there are more than 8 */
++				.ctrl_reg = VIDEO_CLK_VEC_CTRL,
++				.div_int_reg = VIDEO_CLK_VEC_DIV_INT,
++				.sel_reg = VIDEO_CLK_VEC_SEL,
++				.flags = CLK_SET_RATE_NO_REPARENT, /* Let VEC driver set parent */
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(0, 6),
++				),
++
++	[RP1_CLK_DPI] = REGISTER_CLK(
++				.name = "clk_dpi",
++				.parents = {"pll_sys",
++					    "pll_video_sec",
++					    "pll_video",
++					    "clk_gp0",
++					    "clk_gp1",
++					    "clk_gp2",
++					    "clk_gp3",
++					    "clk_gp4"},
++				.num_std_parents = 0,
++				.num_aux_parents = 8, /* XXX in fact there are more than 8 */
++				.ctrl_reg = VIDEO_CLK_DPI_CTRL,
++				.div_int_reg = VIDEO_CLK_DPI_DIV_INT,
++				.sel_reg = VIDEO_CLK_DPI_SEL,
++				.flags = CLK_SET_RATE_NO_REPARENT, /* Let DPI driver set parent */
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(1, 6),
++				),
++
++	[RP1_CLK_MIPI0_DPI] = REGISTER_CLK(
++				.name = "clk_mipi0_dpi",
++				.parents = {"pll_sys",
++					    "pll_video_sec",
++					    "pll_video",
++					    "clksrc_mipi0_dsi_byteclk",
++					    "clk_gp0",
++					    "clk_gp1",
++					    "clk_gp2",
++					    "clk_gp3"},
++				.num_std_parents = 0,
++				.num_aux_parents = 8, /* XXX in fact there are more than 8 */
++				.ctrl_reg = VIDEO_CLK_MIPI0_DPI_CTRL,
++				.div_int_reg = VIDEO_CLK_MIPI0_DPI_DIV_INT,
++				.div_frac_reg = VIDEO_CLK_MIPI0_DPI_DIV_FRAC,
++				.sel_reg = VIDEO_CLK_MIPI0_DPI_SEL,
++				.flags = CLK_SET_RATE_NO_REPARENT, /* Let DSI driver set parent */
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(2, 6),
++				),
++
++	[RP1_CLK_MIPI1_DPI] = REGISTER_CLK(
++				.name = "clk_mipi1_dpi",
++				.parents = {"pll_sys",
++					    "pll_video_sec",
++					    "pll_video",
++					    "clksrc_mipi1_dsi_byteclk",
++					    "clk_gp0",
++					    "clk_gp1",
++					    "clk_gp2",
++					    "clk_gp3"},
++				.num_std_parents = 0,
++				.num_aux_parents = 8, /* XXX in fact there are more than 8 */
++				.ctrl_reg = VIDEO_CLK_MIPI1_DPI_CTRL,
++				.div_int_reg = VIDEO_CLK_MIPI1_DPI_DIV_INT,
++				.div_frac_reg = VIDEO_CLK_MIPI1_DPI_DIV_FRAC,
++				.sel_reg = VIDEO_CLK_MIPI1_DPI_SEL,
++				.flags = CLK_SET_RATE_NO_REPARENT, /* Let DSI driver set parent */
++				.div_int_max = DIV_INT_8BIT_MAX,
++				.fc0_src = FC_NUM(3, 6),
++				),
++};
++
++static bool rp1_clk_claimed[ARRAY_SIZE(clk_desc_array)];
++
++static bool rp1_clk_is_claimed(const char *name)
++{
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(clk_desc_array); i++) {
++		if (clk_desc_array[i].data) {
++			const char *clk_name = *(const char **)(clk_desc_array[i].data);
++
++			if (!strcmp(name, clk_name))
++				return rp1_clk_claimed[i];
++		}
++	}
++
++	return false;
++}
++
++static int rp1_clk_probe(struct platform_device *pdev)
++{
++	const struct rp1_clk_desc *desc;
++	struct device *dev = &pdev->dev;
++	struct rp1_clockman *clockman;
++	struct resource *res;
++	struct clk_hw **hws;
++	const size_t asize = ARRAY_SIZE(clk_desc_array);
++	u32 chip_id, platform;
++	unsigned int i;
++	u32 clk_id;
++	int ret;
++
++	clockman = devm_kzalloc(dev, struct_size(clockman, onecell.hws, asize),
++				GFP_KERNEL);
++	if (!clockman)
++		return -ENOMEM;
++
++	rp1_get_platform(&chip_id, &platform);
++
++	spin_lock_init(&clockman->regs_lock);
++	clockman->dev = dev;
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	clockman->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(clockman->regs))
++		return PTR_ERR(clockman->regs);
++
++	memset(rp1_clk_claimed, 0, sizeof(rp1_clk_claimed));
++	for (i = 0;
++	     !of_property_read_u32_index(pdev->dev.of_node, "claim-clocks",
++					 i, &clk_id);
++	     i++)
++		rp1_clk_claimed[clk_id] = true;
++
++	platform_set_drvdata(pdev, clockman);
++
++	clockman->onecell.num = asize;
++	hws = clockman->onecell.hws;
++
++	for (i = 0; i < asize; i++) {
++		desc = &clk_desc_array[i];
++		if (desc->clk_register && desc->data)
++			hws[i] = desc->clk_register(clockman, desc->data);
++	}
++
++	ret = of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,
++				     &clockman->onecell);
++	if (ret)
++		return ret;
++
++	return 0;
++}
++
++static const struct of_device_id rp1_clk_of_match[] = {
++	{ .compatible = "raspberrypi,rp1-clocks" },
++	{}
++};
++MODULE_DEVICE_TABLE(of, rp1_clk_of_match);
++
++static struct platform_driver rp1_clk_driver = {
++	.driver = {
++		.name = "rp1-clk",
++		.of_match_table = rp1_clk_of_match,
++	},
++	.probe = rp1_clk_probe,
++};
++
++static int __init __rp1_clk_driver_init(void)
++{
++	return platform_driver_register(&rp1_clk_driver);
++}
++postcore_initcall(__rp1_clk_driver_init);
++
++MODULE_AUTHOR("Naushir Patuck <naush@raspberrypi.com>");
++MODULE_DESCRIPTION("RP1 clock driver");
++MODULE_LICENSE("GPL");
+--- a/include/dt-bindings/clock/rp1.h
++++ b/include/dt-bindings/clock/rp1.h
+@@ -13,39 +13,40 @@
+ 
+ #define RP1_PLL_SYS_PRI_PH		6
+ #define RP1_PLL_SYS_SEC_PH		7
++#define RP1_PLL_AUDIO_PRI_PH		8
+ 
+-#define RP1_PLL_SYS_SEC			8
+-#define RP1_PLL_AUDIO_SEC		9
+-#define RP1_PLL_VIDEO_SEC		10
++#define RP1_PLL_SYS_SEC			9
++#define RP1_PLL_AUDIO_SEC		10
++#define RP1_PLL_VIDEO_SEC		11
+ 
+-#define RP1_CLK_SYS			11
+-#define RP1_CLK_SLOW_SYS		12
+-#define RP1_CLK_DMA			13
+-#define RP1_CLK_UART			14
+-#define RP1_CLK_ETH			15
+-#define RP1_CLK_PWM0			16
+-#define RP1_CLK_PWM1			17
+-#define RP1_CLK_AUDIO_IN		18
+-#define RP1_CLK_AUDIO_OUT		19
+-#define RP1_CLK_I2S			20
+-#define RP1_CLK_MIPI0_CFG		21
+-#define RP1_CLK_MIPI1_CFG		22
+-#define RP1_CLK_PCIE_AUX		23
+-#define RP1_CLK_USBH0_MICROFRAME	24
+-#define RP1_CLK_USBH1_MICROFRAME	25
+-#define RP1_CLK_USBH0_SUSPEND		26
+-#define RP1_CLK_USBH1_SUSPEND		27
+-#define RP1_CLK_ETH_TSU			28
+-#define RP1_CLK_ADC			29
+-#define RP1_CLK_SDIO_TIMER		30
+-#define RP1_CLK_SDIO_ALT_SRC		31
+-#define RP1_CLK_GP0			32
+-#define RP1_CLK_GP1			33
+-#define RP1_CLK_GP2			34
+-#define RP1_CLK_GP3			35
+-#define RP1_CLK_GP4			36
+-#define RP1_CLK_GP5			37
+-#define RP1_CLK_VEC			38
+-#define RP1_CLK_DPI			39
+-#define RP1_CLK_MIPI0_DPI		40
+-#define RP1_CLK_MIPI1_DPI		41
++#define RP1_CLK_SYS			12
++#define RP1_CLK_SLOW_SYS		13
++#define RP1_CLK_DMA			14
++#define RP1_CLK_UART			15
++#define RP1_CLK_ETH			16
++#define RP1_CLK_PWM0			17
++#define RP1_CLK_PWM1			18
++#define RP1_CLK_AUDIO_IN		19
++#define RP1_CLK_AUDIO_OUT		20
++#define RP1_CLK_I2S			21
++#define RP1_CLK_MIPI0_CFG		22
++#define RP1_CLK_MIPI1_CFG		23
++#define RP1_CLK_PCIE_AUX		24
++#define RP1_CLK_USBH0_MICROFRAME	25
++#define RP1_CLK_USBH1_MICROFRAME	26
++#define RP1_CLK_USBH0_SUSPEND		27
++#define RP1_CLK_USBH1_SUSPEND		28
++#define RP1_CLK_ETH_TSU			29
++#define RP1_CLK_ADC			30
++#define RP1_CLK_SDIO_TIMER		31
++#define RP1_CLK_SDIO_ALT_SRC		32
++#define RP1_CLK_GP0			33
++#define RP1_CLK_GP1			34
++#define RP1_CLK_GP2			35
++#define RP1_CLK_GP3			36
++#define RP1_CLK_GP4			37
++#define RP1_CLK_GP5			38
++#define RP1_CLK_VEC			39
++#define RP1_CLK_DPI			40
++#define RP1_CLK_MIPI0_DPI		41
++#define RP1_CLK_MIPI1_DPI		42
diff --git a/target/linux/bcm27xx/patches-6.1/950-0875-dt-bindings-pinctrl-Add-bindings-for-Raspberry-Pi-RP.patch b/target/linux/bcm27xx/patches-6.1/950-0875-dt-bindings-pinctrl-Add-bindings-for-Raspberry-Pi-RP.patch
new file mode 100644
index 0000000000..d0180a65ba
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0875-dt-bindings-pinctrl-Add-bindings-for-Raspberry-Pi-RP.patch
@@ -0,0 +1,60 @@
+From 19b934ce3763c9465c5c80302f7c142d30b75869 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 28 Oct 2022 14:13:30 +0100
+Subject: [PATCH] dt-bindings: pinctrl: Add bindings for Raspberry Pi RP1
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ include/dt-bindings/pinctrl/rp1.h | 46 +++++++++++++++++++++++++++++++
+ 1 file changed, 46 insertions(+)
+ create mode 100644 include/dt-bindings/pinctrl/rp1.h
+
+--- /dev/null
++++ b/include/dt-bindings/pinctrl/rp1.h
+@@ -0,0 +1,46 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Header providing constants for RP1 pinctrl bindings.
++ *
++ * Copyright (C) 2019-2022 Raspberry Pi Ltd.
++ */
++
++#ifndef __DT_BINDINGS_PINCTRL_RP1_H__
++#define __DT_BINDINGS_PINCTRL_RP1_H__
++
++/* brcm,function property */
++#define RP1_FSEL_GPIO_IN	0
++#define RP1_FSEL_GPIO_OUT	1
++#define RP1_FSEL_ALT0_LEGACY	4
++#define RP1_FSEL_ALT1_LEGACY	5
++#define RP1_FSEL_ALT2_LEGACY	6
++#define RP1_FSEL_ALT3_LEGACY	7
++#define RP1_FSEL_ALT4_LEGACY	3
++#define RP1_FSEL_ALT5_LEGACY	2
++#define RP1_FSEL_ALT0		0x08
++#define RP1_FSEL_ALT0INV	0x09
++#define RP1_FSEL_ALT1		0x0a
++#define RP1_FSEL_ALT1INV	0x0b
++#define RP1_FSEL_ALT2		0x0c
++#define RP1_FSEL_ALT2INV	0x0d
++#define RP1_FSEL_ALT3		0x0e
++#define RP1_FSEL_ALT3INV	0x0f
++#define RP1_FSEL_ALT4		0x10
++#define RP1_FSEL_ALT4INV	0x11
++#define RP1_FSEL_ALT5		0x12
++#define RP1_FSEL_ALT5INV	0x13
++#define RP1_FSEL_ALT6		0x14
++#define RP1_FSEL_ALT6INV	0x15
++#define RP1_FSEL_ALT7		0x16
++#define RP1_FSEL_ALT7INV	0x17
++#define RP1_FSEL_ALT8		0x18
++#define RP1_FSEL_ALT8INV	0x19
++#define RP1_FSEL_NONE		0x1a
++
++/* brcm,pull property */
++#define RP1_PUD_OFF		0
++#define RP1_PUD_DOWN		1
++#define RP1_PUD_UP		2
++#define RP1_PUD_KEEP		3
++
++#endif /* __DT_BINDINGS_PINCTRL_RP1_H__ */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0876-pinctrl-Add-rp1-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0876-pinctrl-Add-rp1-driver.patch
new file mode 100644
index 0000000000..c824cddb51
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0876-pinctrl-Add-rp1-driver.patch
@@ -0,0 +1,1666 @@
+From 4d4cc5be473a7767052122a87393a83d10f9ed41 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 10 Oct 2022 14:21:11 +0100
+Subject: [PATCH] pinctrl: Add rp1 driver
+
+RP1 exposes GPIOs. Add a pinctrl driver to allow control of those.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/pinctrl/Kconfig           |    7 +
+ drivers/pinctrl/Makefile          |    1 +
+ drivers/pinctrl/pinctrl-rp1.c     | 1571 +++++++++++++++++++++++++++++
+ include/dt-bindings/pinctrl/rp1.h |   46 -
+ 4 files changed, 1579 insertions(+), 46 deletions(-)
+ create mode 100644 drivers/pinctrl/pinctrl-rp1.c
+ delete mode 100644 include/dt-bindings/pinctrl/rp1.h
+
+--- a/drivers/pinctrl/Kconfig
++++ b/drivers/pinctrl/Kconfig
+@@ -512,6 +512,13 @@ config PINCTRL_ZYNQMP
+ 	  This driver can also be built as a module. If so, the module
+ 	  will be called pinctrl-zynqmp.
+ 
++config PINCTRL_RP1
++	bool "Pinctrl driver for RP1"
++	select PINMUX
++	select PINCONF
++	select GENERIC_PINCONF
++	select GPIOLIB_IRQCHIP
++
+ source "drivers/pinctrl/actions/Kconfig"
+ source "drivers/pinctrl/aspeed/Kconfig"
+ source "drivers/pinctrl/bcm/Kconfig"
+--- a/drivers/pinctrl/Makefile
++++ b/drivers/pinctrl/Makefile
+@@ -42,6 +42,7 @@ obj-$(CONFIG_PINCTRL_PIC32)	+= pinctrl-p
+ obj-$(CONFIG_PINCTRL_PISTACHIO)	+= pinctrl-pistachio.o
+ obj-$(CONFIG_PINCTRL_RK805)	+= pinctrl-rk805.o
+ obj-$(CONFIG_PINCTRL_ROCKCHIP)	+= pinctrl-rockchip.o
++obj-$(CONFIG_PINCTRL_RP1)	+= pinctrl-rp1.o
+ obj-$(CONFIG_PINCTRL_SINGLE)	+= pinctrl-single.o
+ obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
+ obj-$(CONFIG_PINCTRL_STMFX) 	+= pinctrl-stmfx.o
+--- /dev/null
++++ b/drivers/pinctrl/pinctrl-rp1.c
+@@ -0,0 +1,1571 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Driver for Raspberry Pi RP1 GPIO unit (pinctrl + GPIO)
++ *
++ * Copyright (C) 2023 Raspberry Pi Ltd.
++ *
++ * This driver is inspired by:
++ * pinctrl-bcm2835.c, please see original file for copyright information
++ */
++
++#include <linux/bitmap.h>
++#include <linux/bitops.h>
++#include <linux/bug.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/err.h>
++#include <linux/gpio/driver.h>
++#include <linux/io.h>
++#include <linux/irq.h>
++#include <linux/irqdesc.h>
++#include <linux/init.h>
++#include <linux/of_address.h>
++#include <linux/of.h>
++#include <linux/of_irq.h>
++#include <linux/pinctrl/consumer.h>
++#include <linux/pinctrl/machine.h>
++#include <linux/pinctrl/pinconf.h>
++#include <linux/pinctrl/pinctrl.h>
++#include <linux/pinctrl/pinmux.h>
++#include <linux/pinctrl/pinconf-generic.h>
++#include <linux/platform_device.h>
++#include <linux/seq_file.h>
++#include <linux/spinlock.h>
++#include <linux/types.h>
++#include "core.h"
++#include "pinconf.h"
++#include "pinctrl-utils.h"
++
++#define MODULE_NAME "pinctrl-rp1"
++#define RP1_NUM_GPIOS	54
++#define RP1_NUM_BANKS	3
++
++#define RP1_RW_OFFSET			0x0000
++#define RP1_XOR_OFFSET			0x1000
++#define RP1_SET_OFFSET			0x2000
++#define RP1_CLR_OFFSET			0x3000
++
++#define RP1_GPIO_STATUS			0x0000
++#define RP1_GPIO_CTRL			0x0004
++
++#define RP1_GPIO_PCIE_INTE		0x011c
++#define RP1_GPIO_PCIE_INTS		0x0124
++
++#define RP1_GPIO_EVENTS_SHIFT_RAW	20
++#define RP1_GPIO_STATUS_FALLING		BIT(20)
++#define RP1_GPIO_STATUS_RISING		BIT(21)
++#define RP1_GPIO_STATUS_LOW		BIT(22)
++#define RP1_GPIO_STATUS_HIGH		BIT(23)
++
++#define RP1_GPIO_EVENTS_SHIFT_FILTERED	24
++#define RP1_GPIO_STATUS_F_FALLING	BIT(24)
++#define RP1_GPIO_STATUS_F_RISING	BIT(25)
++#define RP1_GPIO_STATUS_F_LOW		BIT(26)
++#define RP1_GPIO_STATUS_F_HIGH		BIT(27)
++
++#define RP1_GPIO_CTRL_FUNCSEL_LSB	0
++#define RP1_GPIO_CTRL_FUNCSEL_MASK	0x0000001f
++#define RP1_GPIO_CTRL_OUTOVER_LSB	12
++#define RP1_GPIO_CTRL_OUTOVER_MASK	0x00003000
++#define RP1_GPIO_CTRL_OEOVER_LSB	14
++#define RP1_GPIO_CTRL_OEOVER_MASK	0x0000c000
++#define RP1_GPIO_CTRL_INOVER_LSB	16
++#define RP1_GPIO_CTRL_INOVER_MASK	0x00030000
++#define RP1_GPIO_CTRL_IRQEN_FALLING	BIT(20)
++#define RP1_GPIO_CTRL_IRQEN_RISING	BIT(21)
++#define RP1_GPIO_CTRL_IRQEN_LOW		BIT(22)
++#define RP1_GPIO_CTRL_IRQEN_HIGH	BIT(23)
++#define RP1_GPIO_CTRL_IRQEN_F_FALLING	BIT(24)
++#define RP1_GPIO_CTRL_IRQEN_F_RISING	BIT(25)
++#define RP1_GPIO_CTRL_IRQEN_F_LOW	BIT(26)
++#define RP1_GPIO_CTRL_IRQEN_F_HIGH	BIT(27)
++#define RP1_GPIO_CTRL_IRQRESET		BIT(28)
++#define RP1_GPIO_CTRL_IRQOVER_LSB	30
++#define RP1_GPIO_CTRL_IRQOVER_MASK	0xc0000000
++
++#define RP1_INT_EDGE_FALLING		BIT(0)
++#define RP1_INT_EDGE_RISING		BIT(1)
++#define RP1_INT_LEVEL_LOW		BIT(2)
++#define RP1_INT_LEVEL_HIGH		BIT(3)
++#define RP1_INT_MASK			0xf
++
++#define RP1_INT_EDGE_BOTH		(RP1_INT_EDGE_FALLING |	\
++					 RP1_INT_EDGE_RISING)
++#define RP1_PUD_OFF			0
++#define RP1_PUD_DOWN			1
++#define RP1_PUD_UP			2
++
++#define RP1_FSEL_COUNT			9
++
++#define RP1_FSEL_ALT0			0x00
++#define RP1_FSEL_GPIO			0x05
++#define RP1_FSEL_NONE			0x09
++#define RP1_FSEL_NONE_HW		0x1f
++
++#define RP1_DIR_OUTPUT			0
++#define RP1_DIR_INPUT			1
++
++#define RP1_OUTOVER_PERI		0
++#define RP1_OUTOVER_INVPERI		1
++#define RP1_OUTOVER_LOW			2
++#define RP1_OUTOVER_HIGH		3
++
++#define RP1_OEOVER_PERI			0
++#define RP1_OEOVER_INVPERI		1
++#define RP1_OEOVER_DISABLE		2
++#define RP1_OEOVER_ENABLE		3
++
++#define RP1_INOVER_PERI			0
++#define RP1_INOVER_INVPERI		1
++#define RP1_INOVER_LOW			2
++#define RP1_INOVER_HIGH			3
++
++#define RP1_RIO_OUT			0x00
++#define RP1_RIO_OE			0x04
++#define RP1_RIO_IN			0x08
++
++#define RP1_PAD_SLEWFAST_MASK		0x00000001
++#define RP1_PAD_SLEWFAST_LSB		0
++#define RP1_PAD_SCHMITT_MASK		0x00000002
++#define RP1_PAD_SCHMITT_LSB		1
++#define RP1_PAD_PULL_MASK		0x0000000c
++#define RP1_PAD_PULL_LSB		2
++#define RP1_PAD_DRIVE_MASK		0x00000030
++#define RP1_PAD_DRIVE_LSB		4
++#define RP1_PAD_IN_ENABLE_MASK		0x00000040
++#define RP1_PAD_IN_ENABLE_LSB		6
++#define RP1_PAD_OUT_DISABLE_MASK	0x00000080
++#define RP1_PAD_OUT_DISABLE_LSB		7
++
++#define RP1_PAD_DRIVE_2MA		0x00000000
++#define RP1_PAD_DRIVE_4MA		0x00000010
++#define RP1_PAD_DRIVE_8MA		0x00000020
++#define RP1_PAD_DRIVE_12MA		0x00000030
++
++#define FLD_GET(r, f) (((r) & (f ## _MASK)) >> (f ## _LSB))
++#define FLD_SET(r, f, v) r = (((r) & ~(f ## _MASK)) | ((v) << (f ## _LSB)))
++
++#define FUNC(f) \
++	[func_##f] = #f
++#define RP1_MAX_FSEL 8
++#define PIN(i, f0, f1, f2, f3, f4, f5, f6, f7, f8) \
++	[i] = { \
++		.funcs = { \
++			func_##f0, \
++			func_##f1, \
++			func_##f2, \
++			func_##f3, \
++			func_##f4, \
++			func_##f5, \
++			func_##f6, \
++			func_##f7, \
++			func_##f8, \
++		}, \
++	}
++
++#define LEGACY_MAP(n, f0, f1, f2, f3, f4, f5) \
++	[n] = { \
++		func_gpio, \
++		func_gpio, \
++		func_##f5, \
++		func_##f4, \
++		func_##f0, \
++		func_##f1, \
++		func_##f2, \
++		func_##f3, \
++	}
++
++struct rp1_iobank_desc {
++	int min_gpio;
++	int num_gpios;
++	int gpio_offset;
++	int inte_offset;
++	int ints_offset;
++	int rio_offset;
++	int pads_offset;
++};
++
++struct rp1_pin_info {
++	u8 num;
++	u8 bank;
++	u8 offset;
++	u8 fsel;
++	u8 irq_type;
++
++	void __iomem *gpio;
++	void __iomem *rio;
++	void __iomem *inte;
++	void __iomem *ints;
++	void __iomem *pad;
++};
++
++enum funcs {
++	func_alt0,
++	func_alt1,
++	func_alt2,
++	func_alt3,
++	func_alt4,
++	func_gpio,
++	func_alt6,
++	func_alt7,
++	func_alt8,
++	func_none,
++	func_aaud,
++	func_dcd0,
++	func_dpi,
++	func_dsi0_te_ext,
++	func_dsi1_te_ext,
++	func_dsr0,
++	func_dtr0,
++	func_gpclk0,
++	func_gpclk1,
++	func_gpclk2,
++	func_gpclk3,
++	func_gpclk4,
++	func_gpclk5,
++	func_i2c0,
++	func_i2c1,
++	func_i2c2,
++	func_i2c3,
++	func_i2c4,
++	func_i2c5,
++	func_i2c6,
++	func_i2s0,
++	func_i2s1,
++	func_i2s2,
++	func_ir,
++	func_mic,
++	func_pcie_clkreq_n,
++	func_pio,
++	func_proc_rio,
++	func_pwm0,
++	func_pwm1,
++	func_ri0,
++	func_sd0,
++	func_sd1,
++	func_spi0,
++	func_spi1,
++	func_spi2,
++	func_spi3,
++	func_spi4,
++	func_spi5,
++	func_spi6,
++	func_spi7,
++	func_spi8,
++	func_uart0,
++	func_uart1,
++	func_uart2,
++	func_uart3,
++	func_uart4,
++	func_uart5,
++	func_vbus0,
++	func_vbus1,
++	func_vbus2,
++	func_vbus3,
++	func__,
++	func_count = func__,
++	func_invalid = func__,
++};
++
++struct rp1_pin_funcs {
++	u8 funcs[RP1_FSEL_COUNT];
++};
++
++struct rp1_pinctrl {
++	struct device *dev;
++	void __iomem *gpio_base;
++	void __iomem *rio_base;
++	void __iomem *pads_base;
++	int irq[RP1_NUM_BANKS];
++	struct rp1_pin_info pins[RP1_NUM_GPIOS];
++
++	struct pinctrl_dev *pctl_dev;
++	struct gpio_chip gpio_chip;
++	struct pinctrl_gpio_range gpio_range;
++
++	raw_spinlock_t irq_lock[RP1_NUM_BANKS];
++};
++
++const struct rp1_iobank_desc rp1_iobanks[RP1_NUM_BANKS] = {
++	/*         gpio   inte    ints     rio    pads */
++	{  0, 28, 0x0000, 0x011c, 0x0124, 0x0000, 0x0004 },
++	{ 28,  6, 0x4000, 0x411c, 0x4124, 0x4000, 0x4004 },
++	{ 34, 20, 0x8000, 0x811c, 0x8124, 0x8000, 0x8004 },
++};
++
++/* pins are just named GPIO0..GPIO53 */
++#define RP1_GPIO_PIN(a) PINCTRL_PIN(a, "gpio" #a)
++static struct pinctrl_pin_desc rp1_gpio_pins[] = {
++	RP1_GPIO_PIN(0),
++	RP1_GPIO_PIN(1),
++	RP1_GPIO_PIN(2),
++	RP1_GPIO_PIN(3),
++	RP1_GPIO_PIN(4),
++	RP1_GPIO_PIN(5),
++	RP1_GPIO_PIN(6),
++	RP1_GPIO_PIN(7),
++	RP1_GPIO_PIN(8),
++	RP1_GPIO_PIN(9),
++	RP1_GPIO_PIN(10),
++	RP1_GPIO_PIN(11),
++	RP1_GPIO_PIN(12),
++	RP1_GPIO_PIN(13),
++	RP1_GPIO_PIN(14),
++	RP1_GPIO_PIN(15),
++	RP1_GPIO_PIN(16),
++	RP1_GPIO_PIN(17),
++	RP1_GPIO_PIN(18),
++	RP1_GPIO_PIN(19),
++	RP1_GPIO_PIN(20),
++	RP1_GPIO_PIN(21),
++	RP1_GPIO_PIN(22),
++	RP1_GPIO_PIN(23),
++	RP1_GPIO_PIN(24),
++	RP1_GPIO_PIN(25),
++	RP1_GPIO_PIN(26),
++	RP1_GPIO_PIN(27),
++	RP1_GPIO_PIN(28),
++	RP1_GPIO_PIN(29),
++	RP1_GPIO_PIN(30),
++	RP1_GPIO_PIN(31),
++	RP1_GPIO_PIN(32),
++	RP1_GPIO_PIN(33),
++	RP1_GPIO_PIN(34),
++	RP1_GPIO_PIN(35),
++	RP1_GPIO_PIN(36),
++	RP1_GPIO_PIN(37),
++	RP1_GPIO_PIN(38),
++	RP1_GPIO_PIN(39),
++	RP1_GPIO_PIN(40),
++	RP1_GPIO_PIN(41),
++	RP1_GPIO_PIN(42),
++	RP1_GPIO_PIN(43),
++	RP1_GPIO_PIN(44),
++	RP1_GPIO_PIN(45),
++	RP1_GPIO_PIN(46),
++	RP1_GPIO_PIN(47),
++	RP1_GPIO_PIN(48),
++	RP1_GPIO_PIN(49),
++	RP1_GPIO_PIN(50),
++	RP1_GPIO_PIN(51),
++	RP1_GPIO_PIN(52),
++	RP1_GPIO_PIN(53),
++};
++
++/* one pin per group */
++static const char * const rp1_gpio_groups[] = {
++	"gpio0",
++	"gpio1",
++	"gpio2",
++	"gpio3",
++	"gpio4",
++	"gpio5",
++	"gpio6",
++	"gpio7",
++	"gpio8",
++	"gpio9",
++	"gpio10",
++	"gpio11",
++	"gpio12",
++	"gpio13",
++	"gpio14",
++	"gpio15",
++	"gpio16",
++	"gpio17",
++	"gpio18",
++	"gpio19",
++	"gpio20",
++	"gpio21",
++	"gpio22",
++	"gpio23",
++	"gpio24",
++	"gpio25",
++	"gpio26",
++	"gpio27",
++	"gpio28",
++	"gpio29",
++	"gpio30",
++	"gpio31",
++	"gpio32",
++	"gpio33",
++	"gpio34",
++	"gpio35",
++	"gpio36",
++	"gpio37",
++	"gpio38",
++	"gpio39",
++	"gpio40",
++	"gpio41",
++	"gpio42",
++	"gpio43",
++	"gpio44",
++	"gpio45",
++	"gpio46",
++	"gpio47",
++	"gpio48",
++	"gpio49",
++	"gpio50",
++	"gpio51",
++	"gpio52",
++	"gpio53",
++};
++
++static const char * const rp1_func_names[] = {
++	FUNC(alt0),
++	FUNC(alt1),
++	FUNC(alt2),
++	FUNC(alt3),
++	FUNC(alt4),
++	FUNC(gpio),
++	FUNC(alt6),
++	FUNC(alt7),
++	FUNC(alt8),
++	FUNC(none),
++	FUNC(aaud),
++	FUNC(dcd0),
++	FUNC(dpi),
++	FUNC(dsi0_te_ext),
++	FUNC(dsi1_te_ext),
++	FUNC(dsr0),
++	FUNC(dtr0),
++	FUNC(gpclk0),
++	FUNC(gpclk1),
++	FUNC(gpclk2),
++	FUNC(gpclk3),
++	FUNC(gpclk4),
++	FUNC(gpclk5),
++	FUNC(i2c0),
++	FUNC(i2c1),
++	FUNC(i2c2),
++	FUNC(i2c3),
++	FUNC(i2c4),
++	FUNC(i2c5),
++	FUNC(i2c6),
++	FUNC(i2s0),
++	FUNC(i2s1),
++	FUNC(i2s2),
++	FUNC(ir),
++	FUNC(mic),
++	FUNC(pcie_clkreq_n),
++	FUNC(pio),
++	FUNC(proc_rio),
++	FUNC(pwm0),
++	FUNC(pwm1),
++	FUNC(ri0),
++	FUNC(sd0),
++	FUNC(sd1),
++	FUNC(spi0),
++	FUNC(spi1),
++	FUNC(spi2),
++	FUNC(spi3),
++	FUNC(spi4),
++	FUNC(spi5),
++	FUNC(spi6),
++	FUNC(spi7),
++	FUNC(spi8),
++	FUNC(uart0),
++	FUNC(uart1),
++	FUNC(uart2),
++	FUNC(uart3),
++	FUNC(uart4),
++	FUNC(uart5),
++	FUNC(vbus0),
++	FUNC(vbus1),
++	FUNC(vbus2),
++	FUNC(vbus3),
++	[func_invalid] = "?"
++};
++
++static const struct rp1_pin_funcs rp1_gpio_pin_funcs[] = {
++	PIN(0, spi0, dpi, uart1, i2c0, _, gpio, proc_rio, pio, spi2),
++	PIN(1, spi0, dpi, uart1, i2c0, _, gpio, proc_rio, pio, spi2),
++	PIN(2, spi0, dpi, uart1, i2c1, ir, gpio, proc_rio, pio, spi2),
++	PIN(3, spi0, dpi, uart1, i2c1, ir, gpio, proc_rio, pio, spi2),
++	PIN(4, gpclk0, dpi, uart2, i2c2, ri0, gpio, proc_rio, pio, spi3),
++	PIN(5, gpclk1, dpi, uart2, i2c2, dtr0, gpio, proc_rio, pio, spi3),
++	PIN(6, gpclk2, dpi, uart2, i2c3, dcd0, gpio, proc_rio, pio, spi3),
++	PIN(7, spi0, dpi, uart2, i2c3, dsr0, gpio, proc_rio, pio, spi3),
++	PIN(8, spi0, dpi, uart3, i2c0, _, gpio, proc_rio, pio, spi4),
++	PIN(9, spi0, dpi, uart3, i2c0, _, gpio, proc_rio, pio, spi4),
++	PIN(10, spi0, dpi, uart3, i2c1, _, gpio, proc_rio, pio, spi4),
++	PIN(11, spi0, dpi, uart3, i2c1, _, gpio, proc_rio, pio, spi4),
++	PIN(12, pwm0, dpi, uart4, i2c2, aaud, gpio, proc_rio, pio, spi5),
++	PIN(13, pwm0, dpi, uart4, i2c2, aaud, gpio, proc_rio, pio, spi5),
++	PIN(14, pwm0, dpi, uart4, i2c3, uart0, gpio, proc_rio, pio, spi5),
++	PIN(15, pwm0, dpi, uart4, i2c3, uart0, gpio, proc_rio, pio, spi5),
++	PIN(16, spi1, dpi, dsi0_te_ext, _, uart0, gpio, proc_rio, pio, _),
++	PIN(17, spi1, dpi, dsi1_te_ext, _, uart0, gpio, proc_rio, pio, _),
++	PIN(18, spi1, dpi, i2s0, pwm0, i2s1, gpio, proc_rio, pio, gpclk1),
++	PIN(19, spi1, dpi, i2s0, pwm0, i2s1, gpio, proc_rio, pio, _),
++	PIN(20, spi1, dpi, i2s0, gpclk0, i2s1, gpio, proc_rio, pio, _),
++	PIN(21, spi1, dpi, i2s0, gpclk1, i2s1, gpio, proc_rio, pio, _),
++	PIN(22, sd0, dpi, i2s0, i2c3, i2s1, gpio, proc_rio, pio, _),
++	PIN(23, sd0, dpi, i2s0, i2c3, i2s1, gpio, proc_rio, pio, _),
++	PIN(24, sd0, dpi, i2s0, _, i2s1, gpio, proc_rio, pio, spi2),
++	PIN(25, sd0, dpi, i2s0, mic, i2s1, gpio, proc_rio, pio, spi3),
++	PIN(26, sd0, dpi, i2s0, mic, i2s1, gpio, proc_rio, pio, spi5),
++	PIN(27, sd0, dpi, i2s0, mic, i2s1, gpio, proc_rio, pio, spi1),
++	PIN(28, sd1, i2c4, i2s2, spi6, vbus0, gpio, proc_rio, _, _),
++	PIN(29, sd1, i2c4, i2s2, spi6, vbus0, gpio, proc_rio, _, _),
++	PIN(30, sd1, i2c5, i2s2, spi6, uart5, gpio, proc_rio, _, _),
++	PIN(31, sd1, i2c5, i2s2, spi6, uart5, gpio, proc_rio, _, _),
++	PIN(32, sd1, gpclk3, i2s2, spi6, uart5, gpio, proc_rio, _, _),
++	PIN(33, sd1, gpclk4, i2s2, spi6, uart5, gpio, proc_rio, _, _),
++	PIN(34, pwm1, gpclk3, vbus0, i2c4, mic, gpio, proc_rio, _, _),
++	PIN(35, spi8, pwm1, vbus0, i2c4, mic, gpio, proc_rio, _, _),
++	PIN(36, spi8, uart5, pcie_clkreq_n, i2c5, mic, gpio, proc_rio, _, _),
++	PIN(37, spi8, uart5, mic, i2c5, pcie_clkreq_n, gpio, proc_rio, _, _),
++	PIN(38, spi8, uart5, mic, i2c6, aaud, gpio, proc_rio, dsi0_te_ext, _),
++	PIN(39, spi8, uart5, mic, i2c6, aaud, gpio, proc_rio, dsi1_te_ext, _),
++	PIN(40, pwm1, uart5, i2c4, spi6, aaud, gpio, proc_rio, _, _),
++	PIN(41, pwm1, uart5, i2c4, spi6, aaud, gpio, proc_rio, _, _),
++	PIN(42, gpclk5, uart5, vbus1, spi6, i2s2, gpio, proc_rio, _, _),
++	PIN(43, gpclk4, uart5, vbus1, spi6, i2s2, gpio, proc_rio, _, _),
++	PIN(44, gpclk5, i2c5, pwm1, spi6, i2s2, gpio, proc_rio, _, _),
++	PIN(45, pwm1, i2c5, spi7, spi6, i2s2, gpio, proc_rio, _, _),
++	PIN(46, gpclk3, i2c4, spi7, mic, i2s2, gpio, proc_rio, dsi0_te_ext, _),
++	PIN(47, gpclk5, i2c4, spi7, mic, i2s2, gpio, proc_rio, dsi1_te_ext, _),
++	PIN(48, pwm1, pcie_clkreq_n, spi7, mic, uart5, gpio, proc_rio, _, _),
++	PIN(49, spi8, spi7, i2c5, aaud, uart5, gpio, proc_rio, _, _),
++	PIN(50, spi8, spi7, i2c5, aaud, vbus2, gpio, proc_rio, _, _),
++	PIN(51, spi8, spi7, i2c6, aaud, vbus2, gpio, proc_rio, _, _),
++	PIN(52, spi8, _, i2c6, aaud, vbus3, gpio, proc_rio, _, _),
++	PIN(53, spi8, spi7, _, pcie_clkreq_n, vbus3, gpio, proc_rio, _, _),
++};
++
++static const u8 legacy_fsel_map[][8] = {
++	LEGACY_MAP(0, i2c0, _, dpi, spi2, uart1, _),
++	LEGACY_MAP(1, i2c0, _, dpi, spi2, uart1, _),
++	LEGACY_MAP(2, i2c1, _, dpi, spi2, uart1, _),
++	LEGACY_MAP(3, i2c1, _, dpi, spi2, uart1, _),
++	LEGACY_MAP(4, gpclk0, _, dpi, spi3, uart2, i2c2),
++	LEGACY_MAP(5, gpclk1, _, dpi, spi3, uart2, i2c2),
++	LEGACY_MAP(6, gpclk2, _, dpi, spi3, uart2, i2c3),
++	LEGACY_MAP(7, spi0, _, dpi, spi3, uart2, i2c3),
++	LEGACY_MAP(8, spi0, _, dpi, _, uart3, i2c0),
++	LEGACY_MAP(9, spi0, _, dpi, _, uart3, i2c0),
++	LEGACY_MAP(10, spi0, _, dpi, _, uart3, i2c1),
++	LEGACY_MAP(11, spi0, _, dpi, _, uart3, i2c1),
++	LEGACY_MAP(12, pwm0, _, dpi, spi5, uart4, i2c2),
++	LEGACY_MAP(13, pwm0, _, dpi, spi5, uart4, i2c2),
++	LEGACY_MAP(14, uart0, _, dpi, spi5, uart4, _),
++	LEGACY_MAP(15, uart0, _, dpi, spi5, uart4, _),
++	LEGACY_MAP(16, _, _, dpi, uart0, spi1, _),
++	LEGACY_MAP(17, _, _, dpi, uart0, spi1, _),
++	LEGACY_MAP(18, i2s0, _, dpi, _, spi1, pwm0),
++	LEGACY_MAP(19, i2s0, _, dpi, _, spi1, pwm0),
++	LEGACY_MAP(20, i2s0, _, dpi, _, spi1, gpclk0),
++	LEGACY_MAP(21, i2s0, _, dpi, _, spi1, gpclk1),
++	LEGACY_MAP(22, sd0, _, dpi, _, _, i2c3),
++	LEGACY_MAP(23, sd0, _, dpi, _, _, i2c3),
++	LEGACY_MAP(24, sd0, _, dpi, _, _, spi2),
++	LEGACY_MAP(25, sd0, _, dpi, _, _, spi3),
++	LEGACY_MAP(26, sd0, _, dpi, _, _, spi5),
++	LEGACY_MAP(27, sd0, _, dpi, _, _, _),
++};
++
++static const char * const irq_type_names[] = {
++	[IRQ_TYPE_NONE] = "none",
++	[IRQ_TYPE_EDGE_RISING] = "edge-rising",
++	[IRQ_TYPE_EDGE_FALLING] = "edge-falling",
++	[IRQ_TYPE_EDGE_BOTH] = "edge-both",
++	[IRQ_TYPE_LEVEL_HIGH] = "level-high",
++	[IRQ_TYPE_LEVEL_LOW] = "level-low",
++};
++
++static int rp1_pinconf_set(struct pinctrl_dev *pctldev,
++			   unsigned int offset, unsigned long *configs,
++			   unsigned int num_configs);
++
++static struct rp1_pin_info *rp1_get_pin(struct gpio_chip *chip,
++					unsigned int offset)
++{
++	struct rp1_pinctrl *pc = gpiochip_get_data(chip);
++
++	if (pc && offset < RP1_NUM_GPIOS)
++		return &pc->pins[offset];
++	return NULL;
++}
++
++static struct rp1_pin_info *rp1_get_pin_pctl(struct pinctrl_dev *pctldev,
++					     unsigned int offset)
++{
++	struct rp1_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++
++	if (pc && offset < RP1_NUM_GPIOS)
++		return &pc->pins[offset];
++	return NULL;
++}
++
++static void rp1_pad_update(struct rp1_pin_info *pin, u32 clr, u32 set)
++{
++	u32 padctrl = readl(pin->pad);
++
++	padctrl &= ~clr;
++	padctrl |= set;
++
++	writel(padctrl, pin->pad);
++}
++
++static void rp1_input_enable(struct rp1_pin_info *pin, int value)
++{
++	rp1_pad_update(pin, RP1_PAD_IN_ENABLE_MASK,
++		       value ? RP1_PAD_IN_ENABLE_MASK : 0);
++}
++
++static void rp1_output_enable(struct rp1_pin_info *pin, int value)
++{
++	rp1_pad_update(pin, RP1_PAD_OUT_DISABLE_MASK,
++		       value ? 0 : RP1_PAD_OUT_DISABLE_MASK);
++}
++
++static u32 rp1_get_fsel(struct rp1_pin_info *pin)
++{
++	u32 ctrl = readl(pin->gpio + RP1_GPIO_CTRL);
++	u32 oeover = FLD_GET(ctrl, RP1_GPIO_CTRL_OEOVER);
++	u32 fsel = FLD_GET(ctrl, RP1_GPIO_CTRL_FUNCSEL);
++
++	if (oeover != RP1_OEOVER_PERI || fsel >= RP1_FSEL_COUNT)
++		fsel = RP1_FSEL_NONE;
++
++	return fsel;
++}
++
++static void rp1_set_fsel(struct rp1_pin_info *pin, u32 fsel)
++{
++	u32 ctrl = readl(pin->gpio + RP1_GPIO_CTRL);
++
++	if (fsel >= RP1_FSEL_COUNT)
++		fsel = RP1_FSEL_NONE_HW;
++
++	rp1_input_enable(pin, 1);
++	rp1_output_enable(pin, 1);
++
++	if (fsel == RP1_FSEL_NONE) {
++		FLD_SET(ctrl, RP1_GPIO_CTRL_OEOVER, RP1_OEOVER_DISABLE);
++	} else {
++		FLD_SET(ctrl, RP1_GPIO_CTRL_OUTOVER, RP1_OUTOVER_PERI);
++		FLD_SET(ctrl, RP1_GPIO_CTRL_OEOVER, RP1_OEOVER_PERI);
++	}
++	FLD_SET(ctrl, RP1_GPIO_CTRL_FUNCSEL, fsel);
++	writel(ctrl, pin->gpio + RP1_GPIO_CTRL);
++}
++
++static int rp1_get_dir(struct rp1_pin_info *pin)
++{
++	return !(readl(pin->rio + RP1_RIO_OE) & (1 << pin->offset)) ?
++		RP1_DIR_INPUT : RP1_DIR_OUTPUT;
++}
++
++static void rp1_set_dir(struct rp1_pin_info *pin, bool is_input)
++{
++	int offset = is_input ? RP1_CLR_OFFSET : RP1_SET_OFFSET;
++
++	writel(1 << pin->offset, pin->rio + RP1_RIO_OE + offset);
++}
++
++static int rp1_get_value(struct rp1_pin_info *pin)
++{
++	return !!(readl(pin->rio + RP1_RIO_IN) & (1 << pin->offset));
++}
++
++static void rp1_set_value(struct rp1_pin_info *pin, int value)
++{
++	/* Assume the pin is already an output */
++	writel(1 << pin->offset,
++	       pin->rio + RP1_RIO_OUT + (value ? RP1_SET_OFFSET : RP1_CLR_OFFSET));
++}
++
++static int rp1_gpio_get(struct gpio_chip *chip, unsigned offset)
++{
++	struct rp1_pin_info *pin = rp1_get_pin(chip, offset);
++	int ret;
++
++	if (!pin)
++		return -EINVAL;
++	ret = rp1_get_value(pin);
++	return ret;
++}
++
++static void rp1_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
++{
++	struct rp1_pin_info *pin = rp1_get_pin(chip, offset);
++
++	if (pin)
++		rp1_set_value(pin, value);
++}
++
++static int rp1_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
++{
++	struct rp1_pin_info *pin = rp1_get_pin(chip, offset);
++	u32 fsel;
++
++	if (!pin)
++		return -EINVAL;
++	fsel = rp1_get_fsel(pin);
++	if (fsel != RP1_FSEL_GPIO)
++		return -EINVAL;
++	return (rp1_get_dir(pin) == RP1_DIR_OUTPUT) ?
++		GPIO_LINE_DIRECTION_OUT :
++		GPIO_LINE_DIRECTION_IN;
++}
++
++static int rp1_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
++{
++	struct rp1_pin_info *pin = rp1_get_pin(chip, offset);
++
++	if (!pin)
++		return -EINVAL;
++	rp1_set_dir(pin, RP1_DIR_INPUT);
++	rp1_set_fsel(pin, RP1_FSEL_GPIO);
++	return 0;
++}
++
++static int rp1_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
++				     int value)
++{
++	struct rp1_pin_info *pin = rp1_get_pin(chip, offset);
++
++	if (!pin)
++		return -EINVAL;
++	rp1_set_value(pin, value);
++	rp1_set_dir(pin, RP1_DIR_OUTPUT);
++	rp1_set_fsel(pin, RP1_FSEL_GPIO);
++	return 0;
++}
++
++static int rp1_gpio_set_config(struct gpio_chip *gc, unsigned offset,
++			       unsigned long config)
++{
++	struct rp1_pinctrl *pc = gpiochip_get_data(gc);
++	unsigned long configs[] = { config };
++
++	return rp1_pinconf_set(pc->pctl_dev, offset, configs,
++			      ARRAY_SIZE(configs));
++}
++
++static const struct gpio_chip rp1_gpio_chip = {
++	.label = MODULE_NAME,
++	.owner = THIS_MODULE,
++	.request = gpiochip_generic_request,
++	.free = gpiochip_generic_free,
++	.direction_input = rp1_gpio_direction_input,
++	.direction_output = rp1_gpio_direction_output,
++	.get_direction = rp1_gpio_get_direction,
++	.get = rp1_gpio_get,
++	.set = rp1_gpio_set,
++	.base = -1,
++	.set_config = rp1_gpio_set_config,
++	.ngpio = RP1_NUM_GPIOS,
++	.can_sleep = false,
++};
++
++static void rp1_gpio_irq_handler(struct irq_desc *desc)
++{
++	struct gpio_chip *chip = irq_desc_get_handler_data(desc);
++	struct rp1_pinctrl *pc = gpiochip_get_data(chip);
++	struct irq_chip *host_chip = irq_desc_get_chip(desc);
++	const struct rp1_iobank_desc *bank;
++	int irq = irq_desc_get_irq(desc);
++	unsigned long ints;
++	int b;
++
++	if (pc->irq[0] == irq)
++		bank = &rp1_iobanks[0];
++	else if (pc->irq[1] == irq)
++		bank = &rp1_iobanks[1];
++	else
++		bank = &rp1_iobanks[2];
++
++	chained_irq_enter(host_chip, desc);
++
++	ints = readl(pc->gpio_base + bank->ints_offset);
++	for_each_set_bit(b, &ints, 32) {
++		struct rp1_pin_info *pin = rp1_get_pin(chip, b);
++
++		writel(RP1_GPIO_CTRL_IRQRESET,
++		       pin->gpio + RP1_SET_OFFSET + RP1_GPIO_CTRL);
++		generic_handle_irq(irq_linear_revmap(pc->gpio_chip.irq.domain,
++						     bank->gpio_offset + b));
++	}
++
++	chained_irq_exit(host_chip, desc);
++}
++
++static void rp1_gpio_irq_config(struct rp1_pin_info *pin, bool enable)
++{
++	writel(1 << pin->offset,
++	       pin->inte + (enable ? RP1_SET_OFFSET : RP1_CLR_OFFSET));
++	if (!enable)
++		/* Clear any latched events */
++		writel(RP1_GPIO_CTRL_IRQRESET,
++		       pin->gpio + RP1_SET_OFFSET + RP1_GPIO_CTRL);
++}
++
++static void rp1_gpio_irq_enable(struct irq_data *data)
++{
++	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
++	unsigned gpio = irqd_to_hwirq(data);
++	struct rp1_pin_info *pin = rp1_get_pin(chip, gpio);
++
++	rp1_gpio_irq_config(pin, true);
++}
++
++static void rp1_gpio_irq_disable(struct irq_data *data)
++{
++	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
++	unsigned gpio = irqd_to_hwirq(data);
++	struct rp1_pin_info *pin = rp1_get_pin(chip, gpio);
++
++	rp1_gpio_irq_config(pin, false);
++}
++
++static int rp1_irq_set_type(struct rp1_pin_info *pin, unsigned int type)
++{
++	u32 irq_flags;
++
++	switch (type) {
++	case IRQ_TYPE_NONE:
++		irq_flags = 0;
++		break;
++	case IRQ_TYPE_EDGE_RISING:
++		irq_flags = RP1_INT_EDGE_RISING;
++		break;
++	case IRQ_TYPE_EDGE_FALLING:
++		irq_flags = RP1_INT_EDGE_FALLING;
++		break;
++	case IRQ_TYPE_EDGE_BOTH:
++		irq_flags = RP1_INT_EDGE_RISING | RP1_INT_EDGE_FALLING;
++		break;
++	case IRQ_TYPE_LEVEL_HIGH:
++		irq_flags = RP1_INT_LEVEL_HIGH;
++		break;
++	case IRQ_TYPE_LEVEL_LOW:
++		irq_flags = RP1_INT_LEVEL_LOW;
++		break;
++
++	default:
++		return -EINVAL;
++	}
++
++	/* Clear them all */
++	writel(RP1_INT_MASK << RP1_GPIO_EVENTS_SHIFT_RAW,
++	       pin->gpio + RP1_CLR_OFFSET + RP1_GPIO_CTRL);
++	/* Set those that are needed */
++	writel(irq_flags << RP1_GPIO_EVENTS_SHIFT_RAW,
++	       pin->gpio + RP1_SET_OFFSET + RP1_GPIO_CTRL);
++	pin->irq_type = type;
++
++	return 0;
++}
++
++static int rp1_gpio_irq_set_type(struct irq_data *data, unsigned int type)
++{
++	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
++	struct rp1_pinctrl *pc = gpiochip_get_data(chip);
++	unsigned gpio = irqd_to_hwirq(data);
++	struct rp1_pin_info *pin = rp1_get_pin(chip, gpio);
++	int bank = pin->bank;
++	unsigned long flags;
++	int ret;
++
++	raw_spin_lock_irqsave(&pc->irq_lock[bank], flags);
++
++	ret = rp1_irq_set_type(pin, type);
++	if (!ret) {
++		if (type & IRQ_TYPE_EDGE_BOTH)
++			irq_set_handler_locked(data, handle_edge_irq);
++		else
++			irq_set_handler_locked(data, handle_level_irq);
++	}
++
++	raw_spin_unlock_irqrestore(&pc->irq_lock[bank], flags);
++
++	return ret;
++}
++
++static void rp1_gpio_irq_ack(struct irq_data *data)
++{
++	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
++	unsigned gpio = irqd_to_hwirq(data);
++	struct rp1_pin_info *pin = rp1_get_pin(chip, gpio);
++
++	/* Clear any latched events */
++	writel(RP1_GPIO_CTRL_IRQRESET, pin->gpio + RP1_SET_OFFSET + RP1_GPIO_CTRL);
++}
++
++static struct irq_chip rp1_gpio_irq_chip = {
++	.name = MODULE_NAME,
++	.irq_enable = rp1_gpio_irq_enable,
++	.irq_disable = rp1_gpio_irq_disable,
++	.irq_set_type = rp1_gpio_irq_set_type,
++	.irq_ack = rp1_gpio_irq_ack,
++	.irq_mask = rp1_gpio_irq_disable,
++	.irq_unmask = rp1_gpio_irq_enable,
++	.flags = IRQCHIP_IMMUTABLE,
++};
++
++static int rp1_pctl_get_groups_count(struct pinctrl_dev *pctldev)
++{
++	return ARRAY_SIZE(rp1_gpio_groups);
++}
++
++static const char *rp1_pctl_get_group_name(struct pinctrl_dev *pctldev,
++					   unsigned selector)
++{
++	return rp1_gpio_groups[selector];
++}
++
++static enum funcs rp1_get_fsel_func(unsigned pin, unsigned fsel)
++{
++	if (pin < RP1_NUM_GPIOS) {
++		if (fsel < RP1_FSEL_COUNT)
++			return rp1_gpio_pin_funcs[pin].funcs[fsel];
++		else if (fsel == RP1_FSEL_NONE)
++			return func_none;
++	}
++	return func_invalid;
++}
++
++static int rp1_pctl_get_group_pins(struct pinctrl_dev *pctldev,
++				   unsigned selector,
++				   const unsigned **pins,
++				   unsigned *num_pins)
++{
++	*pins = &rp1_gpio_pins[selector].number;
++	*num_pins = 1;
++
++	return 0;
++}
++
++static void rp1_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,
++				  struct seq_file *s,
++				  unsigned offset)
++{
++	struct rp1_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++	struct gpio_chip *chip = &pc->gpio_chip;
++	struct rp1_pin_info *pin = rp1_get_pin_pctl(pctldev, offset);
++	u32 fsel = rp1_get_fsel(pin);
++	enum funcs func = rp1_get_fsel_func(offset, fsel);
++	int value = rp1_get_value(pin);
++	int irq = irq_find_mapping(chip->irq.domain, offset);
++
++	seq_printf(s, "function %s (%s) in %s; irq %d (%s)",
++		   rp1_func_names[fsel], rp1_func_names[func],
++		   value ? "hi" : "lo",
++		   irq, irq_type_names[pin->irq_type]);
++}
++
++static void rp1_pctl_dt_free_map(struct pinctrl_dev *pctldev,
++				 struct pinctrl_map *maps, unsigned num_maps)
++{
++	int i;
++
++	for (i = 0; i < num_maps; i++)
++		if (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)
++			kfree(maps[i].data.configs.configs);
++
++	kfree(maps);
++}
++
++static int rp1_pctl_legacy_map_func(struct rp1_pinctrl *pc,
++				    struct device_node *np, u32 pin, u32 fnum,
++				    struct pinctrl_map *maps,
++				    unsigned int *num_maps)
++{
++	struct pinctrl_map *map = &maps[*num_maps];
++	enum funcs func;
++
++	if (fnum >= ARRAY_SIZE(legacy_fsel_map[0])) {
++		dev_err(pc->dev, "%pOF: invalid brcm,function %d\n", np, fnum);
++		return -EINVAL;
++	}
++
++	func = legacy_fsel_map[pin][fnum];
++	if (func == func_invalid) {
++		dev_err(pc->dev, "%pOF: brcm,function %d not supported on pin %d\n",
++			np, fnum, pin);
++	}
++
++	map->type = PIN_MAP_TYPE_MUX_GROUP;
++	map->data.mux.group = rp1_gpio_groups[pin];
++	map->data.mux.function = rp1_func_names[func];
++	(*num_maps)++;
++
++	return 0;
++}
++
++static int rp1_pctl_legacy_map_pull(struct rp1_pinctrl *pc,
++				    struct device_node *np, u32 pin, u32 pull,
++				    struct pinctrl_map *maps,
++				    unsigned int *num_maps)
++{
++	struct pinctrl_map *map = &maps[*num_maps];
++	enum pin_config_param param;
++	unsigned long *configs;
++
++	switch (pull) {
++	case RP1_PUD_OFF:
++		param = PIN_CONFIG_BIAS_DISABLE;
++		break;
++	case RP1_PUD_DOWN:
++		param = PIN_CONFIG_BIAS_PULL_DOWN;
++		break;
++	case RP1_PUD_UP:
++		param = PIN_CONFIG_BIAS_PULL_UP;
++		break;
++	default:
++		dev_err(pc->dev, "%pOF: invalid brcm,pull %d\n", np, pull);
++		return -EINVAL;
++	}
++
++	configs = kzalloc(sizeof(*configs), GFP_KERNEL);
++	if (!configs)
++		return -ENOMEM;
++
++	configs[0] = pinconf_to_config_packed(param, 0);
++	map->type = PIN_MAP_TYPE_CONFIGS_PIN;
++	map->data.configs.group_or_pin = rp1_gpio_pins[pin].name;
++	map->data.configs.configs = configs;
++	map->data.configs.num_configs = 1;
++	(*num_maps)++;
++
++	return 0;
++}
++
++static int rp1_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,
++				   struct device_node *np,
++				   struct pinctrl_map **map,
++				   unsigned int *num_maps)
++{
++	struct rp1_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
++	struct property *pins, *funcs, *pulls;
++	int num_pins, num_funcs, num_pulls, maps_per_pin;
++	struct pinctrl_map *maps;
++	unsigned long *configs = NULL;
++	const char *function = NULL;
++	unsigned int reserved_maps;
++	int num_configs = 0;
++	int i, err;
++	u32 pin, func, pull;
++
++	/* Check for legacy pin declaration */
++	pins = of_find_property(np, "brcm,pins", NULL);
++
++	if (!pins) /* Assume generic bindings in this node */
++		return pinconf_generic_dt_node_to_map_all(pctldev, np, map, num_maps);
++
++	funcs = of_find_property(np, "brcm,function", NULL);
++	if (!funcs)
++		of_property_read_string(np, "function", &function);
++
++	pulls = of_find_property(np, "brcm,pull", NULL);
++	if (!pulls)
++		pinconf_generic_parse_dt_config(np, pctldev, &configs, &num_configs);
++
++	if (!function && !funcs && !num_configs && !pulls) {
++		dev_err(pc->dev,
++			"%pOF: no function, brcm,function, brcm,pull, etc.\n",
++			np);
++		return -EINVAL;
++	}
++
++	num_pins = pins->length / 4;
++	num_funcs = funcs ? (funcs->length / 4) : 0;
++	num_pulls = pulls ? (pulls->length / 4) : 0;
++
++	if (num_funcs > 1 && num_funcs != num_pins) {
++		dev_err(pc->dev,
++			"%pOF: brcm,function must have 1 or %d entries\n",
++			np, num_pins);
++		return -EINVAL;
++	}
++
++	if (num_pulls > 1 && num_pulls != num_pins) {
++		dev_err(pc->dev,
++			"%pOF: brcm,pull must have 1 or %d entries\n",
++			np, num_pins);
++		return -EINVAL;
++	}
++
++	maps_per_pin = 0;
++	if (function || num_funcs)
++		maps_per_pin++;
++	if (num_configs || num_pulls)
++		maps_per_pin++;
++	reserved_maps = num_pins * maps_per_pin;
++	maps = kcalloc(reserved_maps, sizeof(*maps), GFP_KERNEL);
++	if (!maps)
++		return -ENOMEM;
++
++	*num_maps = 0;
++
++	for (i = 0; i < num_pins; i++) {
++		err = of_property_read_u32_index(np, "brcm,pins", i, &pin);
++		if (err)
++			goto out;
++		if (pin >= ARRAY_SIZE(legacy_fsel_map)) {
++			dev_err(pc->dev, "%pOF: invalid brcm,pins value %d\n",
++				np, pin);
++			err = -EINVAL;
++			goto out;
++		}
++
++		if (num_funcs) {
++			err = of_property_read_u32_index(np, "brcm,function",
++							 (num_funcs > 1) ? i : 0,
++							 &func);
++			if (err)
++				goto out;
++			err = rp1_pctl_legacy_map_func(pc, np, pin, func,
++						       maps, num_maps);
++		} else if (function) {
++			err = pinctrl_utils_add_map_mux(pctldev, &maps,
++							&reserved_maps, num_maps,
++							rp1_gpio_groups[pin],
++							function);
++		}
++
++		if (err)
++			goto out;
++
++		if (num_pulls) {
++			err = of_property_read_u32_index(np, "brcm,pull",
++							 (num_pulls > 1) ? i : 0,
++							 &pull);
++			if (err)
++				goto out;
++			err = rp1_pctl_legacy_map_pull(pc, np, pin, pull,
++						       maps, num_maps);
++		} else if (num_configs) {
++			err = pinctrl_utils_add_map_configs(pctldev, &maps,
++							    &reserved_maps, num_maps,
++							    rp1_gpio_groups[pin],
++							    configs, num_configs,
++							    PIN_MAP_TYPE_CONFIGS_PIN);
++		}
++
++		if (err)
++			goto out;
++	}
++
++	*map = maps;
++
++	return 0;
++
++out:
++	rp1_pctl_dt_free_map(pctldev, maps, reserved_maps);
++	return err;
++}
++
++static const struct pinctrl_ops rp1_pctl_ops = {
++	.get_groups_count = rp1_pctl_get_groups_count,
++	.get_group_name = rp1_pctl_get_group_name,
++	.get_group_pins = rp1_pctl_get_group_pins,
++	.pin_dbg_show = rp1_pctl_pin_dbg_show,
++	.dt_node_to_map = rp1_pctl_dt_node_to_map,
++	.dt_free_map = rp1_pctl_dt_free_map,
++};
++
++static int rp1_pmx_free(struct pinctrl_dev *pctldev, unsigned offset)
++{
++	struct rp1_pin_info *pin = rp1_get_pin_pctl(pctldev, offset);
++	u32 fsel = rp1_get_fsel(pin);
++
++	/* Return non-GPIOs to GPIO_IN */
++	if (fsel != RP1_FSEL_GPIO) {
++		rp1_set_dir(pin, RP1_DIR_INPUT);
++		rp1_set_fsel(pin, RP1_FSEL_GPIO);
++	}
++
++	return 0;
++}
++
++static int rp1_pmx_get_functions_count(struct pinctrl_dev *pctldev)
++{
++	return func_count;
++}
++
++static const char *rp1_pmx_get_function_name(struct pinctrl_dev *pctldev,
++					     unsigned selector)
++{
++	return (selector < func_count) ? rp1_func_names[selector] : NULL;
++}
++
++static int rp1_pmx_get_function_groups(struct pinctrl_dev *pctldev,
++				       unsigned selector,
++				       const char * const **groups,
++				       unsigned * const num_groups)
++{
++	/* every pin can do every function */
++	*groups = rp1_gpio_groups;
++	*num_groups = ARRAY_SIZE(rp1_gpio_groups);
++
++	return 0;
++}
++
++static int rp1_pmx_set(struct pinctrl_dev *pctldev, unsigned func_selector,
++		       unsigned group_selector)
++{
++	struct rp1_pin_info *pin = rp1_get_pin_pctl(pctldev, group_selector);
++	const u8 *pin_funcs;
++	int fsel;
++
++	/* func_selector is an enum funcs, so needs translation */
++
++	if (func_selector >= RP1_FSEL_COUNT) {
++		/* Convert to an fsel number */
++		pin_funcs = rp1_gpio_pin_funcs[pin->num].funcs;
++		for (fsel = 0; fsel < RP1_FSEL_COUNT; fsel++) {
++			if (pin_funcs[fsel] == func_selector)
++				break;
++		}
++	} else {
++		fsel = (int)func_selector;
++	}
++
++	if (fsel >= RP1_FSEL_COUNT && fsel != RP1_FSEL_NONE)
++		return -EINVAL;
++
++	rp1_set_fsel(pin, fsel);
++
++	return 0;
++}
++
++static void rp1_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,
++				      struct pinctrl_gpio_range *range,
++				      unsigned offset)
++{
++	(void)rp1_pmx_free(pctldev, offset);
++}
++
++static int rp1_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
++				      struct pinctrl_gpio_range *range,
++				      unsigned offset,
++				      bool input)
++{
++	struct rp1_pin_info *pin = rp1_get_pin_pctl(pctldev, offset);
++
++	rp1_set_dir(pin, input);
++	rp1_set_fsel(pin, RP1_FSEL_GPIO);
++
++	return 0;
++}
++
++static const struct pinmux_ops rp1_pmx_ops = {
++	.free = rp1_pmx_free,
++	.get_functions_count = rp1_pmx_get_functions_count,
++	.get_function_name = rp1_pmx_get_function_name,
++	.get_function_groups = rp1_pmx_get_function_groups,
++	.set_mux = rp1_pmx_set,
++	.gpio_disable_free = rp1_pmx_gpio_disable_free,
++	.gpio_set_direction = rp1_pmx_gpio_set_direction,
++};
++
++static void rp1_pull_config_set(struct rp1_pin_info *pin, unsigned int arg)
++{
++	u32 padctrl = readl(pin->pad);
++
++	FLD_SET(padctrl, RP1_PAD_PULL, arg & 0x3);
++
++	writel(padctrl, pin->pad);
++}
++
++/* Generic pinconf methods */
++
++static int rp1_pinconf_set(struct pinctrl_dev *pctldev, unsigned int offset,
++			   unsigned long *configs, unsigned int num_configs)
++{
++	struct rp1_pin_info *pin = rp1_get_pin_pctl(pctldev, offset);
++	u32 param, arg;
++	int i;
++
++	if (!pin)
++		return -EINVAL;
++
++	for (i = 0; i < num_configs; i++) {
++		param = pinconf_to_config_param(configs[i]);
++		arg = pinconf_to_config_argument(configs[i]);
++
++		switch (param) {
++		case PIN_CONFIG_BIAS_DISABLE:
++			rp1_pull_config_set(pin, RP1_PUD_OFF);
++			break;
++
++		case PIN_CONFIG_BIAS_PULL_DOWN:
++			rp1_pull_config_set(pin, RP1_PUD_DOWN);
++			break;
++
++		case PIN_CONFIG_BIAS_PULL_UP:
++			rp1_pull_config_set(pin, RP1_PUD_UP);
++			break;
++
++		case PIN_CONFIG_INPUT_ENABLE:
++			rp1_input_enable(pin, arg);
++			break;
++
++		case PIN_CONFIG_OUTPUT_ENABLE:
++			rp1_output_enable(pin, arg);
++			break;
++
++		case PIN_CONFIG_OUTPUT:
++			rp1_set_value(pin, arg);
++			rp1_set_dir(pin, RP1_DIR_OUTPUT);
++			rp1_set_fsel(pin, RP1_FSEL_GPIO);
++			break;
++
++		case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
++			rp1_pad_update(pin, RP1_PAD_SCHMITT_MASK,
++				       arg ? RP1_PAD_SCHMITT_MASK : 0);
++			break;
++
++		case PIN_CONFIG_SLEW_RATE:
++			rp1_pad_update(pin, RP1_PAD_SLEWFAST_MASK,
++				       arg ? RP1_PAD_SLEWFAST_MASK : 0);
++			break;
++
++		case PIN_CONFIG_DRIVE_STRENGTH:
++			switch (arg) {
++			case 2:
++				arg = RP1_PAD_DRIVE_2MA;
++				break;
++			case 4:
++				arg = RP1_PAD_DRIVE_4MA;
++				break;
++			case 8:
++				arg = RP1_PAD_DRIVE_8MA;
++				break;
++			case 12:
++				arg = RP1_PAD_DRIVE_12MA;
++				break;
++			default:
++				return -ENOTSUPP;
++			}
++			rp1_pad_update(pin, RP1_PAD_DRIVE_MASK, arg);
++			break;
++
++		default:
++			return -ENOTSUPP;
++
++		} /* switch param type */
++	} /* for each config */
++
++	return 0;
++}
++
++static int rp1_pinconf_get(struct pinctrl_dev *pctldev, unsigned offset,
++			   unsigned long *config)
++{
++	struct rp1_pin_info *pin = rp1_get_pin_pctl(pctldev, offset);
++	enum pin_config_param param = pinconf_to_config_param(*config);
++	u32 padctrl;
++	u32 arg;
++
++	if (!pin)
++		return -EINVAL;
++
++	padctrl = readl(pin->pad);
++
++	switch (param) {
++	case PIN_CONFIG_INPUT_ENABLE:
++		arg = !!(padctrl & RP1_PAD_IN_ENABLE_MASK);
++		break;
++	case PIN_CONFIG_OUTPUT_ENABLE:
++		arg = !(padctrl & RP1_PAD_OUT_DISABLE_MASK);
++		break;
++	case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
++		arg = !!(padctrl & RP1_PAD_SCHMITT_MASK);
++		break;
++	case PIN_CONFIG_SLEW_RATE:
++		arg = !!(padctrl & RP1_PAD_SLEWFAST_MASK);
++		break;
++	case PIN_CONFIG_DRIVE_STRENGTH:
++		switch (padctrl & RP1_PAD_DRIVE_MASK) {
++		case RP1_PAD_DRIVE_2MA:
++			arg = 2;
++			break;
++		case RP1_PAD_DRIVE_4MA:
++			arg = 4;
++			break;
++		case RP1_PAD_DRIVE_8MA:
++			arg = 8;
++			break;
++		case RP1_PAD_DRIVE_12MA:
++			arg = 12;
++			break;
++		}
++		break;
++	case PIN_CONFIG_BIAS_DISABLE:
++		arg = ((padctrl & RP1_PAD_PULL_MASK) == (RP1_PUD_OFF << RP1_PAD_PULL_LSB));
++		break;
++	case PIN_CONFIG_BIAS_PULL_DOWN:
++		arg = ((padctrl & RP1_PAD_PULL_MASK) == (RP1_PUD_DOWN << RP1_PAD_PULL_LSB));
++		break;
++
++	case PIN_CONFIG_BIAS_PULL_UP:
++		arg = ((padctrl & RP1_PAD_PULL_MASK) == (RP1_PUD_UP << RP1_PAD_PULL_LSB));
++		break;
++	default:
++		return -ENOTSUPP;
++	}
++
++	*config = pinconf_to_config_packed(param, arg);
++
++	return 0;
++}
++
++static const struct pinconf_ops rp1_pinconf_ops = {
++	.is_generic = true,
++	.pin_config_get = rp1_pinconf_get,
++	.pin_config_set = rp1_pinconf_set,
++};
++
++static struct pinctrl_desc rp1_pinctrl_desc = {
++	.name = MODULE_NAME,
++	.pins = rp1_gpio_pins,
++	.npins = ARRAY_SIZE(rp1_gpio_pins),
++	.pctlops = &rp1_pctl_ops,
++	.pmxops = &rp1_pmx_ops,
++	.confops = &rp1_pinconf_ops,
++	.owner = THIS_MODULE,
++};
++
++static struct pinctrl_gpio_range rp1_pinctrl_gpio_range = {
++	.name = MODULE_NAME,
++	.npins = RP1_NUM_GPIOS,
++};
++
++static const struct of_device_id rp1_pinctrl_match[] = {
++	{
++		.compatible = "raspberrypi,rp1-gpio",
++		.data = &rp1_pinconf_ops,
++	},
++	{}
++};
++
++static inline void __iomem *devm_auto_iomap(struct platform_device *pdev,
++					    unsigned int index)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++
++	if (np)
++		return devm_of_iomap(dev, np, (int)index, NULL);
++	else
++		return devm_platform_ioremap_resource(pdev, index);
++}
++
++static int rp1_pinctrl_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++	struct rp1_pinctrl *pc;
++	struct gpio_irq_chip *girq;
++	int err, i;
++
++	BUILD_BUG_ON(ARRAY_SIZE(rp1_gpio_pins) != RP1_NUM_GPIOS);
++	BUILD_BUG_ON(ARRAY_SIZE(rp1_gpio_groups) != RP1_NUM_GPIOS);
++
++	pc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);
++	if (!pc)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, pc);
++	pc->dev = dev;
++
++	pc->gpio_base = devm_auto_iomap(pdev, 0);
++	if (IS_ERR(pc->gpio_base)) {
++		dev_err(dev, "could not get GPIO IO memory\n");
++		return PTR_ERR(pc->gpio_base);
++	}
++
++	pc->rio_base = devm_auto_iomap(pdev, 1);
++	if (IS_ERR(pc->rio_base)) {
++		dev_err(dev, "could not get RIO IO memory\n");
++		return PTR_ERR(pc->rio_base);
++	}
++
++	pc->pads_base = devm_auto_iomap(pdev, 2);
++	if (IS_ERR(pc->pads_base)) {
++		dev_err(dev, "could not get PADS IO memory\n");
++		return PTR_ERR(pc->pads_base);
++	}
++
++	pc->gpio_chip = rp1_gpio_chip;
++	pc->gpio_chip.parent = dev;
++
++	for (i = 0; i < RP1_NUM_BANKS; i++) {
++		const struct rp1_iobank_desc *bank = &rp1_iobanks[i];
++		int j;
++
++		for (j = 0; j < bank->num_gpios; j++) {
++			struct rp1_pin_info *pin =
++				&pc->pins[bank->min_gpio + j];
++
++			pin->num = bank->min_gpio + j;
++			pin->bank = i;
++			pin->offset = j;
++
++			pin->gpio = pc->gpio_base + bank->gpio_offset +
++				    j * sizeof(u32) * 2;
++			pin->inte = pc->gpio_base + bank->inte_offset;
++			pin->ints = pc->gpio_base + bank->ints_offset;
++			pin->rio  = pc->rio_base + bank->rio_offset;
++			pin->pad  = pc->pads_base + bank->pads_offset +
++				    j * sizeof(u32);
++		}
++
++		raw_spin_lock_init(&pc->irq_lock[i]);
++	}
++
++	pc->pctl_dev = devm_pinctrl_register(dev, &rp1_pinctrl_desc, pc);
++	if (IS_ERR(pc->pctl_dev))
++		return PTR_ERR(pc->pctl_dev);
++
++	girq = &pc->gpio_chip.irq;
++	girq->chip = &rp1_gpio_irq_chip;
++	girq->parent_handler = rp1_gpio_irq_handler;
++	girq->num_parents = RP1_NUM_BANKS;
++	girq->parents = pc->irq;
++
++	/*
++	 * Use the same handler for all groups: this is necessary
++	 * since we use one gpiochip to cover all lines - the
++	 * irq handler then needs to figure out which group and
++	 * bank that was firing the IRQ and look up the per-group
++	 * and bank data.
++	 */
++	for (i = 0; i < RP1_NUM_BANKS; i++) {
++		pc->irq[i] = irq_of_parse_and_map(np, i);
++		if (!pc->irq[i]) {
++			girq->num_parents = i;
++			break;
++		}
++	}
++
++	girq->default_type = IRQ_TYPE_NONE;
++	girq->handler = handle_level_irq;
++
++	err = devm_gpiochip_add_data(dev, &pc->gpio_chip, pc);
++	if (err) {
++		dev_err(dev, "could not add GPIO chip\n");
++		return err;
++	}
++
++	pc->gpio_range = rp1_pinctrl_gpio_range;
++	pc->gpio_range.base = pc->gpio_chip.base;
++	pc->gpio_range.gc = &pc->gpio_chip;
++	pinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);
++
++	return 0;
++}
++
++static struct platform_driver rp1_pinctrl_driver = {
++	.probe = rp1_pinctrl_probe,
++	.driver = {
++		.name = MODULE_NAME,
++		.of_match_table = rp1_pinctrl_match,
++		.suppress_bind_attrs = true,
++	},
++};
++builtin_platform_driver(rp1_pinctrl_driver);
+--- a/include/dt-bindings/pinctrl/rp1.h
++++ /dev/null
+@@ -1,46 +0,0 @@
+-/* SPDX-License-Identifier: GPL-2.0 */
+-/*
+- * Header providing constants for RP1 pinctrl bindings.
+- *
+- * Copyright (C) 2019-2022 Raspberry Pi Ltd.
+- */
+-
+-#ifndef __DT_BINDINGS_PINCTRL_RP1_H__
+-#define __DT_BINDINGS_PINCTRL_RP1_H__
+-
+-/* brcm,function property */
+-#define RP1_FSEL_GPIO_IN	0
+-#define RP1_FSEL_GPIO_OUT	1
+-#define RP1_FSEL_ALT0_LEGACY	4
+-#define RP1_FSEL_ALT1_LEGACY	5
+-#define RP1_FSEL_ALT2_LEGACY	6
+-#define RP1_FSEL_ALT3_LEGACY	7
+-#define RP1_FSEL_ALT4_LEGACY	3
+-#define RP1_FSEL_ALT5_LEGACY	2
+-#define RP1_FSEL_ALT0		0x08
+-#define RP1_FSEL_ALT0INV	0x09
+-#define RP1_FSEL_ALT1		0x0a
+-#define RP1_FSEL_ALT1INV	0x0b
+-#define RP1_FSEL_ALT2		0x0c
+-#define RP1_FSEL_ALT2INV	0x0d
+-#define RP1_FSEL_ALT3		0x0e
+-#define RP1_FSEL_ALT3INV	0x0f
+-#define RP1_FSEL_ALT4		0x10
+-#define RP1_FSEL_ALT4INV	0x11
+-#define RP1_FSEL_ALT5		0x12
+-#define RP1_FSEL_ALT5INV	0x13
+-#define RP1_FSEL_ALT6		0x14
+-#define RP1_FSEL_ALT6INV	0x15
+-#define RP1_FSEL_ALT7		0x16
+-#define RP1_FSEL_ALT7INV	0x17
+-#define RP1_FSEL_ALT8		0x18
+-#define RP1_FSEL_ALT8INV	0x19
+-#define RP1_FSEL_NONE		0x1a
+-
+-/* brcm,pull property */
+-#define RP1_PUD_OFF		0
+-#define RP1_PUD_DOWN		1
+-#define RP1_PUD_UP		2
+-#define RP1_PUD_KEEP		3
+-
+-#endif /* __DT_BINDINGS_PINCTRL_RP1_H__ */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0877-serial-pl011-rp1-uart-support.patch b/target/linux/bcm27xx/patches-6.1/950-0877-serial-pl011-rp1-uart-support.patch
new file mode 100644
index 0000000000..b0b9897e89
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0877-serial-pl011-rp1-uart-support.patch
@@ -0,0 +1,129 @@
+From f88da9e21d8eff58eeb9280ae96bf9593121d8eb Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 12 Oct 2022 13:24:51 +0100
+Subject: [PATCH] serial: pl011: rp1 uart support
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/tty/serial/amba-pl011.c | 96 +++++++++++++++++++++++++++++++++
+ 1 file changed, 96 insertions(+)
+
+--- a/drivers/tty/serial/amba-pl011.c
++++ b/drivers/tty/serial/amba-pl011.c
+@@ -152,6 +152,20 @@ static const struct vendor_data vendor_s
+ 	.fixed_options		= true,
+ };
+ 
++static struct vendor_data vendor_arm_axi = {
++	.reg_offset		= pl011_std_offsets,
++	.ifls			= UART011_IFLS_RX4_8 | UART011_IFLS_TX4_8,
++	.fr_busy		= UART01x_FR_BUSY,
++	.fr_dsr			= UART01x_FR_DSR,
++	.fr_cts			= UART01x_FR_CTS,
++	.fr_ri			= UART011_FR_RI,
++	.oversampling		= false,
++	.dma_threshold		= false,
++	.cts_event_workaround	= false,
++	.always_enabled		= false,
++	.fixed_options		= false,
++};
++
+ #ifdef CONFIG_ACPI_SPCR_TABLE
+ static const struct vendor_data vendor_qdt_qdf2400_e44 = {
+ 	.reg_offset		= pl011_std_offsets,
+@@ -2972,6 +2986,86 @@ static struct platform_driver arm_sbsa_u
+ 	},
+ };
+ 
++static int pl011_axi_probe(struct platform_device *pdev)
++{
++	struct uart_amba_port *uap;
++	struct vendor_data *vendor =  &vendor_arm_axi;
++	struct resource *r;
++	unsigned int periphid;
++	int portnr, ret, irq;
++
++	portnr = pl011_find_free_port();
++	if (portnr < 0)
++		return portnr;
++
++	uap = devm_kzalloc(&pdev->dev, sizeof(struct uart_amba_port),
++			   GFP_KERNEL);
++	if (!uap)
++		return -ENOMEM;
++
++	uap->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(uap->clk))
++		return PTR_ERR(uap->clk);
++
++	if (of_property_read_bool(pdev->dev.of_node, "cts-event-workaround")) {
++		vendor->cts_event_workaround = true;
++		dev_info(&pdev->dev, "cts_event_workaround enabled\n");
++	}
++
++	irq = platform_get_irq(pdev, 0);
++	if (irq < 0)
++		return irq;
++
++	periphid = 0x00241011; /* A safe default */
++	of_property_read_u32(pdev->dev.of_node, "arm,primecell-periphid",
++			     &periphid);
++
++	uap->reg_offset = vendor->reg_offset;
++	uap->vendor = vendor;
++	uap->fifosize = (AMBA_REV_BITS(periphid) < 3) ? 16 : 32;
++	uap->port.iotype = vendor->access_32b ? UPIO_MEM32 : UPIO_MEM;
++	uap->port.irq = irq;
++	uap->port.ops = &amba_pl011_pops;
++
++	snprintf(uap->type, sizeof(uap->type), "PL011 AXI");
++
++	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	ret = pl011_setup_port(&pdev->dev, uap, r, portnr);
++	if (ret)
++		return ret;
++
++	platform_set_drvdata(pdev, uap);
++
++	return pl011_register_port(uap);
++}
++
++static int pl011_axi_remove(struct platform_device *pdev)
++{
++	struct uart_amba_port *uap = platform_get_drvdata(pdev);
++
++	uart_remove_one_port(&amba_reg, &uap->port);
++	pl011_unregister_port(uap);
++	return 0;
++}
++
++static const struct of_device_id pl011_axi_of_match[] = {
++	{ .compatible = "arm,pl011-axi" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, pl011_axi_of_match);
++
++static struct platform_driver pl011_axi_platform_driver = {
++	.probe		= pl011_axi_probe,
++	.remove		= pl011_axi_remove,
++	.driver	= {
++		.name	= "pl011-axi",
++		.pm	= &pl011_dev_pm_ops,
++		.of_match_table = of_match_ptr(pl011_axi_of_match),
++		.suppress_bind_attrs = IS_BUILTIN(CONFIG_SERIAL_AMBA_PL011),
++	},
++};
++
+ static const struct amba_id pl011_ids[] = {
+ 	{
+ 		.id	= 0x00041011,
+@@ -3005,6 +3099,8 @@ static int __init pl011_init(void)
+ 
+ 	if (platform_driver_register(&arm_sbsa_uart_platform_driver))
+ 		pr_warn("could not register SBSA UART platform driver\n");
++	if (platform_driver_register(&pl011_axi_platform_driver))
++		pr_warn("could not register PL011 AXI platform driver\n");
+ 	return amba_driver_register(&pl011_driver);
+ }
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0878-mmc-sdhci-of-dwcmshc-define-sdio-timeout-clocks.patch b/target/linux/bcm27xx/patches-6.1/950-0878-mmc-sdhci-of-dwcmshc-define-sdio-timeout-clocks.patch
new file mode 100644
index 0000000000..6bc21a6a57
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0878-mmc-sdhci-of-dwcmshc-define-sdio-timeout-clocks.patch
@@ -0,0 +1,83 @@
+From 4a5ac516ca0a820e7c006ae408872009e37e114b Mon Sep 17 00:00:00 2001
+From: Liam Fraser <liam@raspberrypi.com>
+Date: Thu, 14 Mar 2019 16:01:26 +0000
+Subject: [PATCH] mmc: sdhci-of-dwcmshc: define sdio timeout clocks
+
+Signed-off-by: Liam Fraser <liam@raspberrypi.com>
+---
+ drivers/mmc/host/sdhci-of-dwcmshc.c | 12 ++++++++++++
+ drivers/mmc/host/sdhci-pltfm.c      |  8 ++++++++
+ drivers/mmc/host/sdhci-pltfm.h      |  3 +++
+ 3 files changed, 23 insertions(+)
+
+--- a/drivers/mmc/host/sdhci-of-dwcmshc.c
++++ b/drivers/mmc/host/sdhci-of-dwcmshc.c
+@@ -330,6 +330,7 @@ static const struct sdhci_ops sdhci_dwcm
+ 	.set_bus_width		= sdhci_set_bus_width,
+ 	.set_uhs_signaling	= dwcmshc_set_uhs_signaling,
+ 	.get_max_clock		= dwcmshc_get_max_clock,
++	.get_timeout_clock	= sdhci_pltfm_clk_get_timeout_clock,
+ 	.reset			= sdhci_reset,
+ 	.adma_write_desc	= dwcmshc_adma_write_desc,
+ };
+@@ -500,6 +501,16 @@ static int dwcmshc_probe(struct platform
+ 			clk_prepare_enable(priv->bus_clk);
+ 	}
+ 
++	pltfm_host->timeout_clk = devm_clk_get(&pdev->dev, "timeout");
++	if (IS_ERR(pltfm_host->timeout_clk)) {
++		err = PTR_ERR(pltfm_host->timeout_clk);
++		dev_err(&pdev->dev, "failed to get timeout clk: %d\n", err);
++		goto free_pltfm;
++	}
++	err = clk_prepare_enable(pltfm_host->timeout_clk);
++	if (err)
++		goto free_pltfm;
++
+ 	err = mmc_of_parse(host->mmc);
+ 	if (err)
+ 		goto err_clk;
+@@ -550,6 +561,7 @@ err_setup_host:
+ 	sdhci_cleanup_host(host);
+ err_clk:
+ 	clk_disable_unprepare(pltfm_host->clk);
++	clk_disable_unprepare(pltfm_host->timeout_clk);
+ 	clk_disable_unprepare(priv->bus_clk);
+ 	if (rk_priv)
+ 		clk_bulk_disable_unprepare(RK35xx_MAX_CLKS,
+--- a/drivers/mmc/host/sdhci-pltfm.c
++++ b/drivers/mmc/host/sdhci-pltfm.c
+@@ -33,6 +33,14 @@ unsigned int sdhci_pltfm_clk_get_max_clo
+ }
+ EXPORT_SYMBOL_GPL(sdhci_pltfm_clk_get_max_clock);
+ 
++unsigned int sdhci_pltfm_clk_get_timeout_clock(struct sdhci_host *host)
++{
++	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
++
++	return clk_get_rate(pltfm_host->timeout_clk);
++}
++EXPORT_SYMBOL_GPL(sdhci_pltfm_clk_get_timeout_clock);
++
+ static const struct sdhci_ops sdhci_pltfm_ops = {
+ 	.set_clock = sdhci_set_clock,
+ 	.set_bus_width = sdhci_set_bus_width,
+--- a/drivers/mmc/host/sdhci-pltfm.h
++++ b/drivers/mmc/host/sdhci-pltfm.h
+@@ -20,6 +20,7 @@ struct sdhci_pltfm_data {
+ 
+ struct sdhci_pltfm_host {
+ 	struct clk *clk;
++	struct clk *timeout_clk;
+ 
+ 	/* migrate from sdhci_of_host */
+ 	unsigned int clock;
+@@ -106,6 +107,8 @@ extern int sdhci_pltfm_unregister(struct
+ 
+ extern unsigned int sdhci_pltfm_clk_get_max_clock(struct sdhci_host *host);
+ 
++extern unsigned int sdhci_pltfm_clk_get_timeout_clock(struct sdhci_host *host);
++
+ static inline void *sdhci_pltfm_priv(struct sdhci_pltfm_host *host)
+ {
+ 	return host->private;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0879-mmc-sdhci-of-dwcmshc-rp1-sdio-changes.patch b/target/linux/bcm27xx/patches-6.1/950-0879-mmc-sdhci-of-dwcmshc-rp1-sdio-changes.patch
new file mode 100644
index 0000000000..12d614fd94
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0879-mmc-sdhci-of-dwcmshc-rp1-sdio-changes.patch
@@ -0,0 +1,83 @@
+From 14a43b3fd43bf9b230f93d1eba276d40aac969ba Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 12 Oct 2022 14:07:32 +0100
+Subject: [PATCH] mmc: sdhci-of-dwcmshc: rp1 sdio changes
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/mmc/host/sdhci-of-dwcmshc.c | 29 ++++++++++++++++++++++++++---
+ 1 file changed, 26 insertions(+), 3 deletions(-)
+
+--- a/drivers/mmc/host/sdhci-of-dwcmshc.c
++++ b/drivers/mmc/host/sdhci-of-dwcmshc.c
+@@ -87,6 +87,7 @@ struct rk35xx_priv {
+ 
+ struct dwcmshc_priv {
+ 	struct clk	*bus_clk;
++	struct clk	*sdio_clk;
+ 	int vendor_specific_area1; /* P_VENDOR_SPECIFIC_AREA reg */
+ 	void *priv; /* pointer to SoC private stuff */
+ };
+@@ -114,6 +115,17 @@ static void dwcmshc_adma_write_desc(stru
+ 	sdhci_adma_write_desc(host, desc, addr, len, cmd);
+ }
+ 
++static void dwcmshc_set_clock(struct sdhci_host *host, unsigned int clock)
++{
++	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
++	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
++
++	if (priv->sdio_clk)
++		clk_set_rate(priv->sdio_clk, clock);
++
++	sdhci_set_clock(host, clock);
++}
++
+ static unsigned int dwcmshc_get_max_clock(struct sdhci_host *host)
+ {
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+@@ -326,7 +338,7 @@ static void rk35xx_sdhci_reset(struct sd
+ }
+ 
+ static const struct sdhci_ops sdhci_dwcmshc_ops = {
+-	.set_clock		= sdhci_set_clock,
++	.set_clock		= dwcmshc_set_clock,
+ 	.set_bus_width		= sdhci_set_bus_width,
+ 	.set_uhs_signaling	= dwcmshc_set_uhs_signaling,
+ 	.get_max_clock		= dwcmshc_get_max_clock,
+@@ -346,8 +358,10 @@ static const struct sdhci_ops sdhci_dwcm
+ 
+ static const struct sdhci_pltfm_data sdhci_dwcmshc_pdata = {
+ 	.ops = &sdhci_dwcmshc_ops,
+-	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+-	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
++	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |
++		  SDHCI_QUIRK_BROKEN_CARD_DETECTION,
++	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
++		   SDHCI_QUIRK2_BROKEN_HS200,
+ };
+ 
+ #ifdef CONFIG_ACPI
+@@ -499,6 +513,14 @@ static int dwcmshc_probe(struct platform
+ 		priv->bus_clk = devm_clk_get(dev, "bus");
+ 		if (!IS_ERR(priv->bus_clk))
+ 			clk_prepare_enable(priv->bus_clk);
++
++		pltfm_host->timeout_clk = devm_clk_get(dev, "timeout");
++		if (!IS_ERR(pltfm_host->timeout_clk))
++			err = clk_prepare_enable(pltfm_host->timeout_clk);
++		if (err)
++			goto free_pltfm;
++
++		priv->sdio_clk = devm_clk_get_optional(&pdev->dev, "sdio");
+ 	}
+ 
+ 	pltfm_host->timeout_clk = devm_clk_get(&pdev->dev, "timeout");
+@@ -516,6 +538,7 @@ static int dwcmshc_probe(struct platform
+ 		goto err_clk;
+ 
+ 	sdhci_get_of_property(pdev);
++	sdhci_enable_v4_mode(host);
+ 
+ 	priv->vendor_specific_area1 =
+ 		sdhci_readl(host, DWCMSHC_P_VENDOR_AREA1) & DWCMSHC_AREA1_MASK;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0880-clk-rp1-Add-sdio-clk-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0880-clk-rp1-Add-sdio-clk-driver.patch
new file mode 100644
index 0000000000..7db5202ae4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0880-clk-rp1-Add-sdio-clk-driver.patch
@@ -0,0 +1,641 @@
+From b427cc1a83404f48b12dec2efbef076b38df6218 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 12 Oct 2022 14:20:07 +0100
+Subject: [PATCH] clk: rp1: Add sdio-clk driver
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/clk/Kconfig        |   6 +
+ drivers/clk/Makefile       |   1 +
+ drivers/clk/clk-rp1-sdio.c | 600 +++++++++++++++++++++++++++++++++++++
+ 3 files changed, 607 insertions(+)
+ create mode 100644 drivers/clk/clk-rp1-sdio.c
+
+--- a/drivers/clk/Kconfig
++++ b/drivers/clk/Kconfig
+@@ -96,6 +96,12 @@ config COMMON_CLK_RP1
+ 	help
+ 	  Enable common clock framework support for Raspberry Pi RP1
+ 
++config COMMON_CLK_RP1_SDIO
++	tristate "Clock driver for the RP1 SDIO interfaces"
++	depends on MFD_RP1
++	help
++	  SDIO clock driver for the RP1 support chip
++
+ config COMMON_CLK_HI655X
+ 	tristate "Clock driver for Hi655x" if EXPERT
+ 	depends on (MFD_HI655X_PMIC || COMPILE_TEST)
+--- a/drivers/clk/Makefile
++++ b/drivers/clk/Makefile
+@@ -59,6 +59,7 @@ obj-$(CONFIG_COMMON_CLK_PWM)		+= clk-pwm
+ obj-$(CONFIG_CLK_QORIQ)			+= clk-qoriq.o
+ obj-$(CONFIG_COMMON_CLK_RK808)		+= clk-rk808.o
+ obj-$(CONFIG_COMMON_CLK_RP1)		+= clk-rp1.o
++obj-$(CONFIG_COMMON_CLK_RP1_SDIO)	+= clk-rp1-sdio.o
+ obj-$(CONFIG_COMMON_CLK_HI655X)		+= clk-hi655x.o
+ obj-$(CONFIG_COMMON_CLK_S2MPS11)	+= clk-s2mps11.o
+ obj-$(CONFIG_COMMON_CLK_SCMI)           += clk-scmi.o
+--- /dev/null
++++ b/drivers/clk/clk-rp1-sdio.c
+@@ -0,0 +1,600 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * SDIO clock driver for RP1
++ *
++ * Copyright (C) 2023 Raspberry Pi Ltd.
++ */
++
++#include <linux/io.h>
++#include <linux/clk.h>
++#include <linux/clk-provider.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++
++// Register    : MODE
++#define MODE        0x00000000
++#define MODE_BITS   0x70030000
++#define MODE_RESET  0x00000000
++// Field       : MODE_STEPS_PER_CYCLE
++#define MODE_STEPS_PER_CYCLE_RESET          0x0
++#define MODE_STEPS_PER_CYCLE_BITS           0x70000000
++#define MODE_STEPS_PER_CYCLE_MSB            30
++#define MODE_STEPS_PER_CYCLE_LSB            28
++#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_20 0x0
++#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_10 0x1
++#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_16 0x2
++#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_8  0x3
++#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_12 0x4
++#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_6  0x5
++#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_5  0x6
++#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_4  0x7
++// Field       : MODE_SRC_SEL
++#define MODE_SRC_SEL_RESET                   0x0
++#define MODE_SRC_SEL_BITS                    0x00030000
++#define MODE_SRC_SEL_MSB                     17
++#define MODE_SRC_SEL_LSB                     16
++#define MODE_SRC_SEL_VALUE_STOP              0x0
++#define MODE_SRC_SEL_VALUE_CLK_ALT_SRC       0x1
++#define MODE_SRC_SEL_VALUE_PLL_SYS_VCO       0x2
++#define MODE_SRC_SEL_VALUE_PLL_SYS_VCO_AGAIN 0x3
++// Register    : FROMIP
++#define FROMIP        0x00000004
++#define FROMIP_BITS   0x0f9713ff
++#define FROMIP_RESET  0x00000000
++// Field       : FROMIP_TUNING_CCLK_SEL
++#define FROMIP_TUNING_CCLK_SEL_RESET  0x0
++#define FROMIP_TUNING_CCLK_SEL_BITS   0x0f000000
++#define FROMIP_TUNING_CCLK_SEL_MSB    27
++#define FROMIP_TUNING_CCLK_SEL_LSB    24
++// Field       : FROMIP_TUNING_CCLK_UPDATE
++#define FROMIP_TUNING_CCLK_UPDATE_RESET  0x0
++#define FROMIP_TUNING_CCLK_UPDATE_BITS   0x00800000
++#define FROMIP_TUNING_CCLK_UPDATE_MSB    23
++#define FROMIP_TUNING_CCLK_UPDATE_LSB    23
++// Field       : FROMIP_SAMPLE_CCLK_SEL
++#define FROMIP_SAMPLE_CCLK_SEL_RESET  0x0
++#define FROMIP_SAMPLE_CCLK_SEL_BITS   0x00100000
++#define FROMIP_SAMPLE_CCLK_SEL_MSB    20
++#define FROMIP_SAMPLE_CCLK_SEL_LSB    20
++// Field       : FROMIP_CLK2CARD_ON
++#define FROMIP_CLK2CARD_ON_RESET  0x0
++#define FROMIP_CLK2CARD_ON_BITS   0x00040000
++#define FROMIP_CLK2CARD_ON_MSB    18
++#define FROMIP_CLK2CARD_ON_LSB    18
++// Field       : FROMIP_CARD_CLK_STABLE
++#define FROMIP_CARD_CLK_STABLE_RESET  0x0
++#define FROMIP_CARD_CLK_STABLE_BITS   0x00020000
++#define FROMIP_CARD_CLK_STABLE_MSB    17
++#define FROMIP_CARD_CLK_STABLE_LSB    17
++// Field       : FROMIP_CARD_CLK_EN
++#define FROMIP_CARD_CLK_EN_RESET  0x0
++#define FROMIP_CARD_CLK_EN_BITS   0x00010000
++#define FROMIP_CARD_CLK_EN_MSB    16
++#define FROMIP_CARD_CLK_EN_LSB    16
++// Field       : FROMIP_CLK_GEN_SEL
++#define FROMIP_CLK_GEN_SEL_RESET  0x0
++#define FROMIP_CLK_GEN_SEL_BITS   0x00001000
++#define FROMIP_CLK_GEN_SEL_MSB    12
++#define FROMIP_CLK_GEN_SEL_LSB    12
++// Field       : FROMIP_FREQ_SEL
++#define FROMIP_FREQ_SEL_RESET  0x000
++#define FROMIP_FREQ_SEL_BITS   0x000003ff
++#define FROMIP_FREQ_SEL_MSB    9
++#define FROMIP_FREQ_SEL_LSB    0
++// Register    : LOCAL
++#define LOCAL        0x00000008
++#define LOCAL_BITS   0x1f9713ff
++#define LOCAL_RESET  0x00000000
++// Field       : LOCAL_TUNING_CCLK_SEL
++#define LOCAL_TUNING_CCLK_SEL_RESET  0x00
++#define LOCAL_TUNING_CCLK_SEL_BITS   0x1f000000
++#define LOCAL_TUNING_CCLK_SEL_MSB    28
++#define LOCAL_TUNING_CCLK_SEL_LSB    24
++// Field       : LOCAL_TUNING_CCLK_UPDATE
++#define LOCAL_TUNING_CCLK_UPDATE_RESET  0x0
++#define LOCAL_TUNING_CCLK_UPDATE_BITS   0x00800000
++#define LOCAL_TUNING_CCLK_UPDATE_MSB    23
++#define LOCAL_TUNING_CCLK_UPDATE_LSB    23
++// Field       : LOCAL_SAMPLE_CCLK_SEL
++#define LOCAL_SAMPLE_CCLK_SEL_RESET  0x0
++#define LOCAL_SAMPLE_CCLK_SEL_BITS   0x00100000
++#define LOCAL_SAMPLE_CCLK_SEL_MSB    20
++#define LOCAL_SAMPLE_CCLK_SEL_LSB    20
++// Field       : LOCAL_CLK2CARD_ON
++#define LOCAL_CLK2CARD_ON_RESET  0x0
++#define LOCAL_CLK2CARD_ON_BITS   0x00040000
++#define LOCAL_CLK2CARD_ON_MSB    18
++#define LOCAL_CLK2CARD_ON_LSB    18
++// Field       : LOCAL_CARD_CLK_STABLE
++#define LOCAL_CARD_CLK_STABLE_RESET  0x0
++#define LOCAL_CARD_CLK_STABLE_BITS   0x00020000
++#define LOCAL_CARD_CLK_STABLE_MSB    17
++#define LOCAL_CARD_CLK_STABLE_LSB    17
++// Field       : LOCAL_CARD_CLK_EN
++#define LOCAL_CARD_CLK_EN_RESET  0x0
++#define LOCAL_CARD_CLK_EN_BITS   0x00010000
++#define LOCAL_CARD_CLK_EN_MSB    16
++#define LOCAL_CARD_CLK_EN_LSB    16
++// Field       : LOCAL_CLK_GEN_SEL
++#define LOCAL_CLK_GEN_SEL_RESET               0x0
++#define LOCAL_CLK_GEN_SEL_BITS                0x00001000
++#define LOCAL_CLK_GEN_SEL_MSB                 12
++#define LOCAL_CLK_GEN_SEL_LSB                 12
++#define LOCAL_CLK_GEN_SEL_VALUE_PROGCLOCKMODE 0x0
++#define LOCAL_CLK_GEN_SEL_VALUE_DIVCLOCKMODE  0x1
++// Field       : LOCAL_FREQ_SEL
++#define LOCAL_FREQ_SEL_RESET  0x000
++#define LOCAL_FREQ_SEL_BITS   0x000003ff
++#define LOCAL_FREQ_SEL_MSB    9
++#define LOCAL_FREQ_SEL_LSB    0
++// Register    : USE_LOCAL
++#define USE_LOCAL        0x0000000c
++#define USE_LOCAL_BITS   0x01951001
++#define USE_LOCAL_RESET  0x00000000
++// Field       : USE_LOCAL_TUNING_CCLK_SEL
++#define USE_LOCAL_TUNING_CCLK_SEL_RESET  0x0
++#define USE_LOCAL_TUNING_CCLK_SEL_BITS   0x01000000
++#define USE_LOCAL_TUNING_CCLK_SEL_MSB    24
++#define USE_LOCAL_TUNING_CCLK_SEL_LSB    24
++// Field       : USE_LOCAL_TUNING_CCLK_UPDATE
++#define USE_LOCAL_TUNING_CCLK_UPDATE_RESET  0x0
++#define USE_LOCAL_TUNING_CCLK_UPDATE_BITS   0x00800000
++#define USE_LOCAL_TUNING_CCLK_UPDATE_MSB    23
++#define USE_LOCAL_TUNING_CCLK_UPDATE_LSB    23
++// Field       : USE_LOCAL_SAMPLE_CCLK_SEL
++#define USE_LOCAL_SAMPLE_CCLK_SEL_RESET  0x0
++#define USE_LOCAL_SAMPLE_CCLK_SEL_BITS   0x00100000
++#define USE_LOCAL_SAMPLE_CCLK_SEL_MSB    20
++#define USE_LOCAL_SAMPLE_CCLK_SEL_LSB    20
++// Field       : USE_LOCAL_CLK2CARD_ON
++#define USE_LOCAL_CLK2CARD_ON_RESET  0x0
++#define USE_LOCAL_CLK2CARD_ON_BITS   0x00040000
++#define USE_LOCAL_CLK2CARD_ON_MSB    18
++#define USE_LOCAL_CLK2CARD_ON_LSB    18
++// Field       : USE_LOCAL_CARD_CLK_EN
++#define USE_LOCAL_CARD_CLK_EN_RESET  0x0
++#define USE_LOCAL_CARD_CLK_EN_BITS   0x00010000
++#define USE_LOCAL_CARD_CLK_EN_MSB    16
++#define USE_LOCAL_CARD_CLK_EN_LSB    16
++// Field       : USE_LOCAL_CLK_GEN_SEL
++#define USE_LOCAL_CLK_GEN_SEL_RESET  0x0
++#define USE_LOCAL_CLK_GEN_SEL_BITS   0x00001000
++#define USE_LOCAL_CLK_GEN_SEL_MSB    12
++#define USE_LOCAL_CLK_GEN_SEL_LSB    12
++// Field       : USE_LOCAL_FREQ_SEL
++#define USE_LOCAL_FREQ_SEL_RESET  0x0
++#define USE_LOCAL_FREQ_SEL_BITS   0x00000001
++#define USE_LOCAL_FREQ_SEL_MSB    0
++#define USE_LOCAL_FREQ_SEL_LSB    0
++// Register    : SD_DELAY
++#define SD_DELAY        0x00000010
++#define SD_DELAY_BITS   0x0000001f
++#define SD_DELAY_RESET  0x00000000
++// Field       : SD_DELAY_STEPS
++#define SD_DELAY_STEPS_RESET  0x00
++#define SD_DELAY_STEPS_BITS   0x0000001f
++#define SD_DELAY_STEPS_MSB    4
++#define SD_DELAY_STEPS_LSB    0
++// Register    : RX_DELAY
++#define RX_DELAY        0x00000014
++#define RX_DELAY_BITS   0x19f3331f
++#define RX_DELAY_RESET  0x00000000
++// Field       : RX_DELAY_BYPASS
++#define RX_DELAY_BYPASS_RESET  0x0
++#define RX_DELAY_BYPASS_BITS   0x10000000
++#define RX_DELAY_BYPASS_MSB    28
++#define RX_DELAY_BYPASS_LSB    28
++// Field       : RX_DELAY_FAIL_ACTUAL
++#define RX_DELAY_FAIL_ACTUAL_RESET  0x0
++#define RX_DELAY_FAIL_ACTUAL_BITS   0x08000000
++#define RX_DELAY_FAIL_ACTUAL_MSB    27
++#define RX_DELAY_FAIL_ACTUAL_LSB    27
++// Field       : RX_DELAY_ACTUAL
++#define RX_DELAY_ACTUAL_RESET  0x00
++#define RX_DELAY_ACTUAL_BITS   0x01f00000
++#define RX_DELAY_ACTUAL_MSB    24
++#define RX_DELAY_ACTUAL_LSB    20
++// Field       : RX_DELAY_OFFSET
++#define RX_DELAY_OFFSET_RESET  0x0
++#define RX_DELAY_OFFSET_BITS   0x00030000
++#define RX_DELAY_OFFSET_MSB    17
++#define RX_DELAY_OFFSET_LSB    16
++// Field       : RX_DELAY_OVERFLOW
++#define RX_DELAY_OVERFLOW_RESET       0x0
++#define RX_DELAY_OVERFLOW_BITS        0x00003000
++#define RX_DELAY_OVERFLOW_MSB         13
++#define RX_DELAY_OVERFLOW_LSB         12
++#define RX_DELAY_OVERFLOW_VALUE_ALLOW 0x0
++#define RX_DELAY_OVERFLOW_VALUE_CLAMP 0x1
++#define RX_DELAY_OVERFLOW_VALUE_FAIL  0x2
++// Field       : RX_DELAY_MAP
++#define RX_DELAY_MAP_RESET         0x0
++#define RX_DELAY_MAP_BITS          0x00000300
++#define RX_DELAY_MAP_MSB           9
++#define RX_DELAY_MAP_LSB           8
++#define RX_DELAY_MAP_VALUE_DIRECT  0x0
++#define RX_DELAY_MAP_VALUE         0x1
++#define RX_DELAY_MAP_VALUE_STRETCH 0x2
++// Field       : RX_DELAY_FIXED
++#define RX_DELAY_FIXED_RESET  0x00
++#define RX_DELAY_FIXED_BITS   0x0000001f
++#define RX_DELAY_FIXED_MSB    4
++#define RX_DELAY_FIXED_LSB    0
++// Register    : NDIV
++#define NDIV        0x00000018
++#define NDIV_BITS   0x1fff0000
++#define NDIV_RESET  0x00110000
++// Field       : NDIV_DIVB
++#define NDIV_DIVB_RESET  0x001
++#define NDIV_DIVB_BITS   0x1ff00000
++#define NDIV_DIVB_MSB    28
++#define NDIV_DIVB_LSB    20
++// Field       : NDIV_DIVA
++#define NDIV_DIVA_RESET  0x1
++#define NDIV_DIVA_BITS   0x000f0000
++#define NDIV_DIVA_MSB    19
++#define NDIV_DIVA_LSB    16
++// Register    : CS
++#define CS        0x0000001c
++#define CS_BITS   0x00111101
++#define CS_RESET  0x00000001
++// Field       : CS_RX_DEL_UPDATED
++#define CS_RX_DEL_UPDATED_RESET  0x0
++#define CS_RX_DEL_UPDATED_BITS   0x00100000
++#define CS_RX_DEL_UPDATED_MSB    20
++#define CS_RX_DEL_UPDATED_LSB    20
++// Field       : CS_RX_CLK_RUNNING
++#define CS_RX_CLK_RUNNING_RESET  0x0
++#define CS_RX_CLK_RUNNING_BITS   0x00010000
++#define CS_RX_CLK_RUNNING_MSB    16
++#define CS_RX_CLK_RUNNING_LSB    16
++// Field       : CS_SD_CLK_RUNNING
++#define CS_SD_CLK_RUNNING_RESET  0x0
++#define CS_SD_CLK_RUNNING_BITS   0x00001000
++#define CS_SD_CLK_RUNNING_MSB    12
++#define CS_SD_CLK_RUNNING_LSB    12
++// Field       : CS_TX_CLK_RUNNING
++#define CS_TX_CLK_RUNNING_RESET  0x0
++#define CS_TX_CLK_RUNNING_BITS   0x00000100
++#define CS_TX_CLK_RUNNING_MSB    8
++#define CS_TX_CLK_RUNNING_LSB    8
++// Field       : CS_RESET
++#define CS_RESET_RESET  0x1
++#define CS_RESET_BITS   0x00000001
++#define CS_RESET_MSB    0
++#define CS_RESET_LSB    0
++
++#define FPGA_SRC_RATE 400000000
++
++/* Base number of steps to delay in relation to tx clk.
++ * The relationship of the 3 clocks are as follows:
++ * tx_clk: This clock is provided to the controller. Data is sent out
++ * to the pads using this clock.
++ * sd_clk: This clock is sent out to the card.
++ * rx_clk: This clock is used to sample the data coming back from the card.
++ * This may need to be several steps ahead of the tx_clk. The default rx delay
++ * is used as a base delay, and can be further adjusted by the sd host
++ * controller during the tuning process if using a DDR50 or faster SD card
++ */
++/*
++ * PRJY-1813 - the default SD clock delay needs to be set to ~60% of the total
++ * number of steps to meet tISU (>6ns) and tIH (>2ns) in high-speed mode.
++ * On FPGA this means delay SDCLK by 5, and sample RX with a delay of 6.
++ */
++#define DEFAULT_RX_DELAY 6
++#define DEFAULT_SD_DELAY 5
++
++struct rp1_sdio_clkgen {
++	struct device *dev;
++
++	/* Source clock. Either PLL VCO or fixed freq on FPGA */
++	struct clk *src_clk;
++	/* Desired base frequency. Max freq card can go */
++	struct clk *base_clk;
++
++	struct clk_hw hw;
++	void __iomem *regs;
++
++	/* Starting value of local register before changing freq */
++	u32 local_base;
++};
++
++static inline void clkgen_write(struct rp1_sdio_clkgen *clkgen, u32 reg, u32 val)
++{
++	dev_dbg(clkgen->dev, "%s: write reg 0x%x: 0x%x\n", __func__, reg, val);
++	writel(val, clkgen->regs + reg);
++}
++
++static inline u32 clkgen_read(struct rp1_sdio_clkgen *clkgen, u32 reg)
++{
++	u32 val = readl(clkgen->regs + reg);
++
++	dev_dbg(clkgen->dev, "%s: read reg 0x%x: 0x%x\n", __func__, reg, val);
++	return val;
++}
++
++static int get_steps(unsigned int steps)
++{
++	int ret = -1;
++
++	if (steps == 4)
++		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_4;
++	else if (steps == 5)
++		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_5;
++	else if (steps == 6)
++		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_6;
++	else if (steps == 8)
++		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_8;
++	else if (steps == 10)
++		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_10;
++	else if (steps == 12)
++		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_12;
++	else if (steps == 16)
++		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_16;
++	else if (steps == 20)
++		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_20;
++	return ret;
++}
++
++static int rp1_sdio_clk_init(struct rp1_sdio_clkgen *clkgen)
++{
++	unsigned long src_rate = clk_get_rate(clkgen->src_clk);
++	unsigned long base_rate = clk_get_rate(clkgen->base_clk);
++	unsigned int steps = src_rate / base_rate;
++	u32 reg = 0;
++	int steps_value = 0;
++
++	dev_dbg(clkgen->dev, "init: src_rate %lu, base_rate %lu, steps %d\n",
++		src_rate, base_rate, steps);
++
++	/* Assert reset while we set up clkgen */
++	clkgen_write(clkgen, CS, CS_RESET_BITS);
++
++	/* Pick clock source */
++	if (src_rate == FPGA_SRC_RATE) {
++		/* Using ALT SRC */
++		reg |= MODE_SRC_SEL_VALUE_CLK_ALT_SRC << MODE_SRC_SEL_LSB;
++	} else {
++		/* Assume we are using PLL SYS VCO */
++		reg |= MODE_SRC_SEL_VALUE_PLL_SYS_VCO << MODE_SRC_SEL_LSB;
++	}
++
++	/* How many delay steps are available in one cycle for this source */
++	steps_value = get_steps(steps);
++	if (steps_value < 0) {
++		dev_err(clkgen->dev, "Invalid step value: %d\n", steps);
++		return -EINVAL;
++	}
++	reg |= steps_value << MODE_STEPS_PER_CYCLE_LSB;
++
++	/* Mode register is done now*/
++	clkgen_write(clkgen, MODE, reg);
++
++	/* Now set delay mode */
++	/* Clamp value if out of range rx delay is used */
++	reg = RX_DELAY_OVERFLOW_VALUE_CLAMP << RX_DELAY_OVERFLOW_LSB;
++	/* SD tuning bus goes from 0x0 to 0xf but we don't necessarily have that
++	 * many steps available depending on the source so map 0x0 -> 0xf to one
++	 * cycle of rx delay
++	 */
++	reg |= RX_DELAY_MAP_VALUE_STRETCH << RX_DELAY_MAP_LSB;
++
++	/* Default RX delay */
++	dev_dbg(clkgen->dev, "default rx delay %d\n", DEFAULT_RX_DELAY);
++	reg |= (DEFAULT_RX_DELAY & RX_DELAY_FIXED_BITS) << RX_DELAY_FIXED_LSB;
++	clkgen_write(clkgen, RX_DELAY, reg);
++
++	/* Default SD delay */
++	dev_dbg(clkgen->dev, "default sd delay %d\n", DEFAULT_SD_DELAY);
++	reg = (DEFAULT_SD_DELAY & SD_DELAY_STEPS_BITS) << SD_DELAY_STEPS_LSB;
++	clkgen_write(clkgen, SD_DELAY, reg);
++
++	/* We select freq, we turn on tx clock, we turn on sd clk,
++	 * we pick clock generator mode
++	 */
++	reg = USE_LOCAL_FREQ_SEL_BITS | USE_LOCAL_CARD_CLK_EN_BITS |
++	      USE_LOCAL_CLK2CARD_ON_BITS | USE_LOCAL_CLK_GEN_SEL_BITS;
++	clkgen_write(clkgen, USE_LOCAL, reg);
++
++	/* Deassert reset. Reset bit is only writable bit of CS
++	 * reg so fine to write a 0.
++	 */
++	clkgen_write(clkgen, CS, 0);
++
++	return 0;
++}
++
++#define RUNNING	\
++	(CS_TX_CLK_RUNNING_BITS | CS_RX_CLK_RUNNING_BITS | \
++	 CS_SD_CLK_RUNNING_BITS)
++static int rp1_sdio_clk_is_prepared(struct clk_hw *hw)
++{
++	struct rp1_sdio_clkgen *clkgen =
++		container_of(hw, struct rp1_sdio_clkgen, hw);
++	u32 status;
++
++	dev_dbg(clkgen->dev, "is_prepared\n");
++	status = clkgen_read(clkgen, CS);
++	return ((status & RUNNING) == RUNNING);
++}
++
++/* Can define an additional divider if an sd card isn't working at full speed */
++/* #define SLOWDOWN 3 */
++
++static unsigned long rp1_sdio_clk_get_rate(struct clk_hw *hw,
++					   unsigned long parent_rate)
++{
++	/* Get the current rate */
++	struct rp1_sdio_clkgen *clkgen =
++		container_of(hw, struct rp1_sdio_clkgen, hw);
++	unsigned long actual_rate = 0;
++	u32 ndiv_diva;
++	u32 ndiv_divb;
++	u32 tmp;
++	u32 div;
++
++	tmp = clkgen_read(clkgen, LOCAL);
++	if ((tmp & LOCAL_CLK2CARD_ON_BITS) == 0) {
++		dev_dbg(clkgen->dev, "get_rate 0\n");
++		return 0;
++	}
++
++	tmp = clkgen_read(clkgen, NDIV);
++	ndiv_diva = (tmp & NDIV_DIVA_BITS) >> NDIV_DIVA_LSB;
++	ndiv_divb = (tmp & NDIV_DIVB_BITS) >> NDIV_DIVB_LSB;
++	div = ndiv_diva * ndiv_divb;
++	actual_rate = (clk_get_rate(clkgen->base_clk) / div);
++
++#ifdef SLOWDOWN
++	actual_rate *= SLOWDOWN;
++#endif
++
++	dev_dbg(clkgen->dev, "get_rate. ndiv_diva %d, ndiv_divb %d = %lu\n",
++		ndiv_diva, ndiv_divb, actual_rate);
++
++	return actual_rate;
++}
++
++static int rp1_sdio_clk_set_rate(struct clk_hw *hw, unsigned long rate,
++				 unsigned long parent_rate)
++{
++	struct rp1_sdio_clkgen *clkgen =
++		container_of(hw, struct rp1_sdio_clkgen, hw);
++	u32 div;
++	u32 reg;
++
++	dev_dbg(clkgen->dev, "set_rate %lu\n", rate);
++
++	if (rate == 0) {
++		/* Keep tx clock running */
++		clkgen_write(clkgen, LOCAL, LOCAL_CARD_CLK_EN_BITS);
++		return 0;
++	}
++
++#ifdef SLOWDOWN
++	rate /= SLOWDOWN;
++#endif
++
++	div = (clk_get_rate(clkgen->base_clk) / rate) - 1;
++	reg = LOCAL_CLK_GEN_SEL_BITS | LOCAL_CARD_CLK_EN_BITS |
++	      LOCAL_CLK2CARD_ON_BITS | (div << LOCAL_FREQ_SEL_LSB);
++	clkgen_write(clkgen, LOCAL, reg);
++
++	return 0;
++}
++
++#define MAX_NDIV (256 * 8)
++static int rp1_sdio_clk_determine_rate(struct clk_hw *hw,
++				       struct clk_rate_request *req)
++{
++	unsigned long rate;
++	struct rp1_sdio_clkgen *clkgen =
++		container_of(hw, struct rp1_sdio_clkgen, hw);
++	unsigned long base_rate = clk_get_rate(clkgen->base_clk);
++	u32 div;
++
++	/* What is the actual rate I can get if I request xyz */
++	if (req->rate) {
++		div = min((u32)(base_rate / req->rate), (u32)MAX_NDIV);
++		rate = base_rate / div;
++		req->rate = rate;
++		dev_dbg(clkgen->dev, "determine_rate %lu: %lu / %d = %lu\n",
++			req->rate, base_rate, div, rate);
++	} else {
++		rate = 0;
++		dev_dbg(clkgen->dev, "determine_rate %lu: %lu\n", req->rate,
++			rate);
++	}
++
++	return 0;
++}
++
++static const struct clk_ops rp1_sdio_clk_ops = {
++	.is_prepared    = rp1_sdio_clk_is_prepared,
++	.recalc_rate    = rp1_sdio_clk_get_rate,
++	.set_rate       = rp1_sdio_clk_set_rate,
++	.determine_rate = rp1_sdio_clk_determine_rate,
++};
++
++static int rp1_sdio_clk_probe(struct platform_device *pdev)
++{
++	struct device_node *node = pdev->dev.of_node;
++	struct rp1_sdio_clkgen *clkgen;
++	void __iomem *regs;
++	struct clk_init_data init = {};
++	int ret;
++
++	clkgen = devm_kzalloc(&pdev->dev, sizeof(*clkgen), GFP_KERNEL);
++	if (!clkgen)
++		return -ENOMEM;
++	platform_set_drvdata(pdev, clkgen);
++
++	clkgen->dev = &pdev->dev;
++
++	/* Source freq */
++	clkgen->src_clk = devm_clk_get(&pdev->dev, "src");
++	if (IS_ERR(clkgen->src_clk)) {
++		int err = PTR_ERR(clkgen->src_clk);
++
++		dev_err(&pdev->dev, "failed to get src clk: %d\n", err);
++		return err;
++	}
++
++	/* Desired maximum output freq (i.e. base freq) */
++	clkgen->base_clk = devm_clk_get(&pdev->dev, "base");
++	if (IS_ERR(clkgen->base_clk)) {
++		int err = PTR_ERR(clkgen->base_clk);
++
++		dev_err(&pdev->dev, "failed to get base clk: %d\n", err);
++		return err;
++	}
++
++	regs = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(regs))
++		return PTR_ERR(regs);
++
++	init.name = node->name;
++	init.ops = &rp1_sdio_clk_ops;
++	init.flags = CLK_GET_RATE_NOCACHE;
++
++	clkgen->hw.init = &init;
++	clkgen->regs = regs;
++
++	dev_info(&pdev->dev, "loaded %s\n", init.name);
++
++	ret = devm_clk_hw_register(&pdev->dev, &clkgen->hw);
++	if (ret)
++		return ret;
++
++	ret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, &clkgen->hw);
++	if (ret)
++		return ret;
++
++	ret = rp1_sdio_clk_init(clkgen);
++	return ret;
++}
++
++static int rp1_sdio_clk_remove(struct platform_device *pdev)
++{
++	return 0;
++}
++
++static const struct of_device_id rp1_sdio_clk_dt_ids[] = {
++	{ .compatible = "raspberrypi,rp1-sdio-clk", },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, rp1_sdio_clk_dt_ids);
++
++static struct platform_driver rp1_sdio_clk_driver = {
++	.probe	= rp1_sdio_clk_probe,
++	.remove	= rp1_sdio_clk_remove,
++	.driver	= {
++		.name		= "rp1-sdio-clk",
++		.of_match_table	= rp1_sdio_clk_dt_ids,
++	},
++};
++module_platform_driver(rp1_sdio_clk_driver);
++
++MODULE_AUTHOR("Liam Fraser <liam@raspberrypi.com>");
++MODULE_DESCRIPTION("RP1 SDIO clock driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/bcm27xx/patches-6.1/950-0881-i2c-designware-Add-SMBUS-quick-command-support.patch b/target/linux/bcm27xx/patches-6.1/950-0881-i2c-designware-Add-SMBUS-quick-command-support.patch
new file mode 100644
index 0000000000..ea3b315501
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0881-i2c-designware-Add-SMBUS-quick-command-support.patch
@@ -0,0 +1,76 @@
+From 50adadfaf324ed5cbb59ce2b85eda59de4e3801a Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 4 Dec 2020 15:20:36 +0000
+Subject: [PATCH] i2c: designware: Add SMBUS quick command support
+
+The SMBUS emulation code turns an SMBUS quick command into a zero-
+length read. This controller can't do zero length accesses, but it
+can do quick commands, so reverse the emulation. The alternative
+would be to properly implement the SMBUS support but that is a lot
+more work, and unnecessary just to get i2cdetect working.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/i2c/busses/i2c-designware-core.h   |  2 ++
+ drivers/i2c/busses/i2c-designware-master.c | 17 +++++++++++++++--
+ 2 files changed, 17 insertions(+), 2 deletions(-)
+
+--- a/drivers/i2c/busses/i2c-designware-core.h
++++ b/drivers/i2c/busses/i2c-designware-core.h
+@@ -117,7 +117,9 @@
+ 
+ #define DW_IC_ERR_TX_ABRT	0x1
+ 
++#define DW_IC_TAR_SPECIAL		BIT(11)
+ #define DW_IC_TAR_10BITADDR_MASTER	BIT(12)
++#define DW_IC_TAR_SMBUS_QUICK_CMD	BIT(16)
+ 
+ #define DW_IC_COMP_PARAM_1_SPEED_MODE_HIGH	(BIT(2) | BIT(3))
+ #define DW_IC_COMP_PARAM_1_SPEED_MODE_MASK	GENMASK(3, 2)
+--- a/drivers/i2c/busses/i2c-designware-master.c
++++ b/drivers/i2c/busses/i2c-designware-master.c
+@@ -228,6 +228,10 @@ static void i2c_dw_xfer_init(struct dw_i
+ 		ic_tar = DW_IC_TAR_10BITADDR_MASTER;
+ 	}
+ 
++	/* Convert a zero-length read into an SMBUS quick command */
++	if (!msgs[dev->msg_write_idx].len)
++		ic_tar = DW_IC_TAR_SPECIAL | DW_IC_TAR_SMBUS_QUICK_CMD;
++
+ 	regmap_update_bits(dev->map, DW_IC_CON, DW_IC_CON_10BITADDR_MASTER,
+ 			   ic_con);
+ 
+@@ -409,6 +413,14 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
+ 		regmap_read(dev->map, DW_IC_RXFLR, &flr);
+ 		rx_limit = dev->rx_fifo_depth - flr;
+ 
++		/* Handle SMBUS quick commands */
++		if (!buf_len) {
++			if (msgs[dev->msg_write_idx].flags & I2C_M_RD)
++				regmap_write(dev->map, DW_IC_DATA_CMD, 0x300);
++			else
++				regmap_write(dev->map, DW_IC_DATA_CMD, 0x200);
++		}
++
+ 		while (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {
+ 			u32 cmd = 0;
+ 
+@@ -673,7 +685,7 @@ static const struct i2c_algorithm i2c_dw
+ };
+ 
+ static const struct i2c_adapter_quirks i2c_dw_quirks = {
+-	.flags = I2C_AQ_NO_ZERO_LEN,
++	.flags = 0,
+ };
+ 
+ static u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)
+@@ -813,7 +825,8 @@ void i2c_dw_configure_master(struct dw_i
+ {
+ 	struct i2c_timings *t = &dev->timings;
+ 
+-	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
++	dev->functionality = I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_QUICK |
++			     DW_IC_DEFAULT_FUNCTIONALITY;
+ 
+ 	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
+ 			  DW_IC_CON_RESTART_EN;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0882-dmaengine-dw-axi-dmac-Fixes-for-RP1.patch b/target/linux/bcm27xx/patches-6.1/950-0882-dmaengine-dw-axi-dmac-Fixes-for-RP1.patch
new file mode 100644
index 0000000000..fff6cfdeb4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0882-dmaengine-dw-axi-dmac-Fixes-for-RP1.patch
@@ -0,0 +1,355 @@
+From 0a1cd70189daec3baf4b4a233dd8e25ffbb9d512 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 28 Apr 2021 17:46:01 +0100
+Subject: [PATCH] dmaengine: dw-axi-dmac: Fixes for RP1
+
+Don't assume that DMA addresses of devices are the same as their
+physical addresses - convert correctly.
+
+The CFG2 register layout is used when there are more than 8 channels,
+but also when configured for more than 16 target peripheral devices
+because the index of the handshake signal has to be made wider.
+
+Reset the DMAC on probe
+
+The driver goes to the trouble of tracking when transfers have been
+paused, but then doesn't report that state when queried.
+
+Not having APB registers is not an error - for most use cases it's
+not even of interest, it's expected. Demote the message to debug level,
+which is disabled by default.
+
+Each channel has a descriptor pool, which is shared between transfers.
+It is unsafe to treat the total number of descriptors allocated from a
+pool as the number allocated to a specific transfer; doing so leads
+to releasing buffers that shouldn't be released and walking off the
+ends of descriptor lists. Instead, give each transfer descriptor its
+own count.
+
+Support partial transfers:
+Some use cases involve streaming from a device where the transfer only
+proceeds when the device's FIFO occupancy exceeds a certain threshold.
+In such cases (e.g. when pulling data from a UART) it is important to
+know how much data has been transferred so far, in order that remaining
+bytes can be read from the FIFO directly by software.
+
+Add the necessary code to provide this "residue" value with a finer,
+sub-transfer granularity.
+
+In order to prevent the occasional byte getting stuck in the DMA
+controller's internal buffers, restrict the destination memory width
+to the source register width.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ .../dma/dw-axi-dmac/dw-axi-dmac-platform.c    | 136 +++++++++++++++---
+ drivers/dma/dw-axi-dmac/dw-axi-dmac.h         |   3 +
+ 2 files changed, 118 insertions(+), 21 deletions(-)
+
+--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
++++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
+@@ -12,6 +12,7 @@
+ #include <linux/device.h>
+ #include <linux/dmaengine.h>
+ #include <linux/dmapool.h>
++#include <linux/dma-direct.h>
+ #include <linux/dma-mapping.h>
+ #include <linux/err.h>
+ #include <linux/interrupt.h>
+@@ -79,6 +80,17 @@ axi_chan_iowrite64(struct axi_dma_chan *
+ 	iowrite32(upper_32_bits(val), chan->chan_regs + reg + 4);
+ }
+ 
++static inline u64
++axi_chan_ioread64(struct axi_dma_chan *chan, u32 reg)
++{
++	/*
++	 * We split one 64 bit read into two 32 bit reads as some HW doesn't
++	 * support 64 bit access.
++	 */
++	return ((u64)ioread32(chan->chan_regs + reg + 4) << 32) +
++		ioread32(chan->chan_regs + reg);
++}
++
+ static inline void axi_chan_config_write(struct axi_dma_chan *chan,
+ 					 struct axi_dma_chan_config *config)
+ {
+@@ -86,7 +98,7 @@ static inline void axi_chan_config_write
+ 
+ 	cfg_lo = (config->dst_multblk_type << CH_CFG_L_DST_MULTBLK_TYPE_POS |
+ 		  config->src_multblk_type << CH_CFG_L_SRC_MULTBLK_TYPE_POS);
+-	if (chan->chip->dw->hdata->reg_map_8_channels) {
++	if (!chan->chip->dw->hdata->reg_map_cfg2) {
+ 		cfg_hi = config->tt_fc << CH_CFG_H_TT_FC_POS |
+ 			 config->hs_sel_src << CH_CFG_H_HS_SEL_SRC_POS |
+ 			 config->hs_sel_dst << CH_CFG_H_HS_SEL_DST_POS |
+@@ -214,7 +226,18 @@ static void axi_dma_hw_init(struct axi_d
+ {
+ 	int ret;
+ 	u32 i;
++	int retries = 1000;
+ 
++	axi_dma_iowrite32(chip, DMAC_RESET, 1);
++	while (axi_dma_ioread32(chip, DMAC_RESET)) {
++		retries--;
++		if (!retries) {
++			dev_err(chip->dev, "%s: DMAC failed to reset\n",
++				__func__);
++			return;
++		}
++		cpu_relax();
++	}
+ 	for (i = 0; i < chip->dw->hdata->nr_channels; i++) {
+ 		axi_chan_irq_disable(&chip->dw->chan[i], DWAXIDMAC_IRQ_ALL);
+ 		axi_chan_disable(&chip->dw->chan[i]);
+@@ -276,7 +299,7 @@ static struct axi_dma_lli *axi_desc_get(
+ static void axi_desc_put(struct axi_dma_desc *desc)
+ {
+ 	struct axi_dma_chan *chan = desc->chan;
+-	int count = atomic_read(&chan->descs_allocated);
++	u32 count = desc->hw_desc_count;
+ 	struct axi_dma_hw_desc *hw_desc;
+ 	int descs_put;
+ 
+@@ -298,6 +321,48 @@ static void vchan_desc_put(struct virt_d
+ 	axi_desc_put(vd_to_axi_desc(vdesc));
+ }
+ 
++static u32 axi_dma_desc_src_pos(struct axi_dma_desc *desc, dma_addr_t addr)
++{
++	unsigned int idx = 0;
++	u32 pos = 0;
++
++	while (pos < desc->length) {
++		struct axi_dma_hw_desc *hw_desc = &desc->hw_desc[idx++];
++		u32 len = hw_desc->len;
++		dma_addr_t start = le64_to_cpu(hw_desc->lli->sar);
++
++		if (addr >= start && addr <= (start + len)) {
++			pos += addr - start;
++			break;
++		}
++
++		pos += len;
++	}
++
++	return pos;
++}
++
++static u32 axi_dma_desc_dst_pos(struct axi_dma_desc *desc, dma_addr_t addr)
++{
++	unsigned int idx = 0;
++	u32 pos = 0;
++
++	while (pos < desc->length) {
++		struct axi_dma_hw_desc *hw_desc = &desc->hw_desc[idx++];
++		u32 len = hw_desc->len;
++		dma_addr_t start = le64_to_cpu(hw_desc->lli->dar);
++
++		if (addr >= start && addr <= (start + len)) {
++			pos += addr - start;
++			break;
++		}
++
++		pos += len;
++	}
++
++	return pos;
++}
++
+ static enum dma_status
+ dma_chan_tx_status(struct dma_chan *dchan, dma_cookie_t cookie,
+ 		  struct dma_tx_state *txstate)
+@@ -307,10 +372,7 @@ dma_chan_tx_status(struct dma_chan *dcha
+ 	enum dma_status status;
+ 	u32 completed_length;
+ 	unsigned long flags;
+-	u32 completed_blocks;
+ 	size_t bytes = 0;
+-	u32 length;
+-	u32 len;
+ 
+ 	status = dma_cookie_status(dchan, cookie, txstate);
+ 	if (status == DMA_COMPLETE || !txstate)
+@@ -319,16 +381,31 @@ dma_chan_tx_status(struct dma_chan *dcha
+ 	spin_lock_irqsave(&chan->vc.lock, flags);
+ 
+ 	vdesc = vchan_find_desc(&chan->vc, cookie);
+-	if (vdesc) {
+-		length = vd_to_axi_desc(vdesc)->length;
+-		completed_blocks = vd_to_axi_desc(vdesc)->completed_blocks;
+-		len = vd_to_axi_desc(vdesc)->hw_desc[0].len;
+-		completed_length = completed_blocks * len;
+-		bytes = length - completed_length;
++	if (vdesc && vdesc == vchan_next_desc(&chan->vc)) {
++		/* This descriptor is in-progress */
++		struct axi_dma_desc *desc = vd_to_axi_desc(vdesc);
++		dma_addr_t addr;
++
++		if (chan->direction == DMA_MEM_TO_DEV) {
++			addr = axi_chan_ioread64(chan, CH_SAR);
++			completed_length = axi_dma_desc_src_pos(desc, addr);
++		} else if (chan->direction == DMA_DEV_TO_MEM) {
++			addr = axi_chan_ioread64(chan, CH_DAR);
++			completed_length = axi_dma_desc_dst_pos(desc, addr);
++		} else {
++			completed_length = 0;
++		}
++		bytes = desc->length - completed_length;
++	} else if (vdesc) {
++		/* Still in the queue so not started */
++		bytes = vd_to_axi_desc(vdesc)->length;
+ 	}
+ 
+-	spin_unlock_irqrestore(&chan->vc.lock, flags);
++	if (chan->is_paused && status == DMA_IN_PROGRESS)
++		status = DMA_PAUSED;
++
+ 	dma_set_residue(txstate, bytes);
++	spin_unlock_irqrestore(&chan->vc.lock, flags);
+ 
+ 	return status;
+ }
+@@ -516,7 +593,7 @@ static void dw_axi_dma_set_hw_channel(st
+ 	unsigned long reg_value, val;
+ 
+ 	if (!chip->apb_regs) {
+-		dev_err(chip->dev, "apb_regs not initialized\n");
++		dev_dbg(chip->dev, "apb_regs not initialized\n");
+ 		return;
+ 	}
+ 
+@@ -620,18 +697,25 @@ static int dw_axi_dma_set_hw_desc(struct
+ 	switch (chan->direction) {
+ 	case DMA_MEM_TO_DEV:
+ 		reg_width = __ffs(chan->config.dst_addr_width);
+-		device_addr = chan->config.dst_addr;
++		device_addr = phys_to_dma(chan->chip->dev, chan->config.dst_addr);
+ 		ctllo = reg_width << CH_CTL_L_DST_WIDTH_POS |
+ 			mem_width << CH_CTL_L_SRC_WIDTH_POS |
++			DWAXIDMAC_BURST_TRANS_LEN_1 << CH_CTL_L_DST_MSIZE_POS |
++			DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_SRC_MSIZE_POS |
+ 			DWAXIDMAC_CH_CTL_L_NOINC << CH_CTL_L_DST_INC_POS |
+ 			DWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_SRC_INC_POS;
+ 		block_ts = len >> mem_width;
+ 		break;
+ 	case DMA_DEV_TO_MEM:
+ 		reg_width = __ffs(chan->config.src_addr_width);
+-		device_addr = chan->config.src_addr;
++		/* Prevent partial access units getting lost */
++		if (mem_width > reg_width)
++			mem_width = reg_width;
++		device_addr = phys_to_dma(chan->chip->dev, chan->config.src_addr);
+ 		ctllo = reg_width << CH_CTL_L_SRC_WIDTH_POS |
+ 			mem_width << CH_CTL_L_DST_WIDTH_POS |
++			DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_DST_MSIZE_POS |
++			DWAXIDMAC_BURST_TRANS_LEN_1 << CH_CTL_L_SRC_MSIZE_POS |
+ 			DWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_DST_INC_POS |
+ 			DWAXIDMAC_CH_CTL_L_NOINC << CH_CTL_L_SRC_INC_POS;
+ 		block_ts = len >> reg_width;
+@@ -667,9 +751,6 @@ static int dw_axi_dma_set_hw_desc(struct
+ 	}
+ 
+ 	hw_desc->lli->block_ts_lo = cpu_to_le32(block_ts - 1);
+-
+-	ctllo |= DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_DST_MSIZE_POS |
+-		 DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_SRC_MSIZE_POS;
+ 	hw_desc->lli->ctl_lo = cpu_to_le32(ctllo);
+ 
+ 	set_desc_src_master(hw_desc);
+@@ -764,6 +845,8 @@ dw_axi_dma_chan_prep_cyclic(struct dma_c
+ 		src_addr += segment_len;
+ 	}
+ 
++	desc->hw_desc_count = total_segments;
++
+ 	llp = desc->hw_desc[0].llp;
+ 
+ 	/* Managed transfer list */
+@@ -843,6 +926,8 @@ dw_axi_dma_chan_prep_slave_sg(struct dma
+ 		} while (len >= segment_len);
+ 	}
+ 
++	desc->hw_desc_count = loop;
++
+ 	/* Set end-of-link to the last link descriptor of list */
+ 	set_desc_last(&desc->hw_desc[num_sgs - 1]);
+ 
+@@ -950,6 +1035,8 @@ dma_chan_prep_dma_memcpy(struct dma_chan
+ 		num++;
+ 	}
+ 
++	desc->hw_desc_count = num;
++
+ 	/* Set end-of-link to the last link descriptor of list */
+ 	set_desc_last(&desc->hw_desc[num - 1]);
+ 	/* Managed transfer list */
+@@ -998,7 +1085,7 @@ static void axi_chan_dump_lli(struct axi
+ static void axi_chan_list_dump_lli(struct axi_dma_chan *chan,
+ 				   struct axi_dma_desc *desc_head)
+ {
+-	int count = atomic_read(&chan->descs_allocated);
++	u32 count = desc_head->hw_desc_count;
+ 	int i;
+ 
+ 	for (i = 0; i < count; i++)
+@@ -1041,11 +1128,11 @@ out:
+ 
+ static void axi_chan_block_xfer_complete(struct axi_dma_chan *chan)
+ {
+-	int count = atomic_read(&chan->descs_allocated);
+ 	struct axi_dma_hw_desc *hw_desc;
+ 	struct axi_dma_desc *desc;
+ 	struct virt_dma_desc *vd;
+ 	unsigned long flags;
++	u32 count;
+ 	u64 llp;
+ 	int i;
+ 
+@@ -1067,6 +1154,7 @@ static void axi_chan_block_xfer_complete
+ 	if (chan->cyclic) {
+ 		desc = vd_to_axi_desc(vd);
+ 		if (desc) {
++			count = desc->hw_desc_count;
+ 			llp = lo_hi_readq(chan->chan_regs + CH_LLP);
+ 			for (i = 0; i < count; i++) {
+ 				hw_desc = &desc->hw_desc[i];
+@@ -1310,6 +1398,8 @@ static int parse_device_properties(struc
+ 	chip->dw->hdata->nr_channels = tmp;
+ 	if (tmp <= DMA_REG_MAP_CH_REF)
+ 		chip->dw->hdata->reg_map_8_channels = true;
++	else
++		chip->dw->hdata->reg_map_cfg2 = true;
+ 
+ 	ret = device_property_read_u32(dev, "snps,dma-masters", &tmp);
+ 	if (ret)
+@@ -1319,6 +1409,10 @@ static int parse_device_properties(struc
+ 
+ 	chip->dw->hdata->nr_masters = tmp;
+ 
++	ret = device_property_read_u32(dev, "snps,dma-targets", &tmp);
++	if (!ret && tmp > 16)
++		chip->dw->hdata->reg_map_cfg2 = true;
++
+ 	ret = device_property_read_u32(dev, "snps,data-width", &tmp);
+ 	if (ret)
+ 		return ret;
+--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
++++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
+@@ -32,6 +32,8 @@ struct dw_axi_dma_hcfg {
+ 	u32	axi_rw_burst_len;
+ 	/* Register map for DMAX_NUM_CHANNELS <= 8 */
+ 	bool	reg_map_8_channels;
++	/* Register map for DMAX_NUM_CHANNELS > 8 || DMAX_NUM_HS_IF > 16*/
++	bool	reg_map_cfg2;
+ 	bool	restrict_axi_burst_len;
+ };
+ 
+@@ -100,6 +102,7 @@ struct axi_dma_desc {
+ 
+ 	struct virt_dma_desc		vd;
+ 	struct axi_dma_chan		*chan;
++	u32				hw_desc_count;
+ 	u32				completed_blocks;
+ 	u32				length;
+ 	u32				period_len;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0883-spi-dw-Handle-combined-tx-and-rx-messages.patch b/target/linux/bcm27xx/patches-6.1/950-0883-spi-dw-Handle-combined-tx-and-rx-messages.patch
new file mode 100644
index 0000000000..68eca7961f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0883-spi-dw-Handle-combined-tx-and-rx-messages.patch
@@ -0,0 +1,64 @@
+From 8a9c0607ce0daa91c48faefd70ea73bda54ed0ae Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 29 Nov 2022 10:09:54 +0000
+Subject: [PATCH] spi: dw: Handle combined tx and rx messages
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/spi/spi-dw-core.c | 12 +++++++++---
+ drivers/spi/spi-dw-mmio.c |  8 ++++++--
+ 2 files changed, 15 insertions(+), 5 deletions(-)
+
+--- a/drivers/spi/spi-dw-core.c
++++ b/drivers/spi/spi-dw-core.c
+@@ -244,8 +244,11 @@ static irqreturn_t dw_spi_transfer_handl
+ 	 */
+ 	if (irq_status & DW_SPI_INT_TXEI) {
+ 		dw_writer(dws);
+-		if (!dws->tx_len)
++		if (!dws->tx_len) {
+ 			dw_spi_mask_intr(dws, DW_SPI_INT_TXEI);
++			if (!dws->rx_len)
++				spi_finalize_current_transfer(dws->master);
++		}
+ 	}
+ 
+ 	return IRQ_HANDLED;
+@@ -372,8 +375,11 @@ static void dw_spi_irq_setup(struct dw_s
+ 
+ 	dws->transfer_handler = dw_spi_transfer_handler;
+ 
+-	imask = DW_SPI_INT_TXEI | DW_SPI_INT_TXOI |
+-		DW_SPI_INT_RXUI | DW_SPI_INT_RXOI | DW_SPI_INT_RXFI;
++	imask = 0;
++	if (dws->tx_len)
++		imask |= DW_SPI_INT_TXEI | DW_SPI_INT_TXOI;
++	if (dws->rx_len)
++		imask |= DW_SPI_INT_RXUI | DW_SPI_INT_RXOI | DW_SPI_INT_RXFI;
+ 	dw_spi_umask_intr(dws, imask);
+ }
+ 
+--- a/drivers/spi/spi-dw-mmio.c
++++ b/drivers/spi/spi-dw-mmio.c
+@@ -20,6 +20,7 @@
+ #include <linux/property.h>
+ #include <linux/regmap.h>
+ #include <linux/reset.h>
++#include <linux/interrupt.h>
+ 
+ #include "spi-dw.h"
+ 
+@@ -280,8 +281,11 @@ static int dw_spi_mmio_probe(struct plat
+ 	dws->paddr = mem->start;
+ 
+ 	dws->irq = platform_get_irq(pdev, 0);
+-	if (dws->irq < 0)
+-		return dws->irq; /* -ENXIO */
++	if (dws->irq < 0) {
++		if (dws->irq != -ENXIO)
++			return dws->irq; /* -ENXIO */
++		dws->irq = IRQ_NOTCONNECTED;
++	}
+ 
+ 	dwsmmio->clk = devm_clk_get(&pdev->dev, NULL);
+ 	if (IS_ERR(dwsmmio->clk))
diff --git a/target/linux/bcm27xx/patches-6.1/950-0884-pwm-Add-support-for-RP1-PWM.patch b/target/linux/bcm27xx/patches-6.1/950-0884-pwm-Add-support-for-RP1-PWM.patch
new file mode 100644
index 0000000000..241d6c49db
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0884-pwm-Add-support-for-RP1-PWM.patch
@@ -0,0 +1,292 @@
+From 824f18efc8ad59e2783570ae2df83e2cd16b9f04 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 14 Feb 2023 14:03:54 +0000
+Subject: [PATCH] pwm: Add support for RP1 PWM
+
+Add a driver for the RP1 PWM block.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ .../devicetree/bindings/pwm/pwm-rp1.yaml      |  38 ++++
+ drivers/pwm/Kconfig                           |   9 +
+ drivers/pwm/Makefile                          |   1 +
+ drivers/pwm/pwm-rp1.c                         | 203 ++++++++++++++++++
+ 4 files changed, 251 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/pwm/pwm-rp1.yaml
+ create mode 100644 drivers/pwm/pwm-rp1.c
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/pwm/pwm-rp1.yaml
+@@ -0,0 +1,38 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/pwm/pwm-rp1.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Raspberry Pi RP1 PWM controller
++
++maintainers:
++  - Naushir Patuck <naush@raspberrypi.com>
++
++properties:
++  compatible:
++    enum:
++      - raspberrypi,rp1-pwm
++
++  reg:
++    maxItems: 1
++
++  "#pwm-cells":
++    const: 3
++
++required:
++  - compatible
++  - reg
++  - clocks
++  - "#pwm-cells"
++
++additionalProperties: false
++
++examples:
++  - |
++    pwm0: pwm@98000 {
++      compatible = "raspberrypi,rp1-pwm";
++      reg = <0x0 0x98000  0x0 0x100>;
++      clocks = <&rp1_sys>;
++      #pwm-cells = <3>;
++    };
+--- a/drivers/pwm/Kconfig
++++ b/drivers/pwm/Kconfig
+@@ -451,6 +451,15 @@ config PWM_RASPBERRYPI_POE
+ 	  Enable Raspberry Pi firmware controller PWM bus used to control the
+ 	  official RPI PoE hat
+ 
++config PWM_RP1
++	tristate "RP1 PWM support"
++	depends on ARCH_BCM2835 || COMPILE_TEST
++	help
++	  PWM framework driver for Raspberry Pi RP1 controller
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called pwm-rp1.
++
+ config PWM_RCAR
+ 	tristate "Renesas R-Car PWM support"
+ 	depends on ARCH_RENESAS || COMPILE_TEST
+--- a/drivers/pwm/Makefile
++++ b/drivers/pwm/Makefile
+@@ -41,6 +41,7 @@ obj-$(CONFIG_PWM_OMAP_DMTIMER)	+= pwm-om
+ obj-$(CONFIG_PWM_PCA9685)	+= pwm-pca9685.o
+ obj-$(CONFIG_PWM_PXA)		+= pwm-pxa.o
+ obj-$(CONFIG_PWM_RASPBERRYPI_POE)	+= pwm-raspberrypi-poe.o
++obj-$(CONFIG_PWM_RP1)		+= pwm-rp1.o
+ obj-$(CONFIG_PWM_RCAR)		+= pwm-rcar.o
+ obj-$(CONFIG_PWM_RENESAS_TPU)	+= pwm-renesas-tpu.o
+ obj-$(CONFIG_PWM_ROCKCHIP)	+= pwm-rockchip.o
+--- /dev/null
++++ b/drivers/pwm/pwm-rp1.c
+@@ -0,0 +1,203 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * pwm-rp1.c
++ *
++ * Raspberry Pi RP1 PWM.
++ *
++ * Copyright  2023 Raspberry Pi Ltd.
++ *
++ * Author: Naushir Patuck (naush@raspberrypi.com)
++ *
++ * Based on the pwm-bcm2835 driver by:
++ * Bart Tanghe <bart.tanghe@thomasmore.be>
++ */
++
++#include <linux/bitops.h>
++#include <linux/clk.h>
++#include <linux/err.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/pwm.h>
++
++#define PWM_GLOBAL_CTRL		0x000
++#define PWM_CHANNEL_CTRL(x)	(0x014 + ((x) * 16))
++#define PWM_RANGE(x)		(0x018 + ((x) * 16))
++#define PWM_DUTY(x)		(0x020 + ((x) * 16))
++
++/* 8:FIFO_POP_MASK + 0:Trailing edge M/S modulation */
++#define PWM_CHANNEL_DEFAULT	(BIT(8) + BIT(0))
++#define PWM_CHANNEL_ENABLE(x)	BIT(x)
++#define PWM_POLARITY		BIT(3)
++#define SET_UPDATE		BIT(31)
++#define PWM_MODE_MASK		GENMASK(1, 0)
++
++struct rp1_pwm {
++	struct pwm_chip chip;
++	struct device *dev;
++	void __iomem *base;
++	struct clk *clk;
++};
++
++static inline struct rp1_pwm *to_rp1_pwm(struct pwm_chip *chip)
++{
++	return container_of(chip, struct rp1_pwm, chip);
++}
++
++static void rp1_pwm_apply_config(struct pwm_chip *chip, struct pwm_device *pwm)
++{
++	struct rp1_pwm *pc = to_rp1_pwm(chip);
++	u32 value;
++
++	value = readl(pc->base + PWM_GLOBAL_CTRL);
++	value |= SET_UPDATE;
++	writel(value, pc->base + PWM_GLOBAL_CTRL);
++}
++
++static int rp1_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
++{
++	struct rp1_pwm *pc = to_rp1_pwm(chip);
++
++	writel(PWM_CHANNEL_DEFAULT, pc->base + PWM_CHANNEL_CTRL(pwm->hwpwm));
++	return 0;
++}
++
++static void rp1_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)
++{
++	struct rp1_pwm *pc = to_rp1_pwm(chip);
++	u32 value;
++
++	value = readl(pc->base + PWM_CHANNEL_CTRL(pwm->hwpwm));
++	value &= ~PWM_MODE_MASK;
++	writel(value, pc->base + PWM_CHANNEL_CTRL(pwm->hwpwm));
++	rp1_pwm_apply_config(chip, pwm);
++}
++
++static int rp1_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
++			 const struct pwm_state *state)
++{
++	struct rp1_pwm *pc = to_rp1_pwm(chip);
++	unsigned long clk_rate = clk_get_rate(pc->clk);
++	unsigned long clk_period;
++	u32 value;
++
++	if (!clk_rate) {
++		dev_err(pc->dev, "failed to get clock rate\n");
++		return -EINVAL;
++	}
++
++	/* set period */
++	clk_period = DIV_ROUND_CLOSEST(NSEC_PER_SEC, clk_rate);
++
++	writel(DIV_ROUND_CLOSEST(state->duty_cycle, clk_period),
++	       pc->base + PWM_DUTY(pwm->hwpwm));
++
++	/* set duty cycle */
++	writel(DIV_ROUND_CLOSEST(state->period, clk_period),
++	       pc->base + PWM_RANGE(pwm->hwpwm));
++
++	/* set polarity */
++	value = readl(pc->base + PWM_CHANNEL_CTRL(pwm->hwpwm));
++	if (state->polarity == PWM_POLARITY_NORMAL)
++		value &= ~PWM_POLARITY;
++	else
++		value |= PWM_POLARITY;
++	writel(value, pc->base + PWM_CHANNEL_CTRL(pwm->hwpwm));
++
++	/* enable/disable */
++	value = readl(pc->base + PWM_GLOBAL_CTRL);
++	if (state->enabled)
++		value |= PWM_CHANNEL_ENABLE(pwm->hwpwm);
++	else
++		value &= ~PWM_CHANNEL_ENABLE(pwm->hwpwm);
++	writel(value, pc->base + PWM_GLOBAL_CTRL);
++
++	rp1_pwm_apply_config(chip, pwm);
++
++	return 0;
++}
++
++static const struct pwm_ops rp1_pwm_ops = {
++	.request = rp1_pwm_request,
++	.free = rp1_pwm_free,
++	.apply = rp1_pwm_apply,
++	.owner = THIS_MODULE,
++};
++
++static int rp1_pwm_probe(struct platform_device *pdev)
++{
++	struct rp1_pwm *pc;
++	struct resource *res;
++	int ret;
++
++	pc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);
++	if (!pc)
++		return -ENOMEM;
++
++	pc->dev = &pdev->dev;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	pc->base = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(pc->base))
++		return PTR_ERR(pc->base);
++
++	pc->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(pc->clk))
++		return dev_err_probe(&pdev->dev, PTR_ERR(pc->clk),
++				     "clock not found\n");
++
++	ret = clk_prepare_enable(pc->clk);
++	if (ret)
++		return ret;
++
++	pc->chip.dev = &pdev->dev;
++	pc->chip.ops = &rp1_pwm_ops;
++	pc->chip.base = -1;
++	pc->chip.npwm = 4;
++	pc->chip.of_xlate = of_pwm_xlate_with_flags;
++	pc->chip.of_pwm_n_cells = 3;
++
++	platform_set_drvdata(pdev, pc);
++
++	ret = pwmchip_add(&pc->chip);
++	if (ret < 0)
++		goto add_fail;
++
++	return 0;
++
++add_fail:
++	clk_disable_unprepare(pc->clk);
++	return ret;
++}
++
++static int rp1_pwm_remove(struct platform_device *pdev)
++{
++	struct rp1_pwm *pc = platform_get_drvdata(pdev);
++
++	clk_disable_unprepare(pc->clk);
++
++	pwmchip_remove(&pc->chip);
++
++	return 0;
++}
++
++static const struct of_device_id rp1_pwm_of_match[] = {
++	{ .compatible = "raspberrypi,rp1-pwm" },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, rp1_pwm_of_match);
++
++static struct platform_driver rp1_pwm_driver = {
++	.driver = {
++		.name = "rpi-pwm",
++		.of_match_table = rp1_pwm_of_match,
++	},
++	.probe = rp1_pwm_probe,
++	.remove = rp1_pwm_remove,
++};
++module_platform_driver(rp1_pwm_driver);
++
++MODULE_AUTHOR("Naushir Patuck <naush@raspberrypi.com");
++MODULE_DESCRIPTION("RP1 PWM driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/bcm27xx/patches-6.1/950-0885-drm-Add-RP1-DSI-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0885-drm-Add-RP1-DSI-driver.patch
new file mode 100644
index 0000000000..b82d53e080
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0885-drm-Add-RP1-DSI-driver.patch
@@ -0,0 +1,2678 @@
+From f93caa69a9af6476cd4d93944a83acd227e68fd4 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Tue, 14 Feb 2023 14:58:33 +0000
+Subject: [PATCH] drm: Add RP1 DSI driver
+
+Add support for the RP1 DSI hardware.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/gpu/drm/Kconfig                   |    2 +
+ drivers/gpu/drm/Makefile                  |    1 +
+ drivers/gpu/drm/rp1/Kconfig               |    5 +
+ drivers/gpu/drm/rp1/Makefile              |    4 +
+ drivers/gpu/drm/rp1/rp1-dsi/Kconfig       |   15 +
+ drivers/gpu/drm/rp1/rp1-dsi/Makefile      |    5 +
+ drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi.c     |  537 ++++++++
+ drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi.h     |   94 ++
+ drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi_dma.c |  443 ++++++
+ drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi_dsi.c | 1504 +++++++++++++++++++++
+ 10 files changed, 2610 insertions(+)
+ create mode 100644 drivers/gpu/drm/rp1/Kconfig
+ create mode 100644 drivers/gpu/drm/rp1/Makefile
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dsi/Kconfig
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dsi/Makefile
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi.c
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi.h
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi_dma.c
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi_dsi.c
+
+--- a/drivers/gpu/drm/Kconfig
++++ b/drivers/gpu/drm/Kconfig
+@@ -384,6 +384,8 @@ source "drivers/gpu/drm/v3d/Kconfig"
+ 
+ source "drivers/gpu/drm/vc4/Kconfig"
+ 
++source "drivers/gpu/drm/rp1/Kconfig"
++
+ source "drivers/gpu/drm/etnaviv/Kconfig"
+ 
+ source "drivers/gpu/drm/hisilicon/Kconfig"
+--- a/drivers/gpu/drm/Makefile
++++ b/drivers/gpu/drm/Makefile
+@@ -148,3 +148,4 @@ obj-y			+= gud/
+ obj-$(CONFIG_DRM_HYPERV) += hyperv/
+ obj-y			+= solomon/
+ obj-$(CONFIG_DRM_SPRD) += sprd/
++obj-y += rp1/
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/Kconfig
+@@ -0,0 +1,5 @@
++source "drivers/gpu/drm/rp1/rp1-dsi/Kconfig"
++
++source "drivers/gpu/drm/rp1/rp1-dpi/Kconfig"
++
++source "drivers/gpu/drm/rp1/rp1-vec/Kconfig"
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/Makefile
+@@ -0,0 +1,4 @@
++obj-$(CONFIG_DRM_RP1_DSI) += rp1-dsi/
++obj-$(CONFIG_DRM_RP1_DPI) += rp1-dpi/
++obj-$(CONFIG_DRM_RP1_VEC) += rp1-vec/
++
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dsi/Kconfig
+@@ -0,0 +1,15 @@
++# SPDX-License-Identifier: GPL-2.0-only
++config DRM_RP1_DSI
++	tristate "DRM Support for RP1 DSI"
++	depends on DRM
++	select MFD_RP1
++	select DRM_GEM_DMA_HELPER
++	select DRM_KMS_HELPER
++	select DRM_MIPI_DSI
++	select DRM_VRAM_HELPER
++	select DRM_TTM
++	select DRM_TTM_HELPER
++	select GENERIC_PHY
++	select GENERIC_PHY_MIPI_DPHY
++	help
++	  Choose this option to enable DSI display on RP1
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dsi/Makefile
+@@ -0,0 +1,5 @@
++# SPDX-License-Identifier: GPL-2.0-only
++
++drm-rp1-dsi-y := rp1_dsi.o rp1_dsi_dma.o rp1_dsi_dsi.o
++
++obj-$(CONFIG_DRM_RP1_DSI) += drm-rp1-dsi.o
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi.c
+@@ -0,0 +1,537 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for DSI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/clk.h>
++#include <linux/component.h>
++#include <linux/delay.h>
++#include <linux/dma-mapping.h>
++#include <linux/errno.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/list.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/phy/phy-mipi-dphy.h>
++#include <linux/string.h>
++
++#include <drm/drm_atomic_helper.h>
++#include <drm/drm_crtc.h>
++#include <drm/drm_crtc_helper.h>
++#include <drm/drm_drv.h>
++#include <drm/drm_encoder.h>
++#include <drm/drm_fourcc.h>
++#include <drm/drm_fb_helper.h>
++#include <drm/drm_framebuffer.h>
++#include <drm/drm_gem.h>
++#include <drm/drm_gem_atomic_helper.h>
++#include <drm/drm_gem_dma_helper.h>
++#include <drm/drm_gem_framebuffer_helper.h>
++#include <drm/drm_managed.h>
++#include <drm/drm_modeset_helper_vtables.h>
++#include <drm/drm_of.h>
++#include <drm/drm_print.h>
++#include <drm/drm_probe_helper.h>
++#include <drm/drm_simple_kms_helper.h>
++#include <drm/drm_vblank.h>
++
++#include "rp1_dsi.h"
++
++static inline struct rp1_dsi *
++bridge_to_rp1_dsi(struct drm_bridge *bridge)
++{
++	return container_of(bridge, struct rp1_dsi, bridge);
++}
++
++static void rp1_dsi_bridge_pre_enable(struct drm_bridge *bridge,
++				      struct drm_bridge_state *old_state)
++{
++	struct rp1_dsi *dsi = bridge_to_rp1_dsi(bridge);
++
++	rp1dsi_dsi_setup(dsi, &dsi->pipe.crtc.state->adjusted_mode);
++}
++
++static void rp1_dsi_bridge_enable(struct drm_bridge *bridge,
++				  struct drm_bridge_state *old_state)
++{
++}
++
++static void rp1_dsi_bridge_disable(struct drm_bridge *bridge,
++				   struct drm_bridge_state *state)
++{
++}
++
++static void rp1_dsi_bridge_post_disable(struct drm_bridge *bridge,
++					struct drm_bridge_state *state)
++{
++	struct rp1_dsi *dsi = bridge_to_rp1_dsi(bridge);
++
++	if (dsi->dsi_running) {
++		rp1dsi_dsi_stop(dsi);
++		dsi->dsi_running = false;
++	}
++}
++
++static int rp1_dsi_bridge_attach(struct drm_bridge *bridge,
++				 enum drm_bridge_attach_flags flags)
++{
++	struct rp1_dsi *dsi = bridge_to_rp1_dsi(bridge);
++
++	/* Attach the panel or bridge to the dsi bridge */
++	return drm_bridge_attach(bridge->encoder, dsi->out_bridge,
++				 &dsi->bridge, flags);
++	return 0;
++}
++
++static const struct drm_bridge_funcs rp1_dsi_bridge_funcs = {
++	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
++	.atomic_reset = drm_atomic_helper_bridge_reset,
++	.atomic_pre_enable = rp1_dsi_bridge_pre_enable,
++	.atomic_enable = rp1_dsi_bridge_enable,
++	.atomic_disable = rp1_dsi_bridge_disable,
++	.atomic_post_disable = rp1_dsi_bridge_post_disable,
++	.attach = rp1_dsi_bridge_attach,
++};
++
++static void rp1dsi_pipe_update(struct drm_simple_display_pipe *pipe,
++			       struct drm_plane_state *old_state)
++{
++	struct drm_pending_vblank_event *event;
++	unsigned long flags;
++	struct drm_framebuffer *fb = pipe->plane.state->fb;
++	struct rp1_dsi *dsi = pipe->crtc.dev->dev_private;
++	struct drm_gem_object *gem = fb ? drm_gem_fb_get_obj(fb, 0) : NULL;
++	struct drm_gem_dma_object *dma_obj = gem ? to_drm_gem_dma_obj(gem) : NULL;
++	bool can_update = fb && dma_obj && dsi && dsi->pipe_enabled;
++
++	/* (Re-)start DSI,DMA where required; and update FB address */
++	if (can_update) {
++		if (!dsi->dma_running || fb->format->format != dsi->cur_fmt) {
++			if (dsi->dma_running && fb->format->format != dsi->cur_fmt) {
++				rp1dsi_dma_stop(dsi);
++				dsi->dma_running = false;
++			}
++			if (!dsi->dma_running) {
++				rp1dsi_dma_setup(dsi,
++						 fb->format->format, dsi->display_format,
++						&pipe->crtc.state->adjusted_mode);
++				dsi->dma_running = true;
++			}
++			dsi->cur_fmt  = fb->format->format;
++			drm_crtc_vblank_on(&pipe->crtc);
++		}
++		rp1dsi_dma_update(dsi, dma_obj->dma_addr, fb->offsets[0], fb->pitches[0]);
++	}
++
++	/* Arm VBLANK event (or call it immediately in some error cases) */
++	spin_lock_irqsave(&pipe->crtc.dev->event_lock, flags);
++	event = pipe->crtc.state->event;
++	if (event) {
++		pipe->crtc.state->event = NULL;
++		if (can_update && drm_crtc_vblank_get(&pipe->crtc) == 0)
++			drm_crtc_arm_vblank_event(&pipe->crtc, event);
++		else
++			drm_crtc_send_vblank_event(&pipe->crtc, event);
++	}
++	spin_unlock_irqrestore(&pipe->crtc.dev->event_lock, flags);
++}
++
++static inline struct rp1_dsi *
++encoder_to_rp1_dsi(struct drm_encoder *encoder)
++{
++	struct drm_simple_display_pipe *pipe =
++		container_of(encoder, struct drm_simple_display_pipe, encoder);
++	return container_of(pipe, struct rp1_dsi, pipe);
++}
++
++static void rp1dsi_encoder_enable(struct drm_encoder *encoder)
++{
++	struct rp1_dsi *dsi = encoder_to_rp1_dsi(encoder);
++
++	/* Put DSI into video mode before starting video */
++	rp1dsi_dsi_set_cmdmode(dsi, 0);
++
++	/* Start DMA -> DPI */
++	dsi->pipe_enabled = true;
++	dsi->cur_fmt = 0xdeadbeef;
++	rp1dsi_pipe_update(&dsi->pipe, 0);
++}
++
++static void rp1dsi_encoder_disable(struct drm_encoder *encoder)
++{
++	struct rp1_dsi *dsi = encoder_to_rp1_dsi(encoder);
++
++	drm_crtc_vblank_off(&dsi->pipe.crtc);
++	if (dsi->dma_running) {
++		rp1dsi_dma_stop(dsi);
++		dsi->dma_running = false;
++	}
++	dsi->pipe_enabled = false;
++
++	/* Return to command mode after stopping video */
++	rp1dsi_dsi_set_cmdmode(dsi, 1);
++}
++
++static const struct drm_encoder_helper_funcs rp1_dsi_encoder_funcs = {
++	.enable = rp1dsi_encoder_enable,
++	.disable = rp1dsi_encoder_disable,
++};
++
++static void rp1dsi_pipe_enable(struct drm_simple_display_pipe *pipe,
++			       struct drm_crtc_state *crtc_state,
++			       struct drm_plane_state *plane_state)
++{
++}
++
++static void rp1dsi_pipe_disable(struct drm_simple_display_pipe *pipe)
++{
++}
++
++static int rp1dsi_pipe_enable_vblank(struct drm_simple_display_pipe *pipe)
++{
++	struct rp1_dsi *dsi = pipe->crtc.dev->dev_private;
++
++	if (dsi)
++		rp1dsi_dma_vblank_ctrl(dsi, 1);
++
++	return 0;
++}
++
++static void rp1dsi_pipe_disable_vblank(struct drm_simple_display_pipe *pipe)
++{
++	struct rp1_dsi *dsi = pipe->crtc.dev->dev_private;
++
++	if (dsi)
++		rp1dsi_dma_vblank_ctrl(dsi, 0);
++}
++
++static const struct drm_simple_display_pipe_funcs rp1dsi_pipe_funcs = {
++	.enable	    = rp1dsi_pipe_enable,
++	.update	    = rp1dsi_pipe_update,
++	.disable    = rp1dsi_pipe_disable,
++	.prepare_fb = drm_gem_simple_display_pipe_prepare_fb,
++	.enable_vblank  = rp1dsi_pipe_enable_vblank,
++	.disable_vblank = rp1dsi_pipe_disable_vblank,
++};
++
++static const struct drm_mode_config_funcs rp1dsi_mode_funcs = {
++	.fb_create = drm_gem_fb_create,
++	.atomic_check = drm_atomic_helper_check,
++	.atomic_commit = drm_atomic_helper_commit,
++};
++
++static const u32 rp1dsi_formats[] = {
++	DRM_FORMAT_XRGB8888,
++	DRM_FORMAT_XBGR8888,
++	DRM_FORMAT_RGB888,
++	DRM_FORMAT_BGR888,
++	DRM_FORMAT_RGB565
++};
++
++static void rp1dsi_stopall(struct drm_device *drm)
++{
++	if (drm->dev_private) {
++		struct rp1_dsi *dsi = drm->dev_private;
++
++		if (dsi->dma_running || rp1dsi_dma_busy(dsi)) {
++			rp1dsi_dma_stop(dsi);
++			dsi->dma_running = false;
++		}
++		if (dsi->dsi_running) {
++			rp1dsi_dsi_stop(dsi);
++			dsi->dsi_running = false;
++		}
++		if (dsi->clocks[RP1DSI_CLOCK_CFG])
++			clk_disable_unprepare(dsi->clocks[RP1DSI_CLOCK_CFG]);
++	}
++}
++
++DEFINE_DRM_GEM_DMA_FOPS(rp1dsi_fops);
++
++static struct drm_driver rp1dsi_driver = {
++	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
++	.fops			= &rp1dsi_fops,
++	.name			= "drm-rp1-dsi",
++	.desc			= "drm-rp1-dsi",
++	.date			= "0",
++	.major			= 1,
++	.minor			= 0,
++	DRM_GEM_DMA_DRIVER_OPS,
++	.release		= rp1dsi_stopall,
++};
++
++static int rp1dsi_bind(struct rp1_dsi *dsi)
++{
++	struct platform_device *pdev = dsi->pdev;
++	struct drm_device *drm = dsi->drm;
++	int ret;
++
++	dsi->out_bridge = drmm_of_get_bridge(drm, pdev->dev.of_node, 0, 0);
++	if (IS_ERR(dsi->out_bridge))
++		return PTR_ERR(dsi->out_bridge);
++
++	ret = drmm_mode_config_init(drm);
++	if (ret)
++		goto rtn;
++
++	drm->mode_config.max_width  = 4096;
++	drm->mode_config.max_height = 4096;
++	drm->mode_config.fb_base    = 0;
++	drm->mode_config.preferred_depth = 32;
++	drm->mode_config.prefer_shadow	 = 0;
++	drm->mode_config.prefer_shadow_fbdev = 1;
++	drm->mode_config.quirk_addfb_prefer_host_byte_order = true;
++	drm->mode_config.funcs = &rp1dsi_mode_funcs;
++	drm_vblank_init(drm, 1);
++
++	ret = drm_simple_display_pipe_init(drm,
++					   &dsi->pipe,
++					   &rp1dsi_pipe_funcs,
++					   rp1dsi_formats,
++					   ARRAY_SIZE(rp1dsi_formats),
++					   NULL, NULL);
++	if (ret)
++		goto rtn;
++
++	/* We need slightly more complex encoder handling (enabling/disabling
++	 * video mode), so add encoder helper functions.
++	 */
++	drm_encoder_helper_add(&dsi->pipe.encoder, &rp1_dsi_encoder_funcs);
++
++	ret = drm_simple_display_pipe_attach_bridge(&dsi->pipe, &dsi->bridge);
++	if (ret)
++		goto rtn;
++
++	drm_bridge_add(&dsi->bridge);
++
++	drm_mode_config_reset(drm);
++
++	if (dsi->clocks[RP1DSI_CLOCK_CFG])
++		clk_prepare_enable(dsi->clocks[RP1DSI_CLOCK_CFG]);
++
++	ret = drm_dev_register(drm, 0);
++
++	if (ret == 0)
++		drm_fbdev_generic_setup(drm, 32);
++
++rtn:
++	if (ret)
++		dev_err(&pdev->dev, "%s returned %d\n", __func__, ret);
++	else
++		dev_info(&pdev->dev, "%s succeeded", __func__);
++
++	return ret;
++}
++
++static void rp1dsi_unbind(struct rp1_dsi *dsi)
++{
++	struct drm_device *drm = dsi->drm;
++
++	rp1dsi_stopall(drm);
++	drm_dev_unregister(drm);
++	drm_atomic_helper_shutdown(drm);
++}
++
++int rp1dsi_host_attach(struct mipi_dsi_host *host, struct mipi_dsi_device *dsi_dev)
++{
++	struct rp1_dsi *dsi = container_of(host, struct rp1_dsi, dsi_host);
++
++	dev_info(&dsi->pdev->dev, "%s: Attach DSI device name=%s channel=%d lanes=%d format=%d flags=0x%lx hs_rate=%lu lp_rate=%lu",
++		 __func__, dsi_dev->name, dsi_dev->channel, dsi_dev->lanes,
++		 dsi_dev->format, dsi_dev->mode_flags, dsi_dev->hs_rate,
++		 dsi_dev->lp_rate);
++	dsi->vc              = dsi_dev->channel & 3;
++	dsi->lanes           = dsi_dev->lanes;
++
++	switch (dsi_dev->format) {
++	case MIPI_DSI_FMT_RGB666:
++	case MIPI_DSI_FMT_RGB666_PACKED:
++	case MIPI_DSI_FMT_RGB565:
++	case MIPI_DSI_FMT_RGB888:
++		break;
++	default:
++		return -EINVAL;
++	}
++	dsi->display_format  = dsi_dev->format;
++	dsi->display_flags   = dsi_dev->mode_flags;
++	dsi->display_hs_rate = dsi_dev->hs_rate;
++	dsi->display_lp_rate = dsi_dev->lp_rate;
++
++	/*
++	 * Previously, we added a separate component to handle panel/bridge
++	 * discovery and DRM registration, but now it's just a function call.
++	 * The downstream/attaching device should deal with -EPROBE_DEFER
++	 */
++	return rp1dsi_bind(dsi);
++}
++
++int rp1dsi_host_detach(struct mipi_dsi_host *host, struct mipi_dsi_device *dsi_dev)
++{
++	struct rp1_dsi *dsi = container_of(host, struct rp1_dsi, dsi_host);
++
++	/*
++	 * Unregister the DRM driver.
++	 * TODO: Check we are cleaning up correctly and not doing things multiple times!
++	 */
++	rp1dsi_unbind(dsi);
++	return 0;
++}
++
++ssize_t rp1dsi_host_transfer(struct mipi_dsi_host *host, const struct mipi_dsi_msg *msg)
++{
++	struct rp1_dsi *dsi = container_of(host, struct rp1_dsi, dsi_host);
++	struct mipi_dsi_packet packet;
++	int ret = 0;
++
++	/* Write */
++	ret = mipi_dsi_create_packet(&packet, msg);
++	if (ret) {
++		dev_err(dsi->drm->dev, "RP1DSI: failed to create packet: %d\n", ret);
++		return ret;
++	}
++
++	rp1dsi_dsi_send(dsi, *(u32 *)(&packet.header), packet.payload_length, packet.payload);
++
++	/* Optional read back */
++	if (msg->rx_len && msg->rx_buf)
++		ret = rp1dsi_dsi_recv(dsi, msg->rx_len, msg->rx_buf);
++
++	return (ssize_t)ret;
++}
++
++static const struct mipi_dsi_host_ops rp1dsi_mipi_dsi_host_ops = {
++	.attach = rp1dsi_host_attach,
++	.detach = rp1dsi_host_detach,
++	.transfer = rp1dsi_host_transfer
++};
++
++static int rp1dsi_platform_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct drm_device *drm;
++	struct rp1_dsi *dsi;
++	int i, ret;
++
++	drm = drm_dev_alloc(&rp1dsi_driver, dev);
++	if (IS_ERR(drm)) {
++		ret = PTR_ERR(drm);
++		return ret;
++	}
++	dsi = drmm_kzalloc(drm, sizeof(*dsi), GFP_KERNEL);
++	if (!dsi) {
++		ret = -ENOMEM;
++		goto err_free_drm;
++	}
++	init_completion(&dsi->finished);
++	dsi->drm = drm;
++	dsi->pdev = pdev;
++	drm->dev_private = dsi;
++	platform_set_drvdata(pdev, drm);
++
++	dsi->bridge.funcs = &rp1_dsi_bridge_funcs;
++	dsi->bridge.of_node = dev->of_node;
++	dsi->bridge.type = DRM_MODE_CONNECTOR_DSI;
++
++	/* Safe default values for DSI mode */
++	dsi->lanes = 1;
++	dsi->display_format = MIPI_DSI_FMT_RGB888;
++	dsi->display_flags  = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_LPM;
++
++	/* Hardware resources */
++	for (i = 0; i < RP1DSI_NUM_CLOCKS; i++) {
++		static const char * const myclocknames[RP1DSI_NUM_CLOCKS] = {
++			"cfgclk", "dpiclk", "byteclk", "refclk"
++		};
++		dsi->clocks[i] = devm_clk_get(dev, myclocknames[i]);
++		if (IS_ERR(dsi->clocks[i])) {
++			ret = PTR_ERR(dsi->clocks[i]);
++			dev_err(dev, "Error getting clocks[%d]\n", i);
++			goto err_free_drm;
++		}
++	}
++
++	for (i = 0; i < RP1DSI_NUM_HW_BLOCKS; i++) {
++		dsi->hw_base[i] =
++			devm_ioremap_resource(dev,
++					      platform_get_resource(dsi->pdev,
++								    IORESOURCE_MEM,
++								    i));
++		if (IS_ERR(dsi->hw_base[i])) {
++			ret = PTR_ERR(dsi->hw_base[i]);
++			dev_err(dev, "Error memory mapping regs[%d]\n", i);
++			goto err_free_drm;
++		}
++	}
++	ret = platform_get_irq(dsi->pdev, 0);
++	if (ret > 0)
++		ret = devm_request_irq(dev, ret, rp1dsi_dma_isr,
++				       IRQF_SHARED, "rp1-dsi", dsi);
++	if (ret) {
++		dev_err(dev, "Unable to request interrupt\n");
++		ret = -EINVAL;
++		goto err_free_drm;
++	}
++	rp1dsi_mipicfg_setup(dsi);
++	dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
++
++	/* Create the MIPI DSI Host and wait for the panel/bridge to attach to it */
++	dsi->dsi_host.ops = &rp1dsi_mipi_dsi_host_ops;
++	dsi->dsi_host.dev = dev;
++	ret = mipi_dsi_host_register(&dsi->dsi_host);
++	if (ret)
++		goto err_free_drm;
++
++	return ret;
++
++err_free_drm:
++	dev_err(dev, "%s fail %d\n", __func__, ret);
++	drm_dev_put(drm);
++	return ret;
++}
++
++static int rp1dsi_platform_remove(struct platform_device *pdev)
++{
++	struct drm_device *drm = platform_get_drvdata(pdev);
++	struct rp1_dsi *dsi = drm->dev_private;
++
++	mipi_dsi_host_unregister(&dsi->dsi_host);
++	return 0;
++}
++
++static void rp1dsi_platform_shutdown(struct platform_device *pdev)
++{
++	struct drm_device *drm = platform_get_drvdata(pdev);
++
++	rp1dsi_stopall(drm);
++}
++
++static const struct of_device_id rp1dsi_of_match[] = {
++	{
++		.compatible = "raspberrypi,rp1dsi",
++	},
++	{ /* sentinel */ },
++};
++
++MODULE_DEVICE_TABLE(of, rp1dsi_of_match);
++
++static struct platform_driver rp1dsi_platform_driver = {
++	.probe		= rp1dsi_platform_probe,
++	.remove		= rp1dsi_platform_remove,
++	.shutdown       = rp1dsi_platform_shutdown,
++	.driver		= {
++		.name	= DRIVER_NAME,
++		.owner  = THIS_MODULE,
++		.of_match_table = rp1dsi_of_match,
++	},
++};
++
++module_platform_driver(rp1dsi_platform_driver);
++
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("MIPI DSI driver for Raspberry Pi RP1");
++MODULE_AUTHOR("Nick Hollinghurst");
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi.h
+@@ -0,0 +1,94 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * DRM Driver for DSI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++#ifndef _RP1_DSI_H_
++#define _RP1_DSI_H_
++
++#include <linux/clk.h>
++#include <linux/io.h>
++#include <linux/types.h>
++
++#include <drm/drm_bridge.h>
++#include <drm/drm_device.h>
++#include <drm/drm_mipi_dsi.h>
++#include <drm/drm_simple_kms_helper.h>
++
++#define MODULE_NAME "drm-rp1-dsi"
++#define DRIVER_NAME "drm-rp1-dsi"
++
++/* ---------------------------------------------------------------------- */
++
++#define RP1DSI_HW_BLOCK_DMA   0
++#define RP1DSI_HW_BLOCK_DSI   1
++#define RP1DSI_HW_BLOCK_CFG   2
++#define RP1DSI_NUM_HW_BLOCKS  3
++
++#define RP1DSI_CLOCK_CFG     0
++#define RP1DSI_CLOCK_DPI     1
++#define RP1DSI_CLOCK_BYTE    2
++#define RP1DSI_CLOCK_REF     3
++#define RP1DSI_NUM_CLOCKS    4
++
++/* ---------------------------------------------------------------------- */
++
++struct rp1_dsi {
++	/* DRM and platform device pointers */
++	struct drm_device *drm;
++	struct platform_device *pdev;
++
++	/* Framework and helper objects */
++	struct drm_simple_display_pipe pipe;
++	struct drm_bridge bridge;
++	struct drm_bridge *out_bridge;
++	struct mipi_dsi_host dsi_host;
++
++	/* Clocks. We need DPI clock; the others are frequency references */
++	struct clk *clocks[RP1DSI_NUM_CLOCKS];
++
++	/* Block (DSI DMA, DSI Host) base addresses, and current state */
++	void __iomem *hw_base[RP1DSI_NUM_HW_BLOCKS];
++	u32 cur_fmt;
++	bool dsi_running, dma_running, pipe_enabled;
++	struct completion finished;
++
++	/* Attached display parameters (from mipi_dsi_device) */
++	unsigned long display_flags, display_hs_rate, display_lp_rate;
++	enum mipi_dsi_pixel_format display_format;
++	u8 vc;
++	u8 lanes;
++
++	/* DPHY */
++	u8 hsfreq_index;
++};
++
++/* ---------------------------------------------------------------------- */
++/* Functions to control the DSI/DPI/DMA block				  */
++
++void rp1dsi_dma_setup(struct rp1_dsi *dsi,
++		      u32 in_format, enum mipi_dsi_pixel_format out_format,
++		      struct drm_display_mode const *mode);
++void rp1dsi_dma_update(struct rp1_dsi *dsi, dma_addr_t addr, u32 offset, u32 stride);
++void rp1dsi_dma_stop(struct rp1_dsi *dsi);
++int rp1dsi_dma_busy(struct rp1_dsi *dsi);
++irqreturn_t rp1dsi_dma_isr(int irq, void *dev);
++void rp1dsi_dma_vblank_ctrl(struct rp1_dsi *dsi, int enable);
++
++/* ---------------------------------------------------------------------- */
++/* Functions to control the MIPICFG block and check RP1 platform		  */
++
++void rp1dsi_mipicfg_setup(struct rp1_dsi *dsi);
++
++/* ---------------------------------------------------------------------- */
++/* Functions to control the SNPS D-PHY and DSI block setup		  */
++
++void rp1dsi_dsi_setup(struct rp1_dsi *dsi, struct drm_display_mode const *mode);
++void rp1dsi_dsi_send(struct rp1_dsi *dsi, u32 header, int len, const u8 *buf);
++int  rp1dsi_dsi_recv(struct rp1_dsi *dsi, int len, u8 *buf);
++void rp1dsi_dsi_set_cmdmode(struct rp1_dsi *dsi, int cmd_mode);
++void rp1dsi_dsi_stop(struct rp1_dsi *dsi);
++
++#endif
++
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi_dma.c
+@@ -0,0 +1,443 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for DSI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/interrupt.h>
++#include <linux/platform_device.h>
++
++#include <drm/drm_fourcc.h>
++#include <drm/drm_print.h>
++#include <drm/drm_vblank.h>
++
++#include "rp1_dsi.h"
++
++// --- DPI DMA REGISTERS (derived from Argon firmware, via RP1 drivers/mipi, with corrections) ---
++
++// Control
++#define DPI_DMA_CONTROL				      0x0
++#define DPI_DMA_CONTROL_ARM_SHIFT		      0
++#define DPI_DMA_CONTROL_ARM_MASK		      BIT(DPI_DMA_CONTROL_ARM_SHIFT)
++#define DPI_DMA_CONTROL_ALIGN16_SHIFT		      2
++#define DPI_DMA_CONTROL_ALIGN16_MASK		      BIT(DPI_DMA_CONTROL_ALIGN16_SHIFT)
++#define DPI_DMA_CONTROL_AUTO_REPEAT_SHIFT	      1
++#define DPI_DMA_CONTROL_AUTO_REPEAT_MASK	      BIT(DPI_DMA_CONTROL_AUTO_REPEAT_SHIFT)
++#define DPI_DMA_CONTROL_HIGH_WATER_SHIFT	      3
++#define DPI_DMA_CONTROL_HIGH_WATER_MASK		      (0x1FF << DPI_DMA_CONTROL_HIGH_WATER_SHIFT)
++#define DPI_DMA_CONTROL_DEN_POL_SHIFT		      12
++#define DPI_DMA_CONTROL_DEN_POL_MASK		      BIT(DPI_DMA_CONTROL_DEN_POL_SHIFT)
++#define DPI_DMA_CONTROL_HSYNC_POL_SHIFT		      13
++#define DPI_DMA_CONTROL_HSYNC_POL_MASK		      BIT(DPI_DMA_CONTROL_HSYNC_POL_SHIFT)
++#define DPI_DMA_CONTROL_VSYNC_POL_SHIFT		      14
++#define DPI_DMA_CONTROL_VSYNC_POL_MASK		      BIT(DPI_DMA_CONTROL_VSYNC_POL_SHIFT)
++#define DPI_DMA_CONTROL_COLORM_SHIFT		      15
++#define DPI_DMA_CONTROL_COLORM_MASK		      BIT(DPI_DMA_CONTROL_COLORM_SHIFT)
++#define DPI_DMA_CONTROL_SHUTDN_SHIFT		      16
++#define DPI_DMA_CONTROL_SHUTDN_MASK		      BIT(DPI_DMA_CONTROL_SHUTDN_SHIFT)
++#define DPI_DMA_CONTROL_HBP_EN_SHIFT		      17
++#define DPI_DMA_CONTROL_HBP_EN_MASK		      BIT(DPI_DMA_CONTROL_HBP_EN_SHIFT)
++#define DPI_DMA_CONTROL_HFP_EN_SHIFT		      18
++#define DPI_DMA_CONTROL_HFP_EN_MASK		      BIT(DPI_DMA_CONTROL_HFP_EN_SHIFT)
++#define DPI_DMA_CONTROL_VBP_EN_SHIFT		      19
++#define DPI_DMA_CONTROL_VBP_EN_MASK		      BIT(DPI_DMA_CONTROL_VBP_EN_SHIFT)
++#define DPI_DMA_CONTROL_VFP_EN_SHIFT		      20
++#define DPI_DMA_CONTROL_VFP_EN_MASK		      BIT(DPI_DMA_CONTROL_VFP_EN_SHIFT)
++#define DPI_DMA_CONTROL_HSYNC_EN_SHIFT		      21
++#define DPI_DMA_CONTROL_HSYNC_EN_MASK		      BIT(DPI_DMA_CONTROL_HSYNC_EN_SHIFT)
++#define DPI_DMA_CONTROL_VSYNC_EN_SHIFT		      22
++#define DPI_DMA_CONTROL_VSYNC_EN_MASK		      BIT(DPI_DMA_CONTROL_VSYNC_EN_SHIFT)
++#define DPI_DMA_CONTROL_FORCE_IMMED_SHIFT	      23
++#define DPI_DMA_CONTROL_FORCE_IMMED_MASK	      BIT(DPI_DMA_CONTROL_FORCE_IMMED_SHIFT)
++#define DPI_DMA_CONTROL_FORCE_DRAIN_SHIFT	      24
++#define DPI_DMA_CONTROL_FORCE_DRAIN_MASK	      BIT(DPI_DMA_CONTROL_FORCE_DRAIN_SHIFT)
++#define DPI_DMA_CONTROL_FORCE_EMPTY_SHIFT	      25
++#define DPI_DMA_CONTROL_FORCE_EMPTY_MASK	      BIT(DPI_DMA_CONTROL_FORCE_EMPTY_SHIFT)
++
++// IRQ_ENABLES
++#define DPI_DMA_IRQ_EN				      0x04
++#define DPI_DMA_IRQ_EN_DMA_READY_SHIFT		      0
++#define DPI_DMA_IRQ_EN_DMA_READY_MASK		      BIT(DPI_DMA_IRQ_EN_DMA_READY_SHIFT)
++#define DPI_DMA_IRQ_EN_UNDERFLOW_SHIFT		      1
++#define DPI_DMA_IRQ_EN_UNDERFLOW_MASK		      BIT(DPI_DMA_IRQ_EN_UNDERFLOW_SHIFT)
++#define DPI_DMA_IRQ_EN_FRAME_START_SHIFT	      2
++#define DPI_DMA_IRQ_EN_FRAME_START_MASK		      BIT(DPI_DMA_IRQ_EN_FRAME_START_SHIFT)
++#define DPI_DMA_IRQ_EN_AFIFO_EMPTY_SHIFT	      3
++#define DPI_DMA_IRQ_EN_AFIFO_EMPTY_MASK		      BIT(DPI_DMA_IRQ_EN_AFIFO_EMPTY_SHIFT)
++#define DPI_DMA_IRQ_EN_TE_SHIFT			      4
++#define DPI_DMA_IRQ_EN_TE_MASK			      BIT(DPI_DMA_IRQ_EN_TE_SHIFT)
++#define DPI_DMA_IRQ_EN_ERROR_SHIFT		      5
++#define DPI_DMA_IRQ_EN_ERROR_MASK		      BIT(DPI_DMA_IRQ_EN_ERROR_SHIFT)
++#define DPI_DMA_IRQ_EN_MATCH_SHIFT		      6
++#define DPI_DMA_IRQ_EN_MATCH_MASK		      BIT(DPI_DMA_IRQ_EN_MATCH_SHIFT)
++#define DPI_DMA_IRQ_EN_MATCH_LINE_SHIFT		      16
++#define DPI_DMA_IRQ_EN_MATCH_LINE_MASK		      (0xFFF << DPI_DMA_IRQ_EN_MATCH_LINE_SHIFT)
++
++// IRQ_FLAGS
++#define DPI_DMA_IRQ_FLAGS			      0x08
++#define DPI_DMA_IRQ_FLAGS_DMA_READY_SHIFT	      0
++#define DPI_DMA_IRQ_FLAGS_DMA_READY_MASK	      BIT(DPI_DMA_IRQ_FLAGS_DMA_READY_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_UNDERFLOW_SHIFT	      1
++#define DPI_DMA_IRQ_FLAGS_UNDERFLOW_MASK	      BIT(DPI_DMA_IRQ_FLAGS_UNDERFLOW_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_FRAME_START_SHIFT	      2
++#define DPI_DMA_IRQ_FLAGS_FRAME_START_MASK	      BIT(DPI_DMA_IRQ_FLAGS_FRAME_START_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_AFIFO_EMPTY_SHIFT	      3
++#define DPI_DMA_IRQ_FLAGS_AFIFO_EMPTY_MASK	      BIT(DPI_DMA_IRQ_FLAGS_AFIFO_EMPTY_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_TE_SHIFT		      4
++#define DPI_DMA_IRQ_FLAGS_TE_MASK		      BIT(DPI_DMA_IRQ_FLAGS_TE_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_ERROR_SHIFT		      5
++#define DPI_DMA_IRQ_FLAGS_ERROR_MASK		      BIT(DPI_DMA_IRQ_FLAGS_ERROR_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_MATCH_SHIFT		      6
++#define DPI_DMA_IRQ_FLAGS_MATCH_MASK		      BIT(DPI_DMA_IRQ_FLAGS_MATCH_SHIFT)
++
++// QOS
++#define DPI_DMA_QOS				      0xC
++#define DPI_DMA_QOS_DQOS_SHIFT			      0
++#define DPI_DMA_QOS_DQOS_MASK			      (0xF << DPI_DMA_QOS_DQOS_SHIFT)
++#define DPI_DMA_QOS_ULEV_SHIFT			      4
++#define DPI_DMA_QOS_ULEV_MASK			      (0xF << DPI_DMA_QOS_ULEV_SHIFT)
++#define DPI_DMA_QOS_UQOS_SHIFT			      8
++#define DPI_DMA_QOS_UQOS_MASK			      (0xF << DPI_DMA_QOS_UQOS_SHIFT)
++#define DPI_DMA_QOS_LLEV_SHIFT			      12
++#define DPI_DMA_QOS_LLEV_MASK			      (0xF << DPI_DMA_QOS_LLEV_SHIFT)
++#define DPI_DMA_QOS_LQOS_SHIFT			      16
++#define DPI_DMA_QOS_LQOS_MASK			      (0xF << DPI_DMA_QOS_LQOS_SHIFT)
++
++// Panics
++#define DPI_DMA_PANICS				     0x38
++#define DPI_DMA_PANICS_UPPER_COUNT_SHIFT	     0
++#define DPI_DMA_PANICS_UPPER_COUNT_MASK		     \
++				(0x0000FFFF << DPI_DMA_PANICS_UPPER_COUNT_SHIFT)
++#define DPI_DMA_PANICS_LOWER_COUNT_SHIFT	     16
++#define DPI_DMA_PANICS_LOWER_COUNT_MASK		     \
++				(0x0000FFFF << DPI_DMA_PANICS_LOWER_COUNT_SHIFT)
++
++// DMA Address Lower:
++#define DPI_DMA_DMA_ADDR_L			     0x10
++
++// DMA Address Upper:
++#define DPI_DMA_DMA_ADDR_H			     0x40
++
++// DMA stride
++#define DPI_DMA_DMA_STRIDE			     0x14
++
++// Visible Area
++#define DPI_DMA_VISIBLE_AREA			     0x18
++#define DPI_DMA_VISIBLE_AREA_ROWSM1_SHIFT     0
++#define DPI_DMA_VISIBLE_AREA_ROWSM1_MASK     (0x0FFF << DPI_DMA_VISIBLE_AREA_ROWSM1_SHIFT)
++#define DPI_DMA_VISIBLE_AREA_COLSM1_SHIFT    16
++#define DPI_DMA_VISIBLE_AREA_COLSM1_MASK     (0x0FFF << DPI_DMA_VISIBLE_AREA_COLSM1_SHIFT)
++
++// Sync width
++#define DPI_DMA_SYNC_WIDTH   0x1C
++#define DPI_DMA_SYNC_WIDTH_ROWSM1_SHIFT	 0
++#define DPI_DMA_SYNC_WIDTH_ROWSM1_MASK	 (0x0FFF << DPI_DMA_SYNC_WIDTH_ROWSM1_SHIFT)
++#define DPI_DMA_SYNC_WIDTH_COLSM1_SHIFT	 16
++#define DPI_DMA_SYNC_WIDTH_COLSM1_MASK	 (0x0FFF << DPI_DMA_SYNC_WIDTH_COLSM1_SHIFT)
++
++// Back porch
++#define DPI_DMA_BACK_PORCH   0x20
++#define DPI_DMA_BACK_PORCH_ROWSM1_SHIFT	 0
++#define DPI_DMA_BACK_PORCH_ROWSM1_MASK	 (0x0FFF << DPI_DMA_BACK_PORCH_ROWSM1_SHIFT)
++#define DPI_DMA_BACK_PORCH_COLSM1_SHIFT	 16
++#define DPI_DMA_BACK_PORCH_COLSM1_MASK	 (0x0FFF << DPI_DMA_BACK_PORCH_COLSM1_SHIFT)
++
++// Front porch
++#define DPI_DMA_FRONT_PORCH  0x24
++#define DPI_DMA_FRONT_PORCH_ROWSM1_SHIFT     0
++#define DPI_DMA_FRONT_PORCH_ROWSM1_MASK	 (0x0FFF << DPI_DMA_FRONT_PORCH_ROWSM1_SHIFT)
++#define DPI_DMA_FRONT_PORCH_COLSM1_SHIFT     16
++#define DPI_DMA_FRONT_PORCH_COLSM1_MASK	 (0x0FFF << DPI_DMA_FRONT_PORCH_COLSM1_SHIFT)
++
++// Input masks
++#define DPI_DMA_IMASK	 0x2C
++#define DPI_DMA_IMASK_R_SHIFT	 0
++#define DPI_DMA_IMASK_R_MASK	 (0x3FF << DPI_DMA_IMASK_R_SHIFT)
++#define DPI_DMA_IMASK_G_SHIFT	 10
++#define DPI_DMA_IMASK_G_MASK	 (0x3FF << DPI_DMA_IMASK_G_SHIFT)
++#define DPI_DMA_IMASK_B_SHIFT	 20
++#define DPI_DMA_IMASK_B_MASK	 (0x3FF << DPI_DMA_IMASK_B_SHIFT)
++
++// Output Masks
++#define DPI_DMA_OMASK	 0x30
++#define DPI_DMA_OMASK_R_SHIFT	 0
++#define DPI_DMA_OMASK_R_MASK	 (0x3FF << DPI_DMA_OMASK_R_SHIFT)
++#define DPI_DMA_OMASK_G_SHIFT	 10
++#define DPI_DMA_OMASK_G_MASK	 (0x3FF << DPI_DMA_OMASK_G_SHIFT)
++#define DPI_DMA_OMASK_B_SHIFT	 20
++#define DPI_DMA_OMASK_B_MASK	 (0x3FF << DPI_DMA_OMASK_B_SHIFT)
++
++// Shifts
++#define DPI_DMA_SHIFT	 0x28
++#define DPI_DMA_SHIFT_IR_SHIFT	 0
++#define DPI_DMA_SHIFT_IR_MASK	 (0x1F << DPI_DMA_SHIFT_IR_SHIFT)
++#define DPI_DMA_SHIFT_IG_SHIFT	 5
++#define DPI_DMA_SHIFT_IG_MASK	 (0x1F << DPI_DMA_SHIFT_IG_SHIFT)
++#define DPI_DMA_SHIFT_IB_SHIFT	 10
++#define DPI_DMA_SHIFT_IB_MASK	 (0x1F << DPI_DMA_SHIFT_IB_SHIFT)
++#define DPI_DMA_SHIFT_OR_SHIFT	 15
++#define DPI_DMA_SHIFT_OR_MASK	 (0x1F << DPI_DMA_SHIFT_OR_SHIFT)
++#define DPI_DMA_SHIFT_OG_SHIFT	 20
++#define DPI_DMA_SHIFT_OG_MASK	 (0x1F << DPI_DMA_SHIFT_OG_SHIFT)
++#define DPI_DMA_SHIFT_OB_SHIFT	 25
++#define DPI_DMA_SHIFT_OB_MASK	 (0x1F << DPI_DMA_SHIFT_OB_SHIFT)
++
++// Scaling
++#define DPI_DMA_RGBSZ	 0x34
++#define DPI_DMA_RGBSZ_BPP_SHIFT	 16
++#define DPI_DMA_RGBSZ_BPP_MASK	 (0x3 << DPI_DMA_RGBSZ_BPP_SHIFT)
++#define DPI_DMA_RGBSZ_R_SHIFT	 0
++#define DPI_DMA_RGBSZ_R_MASK	 (0xF << DPI_DMA_RGBSZ_R_SHIFT)
++#define DPI_DMA_RGBSZ_G_SHIFT	 4
++#define DPI_DMA_RGBSZ_G_MASK	 (0xF << DPI_DMA_RGBSZ_G_SHIFT)
++#define DPI_DMA_RGBSZ_B_SHIFT	 8
++#define DPI_DMA_RGBSZ_B_MASK	 (0xF << DPI_DMA_RGBSZ_B_SHIFT)
++
++// Status
++#define DPI_DMA_STATUS  0x3c
++
++#define BITS(field, val) (((val) << (field ## _SHIFT)) & (field ## _MASK))
++
++static unsigned int rp1dsi_dma_read(struct rp1_dsi *dsi, unsigned int reg)
++{
++	void __iomem *addr = dsi->hw_base[RP1DSI_HW_BLOCK_DMA] + reg;
++
++	return readl(addr);
++}
++
++static void rp1dsi_dma_write(struct rp1_dsi *dsi, unsigned int reg, unsigned int val)
++{
++	void __iomem *addr = dsi->hw_base[RP1DSI_HW_BLOCK_DMA] + reg;
++
++	writel(val, addr);
++}
++
++int rp1dsi_dma_busy(struct rp1_dsi *dsi)
++{
++	return (rp1dsi_dma_read(dsi, DPI_DMA_STATUS) & 0xF8F) ? 1 : 0;
++}
++
++/* Table of supported input (in-memory/DMA) pixel formats. */
++struct rp1dsi_ipixfmt {
++	u32 format; /* DRM format code                           */
++	u32 mask;   /* RGB masks (10 bits each, left justified)  */
++	u32 shift;  /* RGB MSB positions in the memory word      */
++	u32 rgbsz;  /* Shifts used for scaling; also (BPP/8-1)   */
++};
++
++#define IMASK_RGB(r, g, b)	(BITS(DPI_DMA_IMASK_R, r) | \
++				 BITS(DPI_DMA_IMASK_G, g) |  \
++				 BITS(DPI_DMA_IMASK_B, b))
++#define ISHIFT_RGB(r, g, b)	(BITS(DPI_DMA_SHIFT_IR, r) | \
++				 BITS(DPI_DMA_SHIFT_IG, g) | \
++				 BITS(DPI_DMA_SHIFT_IB, b))
++
++static const struct rp1dsi_ipixfmt my_formats[] = {
++	{
++		.format = DRM_FORMAT_XRGB8888,
++		.mask   = IMASK_RGB(0x3fc, 0x3fc, 0x3fc),
++		.shift  = ISHIFT_RGB(23, 15, 7),
++		.rgbsz  = BITS(DPI_DMA_RGBSZ_BPP, 3),
++	},
++	{
++		.format = DRM_FORMAT_XBGR8888,
++		.mask   = IMASK_RGB(0x3fc, 0x3fc, 0x3fc),
++		.shift  = ISHIFT_RGB(7, 15, 23),
++		.rgbsz  = BITS(DPI_DMA_RGBSZ_BPP, 3),
++	},
++	{
++		.format = DRM_FORMAT_RGB888,
++		.mask   = IMASK_RGB(0x3fc, 0x3fc, 0x3fc),
++		.shift  = ISHIFT_RGB(23, 15, 7),
++		.rgbsz  = BITS(DPI_DMA_RGBSZ_BPP, 2),
++	},
++	{
++		.format = DRM_FORMAT_BGR888,
++		.mask   = IMASK_RGB(0x3fc, 0x3fc, 0x3fc),
++		.shift  = ISHIFT_RGB(7, 15, 23),
++		.rgbsz  = BITS(DPI_DMA_RGBSZ_BPP, 2),
++	},
++	{
++		.format = DRM_FORMAT_RGB565,
++		.mask   = IMASK_RGB(0x3e0, 0x3f0, 0x3e0),
++		.shift  = ISHIFT_RGB(15, 10, 4),
++		.rgbsz  = BITS(DPI_DMA_RGBSZ_R, 5) | BITS(DPI_DMA_RGBSZ_G, 6) |
++			  BITS(DPI_DMA_RGBSZ_B, 5) | BITS(DPI_DMA_RGBSZ_BPP, 1),
++	}
++};
++
++/* Choose the internal on-the-bus DPI format as expected by DSI Host. */
++static u32 get_omask_oshift(enum mipi_dsi_pixel_format fmt, u32 *oshift)
++{
++	switch (fmt) {
++	case MIPI_DSI_FMT_RGB565:
++		*oshift = BITS(DPI_DMA_SHIFT_OR, 15) |
++			  BITS(DPI_DMA_SHIFT_OG, 10) |
++			  BITS(DPI_DMA_SHIFT_OB, 4);
++		return BITS(DPI_DMA_OMASK_R, 0x3e0) |
++		       BITS(DPI_DMA_OMASK_G, 0x3f0) |
++		       BITS(DPI_DMA_OMASK_B, 0x3e0);
++	case MIPI_DSI_FMT_RGB666_PACKED:
++		*oshift = BITS(DPI_DMA_SHIFT_OR, 17) |
++			  BITS(DPI_DMA_SHIFT_OG, 11) |
++			  BITS(DPI_DMA_SHIFT_OB, 5);
++		return BITS(DPI_DMA_OMASK_R, 0x3f0) |
++		       BITS(DPI_DMA_OMASK_G, 0x3f0) |
++		       BITS(DPI_DMA_OMASK_B, 0x3f0);
++	case MIPI_DSI_FMT_RGB666:
++		*oshift = BITS(DPI_DMA_SHIFT_OR, 21) |
++			  BITS(DPI_DMA_SHIFT_OG, 13) |
++			  BITS(DPI_DMA_SHIFT_OB, 5);
++		return BITS(DPI_DMA_OMASK_R, 0x3f0) |
++		       BITS(DPI_DMA_OMASK_G, 0x3f0) |
++		       BITS(DPI_DMA_OMASK_B, 0x3f0);
++	default:
++		*oshift = BITS(DPI_DMA_SHIFT_OR, 23) |
++			  BITS(DPI_DMA_SHIFT_OG, 15) |
++			  BITS(DPI_DMA_SHIFT_OB, 7);
++		return BITS(DPI_DMA_OMASK_R, 0x3fc) |
++		       BITS(DPI_DMA_OMASK_G, 0x3fc) |
++		       BITS(DPI_DMA_OMASK_B, 0x3fc);
++	}
++}
++
++void rp1dsi_dma_setup(struct rp1_dsi *dsi,
++		      u32 in_format, enum mipi_dsi_pixel_format out_format,
++		     struct drm_display_mode const *mode)
++{
++	u32 oshift;
++	int i;
++
++	/*
++	 * Configure all DSI/DPI/DMA block registers, except base address.
++	 * DMA will not actually start until a FB base address is specified
++	 * using rp1dsi_dma_update().
++	 */
++
++	rp1dsi_dma_write(dsi, DPI_DMA_VISIBLE_AREA,
++			 BITS(DPI_DMA_VISIBLE_AREA_ROWSM1, mode->vdisplay - 1) |
++			 BITS(DPI_DMA_VISIBLE_AREA_COLSM1, mode->hdisplay - 1));
++
++	rp1dsi_dma_write(dsi, DPI_DMA_SYNC_WIDTH,
++			 BITS(DPI_DMA_SYNC_WIDTH_ROWSM1, mode->vsync_end - mode->vsync_start - 1) |
++			 BITS(DPI_DMA_SYNC_WIDTH_COLSM1, mode->hsync_end - mode->hsync_start - 1));
++
++	/* In the DPIDMA registers, "back porch" time includes sync width */
++	rp1dsi_dma_write(dsi, DPI_DMA_BACK_PORCH,
++			 BITS(DPI_DMA_BACK_PORCH_ROWSM1, mode->vtotal - mode->vsync_start - 1) |
++			 BITS(DPI_DMA_BACK_PORCH_COLSM1, mode->htotal - mode->hsync_start - 1));
++
++	rp1dsi_dma_write(dsi, DPI_DMA_FRONT_PORCH,
++			 BITS(DPI_DMA_FRONT_PORCH_ROWSM1, mode->vsync_start - mode->vdisplay - 1) |
++			 BITS(DPI_DMA_FRONT_PORCH_COLSM1, mode->hsync_start - mode->hdisplay - 1));
++
++	/* Input to output pixel format conversion */
++	for (i = 0; i < ARRAY_SIZE(my_formats); ++i) {
++		if (my_formats[i].format == in_format)
++			break;
++	}
++	if (i >= ARRAY_SIZE(my_formats)) {
++		drm_err(dsi->drm, "%s: bad input format\n", __func__);
++		i = 0;
++	}
++	rp1dsi_dma_write(dsi, DPI_DMA_IMASK, my_formats[i].mask);
++	rp1dsi_dma_write(dsi, DPI_DMA_OMASK, get_omask_oshift(out_format, &oshift));
++	rp1dsi_dma_write(dsi, DPI_DMA_SHIFT, my_formats[i].shift | oshift);
++	if (out_format == MIPI_DSI_FMT_RGB888)
++		rp1dsi_dma_write(dsi, DPI_DMA_RGBSZ, my_formats[i].rgbsz);
++	else
++		rp1dsi_dma_write(dsi, DPI_DMA_RGBSZ, my_formats[i].rgbsz & DPI_DMA_RGBSZ_BPP_MASK);
++
++	rp1dsi_dma_write(dsi, DPI_DMA_QOS,
++			 BITS(DPI_DMA_QOS_DQOS, 0x0) |
++			 BITS(DPI_DMA_QOS_ULEV, 0xb) |
++			 BITS(DPI_DMA_QOS_UQOS, 0x2) |
++			 BITS(DPI_DMA_QOS_LLEV, 0x8) |
++			 BITS(DPI_DMA_QOS_LQOS, 0x7));
++
++	rp1dsi_dma_write(dsi, DPI_DMA_IRQ_FLAGS, -1);
++	rp1dsi_dma_vblank_ctrl(dsi, 1);
++
++	i = rp1dsi_dma_busy(dsi);
++	if (i)
++		drm_err(dsi->drm, "RP1DSI: Unexpectedly busy at start!");
++
++	rp1dsi_dma_write(dsi, DPI_DMA_CONTROL,
++			 BITS(DPI_DMA_CONTROL_ARM, (i == 0)) |
++			 BITS(DPI_DMA_CONTROL_AUTO_REPEAT, 1) |
++			 BITS(DPI_DMA_CONTROL_HIGH_WATER, 448) |
++			 BITS(DPI_DMA_CONTROL_DEN_POL, 0) |
++			 BITS(DPI_DMA_CONTROL_HSYNC_POL, 0) |
++			 BITS(DPI_DMA_CONTROL_VSYNC_POL, 0) |
++			 BITS(DPI_DMA_CONTROL_COLORM, 0) |
++			 BITS(DPI_DMA_CONTROL_SHUTDN, 0) |
++			 BITS(DPI_DMA_CONTROL_HBP_EN, 1) |
++			 BITS(DPI_DMA_CONTROL_HFP_EN, 1) |
++			 BITS(DPI_DMA_CONTROL_VBP_EN, 1) |
++			 BITS(DPI_DMA_CONTROL_VFP_EN, 1) |
++			 BITS(DPI_DMA_CONTROL_HSYNC_EN, 1) |
++			 BITS(DPI_DMA_CONTROL_VSYNC_EN, 1));
++}
++
++void rp1dsi_dma_update(struct rp1_dsi *dsi, dma_addr_t addr, u32 offset, u32 stride)
++{
++	/*
++	 * Update STRIDE, DMAH and DMAL only. When called after rp1dsi_dma_setup(),
++	 * DMA starts immediately; if already running, the buffer will flip at
++	 * the next vertical sync event.
++	 */
++	u64 a = addr + offset;
++
++	rp1dsi_dma_write(dsi, DPI_DMA_DMA_STRIDE, stride);
++	rp1dsi_dma_write(dsi, DPI_DMA_DMA_ADDR_H, a >> 32);
++	rp1dsi_dma_write(dsi, DPI_DMA_DMA_ADDR_L, a & 0xFFFFFFFFu);
++}
++
++void rp1dsi_dma_stop(struct rp1_dsi *dsi)
++{
++	/*
++	 * Stop DMA by turning off the Auto-Repeat flag, and wait up to 100ms for
++	 * the current and any queued frame to end. "Force drain" flags are not used,
++	 * as they seem to prevent DMA from re-starting properly; it's safer to wait.
++	 */
++	u32 ctrl;
++
++	reinit_completion(&dsi->finished);
++	ctrl = rp1dsi_dma_read(dsi, DPI_DMA_CONTROL);
++	ctrl &= ~(DPI_DMA_CONTROL_ARM_MASK | DPI_DMA_CONTROL_AUTO_REPEAT_MASK);
++	rp1dsi_dma_write(dsi, DPI_DMA_CONTROL, ctrl);
++	if (!wait_for_completion_timeout(&dsi->finished, HZ / 10))
++		drm_err(dsi->drm, "%s: timed out waiting for idle\n", __func__);
++	rp1dsi_dma_write(dsi, DPI_DMA_IRQ_EN, 0);
++}
++
++void rp1dsi_dma_vblank_ctrl(struct rp1_dsi *dsi, int enable)
++{
++	rp1dsi_dma_write(dsi, DPI_DMA_IRQ_EN,
++			 BITS(DPI_DMA_IRQ_EN_AFIFO_EMPTY, 1)      |
++			 BITS(DPI_DMA_IRQ_EN_UNDERFLOW, 1)        |
++			 BITS(DPI_DMA_IRQ_EN_DMA_READY, !!enable) |
++			 BITS(DPI_DMA_IRQ_EN_MATCH_LINE, 4095));
++}
++
++irqreturn_t rp1dsi_dma_isr(int irq, void *dev)
++{
++	struct rp1_dsi *dsi = dev;
++	u32 u = rp1dsi_dma_read(dsi, DPI_DMA_IRQ_FLAGS);
++
++	if (u) {
++		rp1dsi_dma_write(dsi, DPI_DMA_IRQ_FLAGS, u);
++		if (dsi) {
++			if (u & DPI_DMA_IRQ_FLAGS_UNDERFLOW_MASK)
++				drm_err_ratelimited(dsi->drm,
++						    "Underflow! (panics=0x%08x)\n",
++						    rp1dsi_dma_read(dsi, DPI_DMA_PANICS));
++			if (u & DPI_DMA_IRQ_FLAGS_DMA_READY_MASK)
++				drm_crtc_handle_vblank(&dsi->pipe.crtc);
++			if (u & DPI_DMA_IRQ_FLAGS_AFIFO_EMPTY_MASK)
++				complete(&dsi->finished);
++		}
++	}
++	return u ? IRQ_HANDLED : IRQ_NONE;
++}
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dsi/rp1_dsi_dsi.c
+@@ -0,0 +1,1504 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for DSI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/delay.h>
++#include <linux/errno.h>
++#include <linux/platform_device.h>
++#include <linux/rp1_platform.h>
++#include "drm/drm_print.h"
++
++#include "rp1_dsi.h"
++
++/* ------------------------------- Synopsis DSI ------------------------ */
++#define     DSI_VERSION_CFG                       0x000
++#define     DSI_PWR_UP                            0x004
++#define     DSI_CLKMGR_CFG                        0x008
++#define     DSI_DPI_VCID                          0x00C
++#define     DSI_DPI_COLOR_CODING                  0x010
++#define     DSI_DPI_CFG_POL                       0x014
++#define     DSI_DPI_LP_CMD_TIM                    0x018
++#define     DSI_DBI_VCID                          0x01C
++#define     DSI_DBI_CFG                           0x020
++#define     DSI_DBI_PARTITIONING_EN               0x024
++#define     DSI_DBI_CMDSIZE                       0x028
++#define     DSI_PCKHDL_CFG                        0x02C
++#define     DSI_GEN_VCID                          0x030
++#define     DSI_MODE_CFG                          0x034
++#define     DSI_VID_MODE_CFG                      0x038
++#define     DSI_VID_PKT_SIZE                      0x03C
++#define     DSI_VID_NUM_CHUNKS                    0x040
++#define     DSI_VID_NULL_SIZE                     0x044
++#define     DSI_VID_HSA_TIME                      0x048
++#define     DSI_VID_HBP_TIME                      0x04C
++#define     DSI_VID_HLINE_TIME                    0x050
++#define     DSI_VID_VSA_LINES                     0x054
++#define     DSI_VID_VBP_LINES                     0x058
++#define     DSI_VID_VFP_LINES                     0x05C
++#define     DSI_VID_VACTIVE_LINES                 0x060
++#define     DSI_EDPI_CMD_SIZE                     0x064
++#define     DSI_CMD_MODE_CFG                      0x068
++#define     DSI_GEN_HDR                           0x06C
++#define     DSI_GEN_PLD_DATA                      0x070
++#define     DSI_CMD_PKT_STATUS                    0x074
++#define     DSI_TO_CNT_CFG                        0x078
++#define     DSI_HS_RD_TO_CNT                      0x07C
++#define     DSI_LP_RD_TO_CNT                      0x080
++#define     DSI_HS_WR_TO_CNT                      0x084
++#define     DSI_LP_WR_TO_CNT                      0x088
++#define     DSI_BTA_TO_CNT                        0x08C
++#define     DSI_SDF_3D                            0x090
++#define     DSI_LPCLK_CTRL                        0x094
++#define     DSI_PHY_TMR_LPCLK_CFG                 0x098
++#define     DSI_PHY_TMR_HS2LP_LSB       16
++#define     DSI_PHY_TMR_LP2HS_LSB       0
++#define     DSI_PHY_TMR_CFG                       0x09C
++#define     DSI_PHY_TMR_RD_CFG                    0x0F4
++#define     DSI_PHYRSTZ                           0x0A0
++#define     DSI_PHY_IF_CFG                        0x0A4
++#define     DSI_PHY_ULPS_CTRL                     0x0A8
++#define     DSI_PHY_TX_TRIGGERS                   0x0AC
++#define     DSI_PHY_STATUS                        0x0B0
++
++#define     DSI_PHY_TST_CTRL0                     0x0B4
++#define     DSI_PHY_TST_CTRL1                     0x0B8
++#define     DSI_INT_ST0                           0x0BC
++#define     DSI_INT_ST1                           0x0C0
++#define     DSI_INT_MASK0_CFG                     0x0C4
++#define     DSI_INT_MASK1_CFG                     0x0C8
++#define     DSI_PHY_CAL                           0x0CC
++#define     DSI_HEXP_NPKT_CLR                     0x104
++#define     DSI_HEXP_NPKT_SIZE                    0x108
++#define     DSI_VID_SHADOW_CTRL                   0x100
++
++#define     DSI_DPI_VCID_ACT                      0x10C
++#define     DSI_DPI_COLOR_CODING_ACT              0x110
++#define     DSI_DPI_LP_CMD_TIM_ACT                0x118
++#define     DSI_VID_MODE_CFG_ACT                  0x138
++#define     DSI_VID_PKT_SIZE_ACT                  0x13C
++#define     DSI_VID_NUM_CHUNKS_ACT                0x140
++#define     DSI_VID_NULL_SIZE_ACT                 0x144
++#define     DSI_VID_HSA_TIME_ACT                  0x148
++#define     DSI_VID_HBP_TIME_ACT                  0x14C
++#define     DSI_VID_HLINE_TIME_ACT                0x150
++#define     DSI_VID_VSA_LINES_ACT                 0x154
++#define     DSI_VID_VBP_LINES_ACT                 0x158
++#define     DSI_VID_VFP_LINES_ACT                 0x15C
++#define     DSI_VID_VACTIVE_LINES_ACT             0x160
++#define     DSI_SDF_3D_CFG_ACT                    0x190
++
++#define     DSI_INT_FORCE0                        0x0D8
++#define     DSI_INT_FORCE1                        0x0DC
++
++#define     DSI_AUTO_ULPS_MODE                    0x0E0
++#define     DSI_AUTO_ULPS_ENTRY_DELAY             0x0E4
++#define     DSI_AUTO_ULPS_WAKEUP_TIME             0x0E8
++#define     DSI_EDPI_ADV_FEATURES                 0x0EC
++
++#define     DSI_DSC_PARAMETER                     0x0F0
++
++/* And some bitfield definitions */
++
++#define DPHY_PWR_UP_SHUTDOWNZ_LSB 0
++#define DPHY_PWR_UP_SHUTDOWNZ_BITS BIT(DPHY_PWR_UP_SHUTDOWNZ_LSB)
++
++#define DPHY_CTRL0_PHY_TESTCLK_LSB 1
++#define DPHY_CTRL0_PHY_TESTCLK_BITS BIT(DPHY_CTRL0_PHY_TESTCLK_LSB)
++#define DPHY_CTRL0_PHY_TESTCLR_LSB 0
++#define DPHY_CTRL0_PHY_TESTCLR_BITS BIT(DPHY_CTRL0_PHY_TESTCLR_LSB)
++
++#define DPHY_CTRL1_PHY_TESTDIN_LSB  0
++#define DPHY_CTRL1_PHY_TESTDIN_BITS  (0xff << DPHY_CTRL1_PHY_TESTDIN_LSB)
++#define DPHY_CTRL1_PHY_TESTDOUT_LSB 8
++#define DPHY_CTRL1_PHY_TESTDOUT_BITS (0xff << DPHY_CTRL1_PHY_TESTDOUT_LSB)
++#define DPHY_CTRL1_PHY_TESTEN_LSB 16
++#define DPHY_CTRL1_PHY_TESTEN_BITS BIT(DPHY_CTRL1_PHY_TESTEN_LSB)
++
++#define DSI_PHYRSTZ_SHUTDOWNZ_LSB  0
++#define DSI_PHYRSTZ_SHUTDOWNZ_BITS BIT(DSI_PHYRSTZ_SHUTDOWNZ_LSB)
++#define DSI_PHYRSTZ_RSTZ_LSB  1
++#define DSI_PHYRSTZ_RSTZ_BITS BIT(DSI_PHYRSTZ_RSTZ_LSB)
++#define DSI_PHYRSTZ_ENABLECLK_LSB 2
++#define DSI_PHYRSTZ_ENABLECLK_BITS BIT(DSI_PHYRSTZ_ENABLECLK_LSB)
++#define DSI_PHYRSTZ_FORCEPLL_LSB 3
++#define DSI_PHYRSTZ_FORCEPLL_BITS  BIT(DSI_PHYRSTZ_FORCEPLL_LSB)
++
++#define DPHY_HS_RX_CTRL_LANE0_OFFSET  0x44
++#define DPHY_PLL_INPUT_DIV_OFFSET 0x17
++#define DPHY_PLL_LOOP_DIV_OFFSET 0x18
++#define DPHY_PLL_DIV_CTRL_OFFSET 0x19
++
++#define DPHY_PLL_BIAS_OFFSET 0x10
++#define DPHY_PLL_BIAS_VCO_RANGE_LSB 3
++#define DPHY_PLL_BIAS_USE_PROGRAMMED_VCO_RANGE BIT(7)
++
++#define DPHY_PLL_CHARGE_PUMP_OFFSET 0x11
++#define DPHY_PLL_LPF_OFFSET 0x12
++
++#define DSI_WRITE(reg, val)  writel((val),  dsi->hw_base[RP1DSI_HW_BLOCK_DSI] + (reg))
++#define DSI_READ(reg)        readl(dsi->hw_base[RP1DSI_HW_BLOCK_DSI] + (reg))
++
++// ================================================================================
++// Register block : RPI_MIPICFG
++// Version        : 1
++// Bus type       : apb
++// Description    : Register block to control mipi DPHY
++// ================================================================================
++#define RPI_MIPICFG_REGS_RWTYPE_MSB 13
++#define RPI_MIPICFG_REGS_RWTYPE_LSB 12
++// ================================================================================
++// Register    : RPI_MIPICFG_CLK2FC
++// JTAG access : synchronous
++// Description : None
++#define RPI_MIPICFG_CLK2FC_OFFSET 0x00000000
++#define RPI_MIPICFG_CLK2FC_BITS   0x00000007
++#define RPI_MIPICFG_CLK2FC_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_CLK2FC_SEL
++// Description : select a clock to be sent to the frequency counter
++//               7 = none
++//               6 = none
++//               5 = none
++//               4 = rxbyteclkhs (187.5MHz)
++//               3 = rxclkesc0 (20MHz)
++//               2 = txbyteclkhs (187.5MHz)
++//               1 = txclkesc (125MHz)
++//               0 = none
++#define RPI_MIPICFG_CLK2FC_SEL_RESET  0x0
++#define RPI_MIPICFG_CLK2FC_SEL_BITS   0x00000007
++#define RPI_MIPICFG_CLK2FC_SEL_MSB    2
++#define RPI_MIPICFG_CLK2FC_SEL_LSB    0
++#define RPI_MIPICFG_CLK2FC_SEL_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_CFG
++// JTAG access : asynchronous
++// Description : Top level configuration
++#define RPI_MIPICFG_CFG_OFFSET 0x00000004
++#define RPI_MIPICFG_CFG_BITS   0x00000111
++#define RPI_MIPICFG_CFG_RESET  0x00000001
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_CFG_DPIUPDATE
++// Description : Indicate the DSI block that the next frame will have a new video configuration
++#define RPI_MIPICFG_CFG_DPIUPDATE_RESET  0x0
++#define RPI_MIPICFG_CFG_DPIUPDATE_BITS   0x00000100
++#define RPI_MIPICFG_CFG_DPIUPDATE_MSB    8
++#define RPI_MIPICFG_CFG_DPIUPDATE_LSB    8
++#define RPI_MIPICFG_CFG_DPIUPDATE_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_CFG_SEL_TE_EXT
++// Description : Select the TE source: 1 - ext, 0 - int
++#define RPI_MIPICFG_CFG_SEL_TE_EXT_RESET  0x0
++#define RPI_MIPICFG_CFG_SEL_TE_EXT_BITS   0x00000010
++#define RPI_MIPICFG_CFG_SEL_TE_EXT_MSB    4
++#define RPI_MIPICFG_CFG_SEL_TE_EXT_LSB    4
++#define RPI_MIPICFG_CFG_SEL_TE_EXT_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_CFG_SEL_CSI_DSI_N
++// Description : Select PHY direction: input to CSI, output from DSI. CSI 1 DSI 0
++#define RPI_MIPICFG_CFG_SEL_CSI_DSI_N_RESET  0x1
++#define RPI_MIPICFG_CFG_SEL_CSI_DSI_N_BITS   0x00000001
++#define RPI_MIPICFG_CFG_SEL_CSI_DSI_N_MSB    0
++#define RPI_MIPICFG_CFG_SEL_CSI_DSI_N_LSB    0
++#define RPI_MIPICFG_CFG_SEL_CSI_DSI_N_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_TE
++// JTAG access : synchronous
++// Description : Tearing effect processing
++#define RPI_MIPICFG_TE_OFFSET 0x00000008
++#define RPI_MIPICFG_TE_BITS   0x10ffffff
++#define RPI_MIPICFG_TE_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_TE_ARM
++// Description : Tearing effect arm
++#define RPI_MIPICFG_TE_ARM_RESET  0x0
++#define RPI_MIPICFG_TE_ARM_BITS   0x10000000
++#define RPI_MIPICFG_TE_ARM_MSB    28
++#define RPI_MIPICFG_TE_ARM_LSB    28
++#define RPI_MIPICFG_TE_ARM_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_TE_HALT_CYC
++// Description : When arm pulse has been seen, wait for te; then halt the dpi block
++//		 for this many clk_dpi cycles
++#define RPI_MIPICFG_TE_HALT_CYC_RESET  0x000000
++#define RPI_MIPICFG_TE_HALT_CYC_BITS   0x00ffffff
++#define RPI_MIPICFG_TE_HALT_CYC_MSB    23
++#define RPI_MIPICFG_TE_HALT_CYC_LSB    0
++#define RPI_MIPICFG_TE_HALT_CYC_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_DPHY_MONITOR
++// JTAG access : asynchronous
++// Description : DPHY status monitors for analog DFT
++#define RPI_MIPICFG_DPHY_MONITOR_OFFSET 0x00000010
++#define RPI_MIPICFG_DPHY_MONITOR_BITS   0x00111fff
++#define RPI_MIPICFG_DPHY_MONITOR_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_MONITOR_LOCK
++// Description : None
++#define RPI_MIPICFG_DPHY_MONITOR_LOCK_RESET  0x0
++#define RPI_MIPICFG_DPHY_MONITOR_LOCK_BITS   0x00100000
++#define RPI_MIPICFG_DPHY_MONITOR_LOCK_MSB    20
++#define RPI_MIPICFG_DPHY_MONITOR_LOCK_LSB    20
++#define RPI_MIPICFG_DPHY_MONITOR_LOCK_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_MONITOR_BISTOK
++// Description : None
++#define RPI_MIPICFG_DPHY_MONITOR_BISTOK_RESET  0x0
++#define RPI_MIPICFG_DPHY_MONITOR_BISTOK_BITS   0x00010000
++#define RPI_MIPICFG_DPHY_MONITOR_BISTOK_MSB    16
++#define RPI_MIPICFG_DPHY_MONITOR_BISTOK_LSB    16
++#define RPI_MIPICFG_DPHY_MONITOR_BISTOK_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_MONITOR_STOPSTATECLK
++// Description : None
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATECLK_RESET  0x0
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATECLK_BITS   0x00001000
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATECLK_MSB    12
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATECLK_LSB    12
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATECLK_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_MONITOR_STOPSTATEDATA
++// Description : None
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATEDATA_RESET  0x0
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATEDATA_BITS   0x00000f00
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATEDATA_MSB    11
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATEDATA_LSB    8
++#define RPI_MIPICFG_DPHY_MONITOR_STOPSTATEDATA_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_MONITOR_TESTDOUT
++// Description : None
++#define RPI_MIPICFG_DPHY_MONITOR_TESTDOUT_RESET  0x00
++#define RPI_MIPICFG_DPHY_MONITOR_TESTDOUT_BITS   0x000000ff
++#define RPI_MIPICFG_DPHY_MONITOR_TESTDOUT_MSB    7
++#define RPI_MIPICFG_DPHY_MONITOR_TESTDOUT_LSB    0
++#define RPI_MIPICFG_DPHY_MONITOR_TESTDOUT_ACCESS "RO"
++// ================================================================================
++// Register    : RPI_MIPICFG_DPHY_CTRL_0
++// JTAG access : asynchronous
++// Description : DPHY control for analog DFT
++#define RPI_MIPICFG_DPHY_CTRL_0_OFFSET 0x00000014
++#define RPI_MIPICFG_DPHY_CTRL_0_BITS   0x0000003f
++#define RPI_MIPICFG_DPHY_CTRL_0_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_0_TEST_LPMODE
++// Description : When set in lpmode, TXCLKESC is driven from clk_vec(driven from clocks block)
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_LPMODE_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_LPMODE_BITS   0x00000020
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_LPMODE_MSB    5
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_LPMODE_LSB    5
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_LPMODE_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_0_TEST_ENA
++// Description : When set, drive the DPHY from the test registers
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_ENA_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_ENA_BITS   0x00000010
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_ENA_MSB    4
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_ENA_LSB    4
++#define RPI_MIPICFG_DPHY_CTRL_0_TEST_ENA_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_0_CFG_CLK_DIS
++// Description : When test_ena is set, disable cfg_clk
++#define RPI_MIPICFG_DPHY_CTRL_0_CFG_CLK_DIS_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_0_CFG_CLK_DIS_BITS   0x00000008
++#define RPI_MIPICFG_DPHY_CTRL_0_CFG_CLK_DIS_MSB    3
++#define RPI_MIPICFG_DPHY_CTRL_0_CFG_CLK_DIS_LSB    3
++#define RPI_MIPICFG_DPHY_CTRL_0_CFG_CLK_DIS_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_0_REFCLK_DIS
++// Description : When test_ena is set, disable refclk
++#define RPI_MIPICFG_DPHY_CTRL_0_REFCLK_DIS_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_0_REFCLK_DIS_BITS   0x00000004
++#define RPI_MIPICFG_DPHY_CTRL_0_REFCLK_DIS_MSB    2
++#define RPI_MIPICFG_DPHY_CTRL_0_REFCLK_DIS_LSB    2
++#define RPI_MIPICFG_DPHY_CTRL_0_REFCLK_DIS_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_0_TXCLKESC_DIS
++// Description : When test_ena is set, disable txclkesc
++#define RPI_MIPICFG_DPHY_CTRL_0_TXCLKESC_DIS_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_0_TXCLKESC_DIS_BITS   0x00000002
++#define RPI_MIPICFG_DPHY_CTRL_0_TXCLKESC_DIS_MSB    1
++#define RPI_MIPICFG_DPHY_CTRL_0_TXCLKESC_DIS_LSB    1
++#define RPI_MIPICFG_DPHY_CTRL_0_TXCLKESC_DIS_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_0_TXBYTECLKHS_DIS
++// Description : When test_ena is set, disable txbyteclkhs
++#define RPI_MIPICFG_DPHY_CTRL_0_TXBYTECLKHS_DIS_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_0_TXBYTECLKHS_DIS_BITS   0x00000001
++#define RPI_MIPICFG_DPHY_CTRL_0_TXBYTECLKHS_DIS_MSB    0
++#define RPI_MIPICFG_DPHY_CTRL_0_TXBYTECLKHS_DIS_LSB    0
++#define RPI_MIPICFG_DPHY_CTRL_0_TXBYTECLKHS_DIS_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_DPHY_CTRL_1
++// JTAG access : asynchronous
++// Description : DPHY control for analog DFT
++#define RPI_MIPICFG_DPHY_CTRL_1_OFFSET 0x00000018
++#define RPI_MIPICFG_DPHY_CTRL_1_BITS   0x7fffffff
++#define RPI_MIPICFG_DPHY_CTRL_1_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_FORCEPLL
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_FORCEPLL_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_FORCEPLL_BITS   0x40000000
++#define RPI_MIPICFG_DPHY_CTRL_1_FORCEPLL_MSB    30
++#define RPI_MIPICFG_DPHY_CTRL_1_FORCEPLL_LSB    30
++#define RPI_MIPICFG_DPHY_CTRL_1_FORCEPLL_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_SHUTDOWNZ
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_SHUTDOWNZ_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_SHUTDOWNZ_BITS   0x20000000
++#define RPI_MIPICFG_DPHY_CTRL_1_SHUTDOWNZ_MSB    29
++#define RPI_MIPICFG_DPHY_CTRL_1_SHUTDOWNZ_LSB    29
++#define RPI_MIPICFG_DPHY_CTRL_1_SHUTDOWNZ_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_RSTZ
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_RSTZ_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_RSTZ_BITS   0x10000000
++#define RPI_MIPICFG_DPHY_CTRL_1_RSTZ_MSB    28
++#define RPI_MIPICFG_DPHY_CTRL_1_RSTZ_LSB    28
++#define RPI_MIPICFG_DPHY_CTRL_1_RSTZ_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_MASTERSLAVEZ
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_MASTERSLAVEZ_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_MASTERSLAVEZ_BITS   0x08000000
++#define RPI_MIPICFG_DPHY_CTRL_1_MASTERSLAVEZ_MSB    27
++#define RPI_MIPICFG_DPHY_CTRL_1_MASTERSLAVEZ_LSB    27
++#define RPI_MIPICFG_DPHY_CTRL_1_MASTERSLAVEZ_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_BISTON
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_BISTON_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_BISTON_BITS   0x04000000
++#define RPI_MIPICFG_DPHY_CTRL_1_BISTON_MSB    26
++#define RPI_MIPICFG_DPHY_CTRL_1_BISTON_LSB    26
++#define RPI_MIPICFG_DPHY_CTRL_1_BISTON_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTHSCLK
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTHSCLK_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTHSCLK_BITS   0x02000000
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTHSCLK_MSB    25
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTHSCLK_LSB    25
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTHSCLK_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_ENABLECLK
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLECLK_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLECLK_BITS   0x01000000
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLECLK_MSB    24
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLECLK_LSB    24
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLECLK_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_ENABLE_3
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_3_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_3_BITS   0x00800000
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_3_MSB    23
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_3_LSB    23
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_3_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_ENABLE_2
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_2_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_2_BITS   0x00400000
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_2_MSB    22
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_2_LSB    22
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_2_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_ENABLE_1
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_1_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_1_BITS   0x00200000
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_1_MSB    21
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_1_LSB    21
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_1_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_ENABLE_0
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_0_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_0_BITS   0x00100000
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_0_MSB    20
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_0_LSB    20
++#define RPI_MIPICFG_DPHY_CTRL_1_ENABLE_0_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_3
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_3_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_3_BITS   0x00080000
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_3_MSB    19
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_3_LSB    19
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_3_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_2
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_2_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_2_BITS   0x00040000
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_2_MSB    18
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_2_LSB    18
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_2_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_1
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_1_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_1_BITS   0x00020000
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_1_MSB    17
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_1_LSB    17
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_1_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_0
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_0_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_0_BITS   0x00010000
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_0_MSB    16
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_0_LSB    16
++#define RPI_MIPICFG_DPHY_CTRL_1_BASEDIR_0_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_3
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_3_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_3_BITS   0x00008000
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_3_MSB    15
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_3_LSB    15
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_3_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_2
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_2_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_2_BITS   0x00004000
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_2_MSB    14
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_2_LSB    14
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_2_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_1
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_1_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_1_BITS   0x00002000
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_1_MSB    13
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_1_LSB    13
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_1_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_0
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_0_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_0_BITS   0x00001000
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_0_MSB    12
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_0_LSB    12
++#define RPI_MIPICFG_DPHY_CTRL_1_TXLPDTESC_0_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_3
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_3_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_3_BITS   0x00000800
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_3_MSB    11
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_3_LSB    11
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_3_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_2
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_2_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_2_BITS   0x00000400
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_2_MSB    10
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_2_LSB    10
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_2_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_1
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_1_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_1_BITS   0x00000200
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_1_MSB    9
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_1_LSB    9
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_1_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_0
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_0_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_0_BITS   0x00000100
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_0_MSB    8
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_0_LSB    8
++#define RPI_MIPICFG_DPHY_CTRL_1_TXVALIDESC_0_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_3
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_3_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_3_BITS   0x00000080
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_3_MSB    7
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_3_LSB    7
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_3_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_2
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_2_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_2_BITS   0x00000040
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_2_MSB    6
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_2_LSB    6
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_2_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_1
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_1_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_1_BITS   0x00000020
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_1_MSB    5
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_1_LSB    5
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_1_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_0
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_0_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_0_BITS   0x00000010
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_0_MSB    4
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_0_LSB    4
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTESC_0_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_3
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_3_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_3_BITS   0x00000008
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_3_MSB    3
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_3_LSB    3
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_3_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_2
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_2_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_2_BITS   0x00000004
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_2_MSB    2
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_2_LSB    2
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_2_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_1
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_1_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_1_BITS   0x00000002
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_1_MSB    1
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_1_LSB    1
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_1_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_0
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_0_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_0_BITS   0x00000001
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_0_MSB    0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_0_LSB    0
++#define RPI_MIPICFG_DPHY_CTRL_1_TXREQUESTDATAHS_0_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_DPHY_CTRL_2
++// JTAG access : asynchronous
++// Description : DPHY control for analog DFT
++#define RPI_MIPICFG_DPHY_CTRL_2_OFFSET 0x0000001c
++#define RPI_MIPICFG_DPHY_CTRL_2_BITS   0x000007ff
++#define RPI_MIPICFG_DPHY_CTRL_2_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_2_TESTCLK
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLK_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLK_BITS   0x00000400
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLK_MSB    10
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLK_LSB    10
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLK_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_2_TESTEN
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTEN_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTEN_BITS   0x00000200
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTEN_MSB    9
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTEN_LSB    9
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTEN_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_2_TESTCLR
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLR_RESET  0x0
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLR_BITS   0x00000100
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLR_MSB    8
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLR_LSB    8
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTCLR_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_2_TESTDIN
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTDIN_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTDIN_BITS   0x000000ff
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTDIN_MSB    7
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTDIN_LSB    0
++#define RPI_MIPICFG_DPHY_CTRL_2_TESTDIN_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_DPHY_CTRL_3
++// JTAG access : asynchronous
++// Description : DPHY control for analog DFT
++#define RPI_MIPICFG_DPHY_CTRL_3_OFFSET 0x00000020
++#define RPI_MIPICFG_DPHY_CTRL_3_BITS   0xffffffff
++#define RPI_MIPICFG_DPHY_CTRL_3_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_3
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_3_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_3_BITS   0xff000000
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_3_MSB    31
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_3_LSB    24
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_3_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_2
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_2_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_2_BITS   0x00ff0000
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_2_MSB    23
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_2_LSB    16
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_2_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_1
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_1_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_1_BITS   0x0000ff00
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_1_MSB    15
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_1_LSB    8
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_1_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_0
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_0_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_0_BITS   0x000000ff
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_0_MSB    7
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_0_LSB    0
++#define RPI_MIPICFG_DPHY_CTRL_3_TXDATAESC_0_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_DPHY_CTRL_4
++// JTAG access : asynchronous
++// Description : DPHY control for analog DFT
++#define RPI_MIPICFG_DPHY_CTRL_4_OFFSET 0x00000024
++#define RPI_MIPICFG_DPHY_CTRL_4_BITS   0xffffffff
++#define RPI_MIPICFG_DPHY_CTRL_4_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_3
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_3_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_3_BITS   0xff000000
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_3_MSB    31
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_3_LSB    24
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_3_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_2
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_2_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_2_BITS   0x00ff0000
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_2_MSB    23
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_2_LSB    16
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_2_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_1
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_1_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_1_BITS   0x0000ff00
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_1_MSB    15
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_1_LSB    8
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_1_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_0
++// Description : None
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_0_RESET  0x00
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_0_BITS   0x000000ff
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_0_MSB    7
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_0_LSB    0
++#define RPI_MIPICFG_DPHY_CTRL_4_TXDATAHS_0_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_INTR
++// JTAG access : synchronous
++// Description : Raw Interrupts
++#define RPI_MIPICFG_INTR_OFFSET 0x00000028
++#define RPI_MIPICFG_INTR_BITS   0x0000000f
++#define RPI_MIPICFG_INTR_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTR_DSI_HOST
++// Description : None
++#define RPI_MIPICFG_INTR_DSI_HOST_RESET  0x0
++#define RPI_MIPICFG_INTR_DSI_HOST_BITS   0x00000008
++#define RPI_MIPICFG_INTR_DSI_HOST_MSB    3
++#define RPI_MIPICFG_INTR_DSI_HOST_LSB    3
++#define RPI_MIPICFG_INTR_DSI_HOST_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTR_CSI_HOST
++// Description : None
++#define RPI_MIPICFG_INTR_CSI_HOST_RESET  0x0
++#define RPI_MIPICFG_INTR_CSI_HOST_BITS   0x00000004
++#define RPI_MIPICFG_INTR_CSI_HOST_MSB    2
++#define RPI_MIPICFG_INTR_CSI_HOST_LSB    2
++#define RPI_MIPICFG_INTR_CSI_HOST_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTR_DSI_DMA
++// Description : None
++#define RPI_MIPICFG_INTR_DSI_DMA_RESET  0x0
++#define RPI_MIPICFG_INTR_DSI_DMA_BITS   0x00000002
++#define RPI_MIPICFG_INTR_DSI_DMA_MSB    1
++#define RPI_MIPICFG_INTR_DSI_DMA_LSB    1
++#define RPI_MIPICFG_INTR_DSI_DMA_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTR_CSI_DMA
++// Description : None
++#define RPI_MIPICFG_INTR_CSI_DMA_RESET  0x0
++#define RPI_MIPICFG_INTR_CSI_DMA_BITS   0x00000001
++#define RPI_MIPICFG_INTR_CSI_DMA_MSB    0
++#define RPI_MIPICFG_INTR_CSI_DMA_LSB    0
++#define RPI_MIPICFG_INTR_CSI_DMA_ACCESS "RO"
++// ================================================================================
++// Register    : RPI_MIPICFG_INTE
++// JTAG access : synchronous
++// Description : Interrupt Enable
++#define RPI_MIPICFG_INTE_OFFSET 0x0000002c
++#define RPI_MIPICFG_INTE_BITS   0x0000000f
++#define RPI_MIPICFG_INTE_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTE_DSI_HOST
++// Description : None
++#define RPI_MIPICFG_INTE_DSI_HOST_RESET  0x0
++#define RPI_MIPICFG_INTE_DSI_HOST_BITS   0x00000008
++#define RPI_MIPICFG_INTE_DSI_HOST_MSB    3
++#define RPI_MIPICFG_INTE_DSI_HOST_LSB    3
++#define RPI_MIPICFG_INTE_DSI_HOST_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTE_CSI_HOST
++// Description : None
++#define RPI_MIPICFG_INTE_CSI_HOST_RESET  0x0
++#define RPI_MIPICFG_INTE_CSI_HOST_BITS   0x00000004
++#define RPI_MIPICFG_INTE_CSI_HOST_MSB    2
++#define RPI_MIPICFG_INTE_CSI_HOST_LSB    2
++#define RPI_MIPICFG_INTE_CSI_HOST_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTE_DSI_DMA
++// Description : None
++#define RPI_MIPICFG_INTE_DSI_DMA_RESET  0x0
++#define RPI_MIPICFG_INTE_DSI_DMA_BITS   0x00000002
++#define RPI_MIPICFG_INTE_DSI_DMA_MSB    1
++#define RPI_MIPICFG_INTE_DSI_DMA_LSB    1
++#define RPI_MIPICFG_INTE_DSI_DMA_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTE_CSI_DMA
++// Description : None
++#define RPI_MIPICFG_INTE_CSI_DMA_RESET  0x0
++#define RPI_MIPICFG_INTE_CSI_DMA_BITS   0x00000001
++#define RPI_MIPICFG_INTE_CSI_DMA_MSB    0
++#define RPI_MIPICFG_INTE_CSI_DMA_LSB    0
++#define RPI_MIPICFG_INTE_CSI_DMA_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_INTF
++// JTAG access : synchronous
++// Description : Interrupt Force
++#define RPI_MIPICFG_INTF_OFFSET 0x00000030
++#define RPI_MIPICFG_INTF_BITS   0x0000000f
++#define RPI_MIPICFG_INTF_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTF_DSI_HOST
++// Description : None
++#define RPI_MIPICFG_INTF_DSI_HOST_RESET  0x0
++#define RPI_MIPICFG_INTF_DSI_HOST_BITS   0x00000008
++#define RPI_MIPICFG_INTF_DSI_HOST_MSB    3
++#define RPI_MIPICFG_INTF_DSI_HOST_LSB    3
++#define RPI_MIPICFG_INTF_DSI_HOST_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTF_CSI_HOST
++// Description : None
++#define RPI_MIPICFG_INTF_CSI_HOST_RESET  0x0
++#define RPI_MIPICFG_INTF_CSI_HOST_BITS   0x00000004
++#define RPI_MIPICFG_INTF_CSI_HOST_MSB    2
++#define RPI_MIPICFG_INTF_CSI_HOST_LSB    2
++#define RPI_MIPICFG_INTF_CSI_HOST_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTF_DSI_DMA
++// Description : None
++#define RPI_MIPICFG_INTF_DSI_DMA_RESET  0x0
++#define RPI_MIPICFG_INTF_DSI_DMA_BITS   0x00000002
++#define RPI_MIPICFG_INTF_DSI_DMA_MSB    1
++#define RPI_MIPICFG_INTF_DSI_DMA_LSB    1
++#define RPI_MIPICFG_INTF_DSI_DMA_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTF_CSI_DMA
++// Description : None
++#define RPI_MIPICFG_INTF_CSI_DMA_RESET  0x0
++#define RPI_MIPICFG_INTF_CSI_DMA_BITS   0x00000001
++#define RPI_MIPICFG_INTF_CSI_DMA_MSB    0
++#define RPI_MIPICFG_INTF_CSI_DMA_LSB    0
++#define RPI_MIPICFG_INTF_CSI_DMA_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_INTS
++// JTAG access : synchronous
++// Description : Interrupt status after masking & forcing
++#define RPI_MIPICFG_INTS_OFFSET 0x00000034
++#define RPI_MIPICFG_INTS_BITS   0x0000000f
++#define RPI_MIPICFG_INTS_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTS_DSI_HOST
++// Description : None
++#define RPI_MIPICFG_INTS_DSI_HOST_RESET  0x0
++#define RPI_MIPICFG_INTS_DSI_HOST_BITS   0x00000008
++#define RPI_MIPICFG_INTS_DSI_HOST_MSB    3
++#define RPI_MIPICFG_INTS_DSI_HOST_LSB    3
++#define RPI_MIPICFG_INTS_DSI_HOST_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTS_CSI_HOST
++// Description : None
++#define RPI_MIPICFG_INTS_CSI_HOST_RESET  0x0
++#define RPI_MIPICFG_INTS_CSI_HOST_BITS   0x00000004
++#define RPI_MIPICFG_INTS_CSI_HOST_MSB    2
++#define RPI_MIPICFG_INTS_CSI_HOST_LSB    2
++#define RPI_MIPICFG_INTS_CSI_HOST_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTS_DSI_DMA
++// Description : None
++#define RPI_MIPICFG_INTS_DSI_DMA_RESET  0x0
++#define RPI_MIPICFG_INTS_DSI_DMA_BITS   0x00000002
++#define RPI_MIPICFG_INTS_DSI_DMA_MSB    1
++#define RPI_MIPICFG_INTS_DSI_DMA_LSB    1
++#define RPI_MIPICFG_INTS_DSI_DMA_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_INTS_CSI_DMA
++// Description : None
++#define RPI_MIPICFG_INTS_CSI_DMA_RESET  0x0
++#define RPI_MIPICFG_INTS_CSI_DMA_BITS   0x00000001
++#define RPI_MIPICFG_INTS_CSI_DMA_MSB    0
++#define RPI_MIPICFG_INTS_CSI_DMA_LSB    0
++#define RPI_MIPICFG_INTS_CSI_DMA_ACCESS "RO"
++// ================================================================================
++// Register    : RPI_MIPICFG_BLOCK_ID
++// JTAG access : asynchronous
++// Description : Block Identifier
++#define RPI_MIPICFG_BLOCK_ID_OFFSET 0x00000038
++#define RPI_MIPICFG_BLOCK_ID_BITS   0xffffffff
++#define RPI_MIPICFG_BLOCK_ID_RESET  0x4d495049
++#define RPI_MIPICFG_BLOCK_ID_MSB    31
++#define RPI_MIPICFG_BLOCK_ID_LSB    0
++#define RPI_MIPICFG_BLOCK_ID_ACCESS "RO"
++// ================================================================================
++// Register    : RPI_MIPICFG_INSTANCE_ID
++// JTAG access : asynchronous
++// Description : Block Instance Identifier
++#define RPI_MIPICFG_INSTANCE_ID_OFFSET 0x0000003c
++#define RPI_MIPICFG_INSTANCE_ID_BITS   0x0000000f
++#define RPI_MIPICFG_INSTANCE_ID_RESET  0x00000000
++#define RPI_MIPICFG_INSTANCE_ID_MSB    3
++#define RPI_MIPICFG_INSTANCE_ID_LSB    0
++#define RPI_MIPICFG_INSTANCE_ID_ACCESS "RO"
++// ================================================================================
++// Register    : RPI_MIPICFG_RSTSEQ_AUTO
++// JTAG access : synchronous
++// Description : None
++#define RPI_MIPICFG_RSTSEQ_AUTO_OFFSET 0x00000040
++#define RPI_MIPICFG_RSTSEQ_AUTO_BITS   0x00000007
++#define RPI_MIPICFG_RSTSEQ_AUTO_RESET  0x00000007
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_AUTO_CSI
++// Description : 1 = reset is controlled by the sequencer
++//               0 = reset is controlled by rstseq_ctrl
++#define RPI_MIPICFG_RSTSEQ_AUTO_CSI_RESET  0x1
++#define RPI_MIPICFG_RSTSEQ_AUTO_CSI_BITS   0x00000004
++#define RPI_MIPICFG_RSTSEQ_AUTO_CSI_MSB    2
++#define RPI_MIPICFG_RSTSEQ_AUTO_CSI_LSB    2
++#define RPI_MIPICFG_RSTSEQ_AUTO_CSI_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_AUTO_DPI
++// Description : 1 = reset is controlled by the sequencer
++//               0 = reset is controlled by rstseq_ctrl
++#define RPI_MIPICFG_RSTSEQ_AUTO_DPI_RESET  0x1
++#define RPI_MIPICFG_RSTSEQ_AUTO_DPI_BITS   0x00000002
++#define RPI_MIPICFG_RSTSEQ_AUTO_DPI_MSB    1
++#define RPI_MIPICFG_RSTSEQ_AUTO_DPI_LSB    1
++#define RPI_MIPICFG_RSTSEQ_AUTO_DPI_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_AUTO_BUSADAPTER
++// Description : 1 = reset is controlled by the sequencer
++//               0 = reset is controlled by rstseq_ctrl
++#define RPI_MIPICFG_RSTSEQ_AUTO_BUSADAPTER_RESET  0x1
++#define RPI_MIPICFG_RSTSEQ_AUTO_BUSADAPTER_BITS   0x00000001
++#define RPI_MIPICFG_RSTSEQ_AUTO_BUSADAPTER_MSB    0
++#define RPI_MIPICFG_RSTSEQ_AUTO_BUSADAPTER_LSB    0
++#define RPI_MIPICFG_RSTSEQ_AUTO_BUSADAPTER_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_RSTSEQ_PARALLEL
++// JTAG access : synchronous
++// Description : None
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_OFFSET 0x00000044
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_BITS   0x00000007
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_RESET  0x00000006
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_PARALLEL_CSI
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_CSI_RESET  0x1
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_CSI_BITS   0x00000004
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_CSI_MSB    2
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_CSI_LSB    2
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_CSI_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_PARALLEL_DPI
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_DPI_RESET  0x1
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_DPI_BITS   0x00000002
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_DPI_MSB    1
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_DPI_LSB    1
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_DPI_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_PARALLEL_BUSADAPTER
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_BUSADAPTER_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_BUSADAPTER_BITS   0x00000001
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_BUSADAPTER_MSB    0
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_BUSADAPTER_LSB    0
++#define RPI_MIPICFG_RSTSEQ_PARALLEL_BUSADAPTER_ACCESS "RO"
++// ================================================================================
++// Register    : RPI_MIPICFG_RSTSEQ_CTRL
++// JTAG access : synchronous
++// Description : None
++#define RPI_MIPICFG_RSTSEQ_CTRL_OFFSET 0x00000048
++#define RPI_MIPICFG_RSTSEQ_CTRL_BITS   0x00000007
++#define RPI_MIPICFG_RSTSEQ_CTRL_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_CTRL_CSI
++// Description : 1 = keep the reset asserted
++//               0 = keep the reset deasserted
++//               This is ignored if rstseq_auto=1
++#define RPI_MIPICFG_RSTSEQ_CTRL_CSI_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_CTRL_CSI_BITS   0x00000004
++#define RPI_MIPICFG_RSTSEQ_CTRL_CSI_MSB    2
++#define RPI_MIPICFG_RSTSEQ_CTRL_CSI_LSB    2
++#define RPI_MIPICFG_RSTSEQ_CTRL_CSI_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_CTRL_DPI
++// Description : 1 = keep the reset asserted
++//               0 = keep the reset deasserted
++//               This is ignored if rstseq_auto=1
++#define RPI_MIPICFG_RSTSEQ_CTRL_DPI_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_CTRL_DPI_BITS   0x00000002
++#define RPI_MIPICFG_RSTSEQ_CTRL_DPI_MSB    1
++#define RPI_MIPICFG_RSTSEQ_CTRL_DPI_LSB    1
++#define RPI_MIPICFG_RSTSEQ_CTRL_DPI_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_CTRL_BUSADAPTER
++// Description : 1 = keep the reset asserted
++//               0 = keep the reset deasserted
++//               This is ignored if rstseq_auto=1
++#define RPI_MIPICFG_RSTSEQ_CTRL_BUSADAPTER_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_CTRL_BUSADAPTER_BITS   0x00000001
++#define RPI_MIPICFG_RSTSEQ_CTRL_BUSADAPTER_MSB    0
++#define RPI_MIPICFG_RSTSEQ_CTRL_BUSADAPTER_LSB    0
++#define RPI_MIPICFG_RSTSEQ_CTRL_BUSADAPTER_ACCESS "RW"
++// ================================================================================
++// Register    : RPI_MIPICFG_RSTSEQ_TRIG
++// JTAG access : synchronous
++// Description : None
++#define RPI_MIPICFG_RSTSEQ_TRIG_OFFSET 0x0000004c
++#define RPI_MIPICFG_RSTSEQ_TRIG_BITS   0x00000007
++#define RPI_MIPICFG_RSTSEQ_TRIG_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_TRIG_CSI
++// Description : Pulses the reset output
++#define RPI_MIPICFG_RSTSEQ_TRIG_CSI_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_TRIG_CSI_BITS   0x00000004
++#define RPI_MIPICFG_RSTSEQ_TRIG_CSI_MSB    2
++#define RPI_MIPICFG_RSTSEQ_TRIG_CSI_LSB    2
++#define RPI_MIPICFG_RSTSEQ_TRIG_CSI_ACCESS "SC"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_TRIG_DPI
++// Description : Pulses the reset output
++#define RPI_MIPICFG_RSTSEQ_TRIG_DPI_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_TRIG_DPI_BITS   0x00000002
++#define RPI_MIPICFG_RSTSEQ_TRIG_DPI_MSB    1
++#define RPI_MIPICFG_RSTSEQ_TRIG_DPI_LSB    1
++#define RPI_MIPICFG_RSTSEQ_TRIG_DPI_ACCESS "SC"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_TRIG_BUSADAPTER
++// Description : Pulses the reset output
++#define RPI_MIPICFG_RSTSEQ_TRIG_BUSADAPTER_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_TRIG_BUSADAPTER_BITS   0x00000001
++#define RPI_MIPICFG_RSTSEQ_TRIG_BUSADAPTER_MSB    0
++#define RPI_MIPICFG_RSTSEQ_TRIG_BUSADAPTER_LSB    0
++#define RPI_MIPICFG_RSTSEQ_TRIG_BUSADAPTER_ACCESS "SC"
++// ================================================================================
++// Register    : RPI_MIPICFG_RSTSEQ_DONE
++// JTAG access : synchronous
++// Description : None
++#define RPI_MIPICFG_RSTSEQ_DONE_OFFSET 0x00000050
++#define RPI_MIPICFG_RSTSEQ_DONE_BITS   0x00000007
++#define RPI_MIPICFG_RSTSEQ_DONE_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_DONE_CSI
++// Description : Indicates the current state of the reset
++#define RPI_MIPICFG_RSTSEQ_DONE_CSI_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_DONE_CSI_BITS   0x00000004
++#define RPI_MIPICFG_RSTSEQ_DONE_CSI_MSB    2
++#define RPI_MIPICFG_RSTSEQ_DONE_CSI_LSB    2
++#define RPI_MIPICFG_RSTSEQ_DONE_CSI_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_DONE_DPI
++// Description : Indicates the current state of the reset
++#define RPI_MIPICFG_RSTSEQ_DONE_DPI_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_DONE_DPI_BITS   0x00000002
++#define RPI_MIPICFG_RSTSEQ_DONE_DPI_MSB    1
++#define RPI_MIPICFG_RSTSEQ_DONE_DPI_LSB    1
++#define RPI_MIPICFG_RSTSEQ_DONE_DPI_ACCESS "RO"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_RSTSEQ_DONE_BUSADAPTER
++// Description : Indicates the current state of the reset
++#define RPI_MIPICFG_RSTSEQ_DONE_BUSADAPTER_RESET  0x0
++#define RPI_MIPICFG_RSTSEQ_DONE_BUSADAPTER_BITS   0x00000001
++#define RPI_MIPICFG_RSTSEQ_DONE_BUSADAPTER_MSB    0
++#define RPI_MIPICFG_RSTSEQ_DONE_BUSADAPTER_LSB    0
++#define RPI_MIPICFG_RSTSEQ_DONE_BUSADAPTER_ACCESS "RO"
++// ================================================================================
++// Register    : RPI_MIPICFG_DFTSS
++// JTAG access : asynchronous
++// Description : None
++#define RPI_MIPICFG_DFTSS_OFFSET 0x00000054
++#define RPI_MIPICFG_DFTSS_BITS   0x0000001f
++#define RPI_MIPICFG_DFTSS_RESET  0x00000000
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DFTSS_JTAG_COPY
++// Description : None
++#define RPI_MIPICFG_DFTSS_JTAG_COPY_RESET  0x0
++#define RPI_MIPICFG_DFTSS_JTAG_COPY_BITS   0x00000010
++#define RPI_MIPICFG_DFTSS_JTAG_COPY_MSB    4
++#define RPI_MIPICFG_DFTSS_JTAG_COPY_LSB    4
++#define RPI_MIPICFG_DFTSS_JTAG_COPY_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DFTSS_JTAG_ACCESS_ONLY
++// Description : None
++#define RPI_MIPICFG_DFTSS_JTAG_ACCESS_ONLY_RESET  0x0
++#define RPI_MIPICFG_DFTSS_JTAG_ACCESS_ONLY_BITS   0x00000008
++#define RPI_MIPICFG_DFTSS_JTAG_ACCESS_ONLY_MSB    3
++#define RPI_MIPICFG_DFTSS_JTAG_ACCESS_ONLY_LSB    3
++#define RPI_MIPICFG_DFTSS_JTAG_ACCESS_ONLY_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DFTSS_BYPASS_OUTSYNCS
++// Description : None
++#define RPI_MIPICFG_DFTSS_BYPASS_OUTSYNCS_RESET  0x0
++#define RPI_MIPICFG_DFTSS_BYPASS_OUTSYNCS_BITS   0x00000004
++#define RPI_MIPICFG_DFTSS_BYPASS_OUTSYNCS_MSB    2
++#define RPI_MIPICFG_DFTSS_BYPASS_OUTSYNCS_LSB    2
++#define RPI_MIPICFG_DFTSS_BYPASS_OUTSYNCS_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DFTSS_BYPASS_INSYNCS
++// Description : None
++#define RPI_MIPICFG_DFTSS_BYPASS_INSYNCS_RESET  0x0
++#define RPI_MIPICFG_DFTSS_BYPASS_INSYNCS_BITS   0x00000002
++#define RPI_MIPICFG_DFTSS_BYPASS_INSYNCS_MSB    1
++#define RPI_MIPICFG_DFTSS_BYPASS_INSYNCS_LSB    1
++#define RPI_MIPICFG_DFTSS_BYPASS_INSYNCS_ACCESS "RW"
++// --------------------------------------------------------------------------------
++// Field       : RPI_MIPICFG_DFTSS_BYPASS_RESETSYNCS
++// Description : None
++#define RPI_MIPICFG_DFTSS_BYPASS_RESETSYNCS_RESET  0x0
++#define RPI_MIPICFG_DFTSS_BYPASS_RESETSYNCS_BITS   0x00000001
++#define RPI_MIPICFG_DFTSS_BYPASS_RESETSYNCS_MSB    0
++#define RPI_MIPICFG_DFTSS_BYPASS_RESETSYNCS_LSB    0
++#define RPI_MIPICFG_DFTSS_BYPASS_RESETSYNCS_ACCESS "RW"
++
++#define CFG_WRITE(reg, val)  writel((val),  dsi->hw_base[RP1DSI_HW_BLOCK_CFG] + (reg ## _OFFSET))
++#define CFG_READ(reg)        readl(dsi->hw_base[RP1DSI_HW_BLOCK_CFG] + (reg ## _OFFSET))
++
++/* ------------------------------- DPHY setup stuff ------------------------ */
++
++static void dphy_transaction(struct rp1_dsi *dsi, uint8_t test_code, uint8_t test_data)
++{
++	/*
++	 * See pg 101 of mipi dphy bidir databook
++	 * Assume we start with testclk high.
++	 * Each APB write takes at least 10ns and we ignore TESTDOUT
++	 * so there is no need for extra delays between the transitions.
++	 */
++	u32 tmp;
++
++	DSI_WRITE(DSI_PHY_TST_CTRL1, test_code | DPHY_CTRL1_PHY_TESTEN_BITS);
++	DSI_WRITE(DSI_PHY_TST_CTRL0, 0);
++	tmp = (DSI_READ(DSI_PHY_TST_CTRL1) >> DPHY_CTRL1_PHY_TESTDOUT_LSB) & 0xFF;
++	DSI_WRITE(DSI_PHY_TST_CTRL1, test_data);
++	DSI_WRITE(DSI_PHY_TST_CTRL0, DPHY_CTRL0_PHY_TESTCLK_BITS);
++}
++
++static uint8_t dphy_get_div(u32 refclk_khz, u32 vco_freq_khz, u32 *ptr_m, u32 *ptr_n)
++{
++	/*
++	 * See pg 77-78 of dphy databook
++	 * fvco = m/n * refclk
++	 * with the limit
++	 * 40MHz >= fREFCLK / N >= 5MHz
++	 * M (multiplier) must be an even number between 2 and 300
++	 * N (input divider) must be an integer between 1 and 100
++	 *
++	 * In practice, given a 50MHz reference clock, it can produce any
++	 * multiple of 10MHz, 11.1111MHz, 12.5MHz, 14.286MHz or 16.667MHz
++	 * with < 1% error for all frequencies above 495MHz.
++	 */
++
++	static const u32 REF_DIVN_MAX = 40000u;
++	static const u32 REF_DIVN_MIN =  5000u;
++	u32 best_n, best_m, best_err = 0x7fffffff;
++	unsigned int n;
++
++	for (n = 1 + refclk_khz / REF_DIVN_MAX; n * REF_DIVN_MIN <= refclk_khz && n < 100; ++n) {
++		u32 half_m = (n * vco_freq_khz + refclk_khz) / (2 * refclk_khz);
++
++		if (half_m < 150) {
++			u32 f = (2 * half_m * refclk_khz) / n;
++			u32 err = (f > vco_freq_khz) ? f - vco_freq_khz : vco_freq_khz - f;
++
++			if (err < best_err) {
++				best_n = n;
++				best_m = 2 * half_m;
++				best_err = err;
++				if (err == 0)
++					break;
++			}
++		}
++	}
++
++	if (64 * best_err < vco_freq_khz) { /* tolerate small error */
++		*ptr_n = best_n;
++		*ptr_m = best_m;
++		return 1;
++	}
++	return 0;
++}
++
++struct hsfreq_range {
++	u16 mhz_max;
++	u8  hsfreqrange;
++	u8  clk_lp2hs;
++	u8  clk_hs2lp;
++	u8  data_lp2hs; /* excluding clk lane entry */
++	u8  data_hs2lp;
++};
++
++/* See Table A-3 on page 258 of dphy databook */
++static const struct hsfreq_range hsfreq_table[] = {
++	{   89, 0b000000, 32, 20, 26, 13 },
++	{   99, 0b010000, 35, 23, 28, 14 },
++	{  109, 0b100000, 32, 22, 26, 13 },
++	{  129, 0b000001, 31, 20, 27, 13 },
++	{  139, 0b010001, 33, 22, 26, 14 },
++	{  149, 0b100001, 33, 21, 26, 14 },
++	{  169, 0b000010, 32, 20, 27, 13 },
++	{  179, 0b010010, 36, 23, 30, 15 },
++	{  199, 0b100010, 40, 22, 33, 15 },
++	{  219, 0b000011, 40, 22, 33, 15 },
++	{  239, 0b010011, 44, 24, 36, 16 },
++	{  249, 0b100011, 48, 24, 38, 17 },
++	{  269, 0b000100, 48, 24, 38, 17 },
++	{  299, 0b010100, 50, 27, 41, 18 },
++	{  329, 0b000101, 56, 28, 45, 18 },
++	{  359, 0b010101, 59, 28, 48, 19 },
++	{  399, 0b100101, 61, 30, 50, 20 },
++	{  449, 0b000110, 67, 31, 55, 21 },
++	{  499, 0b010110, 73, 31, 59, 22 },
++	{  549, 0b000111, 79, 36, 63, 24 },
++	{  599, 0b010111, 83, 37, 68, 25 },
++	{  649, 0b001000, 90, 38, 73, 27 },
++	{  699, 0b011000, 95, 40, 77, 28 },
++	{  749, 0b001001, 102, 40, 84, 28 },
++	{  799, 0b011001, 106, 42, 87, 30 },
++	{  849, 0b101001, 113, 44, 93, 31 },
++	{  899, 0b111001, 118, 47, 98, 32 },
++	{  949, 0b001010, 124, 47, 102, 34 },
++	{  999, 0b011010, 130, 49, 107, 35 },
++	{ 1049, 0b101010, 135, 51, 111, 37 },
++	{ 1099, 0b111010, 139, 51, 114, 38 },
++	{ 1149, 0b001011, 146, 54, 120, 40 },
++	{ 1199, 0b011011, 153, 57, 125, 41 },
++	{ 1249, 0b101011, 158, 58, 130, 42 },
++	{ 1299, 0b111011, 163, 58, 135, 44 },
++	{ 1349, 0b001100, 168, 60, 140, 45 },
++	{ 1399, 0b011100, 172, 64, 144, 47 },
++	{ 1449, 0b101100, 176, 65, 148, 48 },
++	{ 1500, 0b111100, 181, 66, 153, 50 },
++};
++
++static void dphy_set_hsfreqrange(struct rp1_dsi *dsi, u32 freq_mhz)
++{
++	unsigned int i;
++
++	if (freq_mhz < 80 || freq_mhz > 1500)
++		drm_err(dsi->drm, "DPHY: Frequency %u MHz out of range\n",
++			freq_mhz);
++
++	for (i = 0; i < ARRAY_SIZE(hsfreq_table) - 1; i++) {
++		if (freq_mhz <= hsfreq_table[i].mhz_max)
++			break;
++	}
++
++	dsi->hsfreq_index = i;
++	dphy_transaction(dsi, DPHY_HS_RX_CTRL_LANE0_OFFSET,
++			 hsfreq_table[i].hsfreqrange << 1);
++}
++
++static void dphy_configure_pll(struct rp1_dsi *dsi, u32 refclk_khz, u32 vco_freq_khz)
++{
++	u32 m = 0;
++	u32 n = 0;
++
++	if (dphy_get_div(refclk_khz, vco_freq_khz, &m, &n)) {
++		dphy_set_hsfreqrange(dsi, vco_freq_khz / 1000);
++		/* Program m,n from registers */
++		dphy_transaction(dsi, DPHY_PLL_DIV_CTRL_OFFSET, 0x30);
++		/* N (program N-1) */
++		dphy_transaction(dsi, DPHY_PLL_INPUT_DIV_OFFSET, n - 1);
++		/* M[8:5] ?? */
++		dphy_transaction(dsi, DPHY_PLL_LOOP_DIV_OFFSET, 0x80 | ((m - 1) >> 5));
++		/* M[4:0] (program M-1) */
++		dphy_transaction(dsi, DPHY_PLL_LOOP_DIV_OFFSET, ((m - 1) & 0x1F));
++		drm_dbg_driver(dsi->drm,
++			       "DPHY: vco freq want %dkHz got %dkHz = %d * (%dkHz / %d), hsfreqrange = 0x%02x\r\n",
++			       vco_freq_khz, refclk_khz * m / n, m, refclk_khz,
++			       n, hsfreq_table[dsi->hsfreq_index].hsfreqrange);
++	} else {
++		drm_info(dsi->drm,
++			 "rp1dsi: Error configuring DPHY PLL! %dkHz = %d * (%dkHz / %d)\r\n",
++			 vco_freq_khz, m, refclk_khz, n);
++	}
++}
++
++static void dphy_init_khz(struct rp1_dsi *dsi, u32 ref_freq, u32 vco_freq)
++{
++	/* Reset the PHY */
++	DSI_WRITE(DSI_PHYRSTZ, 0);
++	DSI_WRITE(DSI_PHY_TST_CTRL0, DPHY_CTRL0_PHY_TESTCLK_BITS);
++	DSI_WRITE(DSI_PHY_TST_CTRL1, 0);
++	DSI_WRITE(DSI_PHY_TST_CTRL0, (DPHY_CTRL0_PHY_TESTCLK_BITS | DPHY_CTRL0_PHY_TESTCLR_BITS));
++	udelay(1);
++	DSI_WRITE(DSI_PHY_TST_CTRL0, DPHY_CTRL0_PHY_TESTCLK_BITS);
++	udelay(1);
++	/* Since we are in DSI (not CSI2) mode here, start the PLL */
++	dphy_configure_pll(dsi, ref_freq, vco_freq);
++	udelay(1);
++	/* Unreset */
++	DSI_WRITE(DSI_PHYRSTZ, DSI_PHYRSTZ_SHUTDOWNZ_BITS);
++	udelay(1);
++	DSI_WRITE(DSI_PHYRSTZ, (DSI_PHYRSTZ_SHUTDOWNZ_BITS | DSI_PHYRSTZ_RSTZ_BITS));
++	udelay(1); /* so we can see PLL coming up? */
++}
++
++void rp1dsi_mipicfg_setup(struct rp1_dsi *dsi)
++{
++	/* Select DSI rather than CSI-2 */
++	CFG_WRITE(RPI_MIPICFG_CFG, 0);
++	/* Enable DSIDMA interrupt only */
++	CFG_WRITE(RPI_MIPICFG_INTE, RPI_MIPICFG_INTE_DSI_DMA_BITS);
++}
++
++static unsigned long rp1dsi_refclk_freq(struct rp1_dsi *dsi)
++{
++	unsigned long u;
++
++	u = (dsi->clocks[RP1DSI_CLOCK_REF]) ? clk_get_rate(dsi->clocks[RP1DSI_CLOCK_REF]) : 0;
++	if (u < 1 || u >= (1ul << 30))
++		u = 50000000ul; /* default XOSC frequency */
++	return u;
++}
++
++static void rp1dsi_dpiclk_start(struct rp1_dsi *dsi, unsigned int bpp, unsigned int lanes)
++{
++	unsigned long u;
++
++	if (dsi->clocks[RP1DSI_CLOCK_DPI]) {
++		u = (dsi->clocks[RP1DSI_CLOCK_BYTE]) ?
++				clk_get_rate(dsi->clocks[RP1DSI_CLOCK_BYTE]) : 0;
++		drm_info(dsi->drm,
++			 "rp1dsi: Nominal byte clock %lu; scale by %u/%u",
++			 u, 4 * lanes, (bpp >> 1));
++		if (u < 1 || u >= (1ul << 28))
++			u = 72000000ul; /* default DUMMY frequency for byteclock */
++
++		clk_set_parent(dsi->clocks[RP1DSI_CLOCK_DPI], dsi->clocks[RP1DSI_CLOCK_BYTE]);
++		clk_set_rate(dsi->clocks[RP1DSI_CLOCK_DPI], (4 * lanes * u) / (bpp >> 1));
++		clk_prepare_enable(dsi->clocks[RP1DSI_CLOCK_DPI]);
++	}
++}
++
++static void rp1dsi_dpiclk_stop(struct rp1_dsi *dsi)
++{
++	if (dsi->clocks[RP1DSI_CLOCK_DPI])
++		clk_disable_unprepare(dsi->clocks[RP1DSI_CLOCK_DPI]);
++}
++
++/* Choose the internal on-the-bus DPI format, and DSI packing flag. */
++static u32 get_colorcode(enum mipi_dsi_pixel_format fmt)
++{
++	switch (fmt) {
++	case MIPI_DSI_FMT_RGB666:
++		return 0x104;
++	case MIPI_DSI_FMT_RGB666_PACKED:
++		return 0x003;
++	case MIPI_DSI_FMT_RGB565:
++		return 0x000;
++	case MIPI_DSI_FMT_RGB888:
++		return 0x005;
++	}
++
++	/* This should be impossible as the format is validated in
++	 * rp1dsi_host_attach
++	 */
++	WARN_ONCE(1, "Invalid colour format configured for DSI");
++	return 0x005;
++}
++
++void rp1dsi_dsi_setup(struct rp1_dsi *dsi, struct drm_display_mode const *mode)
++{
++	u32 timeout, mask, vid_mode_cfg;
++	u32 freq_khz;
++	unsigned int bpp = mipi_dsi_pixel_format_to_bpp(dsi->display_format);
++
++	DSI_WRITE(DSI_PHY_IF_CFG, dsi->lanes - 1);
++	DSI_WRITE(DSI_DPI_CFG_POL, 0);
++	DSI_WRITE(DSI_GEN_VCID, dsi->vc);
++	DSI_WRITE(DSI_DPI_COLOR_CODING, get_colorcode(dsi->display_format));
++	/* a conservative guess (LP escape is slow!) */
++	DSI_WRITE(DSI_DPI_LP_CMD_TIM, 0x00100000);
++
++	/* Drop to LP where possible */
++	vid_mode_cfg = 0xbf00;
++	if (!(dsi->display_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE))
++		vid_mode_cfg |= 0x01;
++	if (dsi->display_flags & MIPI_DSI_MODE_VIDEO_BURST)
++		vid_mode_cfg |= 0x02;
++	DSI_WRITE(DSI_VID_MODE_CFG, vid_mode_cfg);
++
++	/* Use LP Escape Data signalling for all commands */
++	DSI_WRITE(DSI_CMD_MODE_CFG, 0x10F7F00);
++	/* Select Command Mode */
++	DSI_WRITE(DSI_MODE_CFG, 1);
++	/* XXX magic number */
++	DSI_WRITE(DSI_TO_CNT_CFG, 0x02000200);
++	/* XXX magic number */
++	DSI_WRITE(DSI_BTA_TO_CNT, 0x800);
++
++	DSI_WRITE(DSI_VID_PKT_SIZE, mode->hdisplay);
++	DSI_WRITE(DSI_VID_NUM_CHUNKS, 0);
++	DSI_WRITE(DSI_VID_NULL_SIZE, 0);
++
++	/* Note, unlike Argon firmware, here we DON'T consider sync to be concurrent with porch */
++	DSI_WRITE(DSI_VID_HSA_TIME,
++		  (bpp * (mode->hsync_end - mode->hsync_start)) / (8 * dsi->lanes));
++	DSI_WRITE(DSI_VID_HBP_TIME,
++		  (bpp * (mode->htotal - mode->hsync_end)) / (8 * dsi->lanes));
++	DSI_WRITE(DSI_VID_HLINE_TIME, (bpp * mode->htotal) / (8 * dsi->lanes));
++	DSI_WRITE(DSI_VID_VSA_LINES, (mode->vsync_end - mode->vsync_start));
++	DSI_WRITE(DSI_VID_VBP_LINES, (mode->vtotal - mode->vsync_end));
++	DSI_WRITE(DSI_VID_VFP_LINES, (mode->vsync_start - mode->vdisplay));
++	DSI_WRITE(DSI_VID_VACTIVE_LINES, mode->vdisplay);
++
++	freq_khz = (bpp *  mode->clock) / dsi->lanes;
++
++	dphy_init_khz(dsi, rp1dsi_refclk_freq(dsi) / 1000, freq_khz);
++
++	DSI_WRITE(DSI_PHY_TMR_LPCLK_CFG,
++		  (hsfreq_table[dsi->hsfreq_index].clk_lp2hs << DSI_PHY_TMR_LP2HS_LSB) |
++		  (hsfreq_table[dsi->hsfreq_index].clk_hs2lp << DSI_PHY_TMR_HS2LP_LSB));
++	DSI_WRITE(DSI_PHY_TMR_CFG,
++		  (hsfreq_table[dsi->hsfreq_index].data_lp2hs << DSI_PHY_TMR_LP2HS_LSB) |
++		  (hsfreq_table[dsi->hsfreq_index].data_hs2lp << DSI_PHY_TMR_HS2LP_LSB));
++
++	DSI_WRITE(DSI_CLKMGR_CFG, 0x00000505);
++
++	/* Wait for PLL lock */
++	for (timeout = (1 << 14); timeout != 0; --timeout) {
++		usleep_range(10, 50);
++		if (DSI_READ(DSI_PHY_STATUS) & (1 << 0))
++			break;
++	}
++	if (timeout == 0)
++		drm_err(dsi->drm, "RP1DSI: Time out waiting for PLL\n");
++
++	DSI_WRITE(DSI_LPCLK_CTRL, 0x1);		/* configure the requesthsclk */
++	DSI_WRITE(DSI_PHY_TST_CTRL0, 0x2);
++	DSI_WRITE(DSI_PCKHDL_CFG, 1 << 2);	/* allow bus turnaround */
++	DSI_WRITE(DSI_PWR_UP, 0x1);		/* power up */
++
++	/* Now it should be safe to start the external DPI clock divider */
++	rp1dsi_dpiclk_start(dsi, bpp, dsi->lanes);
++
++	/* Wait for all lane(s) to be in Stopstate */
++	mask = (1 << 4);
++	if (dsi->lanes >= 2)
++		mask |= (1 << 7);
++	if (dsi->lanes >= 3)
++		mask |= (1 << 9);
++	if (dsi->lanes >= 4)
++		mask |= (1 << 11);
++	for (timeout = (1 << 10); timeout != 0; --timeout) {
++		usleep_range(10, 50);
++		if ((DSI_READ(DSI_PHY_STATUS) & mask) == mask)
++			break;
++	}
++	if (timeout == 0)
++		drm_err(dsi->drm, "RP1DSI: Time out waiting for lanes (%x %x)\n",
++			mask, DSI_READ(DSI_PHY_STATUS));
++}
++
++void rp1dsi_dsi_send(struct rp1_dsi *dsi, u32 hdr, int len, const u8 *buf)
++{
++	u32 val;
++
++	/* Wait for both FIFOs empty */
++	for (val = 256; val > 0; --val) {
++		if ((DSI_READ(DSI_CMD_PKT_STATUS) & 0xF) == 0x5)
++			break;
++		usleep_range(100, 150);
++	}
++
++	/* Write payload (in 32-bit words) and header */
++	for (; len > 0; len -= 4) {
++		val = *buf++;
++		if (len > 1)
++			val |= (*buf++) << 8;
++		if (len > 2)
++			val |= (*buf++) << 16;
++		if (len > 3)
++			val |= (*buf++) << 24;
++		DSI_WRITE(DSI_GEN_PLD_DATA, val);
++	}
++	DSI_WRITE(DSI_GEN_HDR, hdr);
++
++	/* Wait for both FIFOs empty */
++	for (val = 256; val > 0; --val) {
++		if ((DSI_READ(DSI_CMD_PKT_STATUS) & 0xF) == 0x5)
++			break;
++		usleep_range(100, 150);
++	}
++}
++
++int rp1dsi_dsi_recv(struct rp1_dsi *dsi, int len, u8 *buf)
++{
++	int i, j;
++	u32 val;
++
++	/* Wait until not busy and FIFO not empty */
++	for (i = 1024; i > 0; --i) {
++		val = DSI_READ(DSI_CMD_PKT_STATUS);
++		if ((val & ((1 << 6) | (1 << 4))) == 0)
++			break;
++		usleep_range(100, 150);
++	}
++	if (i == 0)
++		return -EIO;
++
++	for (i = 0; i < len; i += 4) {
++		/* Read fifo must not be empty before all bytes are read */
++		if (DSI_READ(DSI_CMD_PKT_STATUS) & (1 << 4))
++			break;
++
++		val = DSI_READ(DSI_GEN_PLD_DATA);
++		for (j = 0; j < 4 && j + i < len; j++)
++			*buf++ = val >> (8 * j);
++	}
++
++	return (i >= len) ? len : (i > 0) ? i : -EIO;
++}
++
++void rp1dsi_dsi_stop(struct rp1_dsi *dsi)
++{
++	DSI_WRITE(DSI_MODE_CFG, 1);	/* Return to Command Mode */
++	DSI_WRITE(DSI_LPCLK_CTRL, 2);	/* Stop the HS clock */
++	DSI_WRITE(DSI_PWR_UP, 0x0);     /* Power down host controller */
++	DSI_WRITE(DSI_PHYRSTZ, 0);      /* PHY into reset. */
++	rp1dsi_dpiclk_stop(dsi);
++}
++
++void rp1dsi_dsi_set_cmdmode(struct rp1_dsi *dsi, int mode)
++{
++	DSI_WRITE(DSI_MODE_CFG, mode);
++}
diff --git a/target/linux/bcm27xx/patches-6.1/950-0886-drm-Add-RP1-DPI-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0886-drm-Add-RP1-DPI-driver.patch
new file mode 100644
index 0000000000..2023bf73e8
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0886-drm-Add-RP1-DPI-driver.patch
@@ -0,0 +1,1552 @@
+From 61c3065f89d4447c7e4cf61a466ebc3c4a834ad2 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Tue, 19 Sep 2023 17:51:49 +0100
+Subject: [PATCH] drm: Add RP1 DPI driver
+
+Add support for the RP1 DPI hardware.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/gpu/drm/rp1/rp1-dpi/Kconfig       |  12 +
+ drivers/gpu/drm/rp1/rp1-dpi/Makefile      |   5 +
+ drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi.c     | 429 ++++++++++++++++++
+ drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi.h     |  69 +++
+ drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi_cfg.c | 510 ++++++++++++++++++++++
+ drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi_hw.c  | 486 +++++++++++++++++++++
+ 6 files changed, 1511 insertions(+)
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dpi/Kconfig
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dpi/Makefile
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi.c
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi.h
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi_cfg.c
+ create mode 100644 drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi_hw.c
+
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dpi/Kconfig
+@@ -0,0 +1,12 @@
++# SPDX-License-Identifier: GPL-2.0-only
++config DRM_RP1_DPI
++	tristate "DRM Support for RP1 DPI"
++	depends on DRM
++	select MFD_RP1
++	select DRM_GEM_DMA_HELPER
++	select DRM_KMS_HELPER
++	select DRM_VRAM_HELPER
++	select DRM_TTM
++	select DRM_TTM_HELPER
++	help
++	  Choose this option to enable Video Out on RP1
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dpi/Makefile
+@@ -0,0 +1,5 @@
++# SPDX-License-Identifier: GPL-2.0-only
++
++drm-rp1-dpi-y := rp1_dpi.o rp1_dpi_hw.o rp1_dpi_cfg.o
++
++obj-$(CONFIG_DRM_RP1_DPI) += drm-rp1-dpi.o
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi.c
+@@ -0,0 +1,429 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for DPI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/string.h>
++#include <linux/slab.h>
++#include <linux/mm.h>
++#include <linux/fb.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/interrupt.h>
++#include <linux/ioport.h>
++#include <linux/list.h>
++#include <linux/platform_device.h>
++#include <linux/clk.h>
++#include <linux/printk.h>
++#include <linux/console.h>
++#include <linux/debugfs.h>
++#include <linux/uaccess.h>
++#include <linux/io.h>
++#include <linux/dma-mapping.h>
++#include <linux/cred.h>
++#include <linux/media-bus-format.h>
++#include <linux/pinctrl/consumer.h>
++#include <drm/drm_drv.h>
++#include <drm/drm_mm.h>
++#include <drm/drm_fourcc.h>
++#include <drm/drm_gem_atomic_helper.h>
++#include <drm/drm_gem_dma_helper.h>
++#include <drm/drm_atomic_helper.h>
++#include <drm/drm_managed.h>
++#include <drm/drm_crtc.h>
++#include <drm/drm_crtc_helper.h>
++#include <drm/drm_encoder.h>
++#include <drm/drm_fb_helper.h>
++#include <drm/drm_framebuffer.h>
++#include <drm/drm_gem.h>
++#include <drm/drm_gem_framebuffer_helper.h>
++#include <drm/drm_simple_kms_helper.h>
++#include <drm/drm_probe_helper.h>
++#include <drm/drm_modeset_helper_vtables.h>
++#include <drm/drm_vblank.h>
++#include <drm/drm_of.h>
++
++#include "rp1_dpi.h"
++
++/*
++ * Default bus format, where not specified by a connector/bridge
++ * and not overridden by the OF property "default_bus_fmt".
++ * This value is for compatibility with vc4 and VGA666-style boards,
++ * even though RP1 hardware cannot achieve the full 18-bit depth
++ * with that pinout (MEDIA_BUS_FMT_RGB666_1X24_CPADHI is preferred).
++ */
++static unsigned int default_bus_fmt = MEDIA_BUS_FMT_RGB666_1X18;
++module_param(default_bus_fmt, uint, 0644);
++
++/* -------------------------------------------------------------- */
++
++static void rp1dpi_pipe_update(struct drm_simple_display_pipe *pipe,
++			       struct drm_plane_state *old_state)
++{
++	struct drm_pending_vblank_event *event;
++	unsigned long flags;
++	struct drm_framebuffer *fb = pipe->plane.state->fb;
++	struct rp1_dpi *dpi = pipe->crtc.dev->dev_private;
++	struct drm_gem_object *gem = fb ? drm_gem_fb_get_obj(fb, 0) : NULL;
++	struct drm_gem_dma_object *dma_obj = gem ? to_drm_gem_dma_obj(gem) : NULL;
++	bool can_update = fb && dma_obj && dpi && dpi->pipe_enabled;
++
++	/* (Re-)start DPI-DMA where required; and update FB address */
++	if (can_update) {
++		if (!dpi->dpi_running || fb->format->format != dpi->cur_fmt) {
++			if (dpi->dpi_running &&
++			    fb->format->format != dpi->cur_fmt) {
++				rp1dpi_hw_stop(dpi);
++				dpi->dpi_running = false;
++			}
++			if (!dpi->dpi_running) {
++				rp1dpi_hw_setup(dpi,
++						fb->format->format,
++						dpi->bus_fmt,
++						dpi->de_inv,
++						&pipe->crtc.state->mode);
++				dpi->dpi_running = true;
++			}
++			dpi->cur_fmt = fb->format->format;
++			drm_crtc_vblank_on(&pipe->crtc);
++		}
++		rp1dpi_hw_update(dpi, dma_obj->dma_addr, fb->offsets[0], fb->pitches[0]);
++	}
++
++	/* Arm VBLANK event (or call it immediately in some error cases) */
++	spin_lock_irqsave(&pipe->crtc.dev->event_lock, flags);
++	event = pipe->crtc.state->event;
++	if (event) {
++		pipe->crtc.state->event = NULL;
++		if (can_update && drm_crtc_vblank_get(&pipe->crtc) == 0)
++			drm_crtc_arm_vblank_event(&pipe->crtc, event);
++		else
++			drm_crtc_send_vblank_event(&pipe->crtc, event);
++	}
++	spin_unlock_irqrestore(&pipe->crtc.dev->event_lock, flags);
++}
++
++static void rp1dpi_pipe_enable(struct drm_simple_display_pipe *pipe,
++			       struct drm_crtc_state *crtc_state,
++			      struct drm_plane_state *plane_state)
++{
++	static const unsigned int M = 1000000;
++	struct rp1_dpi *dpi = pipe->crtc.dev->dev_private;
++	struct drm_connector *conn;
++	struct drm_connector_list_iter conn_iter;
++	unsigned int fpix, fdiv, fvco;
++	int ret;
++
++	/* Look up the connector attached to DPI so we can get the
++	 * bus_format.  Ideally the bridge would tell us the
++	 * bus_format we want, but it doesn't yet, so assume that it's
++	 * uniform throughout the bridge chain.
++	 */
++	dev_info(&dpi->pdev->dev, __func__);
++	drm_connector_list_iter_begin(pipe->encoder.dev, &conn_iter);
++	drm_for_each_connector_iter(conn, &conn_iter) {
++		if (conn->encoder == &pipe->encoder) {
++			dpi->de_inv = !!(conn->display_info.bus_flags &
++							DRM_BUS_FLAG_DE_LOW);
++			dpi->clk_inv = !!(conn->display_info.bus_flags &
++						DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE);
++			if (conn->display_info.num_bus_formats)
++				dpi->bus_fmt = conn->display_info.bus_formats[0];
++			break;
++		}
++	}
++	drm_connector_list_iter_end(&conn_iter);
++
++	/* Set DPI clock to desired frequency. Currently (experimentally)
++	 * we take control of the VideoPLL, to ensure we can generate it
++	 * accurately. NB: this prevents concurrent use of DPI and VEC!
++	 * Magic numbers ensure the parent clock is within [100MHz, 200MHz]
++	 * with VCO in [1GHz, 1.33GHz]. The initial divide is by 6, 8 or 10.
++	 */
++	fpix = 1000 * pipe->crtc.state->mode.clock;
++	fpix = clamp(fpix, 1 * M, 200 * M);
++	fdiv = fpix;
++	while (fdiv < 100 * M)
++		fdiv *= 2;
++	fvco = fdiv * 2 * DIV_ROUND_UP(500 * M, fdiv);
++	ret = clk_set_rate(dpi->clocks[RP1DPI_CLK_PLLCORE], fvco);
++	if (ret)
++		dev_err(&dpi->pdev->dev, "Failed to set PLL VCO to %u (%d)", fvco, ret);
++	ret = clk_set_rate(dpi->clocks[RP1DPI_CLK_PLLDIV], fdiv);
++	if (ret)
++		dev_err(&dpi->pdev->dev, "Failed to set PLL output to %u (%d)", fdiv, ret);
++	ret = clk_set_rate(dpi->clocks[RP1DPI_CLK_DPI], fpix);
++	if (ret)
++		dev_err(&dpi->pdev->dev, "Failed to set DPI clock to %u (%d)", fpix, ret);
++
++	rp1dpi_vidout_setup(dpi, dpi->clk_inv);
++	clk_prepare_enable(dpi->clocks[RP1DPI_CLK_PLLCORE]);
++	clk_prepare_enable(dpi->clocks[RP1DPI_CLK_PLLDIV]);
++	pinctrl_pm_select_default_state(&dpi->pdev->dev);
++	clk_prepare_enable(dpi->clocks[RP1DPI_CLK_DPI]);
++	dev_info(&dpi->pdev->dev, "Want %u /%u %u /%u %u; got VCO=%lu DIV=%lu DPI=%lu",
++		 fvco, fvco / fdiv, fdiv, fdiv / fpix, fpix,
++		 clk_get_rate(dpi->clocks[RP1DPI_CLK_PLLCORE]),
++		 clk_get_rate(dpi->clocks[RP1DPI_CLK_PLLDIV]),
++		 clk_get_rate(dpi->clocks[RP1DPI_CLK_DPI]));
++
++	/* Start DPI-DMA. pipe already has the new crtc and plane state. */
++	dpi->pipe_enabled = true;
++	dpi->cur_fmt = 0xdeadbeef;
++	rp1dpi_pipe_update(pipe, 0);
++}
++
++static void rp1dpi_pipe_disable(struct drm_simple_display_pipe *pipe)
++{
++	struct rp1_dpi *dpi = pipe->crtc.dev->dev_private;
++
++	dev_info(&dpi->pdev->dev, __func__);
++	drm_crtc_vblank_off(&pipe->crtc);
++	if (dpi->dpi_running) {
++		rp1dpi_hw_stop(dpi);
++		dpi->dpi_running = false;
++	}
++	clk_disable_unprepare(dpi->clocks[RP1DPI_CLK_DPI]);
++	pinctrl_pm_select_sleep_state(&dpi->pdev->dev);
++	clk_disable_unprepare(dpi->clocks[RP1DPI_CLK_PLLDIV]);
++	clk_disable_unprepare(dpi->clocks[RP1DPI_CLK_PLLCORE]);
++	dpi->pipe_enabled = false;
++}
++
++static int rp1dpi_pipe_enable_vblank(struct drm_simple_display_pipe *pipe)
++{
++	struct rp1_dpi *dpi = pipe->crtc.dev->dev_private;
++
++	if (dpi)
++		rp1dpi_hw_vblank_ctrl(dpi, 1);
++
++	return 0;
++}
++
++static void rp1dpi_pipe_disable_vblank(struct drm_simple_display_pipe *pipe)
++{
++	struct rp1_dpi *dpi = pipe->crtc.dev->dev_private;
++
++	if (dpi)
++		rp1dpi_hw_vblank_ctrl(dpi, 0);
++}
++
++static const struct drm_simple_display_pipe_funcs rp1dpi_pipe_funcs = {
++	.enable	    = rp1dpi_pipe_enable,
++	.update	    = rp1dpi_pipe_update,
++	.disable    = rp1dpi_pipe_disable,
++	.prepare_fb = drm_gem_simple_display_pipe_prepare_fb,
++	.enable_vblank	= rp1dpi_pipe_enable_vblank,
++	.disable_vblank = rp1dpi_pipe_disable_vblank,
++};
++
++static const struct drm_mode_config_funcs rp1dpi_mode_funcs = {
++	.fb_create = drm_gem_fb_create,
++	.atomic_check = drm_atomic_helper_check,
++	.atomic_commit = drm_atomic_helper_commit,
++};
++
++static void rp1dpi_stopall(struct drm_device *drm)
++{
++	if (drm->dev_private) {
++		struct rp1_dpi *dpi = drm->dev_private;
++
++		if (dpi->dpi_running || rp1dpi_hw_busy(dpi)) {
++			rp1dpi_hw_stop(dpi);
++			clk_disable_unprepare(dpi->clocks[RP1DPI_CLK_DPI]);
++			dpi->dpi_running = false;
++		}
++		rp1dpi_vidout_poweroff(dpi);
++		pinctrl_pm_select_sleep_state(&dpi->pdev->dev);
++	}
++}
++
++DEFINE_DRM_GEM_DMA_FOPS(rp1dpi_fops);
++
++static struct drm_driver rp1dpi_driver = {
++	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
++	.fops			= &rp1dpi_fops,
++	.name			= "drm-rp1-dpi",
++	.desc			= "drm-rp1-dpi",
++	.date			= "0",
++	.major			= 1,
++	.minor			= 0,
++	DRM_GEM_DMA_DRIVER_OPS,
++	.release		= rp1dpi_stopall,
++};
++
++static const u32 rp1dpi_formats[] = {
++	DRM_FORMAT_XRGB8888,
++	DRM_FORMAT_XBGR8888,
++	DRM_FORMAT_RGB888,
++	DRM_FORMAT_BGR888,
++	DRM_FORMAT_RGB565
++};
++
++static int rp1dpi_platform_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct drm_device *drm;
++	struct rp1_dpi *dpi;
++	struct drm_bridge *bridge = NULL;
++	struct drm_panel *panel;
++	int i, ret;
++
++	dev_info(dev, __func__);
++	ret = drm_of_find_panel_or_bridge(pdev->dev.of_node, 0, 0,
++					  &panel, &bridge);
++	if (ret) {
++		dev_info(dev, "%s: bridge not found\n", __func__);
++		return -EPROBE_DEFER;
++	}
++	if (panel) {
++		bridge = devm_drm_panel_bridge_add(dev, panel);
++		if (IS_ERR(bridge))
++			return PTR_ERR(bridge);
++	}
++
++	drm = drm_dev_alloc(&rp1dpi_driver, dev);
++	if (IS_ERR(drm)) {
++		dev_info(dev, "%s %d", __func__, (int)__LINE__);
++		ret = PTR_ERR(drm);
++		return ret;
++	}
++	dpi = drmm_kzalloc(drm, sizeof(*dpi), GFP_KERNEL);
++	if (!dpi) {
++		dev_info(dev, "%s %d", __func__, (int)__LINE__);
++		drm_dev_put(drm);
++		return -ENOMEM;
++	}
++
++	init_completion(&dpi->finished);
++	dpi->drm = drm;
++	dpi->pdev = pdev;
++	drm->dev_private = dpi;
++	platform_set_drvdata(pdev, drm);
++
++	dpi->bus_fmt = default_bus_fmt;
++	ret = of_property_read_u32(dev->of_node, "default_bus_fmt", &dpi->bus_fmt);
++
++	for (i = 0; i < RP1DPI_NUM_HW_BLOCKS; i++) {
++		dpi->hw_base[i] =
++			devm_ioremap_resource(dev,
++					      platform_get_resource(dpi->pdev, IORESOURCE_MEM, i));
++		if (IS_ERR(dpi->hw_base[i])) {
++			ret = PTR_ERR(dpi->hw_base[i]);
++			dev_err(dev, "Error memory mapping regs[%d]\n", i);
++			goto err_free_drm;
++		}
++	}
++	ret = platform_get_irq(dpi->pdev, 0);
++	if (ret > 0)
++		ret = devm_request_irq(dev, ret, rp1dpi_hw_isr,
++				       IRQF_SHARED, "rp1-dpi", dpi);
++	if (ret) {
++		dev_err(dev, "Unable to request interrupt\n");
++		ret = -EINVAL;
++		goto err_free_drm;
++	}
++	dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
++
++	for (i = 0; i < RP1DPI_NUM_CLOCKS; i++) {
++		static const char * const myclocknames[RP1DPI_NUM_CLOCKS] = {
++			"dpiclk", "plldiv", "pllcore"
++		};
++		dpi->clocks[i] = devm_clk_get(dev, myclocknames[i]);
++		if (IS_ERR(dpi->clocks[i])) {
++			ret = PTR_ERR(dpi->clocks[i]);
++			goto err_free_drm;
++		}
++	}
++
++	ret = drmm_mode_config_init(drm);
++	if (ret)
++		goto err_free_drm;
++
++	drm->mode_config.max_width  = 4096;
++	drm->mode_config.max_height = 4096;
++	drm->mode_config.fb_base    = 0;
++	drm->mode_config.preferred_depth = 32;
++	drm->mode_config.prefer_shadow	 = 0;
++	drm->mode_config.prefer_shadow_fbdev = 1;
++	drm->mode_config.quirk_addfb_prefer_host_byte_order = true;
++	drm->mode_config.funcs = &rp1dpi_mode_funcs;
++	drm_vblank_init(drm, 1);
++
++	ret = drm_simple_display_pipe_init(drm,
++					   &dpi->pipe,
++					   &rp1dpi_pipe_funcs,
++					   rp1dpi_formats,
++					   ARRAY_SIZE(rp1dpi_formats),
++					   NULL, NULL);
++	if (!ret)
++		ret = drm_simple_display_pipe_attach_bridge(&dpi->pipe, bridge);
++	if (ret)
++		goto err_free_drm;
++
++	drm_mode_config_reset(drm);
++
++	ret = drm_dev_register(drm, 0);
++	if (ret)
++		goto err_free_drm;
++
++	drm_fbdev_generic_setup(drm, 32);
++
++	dev_info(dev, "%s success\n", __func__);
++	return ret;
++
++err_free_drm:
++	dev_err(dev, "%s fail %d\n", __func__, ret);
++	drm_dev_put(drm);
++	return ret;
++}
++
++static int rp1dpi_platform_remove(struct platform_device *pdev)
++{
++	struct drm_device *drm = platform_get_drvdata(pdev);
++
++	rp1dpi_stopall(drm);
++	drm_dev_unregister(drm);
++	drm_atomic_helper_shutdown(drm);
++	drm_dev_put(drm);
++
++	return 0;
++}
++
++static void rp1dpi_platform_shutdown(struct platform_device *pdev)
++{
++	struct drm_device *drm = platform_get_drvdata(pdev);
++
++	rp1dpi_stopall(drm);
++}
++
++static const struct of_device_id rp1dpi_of_match[] = {
++	{
++		.compatible = "raspberrypi,rp1dpi",
++	},
++	{ /* sentinel */ },
++};
++
++MODULE_DEVICE_TABLE(of, rp1dpi_of_match);
++
++static struct platform_driver rp1dpi_platform_driver = {
++	.probe		= rp1dpi_platform_probe,
++	.remove		= rp1dpi_platform_remove,
++	.shutdown	= rp1dpi_platform_shutdown,
++	.driver		= {
++		.name	= DRIVER_NAME,
++		.owner	= THIS_MODULE,
++		.of_match_table = rp1dpi_of_match,
++	},
++};
++
++module_platform_driver(rp1dpi_platform_driver);
++
++MODULE_AUTHOR("Nick Hollinghurst");
++MODULE_DESCRIPTION("DRM driver for DPI output on Raspberry Pi RP1");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi.h
+@@ -0,0 +1,69 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * DRM Driver for DSI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/types.h>
++#include <linux/io.h>
++#include <linux/clk.h>
++#include <drm/drm_device.h>
++#include <drm/drm_simple_kms_helper.h>
++
++#define MODULE_NAME "drm-rp1-dpi"
++#define DRIVER_NAME "drm-rp1-dpi"
++
++/* ---------------------------------------------------------------------- */
++
++#define RP1DPI_HW_BLOCK_DPI   0
++#define RP1DPI_HW_BLOCK_CFG   1
++#define RP1DPI_NUM_HW_BLOCKS  2
++
++#define RP1DPI_CLK_DPI      0
++#define RP1DPI_CLK_PLLDIV   1
++#define RP1DPI_CLK_PLLCORE  2
++#define RP1DPI_NUM_CLOCKS   3
++
++/* ---------------------------------------------------------------------- */
++
++struct rp1_dpi {
++	/* DRM and platform device pointers */
++	struct drm_device *drm;
++	struct platform_device *pdev;
++
++	/* Framework and helper objects */
++	struct drm_simple_display_pipe pipe;
++	struct drm_connector connector;
++
++	/* Clocks: Video PLL, its primary divider, and DPI clock. */
++	struct clk *clocks[RP1DPI_NUM_CLOCKS];
++
++	/* Block (DPI, VOCFG) base addresses, and current state */
++	void __iomem *hw_base[RP1DPI_NUM_HW_BLOCKS];
++	u32 cur_fmt;
++	u32 bus_fmt;
++	bool de_inv, clk_inv;
++	bool dpi_running, pipe_enabled;
++	struct completion finished;
++};
++
++/* ---------------------------------------------------------------------- */
++/* Functions to control the DPI/DMA block				  */
++
++void rp1dpi_hw_setup(struct rp1_dpi *dpi,
++		     u32 in_format,
++		     u32 bus_format,
++		     bool de_inv,
++		     struct drm_display_mode const *mode);
++void rp1dpi_hw_update(struct rp1_dpi *dpi, dma_addr_t addr, u32 offset, u32 stride);
++void rp1dpi_hw_stop(struct rp1_dpi *dpi);
++int rp1dpi_hw_busy(struct rp1_dpi *dpi);
++irqreturn_t rp1dpi_hw_isr(int irq, void *dev);
++void rp1dpi_hw_vblank_ctrl(struct rp1_dpi *dpi, int enable);
++
++/* ---------------------------------------------------------------------- */
++/* Functions to control the VIDEO OUT CFG block and check RP1 platform	  */
++
++void rp1dpi_vidout_setup(struct rp1_dpi *dpi, bool drive_negedge);
++void rp1dpi_vidout_poweroff(struct rp1_dpi *dpi);
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi_cfg.c
+@@ -0,0 +1,510 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for DPI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/mm.h>
++#include <linux/delay.h>
++#include <linux/interrupt.h>
++#include <linux/platform_device.h>
++#include <linux/printk.h>
++#include <linux/rp1_platform.h>
++
++#include "rp1_dpi.h"
++
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_SEL
++// JTAG access : synchronous
++// Description : Selects source: VEC or DPI
++#define VIDEO_OUT_CFG_SEL_OFFSET 0x00000000
++#define VIDEO_OUT_CFG_SEL_BITS	 0x00000013
++#define VIDEO_OUT_CFG_SEL_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_SEL_PCLK_INV
++// Description : Select dpi_pclk output port polarity inversion.
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_RESET  0x0
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_BITS	  0x00000010
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_MSB	  4
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_LSB	  4
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_SEL_PAD_MUX
++// Description : VEC 1 DPI 0
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_RESET	 0x0
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_BITS	 0x00000002
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_MSB	 1
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_LSB	 1
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_SEL_VDAC_MUX
++// Description : VEC 1 DPI 0
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_RESET  0x0
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_BITS	  0x00000001
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_MSB	  0
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_LSB	  0
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_VDAC_CFG
++// JTAG access : synchronous
++// Description : Configure SNPS VDAC
++#define VIDEO_OUT_CFG_VDAC_CFG_OFFSET 0x00000004
++#define VIDEO_OUT_CFG_VDAC_CFG_BITS   0x1fffffff
++#define VIDEO_OUT_CFG_VDAC_CFG_RESET  0x0003ffff
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENCTR
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_BITS   0x1c000000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_MSB    28
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_LSB    26
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENSC
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_BITS   0x03800000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_MSB	   25
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_LSB	   23
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENDAC
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_BITS   0x00700000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_MSB    22
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_LSB    20
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENVBG
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_BITS   0x00080000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_MSB    19
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_LSB    19
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_BITS   0x00040000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_MSB    18
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_LSB    18
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_DAC2GC
++// Description : dac2 gain control
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_RESET  0x3f
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_BITS   0x0003f000
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_MSB    17
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_LSB    12
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_DAC1GC
++// Description : dac1 gain control
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_RESET  0x3f
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_BITS   0x00000fc0
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_MSB    11
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_LSB    6
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_DAC0GC
++// Description : dac0 gain control
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_RESET  0x3f
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_BITS   0x0000003f
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_MSB    5
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_LSB    0
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_VDAC_STATUS
++// JTAG access : synchronous
++// Description : Read VDAC status
++#define VIDEO_OUT_CFG_VDAC_STATUS_OFFSET 0x00000008
++#define VIDEO_OUT_CFG_VDAC_STATUS_BITS	 0x00000017
++#define VIDEO_OUT_CFG_VDAC_STATUS_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_RESET	0x0
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_BITS	0x00000010
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_MSB	4
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_LSB	4
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_RESET  "-"
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_BITS	  0x00000007
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_MSB	  2
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_LSB	  0
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_MEM_PD
++// JTAG access : synchronous
++// Description : Control memory power down
++#define VIDEO_OUT_CFG_MEM_PD_OFFSET 0x0000000c
++#define VIDEO_OUT_CFG_MEM_PD_BITS   0x00000003
++#define VIDEO_OUT_CFG_MEM_PD_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_MEM_PD_VEC
++// Description : None
++#define VIDEO_OUT_CFG_MEM_PD_VEC_RESET	0x0
++#define VIDEO_OUT_CFG_MEM_PD_VEC_BITS	0x00000002
++#define VIDEO_OUT_CFG_MEM_PD_VEC_MSB	1
++#define VIDEO_OUT_CFG_MEM_PD_VEC_LSB	1
++#define VIDEO_OUT_CFG_MEM_PD_VEC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_MEM_PD_DPI
++// Description : None
++#define VIDEO_OUT_CFG_MEM_PD_DPI_RESET	0x0
++#define VIDEO_OUT_CFG_MEM_PD_DPI_BITS	0x00000001
++#define VIDEO_OUT_CFG_MEM_PD_DPI_MSB	0
++#define VIDEO_OUT_CFG_MEM_PD_DPI_LSB	0
++#define VIDEO_OUT_CFG_MEM_PD_DPI_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_TEST_OVERRIDE
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_OFFSET 0x00000010
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_BITS   0xffffffff
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_TEST_OVERRIDE_PAD
++// Description : None
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_RESET  0x0
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_BITS   0x80000000
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_MSB    31
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_LSB    31
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC
++// Description : None
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_RESET	0x0
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_BITS	0x40000000
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_MSB	30
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_LSB	30
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL
++// Description : None
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_RESET  0x00000000
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_BITS	  0x3fffffff
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_MSB	  29
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_LSB	  0
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INTR
++// JTAG access : synchronous
++// Description : Raw Interrupts
++#define VIDEO_OUT_CFG_INTR_OFFSET 0x00000014
++#define VIDEO_OUT_CFG_INTR_BITS	  0x00000003
++#define VIDEO_OUT_CFG_INTR_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTR_DPI
++// Description : None
++#define VIDEO_OUT_CFG_INTR_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_INTR_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_INTR_DPI_MSB    1
++#define VIDEO_OUT_CFG_INTR_DPI_LSB    1
++#define VIDEO_OUT_CFG_INTR_DPI_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTR_VEC
++// Description : None
++#define VIDEO_OUT_CFG_INTR_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_INTR_VEC_BITS   0x00000001
++#define VIDEO_OUT_CFG_INTR_VEC_MSB    0
++#define VIDEO_OUT_CFG_INTR_VEC_LSB    0
++#define VIDEO_OUT_CFG_INTR_VEC_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INTE
++// JTAG access : synchronous
++// Description : Interrupt Enable
++#define VIDEO_OUT_CFG_INTE_OFFSET 0x00000018
++#define VIDEO_OUT_CFG_INTE_BITS	  0x00000003
++#define VIDEO_OUT_CFG_INTE_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTE_DPI
++// Description : None
++#define VIDEO_OUT_CFG_INTE_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_INTE_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_INTE_DPI_MSB    1
++#define VIDEO_OUT_CFG_INTE_DPI_LSB    1
++#define VIDEO_OUT_CFG_INTE_DPI_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTE_VEC
++// Description : None
++#define VIDEO_OUT_CFG_INTE_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_INTE_VEC_BITS   0x00000001
++#define VIDEO_OUT_CFG_INTE_VEC_MSB    0
++#define VIDEO_OUT_CFG_INTE_VEC_LSB    0
++#define VIDEO_OUT_CFG_INTE_VEC_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INTF
++// JTAG access : synchronous
++// Description : Interrupt Force
++#define VIDEO_OUT_CFG_INTF_OFFSET 0x0000001c
++#define VIDEO_OUT_CFG_INTF_BITS	  0x00000003
++#define VIDEO_OUT_CFG_INTF_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTF_DPI
++// Description : None
++#define VIDEO_OUT_CFG_INTF_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_INTF_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_INTF_DPI_MSB    1
++#define VIDEO_OUT_CFG_INTF_DPI_LSB    1
++#define VIDEO_OUT_CFG_INTF_DPI_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTF_VEC
++// Description : None
++#define VIDEO_OUT_CFG_INTF_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_INTF_VEC_BITS   0x00000001
++#define VIDEO_OUT_CFG_INTF_VEC_MSB    0
++#define VIDEO_OUT_CFG_INTF_VEC_LSB    0
++#define VIDEO_OUT_CFG_INTF_VEC_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INTS
++// JTAG access : synchronous
++// Description : Interrupt status after masking & forcing
++#define VIDEO_OUT_CFG_INTS_OFFSET 0x00000020
++#define VIDEO_OUT_CFG_INTS_BITS	  0x00000003
++#define VIDEO_OUT_CFG_INTS_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTS_DPI
++// Description : None
++#define VIDEO_OUT_CFG_INTS_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_INTS_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_INTS_DPI_MSB    1
++#define VIDEO_OUT_CFG_INTS_DPI_LSB    1
++#define VIDEO_OUT_CFG_INTS_DPI_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTS_VEC
++// Description : None
++#define VIDEO_OUT_CFG_INTS_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_INTS_VEC_BITS   0x00000001
++#define VIDEO_OUT_CFG_INTS_VEC_MSB    0
++#define VIDEO_OUT_CFG_INTS_VEC_LSB    0
++#define VIDEO_OUT_CFG_INTS_VEC_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_BLOCK_ID
++// JTAG access : synchronous
++// Description : Block Identifier
++//		 Hexadecimal representation of "VOCF"
++#define VIDEO_OUT_CFG_BLOCK_ID_OFFSET 0x00000024
++#define VIDEO_OUT_CFG_BLOCK_ID_BITS   0xffffffff
++#define VIDEO_OUT_CFG_BLOCK_ID_RESET  0x564f4346
++#define VIDEO_OUT_CFG_BLOCK_ID_MSB    31
++#define VIDEO_OUT_CFG_BLOCK_ID_LSB    0
++#define VIDEO_OUT_CFG_BLOCK_ID_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INSTANCE_ID
++// JTAG access : synchronous
++// Description : Block Instance Identifier
++#define VIDEO_OUT_CFG_INSTANCE_ID_OFFSET 0x00000028
++#define VIDEO_OUT_CFG_INSTANCE_ID_BITS	 0x0000000f
++#define VIDEO_OUT_CFG_INSTANCE_ID_RESET	 0x00000000
++#define VIDEO_OUT_CFG_INSTANCE_ID_MSB	 3
++#define VIDEO_OUT_CFG_INSTANCE_ID_LSB	 0
++#define VIDEO_OUT_CFG_INSTANCE_ID_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_AUTO
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_OFFSET 0x0000002c
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BITS	 0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_RESET	 0x00000007
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC
++// Description : 1 = reset is controlled by the sequencer
++//		 0 = reset is controlled by rstseq_ctrl
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_RESET  0x1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_BITS   0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_MSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_LSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI
++// Description : 1 = reset is controlled by the sequencer
++//		 0 = reset is controlled by rstseq_ctrl
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_RESET  0x1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_MSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_LSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER
++// Description : 1 = reset is controlled by the sequencer
++//		 0 = reset is controlled by rstseq_ctrl
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_RESET  0x1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_BITS   0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_MSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_LSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_PARALLEL
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_OFFSET 0x00000030
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BITS   0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_RESET  0x00000006
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_RESET	 0x1
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_BITS	 0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_MSB	 2
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_LSB	 2
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_RESET	 0x1
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_BITS	 0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_MSB	 1
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_LSB	 1
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_RESET	0x0
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_BITS	0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_MSB	0
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_LSB	0
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_CTRL
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_OFFSET 0x00000034
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BITS	 0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC
++// Description : 1 = keep the reset asserted
++//		 0 = keep the reset deasserted
++//		 This is ignored if rstseq_auto=1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_BITS   0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_MSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_LSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI
++// Description : 1 = keep the reset asserted
++//		 0 = keep the reset deasserted
++//		 This is ignored if rstseq_auto=1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_MSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_LSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER
++// Description : 1 = keep the reset asserted
++//		 0 = keep the reset deasserted
++//		 This is ignored if rstseq_auto=1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_BITS   0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_MSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_LSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_TRIG
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_OFFSET 0x00000038
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BITS	 0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC
++// Description : Pulses the reset output
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_BITS   0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_MSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_LSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_ACCESS "SC"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI
++// Description : Pulses the reset output
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_MSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_LSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_ACCESS "SC"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER
++// Description : Pulses the reset output
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_BITS   0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_MSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_LSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_ACCESS "SC"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_DONE
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_OFFSET 0x0000003c
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BITS	 0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_DONE_VEC
++// Description : Indicates the current state of the reset
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_BITS   0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_MSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_LSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_DONE_DPI
++// Description : Indicates the current state of the reset
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_MSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_LSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER
++// Description : Indicates the current state of the reset
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_BITS   0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_MSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_LSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_ACCESS "RO"
++// =============================================================================
++
++#define CFG_WRITE(reg, val)  writel((val),  dpi->hw_base[RP1DPI_HW_BLOCK_CFG] + (reg ## _OFFSET))
++#define CFG_READ(reg)	     readl(dpi->hw_base[RP1DPI_HW_BLOCK_CFG] + (reg ## _OFFSET))
++
++void rp1dpi_vidout_setup(struct rp1_dpi *dpi, bool drive_negedge)
++{
++	/*
++	 * We assume DPI and VEC can't be used at the same time (due to
++	 * clashing requirements for PLL_VIDEO, and potentially for VDAC).
++	 * We therefore leave VEC memories powered down.
++	 */
++	CFG_WRITE(VIDEO_OUT_CFG_MEM_PD, VIDEO_OUT_CFG_MEM_PD_VEC_BITS);
++	CFG_WRITE(VIDEO_OUT_CFG_TEST_OVERRIDE,
++		  VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_BITS);
++
++	/* DPI->Pads; DPI->VDAC; optionally flip PCLK polarity */
++	CFG_WRITE(VIDEO_OUT_CFG_SEL,
++		  drive_negedge ? VIDEO_OUT_CFG_SEL_PCLK_INV_BITS : 0);
++
++	/* configure VDAC for 3 channels, bandgap on, 710mV swing */
++	CFG_WRITE(VIDEO_OUT_CFG_VDAC_CFG, 0);
++
++	/* enable DPI interrupt */
++	CFG_WRITE(VIDEO_OUT_CFG_INTE, VIDEO_OUT_CFG_INTE_DPI_BITS);
++}
++
++void rp1dpi_vidout_poweroff(struct rp1_dpi *dpi)
++{
++	/* disable DPI interrupt */
++	CFG_WRITE(VIDEO_OUT_CFG_INTE, 0);
++
++	/* Ensure VDAC is turned off; power down DPI,VEC memories */
++	CFG_WRITE(VIDEO_OUT_CFG_VDAC_CFG, 0);
++	CFG_WRITE(VIDEO_OUT_CFG_MEM_PD, VIDEO_OUT_CFG_MEM_PD_BITS);
++}
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-dpi/rp1_dpi_hw.c
+@@ -0,0 +1,486 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for DPI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/mm.h>
++#include <linux/delay.h>
++#include <linux/interrupt.h>
++#include <linux/media-bus-format.h>
++#include <linux/platform_device.h>
++#include <linux/printk.h>
++#include <drm/drm_fourcc.h>
++#include <drm/drm_print.h>
++#include <drm/drm_vblank.h>
++
++#include "rp1_dpi.h"
++
++// --- DPI DMA REGISTERS ---
++
++// Control
++#define DPI_DMA_CONTROL				      0x0
++#define DPI_DMA_CONTROL_ARM_SHIFT		      0
++#define DPI_DMA_CONTROL_ARM_MASK		      BIT(DPI_DMA_CONTROL_ARM_SHIFT)
++#define DPI_DMA_CONTROL_ALIGN16_SHIFT		      2
++#define DPI_DMA_CONTROL_ALIGN16_MASK		      BIT(DPI_DMA_CONTROL_ALIGN16_SHIFT)
++#define DPI_DMA_CONTROL_AUTO_REPEAT_SHIFT	      1
++#define DPI_DMA_CONTROL_AUTO_REPEAT_MASK	      BIT(DPI_DMA_CONTROL_AUTO_REPEAT_SHIFT)
++#define DPI_DMA_CONTROL_HIGH_WATER_SHIFT	      3
++#define DPI_DMA_CONTROL_HIGH_WATER_MASK		      (0x1FF << DPI_DMA_CONTROL_HIGH_WATER_SHIFT)
++#define DPI_DMA_CONTROL_DEN_POL_SHIFT		      12
++#define DPI_DMA_CONTROL_DEN_POL_MASK		      BIT(DPI_DMA_CONTROL_DEN_POL_SHIFT)
++#define DPI_DMA_CONTROL_HSYNC_POL_SHIFT		      13
++#define DPI_DMA_CONTROL_HSYNC_POL_MASK		      BIT(DPI_DMA_CONTROL_HSYNC_POL_SHIFT)
++#define DPI_DMA_CONTROL_VSYNC_POL_SHIFT		      14
++#define DPI_DMA_CONTROL_VSYNC_POL_MASK		      BIT(DPI_DMA_CONTROL_VSYNC_POL_SHIFT)
++#define DPI_DMA_CONTROL_COLORM_SHIFT		      15
++#define DPI_DMA_CONTROL_COLORM_MASK		      BIT(DPI_DMA_CONTROL_COLORM_SHIFT)
++#define DPI_DMA_CONTROL_SHUTDN_SHIFT		      16
++#define DPI_DMA_CONTROL_SHUTDN_MASK		      BIT(DPI_DMA_CONTROL_SHUTDN_SHIFT)
++#define DPI_DMA_CONTROL_HBP_EN_SHIFT		      17
++#define DPI_DMA_CONTROL_HBP_EN_MASK		      BIT(DPI_DMA_CONTROL_HBP_EN_SHIFT)
++#define DPI_DMA_CONTROL_HFP_EN_SHIFT		      18
++#define DPI_DMA_CONTROL_HFP_EN_MASK		      BIT(DPI_DMA_CONTROL_HFP_EN_SHIFT)
++#define DPI_DMA_CONTROL_VBP_EN_SHIFT		      19
++#define DPI_DMA_CONTROL_VBP_EN_MASK		      BIT(DPI_DMA_CONTROL_VBP_EN_SHIFT)
++#define DPI_DMA_CONTROL_VFP_EN_SHIFT		      20
++#define DPI_DMA_CONTROL_VFP_EN_MASK		      BIT(DPI_DMA_CONTROL_VFP_EN_SHIFT)
++#define DPI_DMA_CONTROL_HSYNC_EN_SHIFT		      21
++#define DPI_DMA_CONTROL_HSYNC_EN_MASK		      BIT(DPI_DMA_CONTROL_HSYNC_EN_SHIFT)
++#define DPI_DMA_CONTROL_VSYNC_EN_SHIFT		      22
++#define DPI_DMA_CONTROL_VSYNC_EN_MASK		      BIT(DPI_DMA_CONTROL_VSYNC_EN_SHIFT)
++#define DPI_DMA_CONTROL_FORCE_IMMED_SHIFT	      23
++#define DPI_DMA_CONTROL_FORCE_IMMED_MASK	      BIT(DPI_DMA_CONTROL_FORCE_IMMED_SHIFT)
++#define DPI_DMA_CONTROL_FORCE_DRAIN_SHIFT	      24
++#define DPI_DMA_CONTROL_FORCE_DRAIN_MASK	      BIT(DPI_DMA_CONTROL_FORCE_DRAIN_SHIFT)
++#define DPI_DMA_CONTROL_FORCE_EMPTY_SHIFT	      25
++#define DPI_DMA_CONTROL_FORCE_EMPTY_MASK	      BIT(DPI_DMA_CONTROL_FORCE_EMPTY_SHIFT)
++
++// IRQ_ENABLES
++#define DPI_DMA_IRQ_EN				      0x04
++#define DPI_DMA_IRQ_EN_DMA_READY_SHIFT		      0
++#define DPI_DMA_IRQ_EN_DMA_READY_MASK		      BIT(DPI_DMA_IRQ_EN_DMA_READY_SHIFT)
++#define DPI_DMA_IRQ_EN_UNDERFLOW_SHIFT		      1
++#define DPI_DMA_IRQ_EN_UNDERFLOW_MASK		      BIT(DPI_DMA_IRQ_EN_UNDERFLOW_SHIFT)
++#define DPI_DMA_IRQ_EN_FRAME_START_SHIFT	      2
++#define DPI_DMA_IRQ_EN_FRAME_START_MASK		      BIT(DPI_DMA_IRQ_EN_FRAME_START_SHIFT)
++#define DPI_DMA_IRQ_EN_AFIFO_EMPTY_SHIFT	      3
++#define DPI_DMA_IRQ_EN_AFIFO_EMPTY_MASK		      BIT(DPI_DMA_IRQ_EN_AFIFO_EMPTY_SHIFT)
++#define DPI_DMA_IRQ_EN_TE_SHIFT			      4
++#define DPI_DMA_IRQ_EN_TE_MASK			      BIT(DPI_DMA_IRQ_EN_TE_SHIFT)
++#define DPI_DMA_IRQ_EN_ERROR_SHIFT		      5
++#define DPI_DMA_IRQ_EN_ERROR_MASK		      BIT(DPI_DMA_IRQ_EN_ERROR_SHIFT)
++#define DPI_DMA_IRQ_EN_MATCH_SHIFT		      6
++#define DPI_DMA_IRQ_EN_MATCH_MASK		      BIT(DPI_DMA_IRQ_EN_MATCH_SHIFT)
++#define DPI_DMA_IRQ_EN_MATCH_LINE_SHIFT		      16
++#define DPI_DMA_IRQ_EN_MATCH_LINE_MASK		      (0xFFF << DPI_DMA_IRQ_EN_MATCH_LINE_SHIFT)
++
++// IRQ_FLAGS
++#define DPI_DMA_IRQ_FLAGS			      0x08
++#define DPI_DMA_IRQ_FLAGS_DMA_READY_SHIFT	      0
++#define DPI_DMA_IRQ_FLAGS_DMA_READY_MASK	      BIT(DPI_DMA_IRQ_FLAGS_DMA_READY_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_UNDERFLOW_SHIFT	      1
++#define DPI_DMA_IRQ_FLAGS_UNDERFLOW_MASK	      BIT(DPI_DMA_IRQ_FLAGS_UNDERFLOW_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_FRAME_START_SHIFT	      2
++#define DPI_DMA_IRQ_FLAGS_FRAME_START_MASK	      BIT(DPI_DMA_IRQ_FLAGS_FRAME_START_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_AFIFO_EMPTY_SHIFT	      3
++#define DPI_DMA_IRQ_FLAGS_AFIFO_EMPTY_MASK	      BIT(DPI_DMA_IRQ_FLAGS_AFIFO_EMPTY_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_TE_SHIFT		      4
++#define DPI_DMA_IRQ_FLAGS_TE_MASK		      BIT(DPI_DMA_IRQ_FLAGS_TE_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_ERROR_SHIFT		      5
++#define DPI_DMA_IRQ_FLAGS_ERROR_MASK		      BIT(DPI_DMA_IRQ_FLAGS_ERROR_SHIFT)
++#define DPI_DMA_IRQ_FLAGS_MATCH_SHIFT		      6
++#define DPI_DMA_IRQ_FLAGS_MATCH_MASK		      BIT(DPI_DMA_IRQ_FLAGS_MATCH_SHIFT)
++
++// QOS
++#define DPI_DMA_QOS				      0xC
++#define DPI_DMA_QOS_DQOS_SHIFT			      0
++#define DPI_DMA_QOS_DQOS_MASK			      (0xF << DPI_DMA_QOS_DQOS_SHIFT)
++#define DPI_DMA_QOS_ULEV_SHIFT			      4
++#define DPI_DMA_QOS_ULEV_MASK			      (0xF << DPI_DMA_QOS_ULEV_SHIFT)
++#define DPI_DMA_QOS_UQOS_SHIFT			      8
++#define DPI_DMA_QOS_UQOS_MASK			      (0xF << DPI_DMA_QOS_UQOS_SHIFT)
++#define DPI_DMA_QOS_LLEV_SHIFT			      12
++#define DPI_DMA_QOS_LLEV_MASK			      (0xF << DPI_DMA_QOS_LLEV_SHIFT)
++#define DPI_DMA_QOS_LQOS_SHIFT			      16
++#define DPI_DMA_QOS_LQOS_MASK			      (0xF << DPI_DMA_QOS_LQOS_SHIFT)
++
++// Panics
++#define DPI_DMA_PANICS				     0x38
++#define DPI_DMA_PANICS_UPPER_COUNT_SHIFT	     0
++#define DPI_DMA_PANICS_UPPER_COUNT_MASK		     \
++				(0x0000FFFF << DPI_DMA_PANICS_UPPER_COUNT_SHIFT)
++#define DPI_DMA_PANICS_LOWER_COUNT_SHIFT	     16
++#define DPI_DMA_PANICS_LOWER_COUNT_MASK		     \
++				(0x0000FFFF << DPI_DMA_PANICS_LOWER_COUNT_SHIFT)
++
++// DMA Address Lower:
++#define DPI_DMA_DMA_ADDR_L			     0x10
++
++// DMA Address Upper:
++#define DPI_DMA_DMA_ADDR_H			     0x40
++
++// DMA stride
++#define DPI_DMA_DMA_STRIDE			     0x14
++
++// Visible Area
++#define DPI_DMA_VISIBLE_AREA			     0x18
++#define DPI_DMA_VISIBLE_AREA_ROWSM1_SHIFT     0
++#define DPI_DMA_VISIBLE_AREA_ROWSM1_MASK     (0x0FFF << DPI_DMA_VISIBLE_AREA_ROWSM1_SHIFT)
++#define DPI_DMA_VISIBLE_AREA_COLSM1_SHIFT    16
++#define DPI_DMA_VISIBLE_AREA_COLSM1_MASK     (0x0FFF << DPI_DMA_VISIBLE_AREA_COLSM1_SHIFT)
++
++// Sync width
++#define DPI_DMA_SYNC_WIDTH   0x1C
++#define DPI_DMA_SYNC_WIDTH_ROWSM1_SHIFT	 0
++#define DPI_DMA_SYNC_WIDTH_ROWSM1_MASK	 (0x0FFF << DPI_DMA_SYNC_WIDTH_ROWSM1_SHIFT)
++#define DPI_DMA_SYNC_WIDTH_COLSM1_SHIFT	 16
++#define DPI_DMA_SYNC_WIDTH_COLSM1_MASK	 (0x0FFF << DPI_DMA_SYNC_WIDTH_COLSM1_SHIFT)
++
++// Back porch
++#define DPI_DMA_BACK_PORCH   0x20
++#define DPI_DMA_BACK_PORCH_ROWSM1_SHIFT	 0
++#define DPI_DMA_BACK_PORCH_ROWSM1_MASK	 (0x0FFF << DPI_DMA_BACK_PORCH_ROWSM1_SHIFT)
++#define DPI_DMA_BACK_PORCH_COLSM1_SHIFT	 16
++#define DPI_DMA_BACK_PORCH_COLSM1_MASK	 (0x0FFF << DPI_DMA_BACK_PORCH_COLSM1_SHIFT)
++
++// Front porch
++#define DPI_DMA_FRONT_PORCH  0x24
++#define DPI_DMA_FRONT_PORCH_ROWSM1_SHIFT     0
++#define DPI_DMA_FRONT_PORCH_ROWSM1_MASK	 (0x0FFF << DPI_DMA_FRONT_PORCH_ROWSM1_SHIFT)
++#define DPI_DMA_FRONT_PORCH_COLSM1_SHIFT     16
++#define DPI_DMA_FRONT_PORCH_COLSM1_MASK	 (0x0FFF << DPI_DMA_FRONT_PORCH_COLSM1_SHIFT)
++
++// Input masks
++#define DPI_DMA_IMASK	 0x2C
++#define DPI_DMA_IMASK_R_SHIFT	 0
++#define DPI_DMA_IMASK_R_MASK	 (0x3FF << DPI_DMA_IMASK_R_SHIFT)
++#define DPI_DMA_IMASK_G_SHIFT	 10
++#define DPI_DMA_IMASK_G_MASK	 (0x3FF << DPI_DMA_IMASK_G_SHIFT)
++#define DPI_DMA_IMASK_B_SHIFT	 20
++#define DPI_DMA_IMASK_B_MASK	 (0x3FF << DPI_DMA_IMASK_B_SHIFT)
++
++// Output Masks
++#define DPI_DMA_OMASK	 0x30
++#define DPI_DMA_OMASK_R_SHIFT	 0
++#define DPI_DMA_OMASK_R_MASK	 (0x3FF << DPI_DMA_OMASK_R_SHIFT)
++#define DPI_DMA_OMASK_G_SHIFT	 10
++#define DPI_DMA_OMASK_G_MASK	 (0x3FF << DPI_DMA_OMASK_G_SHIFT)
++#define DPI_DMA_OMASK_B_SHIFT	 20
++#define DPI_DMA_OMASK_B_MASK	 (0x3FF << DPI_DMA_OMASK_B_SHIFT)
++
++// Shifts
++#define DPI_DMA_SHIFT	 0x28
++#define DPI_DMA_SHIFT_IR_SHIFT	 0
++#define DPI_DMA_SHIFT_IR_MASK	 (0x1F << DPI_DMA_SHIFT_IR_SHIFT)
++#define DPI_DMA_SHIFT_IG_SHIFT	 5
++#define DPI_DMA_SHIFT_IG_MASK	 (0x1F << DPI_DMA_SHIFT_IG_SHIFT)
++#define DPI_DMA_SHIFT_IB_SHIFT	 10
++#define DPI_DMA_SHIFT_IB_MASK	 (0x1F << DPI_DMA_SHIFT_IB_SHIFT)
++#define DPI_DMA_SHIFT_OR_SHIFT	 15
++#define DPI_DMA_SHIFT_OR_MASK	 (0x1F << DPI_DMA_SHIFT_OR_SHIFT)
++#define DPI_DMA_SHIFT_OG_SHIFT	 20
++#define DPI_DMA_SHIFT_OG_MASK	 (0x1F << DPI_DMA_SHIFT_OG_SHIFT)
++#define DPI_DMA_SHIFT_OB_SHIFT	 25
++#define DPI_DMA_SHIFT_OB_MASK	 (0x1F << DPI_DMA_SHIFT_OB_SHIFT)
++
++// Scaling
++#define DPI_DMA_RGBSZ	 0x34
++#define DPI_DMA_RGBSZ_BPP_SHIFT	 16
++#define DPI_DMA_RGBSZ_BPP_MASK	 (0x3 << DPI_DMA_RGBSZ_BPP_SHIFT)
++#define DPI_DMA_RGBSZ_R_SHIFT	 0
++#define DPI_DMA_RGBSZ_R_MASK	 (0xF << DPI_DMA_RGBSZ_R_SHIFT)
++#define DPI_DMA_RGBSZ_G_SHIFT	 4
++#define DPI_DMA_RGBSZ_G_MASK	 (0xF << DPI_DMA_RGBSZ_G_SHIFT)
++#define DPI_DMA_RGBSZ_B_SHIFT	 8
++#define DPI_DMA_RGBSZ_B_MASK	 (0xF << DPI_DMA_RGBSZ_B_SHIFT)
++
++// Status
++#define DPI_DMA_STATUS  0x3c
++
++#define BITS(field, val) (((val) << (field ## _SHIFT)) & (field ## _MASK))
++
++static unsigned int rp1dpi_hw_read(struct rp1_dpi *dpi, unsigned int reg)
++{
++	void __iomem *addr = dpi->hw_base[RP1DPI_HW_BLOCK_DPI] + reg;
++
++	return readl(addr);
++}
++
++static void rp1dpi_hw_write(struct rp1_dpi *dpi, unsigned int reg, unsigned int val)
++{
++	void __iomem *addr = dpi->hw_base[RP1DPI_HW_BLOCK_DPI] + reg;
++
++	writel(val, addr);
++}
++
++int rp1dpi_hw_busy(struct rp1_dpi *dpi)
++{
++	return (rp1dpi_hw_read(dpi, DPI_DMA_STATUS) & 0xF8F) ? 1 : 0;
++}
++
++/* Table of supported input (in-memory/DMA) pixel formats. */
++struct rp1dpi_ipixfmt {
++	u32 format; /* DRM format code                           */
++	u32 mask;   /* RGB masks (10 bits each, left justified)  */
++	u32 shift;  /* RGB MSB positions in the memory word      */
++	u32 rgbsz;  /* Shifts used for scaling; also (BPP/8-1)   */
++};
++
++#define IMASK_RGB(r, g, b)	(BITS(DPI_DMA_IMASK_R, r)  | \
++				 BITS(DPI_DMA_IMASK_G, g)  | \
++				 BITS(DPI_DMA_IMASK_B, b))
++#define OMASK_RGB(r, g, b)	(BITS(DPI_DMA_OMASK_R, r)  | \
++				 BITS(DPI_DMA_OMASK_G, g)  | \
++				 BITS(DPI_DMA_OMASK_B, b))
++#define ISHIFT_RGB(r, g, b)	(BITS(DPI_DMA_SHIFT_IR, r) | \
++				 BITS(DPI_DMA_SHIFT_IG, g) | \
++				 BITS(DPI_DMA_SHIFT_IB, b))
++#define OSHIFT_RGB(r, g, b)	(BITS(DPI_DMA_SHIFT_OR, r) | \
++				 BITS(DPI_DMA_SHIFT_OG, g) | \
++				 BITS(DPI_DMA_SHIFT_OB, b))
++
++static const struct rp1dpi_ipixfmt my_formats[] = {
++	{
++	  .format = DRM_FORMAT_XRGB8888,
++	  .mask	  = IMASK_RGB(0x3fc, 0x3fc, 0x3fc),
++	  .shift  = ISHIFT_RGB(23, 15, 7),
++	  .rgbsz  = BITS(DPI_DMA_RGBSZ_BPP, 3),
++	},
++	{
++	  .format = DRM_FORMAT_XBGR8888,
++	  .mask	  = IMASK_RGB(0x3fc, 0x3fc, 0x3fc),
++	  .shift  = ISHIFT_RGB(7, 15, 23),
++	  .rgbsz  = BITS(DPI_DMA_RGBSZ_BPP, 3),
++	},
++	{
++	  .format = DRM_FORMAT_RGB888,
++	  .mask	  = IMASK_RGB(0x3fc, 0x3fc, 0x3fc),
++	  .shift  = ISHIFT_RGB(23, 15, 7),
++	  .rgbsz  = BITS(DPI_DMA_RGBSZ_BPP, 2),
++	},
++	{
++	  .format = DRM_FORMAT_BGR888,
++	  .mask	  = IMASK_RGB(0x3fc, 0x3fc, 0x3fc),
++	  .shift  = ISHIFT_RGB(7, 15, 23),
++	  .rgbsz  = BITS(DPI_DMA_RGBSZ_BPP, 2),
++	},
++	{
++	  .format = DRM_FORMAT_RGB565,
++	  .mask	  = IMASK_RGB(0x3e0, 0x3f0, 0x3e0),
++	  .shift  = ISHIFT_RGB(15, 10, 4),
++	  .rgbsz  = BITS(DPI_DMA_RGBSZ_R, 5) | BITS(DPI_DMA_RGBSZ_G, 6) |
++		    BITS(DPI_DMA_RGBSZ_B, 5) | BITS(DPI_DMA_RGBSZ_BPP, 1),
++	},
++	{
++	  .format = DRM_FORMAT_BGR565,
++	  .mask	  = IMASK_RGB(0x3e0, 0x3f0, 0x3e0),
++	  .shift  = ISHIFT_RGB(4, 10, 15),
++	  .rgbsz  = BITS(DPI_DMA_RGBSZ_R, 5) | BITS(DPI_DMA_RGBSZ_G, 6) |
++		    BITS(DPI_DMA_RGBSZ_B, 5) | BITS(DPI_DMA_RGBSZ_BPP, 1),
++	}
++};
++
++static u32 set_output_format(u32 bus_format, u32 *shift, u32 *imask, u32 *rgbsz)
++{
++	switch (bus_format) {
++	case MEDIA_BUS_FMT_RGB565_1X16:
++		if (*shift == ISHIFT_RGB(15, 10, 4)) {
++			/* When framebuffer is RGB565, we can output RGB565 */
++			*shift = ISHIFT_RGB(15, 7, 0) | OSHIFT_RGB(19, 9, 0);
++			*rgbsz &= DPI_DMA_RGBSZ_BPP_MASK;
++			return OMASK_RGB(0x3fc, 0x3fc, 0);
++		}
++
++		/* due to a HW limitation, bit-depth is effectively RGB535 */
++		*shift |= OSHIFT_RGB(19, 14, 6);
++		*imask &= IMASK_RGB(0x3e0, 0x380, 0x3e0);
++		*rgbsz = BITS(DPI_DMA_RGBSZ_G, 5) | (*rgbsz & DPI_DMA_RGBSZ_BPP_MASK);
++		return OMASK_RGB(0x3e0, 0x39c, 0x3e0);
++
++	case MEDIA_BUS_FMT_RGB666_1X18:
++	case MEDIA_BUS_FMT_BGR666_1X18:
++		/* due to a HW limitation, bit-depth is effectively RGB444 */
++		*shift |= OSHIFT_RGB(23, 15, 7);
++		*imask &= IMASK_RGB(0x3c0, 0x3c0, 0x3c0);
++		*rgbsz = BITS(DPI_DMA_RGBSZ_R, 2) | (*rgbsz & DPI_DMA_RGBSZ_BPP_MASK);
++		return OMASK_RGB(0x330, 0x3c0, 0x3c0);
++
++	case MEDIA_BUS_FMT_RGB888_1X24:
++	case MEDIA_BUS_FMT_BGR888_1X24:
++	case MEDIA_BUS_FMT_RGB101010_1X30:
++		/* The full 24 bits can be output. Note that RP1's internal wiring means
++		 * that 8.8.8 to GPIO pads can share with 10.10.10 to the onboard VDAC.
++		 */
++		*shift |= OSHIFT_RGB(29, 19, 9);
++		return OMASK_RGB(0x3fc, 0x3fc, 0x3fc);
++
++	default:
++		/* RGB666_1x24_CPADHI, BGR666_1X24_CPADHI and "RGB565_666" formats */
++		*shift |= OSHIFT_RGB(27, 17, 7);
++		*rgbsz &= DPI_DMA_RGBSZ_BPP_MASK;
++		return OMASK_RGB(0x3f0, 0x3f0, 0x3f0);
++	}
++}
++
++#define BUS_FMT_IS_BGR(fmt) (				       \
++		((fmt) == MEDIA_BUS_FMT_BGR666_1X18)        || \
++		((fmt) == MEDIA_BUS_FMT_BGR666_1X24_CPADHI) || \
++		((fmt) == MEDIA_BUS_FMT_BGR888_1X24))
++
++void rp1dpi_hw_setup(struct rp1_dpi *dpi,
++		     u32 in_format, u32 bus_format, bool de_inv,
++		    struct drm_display_mode const *mode)
++{
++	u32 shift, imask, omask, rgbsz;
++	int i;
++
++	pr_info("%s: in_fmt=\'%c%c%c%c\' bus_fmt=0x%x mode=%dx%d total=%dx%d %dkHz %cH%cV%cD%cC",
++		__func__, in_format, in_format >> 8, in_format >> 16, in_format >> 24, bus_format,
++		mode->hdisplay, mode->vdisplay,
++		mode->htotal, mode->vtotal,
++		mode->clock,
++		(mode->flags & DRM_MODE_FLAG_NHSYNC) ? '-' : '+',
++		(mode->flags & DRM_MODE_FLAG_NVSYNC) ? '-' : '+',
++		de_inv ? '-' : '+',
++		dpi->clk_inv ? '-' : '+');
++
++	/*
++	 * Configure all DPI/DMA block registers, except base address.
++	 * DMA will not actually start until a FB base address is specified
++	 * using rp1dpi_hw_update().
++	 */
++	rp1dpi_hw_write(dpi, DPI_DMA_VISIBLE_AREA,
++			BITS(DPI_DMA_VISIBLE_AREA_ROWSM1, mode->vdisplay - 1) |
++			BITS(DPI_DMA_VISIBLE_AREA_COLSM1, mode->hdisplay - 1));
++
++	rp1dpi_hw_write(dpi, DPI_DMA_SYNC_WIDTH,
++			BITS(DPI_DMA_SYNC_WIDTH_ROWSM1, mode->vsync_end - mode->vsync_start - 1) |
++			BITS(DPI_DMA_SYNC_WIDTH_COLSM1, mode->hsync_end - mode->hsync_start - 1));
++
++	/* In these registers, "back porch" time includes sync width */
++	rp1dpi_hw_write(dpi, DPI_DMA_BACK_PORCH,
++			BITS(DPI_DMA_BACK_PORCH_ROWSM1, mode->vtotal - mode->vsync_start - 1) |
++			BITS(DPI_DMA_BACK_PORCH_COLSM1, mode->htotal - mode->hsync_start - 1));
++
++	rp1dpi_hw_write(dpi, DPI_DMA_FRONT_PORCH,
++			BITS(DPI_DMA_FRONT_PORCH_ROWSM1, mode->vsync_start - mode->vdisplay - 1) |
++			BITS(DPI_DMA_FRONT_PORCH_COLSM1, mode->hsync_start - mode->hdisplay - 1));
++
++	/* Input to output pixel format conversion */
++	for (i = 0; i < ARRAY_SIZE(my_formats); ++i) {
++		if (my_formats[i].format == in_format)
++			break;
++	}
++	if (i >= ARRAY_SIZE(my_formats)) {
++		pr_err("%s: bad input format\n", __func__);
++		i = 4;
++	}
++	if (BUS_FMT_IS_BGR(bus_format))
++		i ^= 1;
++	shift = my_formats[i].shift;
++	imask = my_formats[i].mask;
++	rgbsz = my_formats[i].rgbsz;
++	omask = set_output_format(bus_format, &shift, &imask, &rgbsz);
++
++	rp1dpi_hw_write(dpi, DPI_DMA_IMASK, imask);
++	rp1dpi_hw_write(dpi, DPI_DMA_OMASK, omask);
++	rp1dpi_hw_write(dpi, DPI_DMA_SHIFT, shift);
++	rp1dpi_hw_write(dpi, DPI_DMA_RGBSZ, rgbsz);
++
++	rp1dpi_hw_write(dpi, DPI_DMA_QOS,
++			BITS(DPI_DMA_QOS_DQOS, 0x0) |
++			BITS(DPI_DMA_QOS_ULEV, 0xb) |
++			BITS(DPI_DMA_QOS_UQOS, 0x2) |
++			BITS(DPI_DMA_QOS_LLEV, 0x8) |
++			BITS(DPI_DMA_QOS_LQOS, 0x7));
++
++	rp1dpi_hw_write(dpi, DPI_DMA_IRQ_FLAGS, -1);
++	rp1dpi_hw_vblank_ctrl(dpi, 1);
++
++	i = rp1dpi_hw_busy(dpi);
++	if (i)
++		pr_warn("%s: Unexpectedly busy at start!", __func__);
++
++	rp1dpi_hw_write(dpi, DPI_DMA_CONTROL,
++			BITS(DPI_DMA_CONTROL_ARM,          !i) |
++			BITS(DPI_DMA_CONTROL_AUTO_REPEAT,   1) |
++			BITS(DPI_DMA_CONTROL_HIGH_WATER,  448) |
++			BITS(DPI_DMA_CONTROL_DEN_POL,  de_inv) |
++			BITS(DPI_DMA_CONTROL_HSYNC_POL, !!(mode->flags & DRM_MODE_FLAG_NHSYNC)) |
++			BITS(DPI_DMA_CONTROL_VSYNC_POL, !!(mode->flags & DRM_MODE_FLAG_NVSYNC)) |
++			BITS(DPI_DMA_CONTROL_COLORM,	   0) |
++			BITS(DPI_DMA_CONTROL_SHUTDN,	   0) |
++			BITS(DPI_DMA_CONTROL_HBP_EN,    (mode->htotal != mode->hsync_end))      |
++			BITS(DPI_DMA_CONTROL_HFP_EN,    (mode->hsync_start != mode->hdisplay))  |
++			BITS(DPI_DMA_CONTROL_VBP_EN,    (mode->vtotal != mode->vsync_end))      |
++			BITS(DPI_DMA_CONTROL_VFP_EN,    (mode->vsync_start != mode->vdisplay))  |
++			BITS(DPI_DMA_CONTROL_HSYNC_EN,  (mode->hsync_end != mode->hsync_start)) |
++			BITS(DPI_DMA_CONTROL_VSYNC_EN,  (mode->vsync_end != mode->vsync_start)));
++}
++
++void rp1dpi_hw_update(struct rp1_dpi *dpi, dma_addr_t addr, u32 offset, u32 stride)
++{
++	u64 a = addr + offset;
++
++	/*
++	 * Update STRIDE, DMAH and DMAL only. When called after rp1dpi_hw_setup(),
++	 * DMA starts immediately; if already running, the buffer will flip at
++	 * the next vertical sync event.
++	 */
++	rp1dpi_hw_write(dpi, DPI_DMA_DMA_STRIDE, stride);
++	rp1dpi_hw_write(dpi, DPI_DMA_DMA_ADDR_H, a >> 32);
++	rp1dpi_hw_write(dpi, DPI_DMA_DMA_ADDR_L, a & 0xFFFFFFFFu);
++}
++
++void rp1dpi_hw_stop(struct rp1_dpi *dpi)
++{
++	u32 ctrl;
++
++	/*
++	 * Stop DMA by turning off the Auto-Repeat flag, and wait up to 100ms for
++	 * the current and any queued frame to end. "Force drain" flags are not used,
++	 * as they seem to prevent DMA from re-starting properly; it's safer to wait.
++	 */
++	reinit_completion(&dpi->finished);
++	ctrl = rp1dpi_hw_read(dpi, DPI_DMA_CONTROL);
++	ctrl &= ~(DPI_DMA_CONTROL_ARM_MASK | DPI_DMA_CONTROL_AUTO_REPEAT_MASK);
++	rp1dpi_hw_write(dpi, DPI_DMA_CONTROL, ctrl);
++	if (!wait_for_completion_timeout(&dpi->finished, HZ / 10))
++		drm_err(dpi->drm, "%s: timed out waiting for idle\n", __func__);
++	rp1dpi_hw_write(dpi, DPI_DMA_IRQ_EN, 0);
++}
++
++void rp1dpi_hw_vblank_ctrl(struct rp1_dpi *dpi, int enable)
++{
++	rp1dpi_hw_write(dpi, DPI_DMA_IRQ_EN,
++			BITS(DPI_DMA_IRQ_EN_AFIFO_EMPTY, 1)      |
++			BITS(DPI_DMA_IRQ_EN_UNDERFLOW, 1)        |
++			BITS(DPI_DMA_IRQ_EN_DMA_READY, !!enable) |
++			BITS(DPI_DMA_IRQ_EN_MATCH_LINE, 4095));
++}
++
++irqreturn_t rp1dpi_hw_isr(int irq, void *dev)
++{
++	struct rp1_dpi *dpi = dev;
++	u32 u = rp1dpi_hw_read(dpi, DPI_DMA_IRQ_FLAGS);
++
++	if (u) {
++		rp1dpi_hw_write(dpi, DPI_DMA_IRQ_FLAGS, u);
++		if (dpi) {
++			if (u & DPI_DMA_IRQ_FLAGS_UNDERFLOW_MASK)
++				drm_err_ratelimited(dpi->drm,
++						    "Underflow! (panics=0x%08x)\n",
++						    rp1dpi_hw_read(dpi, DPI_DMA_PANICS));
++			if (u & DPI_DMA_IRQ_FLAGS_DMA_READY_MASK)
++				drm_crtc_handle_vblank(&dpi->pipe.crtc);
++			if (u & DPI_DMA_IRQ_FLAGS_AFIFO_EMPTY_MASK)
++				complete(&dpi->finished);
++		}
++	}
++	return u ? IRQ_HANDLED : IRQ_NONE;
++}
diff --git a/target/linux/bcm27xx/patches-6.1/950-0887-drm-Add-RP1-VEC-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0887-drm-Add-RP1-VEC-driver.patch
new file mode 100644
index 0000000000..5bf657ab24
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0887-drm-Add-RP1-VEC-driver.patch
@@ -0,0 +1,3078 @@
+From 09c2c6aad0fed44182defecd274579770feb0ae2 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Tue, 19 Sep 2023 17:54:41 +0100
+Subject: [PATCH] drm: Add RP1 VEC driver
+
+Add support for the RP1 VEC hardware.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/gpu/drm/rp1/rp1-vec/Kconfig       |   12 +
+ drivers/gpu/drm/rp1/rp1-vec/Makefile      |    5 +
+ drivers/gpu/drm/rp1/rp1-vec/rp1_vec.c     |  539 ++++++++
+ drivers/gpu/drm/rp1/rp1-vec/rp1_vec.h     |   79 ++
+ drivers/gpu/drm/rp1/rp1-vec/rp1_vec_cfg.c |  508 ++++++++
+ drivers/gpu/drm/rp1/rp1-vec/rp1_vec_hw.c  |  469 +++++++
+ drivers/gpu/drm/rp1/rp1-vec/vec_regs.h    | 1420 +++++++++++++++++++++
+ 7 files changed, 3032 insertions(+)
+ create mode 100644 drivers/gpu/drm/rp1/rp1-vec/Kconfig
+ create mode 100644 drivers/gpu/drm/rp1/rp1-vec/Makefile
+ create mode 100644 drivers/gpu/drm/rp1/rp1-vec/rp1_vec.c
+ create mode 100644 drivers/gpu/drm/rp1/rp1-vec/rp1_vec.h
+ create mode 100644 drivers/gpu/drm/rp1/rp1-vec/rp1_vec_cfg.c
+ create mode 100644 drivers/gpu/drm/rp1/rp1-vec/rp1_vec_hw.c
+ create mode 100644 drivers/gpu/drm/rp1/rp1-vec/vec_regs.h
+
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-vec/Kconfig
+@@ -0,0 +1,12 @@
++# SPDX-License-Identifier: GPL-2.0-only
++config DRM_RP1_VEC
++	tristate "DRM Support for RP1 VEC"
++	depends on DRM
++	select MFD_RP1
++	select DRM_GEM_DMA_HELPER
++	select DRM_KMS_HELPER
++	select DRM_VRAM_HELPER
++	select DRM_TTM
++	select DRM_TTM_HELPER
++	help
++	  Choose this option to enable Video Out on RP1
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-vec/Makefile
+@@ -0,0 +1,5 @@
++# SPDX-License-Identifier: GPL-2.0-only
++
++drm-rp1-vec-y := rp1_vec.o rp1_vec_hw.o rp1_vec_cfg.o
++
++obj-$(CONFIG_DRM_RP1_VEC) += drm-rp1-vec.o
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-vec/rp1_vec.c
+@@ -0,0 +1,539 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for VEC output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/string.h>
++#include <linux/slab.h>
++#include <linux/mm.h>
++#include <linux/fb.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/interrupt.h>
++#include <linux/ioport.h>
++#include <linux/list.h>
++#include <linux/platform_device.h>
++#include <linux/clk.h>
++#include <linux/printk.h>
++#include <linux/console.h>
++#include <linux/debugfs.h>
++#include <linux/uaccess.h>
++#include <linux/io.h>
++#include <linux/dma-mapping.h>
++#include <linux/cred.h>
++#include <drm/drm_drv.h>
++#include <drm/drm_mm.h>
++#include <drm/drm_fourcc.h>
++#include <drm/drm_atomic_helper.h>
++#include <drm/drm_managed.h>
++#include <drm/drm_crtc.h>
++#include <drm/drm_crtc_helper.h>
++#include <drm/drm_encoder.h>
++#include <drm/drm_fb_helper.h>
++#include <drm/drm_framebuffer.h>
++#include <drm/drm_gem.h>
++#include <drm/drm_gem_atomic_helper.h>
++#include <drm/drm_gem_dma_helper.h>
++#include <drm/drm_gem_framebuffer_helper.h>
++#include <drm/drm_simple_kms_helper.h>
++#include <drm/drm_probe_helper.h>
++#include <drm/drm_modeset_helper_vtables.h>
++#include <drm/drm_vblank.h>
++#include <drm/drm_of.h>
++
++#include "rp1_vec.h"
++
++/*
++ * Default TV standard parameter; it may be overridden by the OF
++ * property "tv_norm" (which should be one of the strings below).
++ *
++ * The default (empty string) supports various 60Hz and 50Hz modes,
++ * and will automatically select NTSC[-M] or PAL[-BDGHIKL]; the two
++ * "fake" 60Hz standards NTSC-443 and PAL60 also support 50Hz PAL.
++ * Other values will restrict the set of video modes offered.
++ *
++ * Finally, the DRM connector property "mode" (which is an integer)
++ * can be used to override this value, but it does not prevent the
++ * selection of an inapplicable video mode.
++ */
++
++static char *rp1vec_tv_norm_str;
++module_param_named(tv_norm, rp1vec_tv_norm_str, charp, 0600);
++MODULE_PARM_DESC(tv_norm, "Default TV norm.\n"
++		 "\t\tSupported: NTSC, NTSC-J, NTSC-443, PAL, PAL-M, PAL-N,\n"
++		 "\t\t\tPAL60.\n"
++		 "\t\tDefault: empty string: infer PAL for a 50 Hz mode,\n"
++		 "\t\t\tNTSC otherwise");
++
++const char * const rp1vec_tvstd_names[] = {
++	[RP1VEC_TVSTD_NTSC]     = "NTSC",
++	[RP1VEC_TVSTD_NTSC_J]   = "NTSC-J",
++	[RP1VEC_TVSTD_NTSC_443] = "NTSC-443",
++	[RP1VEC_TVSTD_PAL]      = "PAL",
++	[RP1VEC_TVSTD_PAL_M]    = "PAL-M",
++	[RP1VEC_TVSTD_PAL_N]    = "PAL-N",
++	[RP1VEC_TVSTD_PAL60]    = "PAL60",
++	[RP1VEC_TVSTD_DEFAULT]  = "",
++};
++
++static int rp1vec_parse_tv_norm(const char *str)
++{
++	int i;
++
++	if (str && *str) {
++		for (i = 0; i < ARRAY_SIZE(rp1vec_tvstd_names); ++i) {
++			if (strcasecmp(str, rp1vec_tvstd_names[i]) == 0)
++				return i;
++		}
++	}
++	return RP1VEC_TVSTD_DEFAULT;
++}
++
++static void rp1vec_pipe_update(struct drm_simple_display_pipe *pipe,
++			       struct drm_plane_state *old_state)
++{
++	struct drm_pending_vblank_event *event;
++	unsigned long flags;
++	struct drm_framebuffer *fb = pipe->plane.state->fb;
++	struct rp1_vec *vec = pipe->crtc.dev->dev_private;
++	struct drm_gem_object *gem = fb ? drm_gem_fb_get_obj(fb, 0) : NULL;
++	struct drm_gem_dma_object *dma_obj = gem ? to_drm_gem_dma_obj(gem) : NULL;
++	bool can_update = fb && dma_obj && vec && vec->pipe_enabled;
++
++	/* (Re-)start VEC where required; and update FB address */
++	if (can_update) {
++		if (!vec->vec_running || fb->format->format != vec->cur_fmt) {
++			if (vec->vec_running && fb->format->format != vec->cur_fmt) {
++				rp1vec_hw_stop(vec);
++				vec->vec_running = false;
++			}
++			if (!vec->vec_running) {
++				rp1vec_hw_setup(vec,
++						fb->format->format,
++						&pipe->crtc.state->mode,
++						vec->connector.state->tv.mode);
++				vec->vec_running = true;
++			}
++			vec->cur_fmt  = fb->format->format;
++			drm_crtc_vblank_on(&pipe->crtc);
++		}
++		rp1vec_hw_update(vec, dma_obj->dma_addr, fb->offsets[0], fb->pitches[0]);
++	}
++
++	/* Check if VBLANK callback needs to be armed (or sent immediately in some error cases).
++	 * Note there is a tiny probability of a race between rp1vec_dma_update() and IRQ;
++	 * ordering it this way around is safe, but theoretically might delay an extra frame.
++	 */
++	spin_lock_irqsave(&pipe->crtc.dev->event_lock, flags);
++	event = pipe->crtc.state->event;
++	if (event) {
++		pipe->crtc.state->event = NULL;
++		if (can_update && drm_crtc_vblank_get(&pipe->crtc) == 0)
++			drm_crtc_arm_vblank_event(&pipe->crtc, event);
++		else
++			drm_crtc_send_vblank_event(&pipe->crtc, event);
++	}
++	spin_unlock_irqrestore(&pipe->crtc.dev->event_lock, flags);
++}
++
++static void rp1vec_pipe_enable(struct drm_simple_display_pipe *pipe,
++			       struct drm_crtc_state *crtc_state,
++			      struct drm_plane_state *plane_state)
++{
++	struct rp1_vec *vec = pipe->crtc.dev->dev_private;
++
++	dev_info(&vec->pdev->dev, __func__);
++	vec->pipe_enabled = true;
++	vec->cur_fmt = 0xdeadbeef;
++	rp1vec_vidout_setup(vec);
++	rp1vec_pipe_update(pipe, 0);
++}
++
++static void rp1vec_pipe_disable(struct drm_simple_display_pipe *pipe)
++{
++	struct rp1_vec *vec = pipe->crtc.dev->dev_private;
++
++	dev_info(&vec->pdev->dev, __func__);
++	drm_crtc_vblank_off(&pipe->crtc);
++	if (vec) {
++		if (vec->vec_running) {
++			rp1vec_hw_stop(vec);
++			vec->vec_running = false;
++		}
++		vec->pipe_enabled = false;
++	}
++}
++
++static int rp1vec_pipe_enable_vblank(struct drm_simple_display_pipe *pipe)
++{
++	if (pipe && pipe->crtc.dev) {
++		struct rp1_vec *vec = pipe->crtc.dev->dev_private;
++
++		if (vec)
++			rp1vec_hw_vblank_ctrl(vec, 1);
++	}
++	return 0;
++}
++
++static void rp1vec_pipe_disable_vblank(struct drm_simple_display_pipe *pipe)
++{
++	if (pipe && pipe->crtc.dev) {
++		struct rp1_vec *vec = pipe->crtc.dev->dev_private;
++
++		if (vec)
++			rp1vec_hw_vblank_ctrl(vec, 0);
++	}
++}
++
++static const struct drm_simple_display_pipe_funcs rp1vec_pipe_funcs = {
++	.enable	    = rp1vec_pipe_enable,
++	.update	    = rp1vec_pipe_update,
++	.disable    = rp1vec_pipe_disable,
++	.prepare_fb = drm_gem_simple_display_pipe_prepare_fb,
++	.enable_vblank	= rp1vec_pipe_enable_vblank,
++	.disable_vblank = rp1vec_pipe_disable_vblank,
++};
++
++static void rp1vec_connector_destroy(struct drm_connector *connector)
++{
++	drm_connector_unregister(connector);
++	drm_connector_cleanup(connector);
++}
++
++static const struct drm_display_mode rp1vec_modes[4] = {
++	{ /* Full size 525/60i with Rec.601 pixel rate */
++		DRM_MODE("720x480i", DRM_MODE_TYPE_DRIVER, 13500,
++			 720, 720 + 14, 720 + 14 + 64, 858, 0,
++			 480, 480 + 7, 480 + 7 + 6, 525, 0,
++			 DRM_MODE_FLAG_INTERLACE)
++	},
++	{ /* Cropped and horizontally squashed to be TV-safe */
++		DRM_MODE("704x432i", DRM_MODE_TYPE_DRIVER, 15429,
++			 704, 704 + 72, 704 + 72 + 72, 980, 0,
++			 432, 432 + 31, 432 + 31 + 6, 525, 0,
++			 DRM_MODE_FLAG_INTERLACE)
++	},
++	{ /* Full size 625/50i with Rec.601 pixel rate */
++		DRM_MODE("720x576i", DRM_MODE_TYPE_DRIVER, 13500,
++			 720, 720 + 20, 720 + 20 + 64, 864, 0,
++			 576, 576 + 4, 576 + 4 + 6, 625, 0,
++			 DRM_MODE_FLAG_INTERLACE)
++	},
++	{ /* Cropped and squashed, for square(ish) pixels */
++		DRM_MODE("704x512i", DRM_MODE_TYPE_DRIVER, 15429,
++			 704, 704 + 80, 704 + 80 + 72, 987, 0,
++			 512, 512 + 36, 512 + 36 + 6, 625, 0,
++			 DRM_MODE_FLAG_INTERLACE)
++	}
++};
++
++static int rp1vec_connector_get_modes(struct drm_connector *connector)
++{
++	struct rp1_vec *vec = container_of(connector, struct rp1_vec, connector);
++	bool ok525 = RP1VEC_TVSTD_SUPPORT_525(vec->tv_norm);
++	bool ok625 = RP1VEC_TVSTD_SUPPORT_625(vec->tv_norm);
++	int i, prog, n = 0;
++
++	for (i = 0; i < ARRAY_SIZE(rp1vec_modes); i++) {
++		if ((rp1vec_modes[i].vtotal == 625) ? ok625 : ok525) {
++			for (prog = 0; prog < 2; prog++) {
++				struct drm_display_mode *mode =
++					drm_mode_duplicate(connector->dev,
++							   &rp1vec_modes[i]);
++
++				if (prog) {
++					mode->flags &= ~DRM_MODE_FLAG_INTERLACE;
++					mode->vdisplay	  >>= 1;
++					mode->vsync_start >>= 1;
++					mode->vsync_end	  >>= 1;
++					mode->vtotal	  >>= 1;
++				}
++
++				if (mode->hdisplay == 704 &&
++				    mode->vtotal == ((ok525) ? 525 : 625))
++					mode->type |= DRM_MODE_TYPE_PREFERRED;
++
++				drm_mode_set_name(mode);
++				drm_mode_probed_add(connector, mode);
++				n++;
++			}
++		}
++	}
++
++	return n;
++}
++
++static void rp1vec_connector_reset(struct drm_connector *connector)
++{
++	struct rp1_vec *vec = container_of(connector, struct rp1_vec, connector);
++
++	drm_atomic_helper_connector_reset(connector);
++	if (connector->state)
++		connector->state->tv.mode = vec->tv_norm;
++}
++
++static int rp1vec_connector_atomic_check(struct drm_connector *conn,
++					 struct drm_atomic_state *state)
++{	struct drm_connector_state *old_state =
++		drm_atomic_get_old_connector_state(state, conn);
++	struct drm_connector_state *new_state =
++		drm_atomic_get_new_connector_state(state, conn);
++
++	if (new_state->crtc && old_state->tv.mode != new_state->tv.mode) {
++		struct drm_crtc_state *crtc_state =
++			drm_atomic_get_new_crtc_state(state, new_state->crtc);
++
++		crtc_state->mode_changed = true;
++	}
++
++	return 0;
++}
++
++static enum drm_mode_status rp1vec_mode_valid(struct drm_device *dev,
++					      const struct drm_display_mode *mode)
++{
++	/*
++	 * Check the mode roughly matches one of our standard modes
++	 * (optionally half-height and progressive). Ignore H/V sync
++	 * timings which for interlaced TV are approximate at best.
++	 */
++	int i, prog;
++
++	prog = !(mode->flags & DRM_MODE_FLAG_INTERLACE);
++
++	for (i = 0; i < ARRAY_SIZE(rp1vec_modes); i++) {
++		const struct drm_display_mode *ref = rp1vec_modes + i;
++
++		if (mode->hdisplay == ref->hdisplay           &&
++		    mode->vdisplay == (ref->vdisplay >> prog) &&
++		    mode->clock + 2 >= ref->clock             &&
++		    mode->clock <= ref->clock + 2             &&
++		    mode->htotal + 2 >= ref->htotal           &&
++		    mode->htotal <= ref->htotal + 2           &&
++		    mode->vtotal + 2 >= (ref->vtotal >> prog) &&
++		    mode->vtotal <= (ref->vtotal >> prog) + 2)
++			return MODE_OK;
++	}
++	return MODE_BAD;
++}
++
++static const struct drm_connector_helper_funcs rp1vec_connector_helper_funcs = {
++	.get_modes = rp1vec_connector_get_modes,
++	.atomic_check = rp1vec_connector_atomic_check,
++};
++
++static const struct drm_connector_funcs rp1vec_connector_funcs = {
++	.fill_modes = drm_helper_probe_single_connector_modes,
++	.destroy = rp1vec_connector_destroy,
++	.reset = rp1vec_connector_reset,
++	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
++};
++
++static const struct drm_mode_config_funcs rp1vec_mode_funcs = {
++	.fb_create = drm_gem_fb_create,
++	.atomic_check = drm_atomic_helper_check,
++	.atomic_commit = drm_atomic_helper_commit,
++	.mode_valid = rp1vec_mode_valid,
++};
++
++static const u32 rp1vec_formats[] = {
++	DRM_FORMAT_XRGB8888,
++	DRM_FORMAT_XBGR8888,
++	DRM_FORMAT_RGB888,
++	DRM_FORMAT_BGR888,
++	DRM_FORMAT_RGB565
++};
++
++static void rp1vec_stopall(struct drm_device *drm)
++{
++	if (drm->dev_private) {
++		struct rp1_vec *vec = drm->dev_private;
++
++		if (vec->vec_running || rp1vec_hw_busy(vec)) {
++			rp1vec_hw_stop(vec);
++			vec->vec_running = false;
++		}
++		rp1vec_vidout_poweroff(vec);
++	}
++}
++
++DEFINE_DRM_GEM_DMA_FOPS(rp1vec_fops);
++
++static struct drm_driver rp1vec_driver = {
++	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
++	.fops			= &rp1vec_fops,
++	.name			= "drm-rp1-vec",
++	.desc			= "drm-rp1-vec",
++	.date			= "0",
++	.major			= 1,
++	.minor			= 0,
++	DRM_GEM_DMA_DRIVER_OPS,
++	.release		= rp1vec_stopall,
++};
++
++static int rp1vec_platform_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct drm_device *drm;
++	struct rp1_vec *vec;
++	const char *str;
++	int i, ret;
++
++	dev_info(dev, __func__);
++	drm = drm_dev_alloc(&rp1vec_driver, dev);
++	if (IS_ERR(drm)) {
++		ret = PTR_ERR(drm);
++		dev_err(dev, "%s drm_dev_alloc %d", __func__, ret);
++		return ret;
++	}
++
++	vec = drmm_kzalloc(drm, sizeof(*vec), GFP_KERNEL);
++	if (!vec) {
++		dev_err(dev, "%s drmm_kzalloc failed", __func__);
++		ret = -ENOMEM;
++		goto err_free_drm;
++	}
++	init_completion(&vec->finished);
++	vec->drm = drm;
++	vec->pdev = pdev;
++	drm->dev_private = vec;
++	platform_set_drvdata(pdev, drm);
++
++	str = rp1vec_tv_norm_str;
++	of_property_read_string(dev->of_node, "tv_norm", &str);
++	vec->tv_norm = rp1vec_parse_tv_norm(str);
++
++	for (i = 0; i < RP1VEC_NUM_HW_BLOCKS; i++) {
++		vec->hw_base[i] =
++			devm_ioremap_resource(dev,
++					      platform_get_resource(vec->pdev, IORESOURCE_MEM, i));
++		if (IS_ERR(vec->hw_base[i])) {
++			ret = PTR_ERR(vec->hw_base[i]);
++			dev_err(dev, "Error memory mapping regs[%d]\n", i);
++			goto err_free_drm;
++		}
++	}
++	ret = platform_get_irq(vec->pdev, 0);
++	if (ret > 0)
++		ret = devm_request_irq(dev, ret, rp1vec_hw_isr,
++				       IRQF_SHARED, "rp1-vec", vec);
++	if (ret) {
++		dev_err(dev, "Unable to request interrupt\n");
++		ret = -EINVAL;
++		goto err_free_drm;
++	}
++	dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
++
++	vec->vec_clock = devm_clk_get(dev, NULL);
++	if (IS_ERR(vec->vec_clock)) {
++		ret = PTR_ERR(vec->vec_clock);
++		goto err_free_drm;
++	}
++	ret = clk_prepare_enable(vec->vec_clock);
++
++	ret = drmm_mode_config_init(drm);
++	if (ret)
++		goto err_free_drm;
++	drm->mode_config.max_width  = 768;
++	drm->mode_config.max_height = 576;
++	drm->mode_config.fb_base    = 0;
++	drm->mode_config.preferred_depth = 32;
++	drm->mode_config.prefer_shadow	 = 0;
++	drm->mode_config.prefer_shadow_fbdev = 1;
++	//drm->mode_config.fbdev_use_iomem = false;
++	drm->mode_config.quirk_addfb_prefer_host_byte_order = true;
++	drm->mode_config.funcs = &rp1vec_mode_funcs;
++	drm_vblank_init(drm, 1);
++
++	ret = drm_mode_create_tv_properties(drm, ARRAY_SIZE(rp1vec_tvstd_names),
++					    rp1vec_tvstd_names);
++	if (ret)
++		goto err_free_drm;
++
++	drm_connector_init(drm, &vec->connector, &rp1vec_connector_funcs,
++			   DRM_MODE_CONNECTOR_Composite);
++	if (ret)
++		goto err_free_drm;
++
++	vec->connector.interlace_allowed = true;
++	drm_connector_helper_add(&vec->connector, &rp1vec_connector_helper_funcs);
++
++	drm_object_attach_property(&vec->connector.base,
++				   drm->mode_config.tv_mode_property,
++				   vec->tv_norm);
++
++	ret = drm_simple_display_pipe_init(drm,
++					   &vec->pipe,
++					   &rp1vec_pipe_funcs,
++					   rp1vec_formats,
++					   ARRAY_SIZE(rp1vec_formats),
++					   NULL,
++					   &vec->connector);
++	if (ret)
++		goto err_free_drm;
++
++	drm_mode_config_reset(drm);
++
++	ret = drm_dev_register(drm, 0);
++	if (ret)
++		goto err_free_drm;
++
++	drm_fbdev_generic_setup(drm, 32); /* the "32" is preferred BPP */
++	return ret;
++
++err_free_drm:
++	dev_info(dev, "%s fail %d", __func__, ret);
++	drm_dev_put(drm);
++	return ret;
++}
++
++static int rp1vec_platform_remove(struct platform_device *pdev)
++{
++	struct drm_device *drm = platform_get_drvdata(pdev);
++
++	rp1vec_stopall(drm);
++	drm_dev_unregister(drm);
++	drm_atomic_helper_shutdown(drm);
++	drm_dev_put(drm);
++
++	return 0;
++}
++
++static void rp1vec_platform_shutdown(struct platform_device *pdev)
++{
++	struct drm_device *drm = platform_get_drvdata(pdev);
++
++	rp1vec_stopall(drm);
++}
++
++static const struct of_device_id rp1vec_of_match[] = {
++	{
++		.compatible = "raspberrypi,rp1vec",
++	},
++	{ /* sentinel */ },
++};
++
++MODULE_DEVICE_TABLE(of, rp1vec_of_match);
++
++static struct platform_driver rp1vec_platform_driver = {
++	.probe		= rp1vec_platform_probe,
++	.remove		= rp1vec_platform_remove,
++	.shutdown	= rp1vec_platform_shutdown,
++	.driver		= {
++		.name	= DRIVER_NAME,
++		.owner	= THIS_MODULE,
++		.of_match_table = rp1vec_of_match,
++	},
++};
++
++module_platform_driver(rp1vec_platform_driver);
++
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("DRM driver for Composite Video on Raspberry Pi RP1");
++MODULE_AUTHOR("Nick Hollinghurst");
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-vec/rp1_vec.h
+@@ -0,0 +1,79 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * DRM Driver for DSI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/types.h>
++#include <linux/io.h>
++#include <linux/clk.h>
++#include <drm/drm_device.h>
++#include <drm/drm_simple_kms_helper.h>
++
++#define MODULE_NAME "drm-rp1-vec"
++#define DRIVER_NAME "drm-rp1-vec"
++
++/* ---------------------------------------------------------------------- */
++
++#define RP1VEC_HW_BLOCK_VEC   0
++#define RP1VEC_HW_BLOCK_CFG   1
++#define RP1VEC_NUM_HW_BLOCKS  2
++
++enum {
++	RP1VEC_TVSTD_NTSC = 0,	/* +525 => NTSC       625 => PAL   */
++	RP1VEC_TVSTD_NTSC_J,	/* +525 => NTSC-J     625 => PAL   */
++	RP1VEC_TVSTD_NTSC_443,	/* +525 => NTSC-443  +625 => PAL   */
++	RP1VEC_TVSTD_PAL,	/*  525 => NTSC      +625 => PAL   */
++	RP1VEC_TVSTD_PAL_M,	/* +525 => PAL-M      625 => PAL   */
++	RP1VEC_TVSTD_PAL_N,	/*  525 => NTSC      +625 => PAL-N */
++	RP1VEC_TVSTD_PAL60,	/* +525 => PAL60     +625 => PAL   */
++	RP1VEC_TVSTD_DEFAULT,	/* +525 => NTSC      +625 => PAL   */
++};
++
++/* Which standards support which modes? Those marked with + above */
++#define RP1VEC_TVSTD_SUPPORT_525(n) ((0xD7 >> (n)) & 1)
++#define RP1VEC_TVSTD_SUPPORT_625(n) ((0xEC >> (n)) & 1)
++
++/* ---------------------------------------------------------------------- */
++
++struct rp1_vec {
++	/* DRM and platform device pointers */
++	struct drm_device *drm;
++	struct platform_device *pdev;
++
++	/* Framework and helper objects */
++	struct drm_simple_display_pipe pipe;
++	struct drm_connector connector;
++
++	/* Clock. We assume this is always at 108 MHz. */
++	struct clk *vec_clock;
++
++	/* Block (VCC, CFG) base addresses, and current state */
++	void __iomem *hw_base[RP1VEC_NUM_HW_BLOCKS];
++	u32 cur_fmt;
++	int tv_norm;
++	bool vec_running, pipe_enabled;
++	struct completion finished;
++};
++
++extern const char * const rp1vec_tvstd_names[];
++
++/* ---------------------------------------------------------------------- */
++/* Functions to control the VEC/DMA block				  */
++
++void rp1vec_hw_setup(struct rp1_vec *vec,
++		     u32 in_format,
++		struct drm_display_mode const *mode,
++		int tvstd);
++void rp1vec_hw_update(struct rp1_vec *vec, dma_addr_t addr, u32 offset, u32 stride);
++void rp1vec_hw_stop(struct rp1_vec *vec);
++int rp1vec_hw_busy(struct rp1_vec *vec);
++irqreturn_t rp1vec_hw_isr(int irq, void *dev);
++void rp1vec_hw_vblank_ctrl(struct rp1_vec *vec, int enable);
++
++/* ---------------------------------------------------------------------- */
++/* Functions to control the VIDEO OUT CFG block and check RP1 platform	  */
++
++void rp1vec_vidout_setup(struct rp1_vec *vec);
++void rp1vec_vidout_poweroff(struct rp1_vec *vec);
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-vec/rp1_vec_cfg.c
+@@ -0,0 +1,508 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for DSI output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/mm.h>
++#include <linux/delay.h>
++#include <linux/interrupt.h>
++#include <linux/platform_device.h>
++#include <linux/printk.h>
++#include <linux/rp1_platform.h>
++
++#include "rp1_vec.h"
++
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_SEL
++// JTAG access : synchronous
++// Description : Selects source: VEC or DPI
++#define VIDEO_OUT_CFG_SEL_OFFSET 0x00000000
++#define VIDEO_OUT_CFG_SEL_BITS	 0x00000013
++#define VIDEO_OUT_CFG_SEL_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_SEL_PCLK_INV
++// Description : Select dpi_pclk output port polarity inversion.
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_RESET  0x0
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_BITS	  0x00000010
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_MSB	  4
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_LSB	  4
++#define VIDEO_OUT_CFG_SEL_PCLK_INV_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_SEL_PAD_MUX
++// Description : VEC 1 DPI 0
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_RESET	 0x0
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_BITS	 0x00000002
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_MSB	 1
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_LSB	 1
++#define VIDEO_OUT_CFG_SEL_PAD_MUX_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_SEL_VDAC_MUX
++// Description : VEC 1 DPI 0
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_RESET  0x0
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_BITS	  0x00000001
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_MSB	  0
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_LSB	  0
++#define VIDEO_OUT_CFG_SEL_VDAC_MUX_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_VDAC_CFG
++// JTAG access : synchronous
++// Description : Configure SNPS VDAC
++#define VIDEO_OUT_CFG_VDAC_CFG_OFFSET 0x00000004
++#define VIDEO_OUT_CFG_VDAC_CFG_BITS   0x1fffffff
++#define VIDEO_OUT_CFG_VDAC_CFG_RESET  0x0003ffff
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENCTR
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_BITS   0x1c000000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_MSB    28
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_LSB    26
++#define VIDEO_OUT_CFG_VDAC_CFG_ENCTR_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENSC
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_BITS   0x03800000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_MSB	   25
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_LSB	   23
++#define VIDEO_OUT_CFG_VDAC_CFG_ENSC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENDAC
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_BITS   0x00700000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_MSB    22
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_LSB    20
++#define VIDEO_OUT_CFG_VDAC_CFG_ENDAC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENVBG
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_BITS   0x00080000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_MSB    19
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_LSB    19
++#define VIDEO_OUT_CFG_VDAC_CFG_ENVBG_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_RESET  0x0
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_BITS   0x00040000
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_MSB    18
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_LSB    18
++#define VIDEO_OUT_CFG_VDAC_CFG_ENEXTREF_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_DAC2GC
++// Description : dac2 gain control
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_RESET  0x3f
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_BITS   0x0003f000
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_MSB    17
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_LSB    12
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC2GC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_DAC1GC
++// Description : dac1 gain control
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_RESET  0x3f
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_BITS   0x00000fc0
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_MSB    11
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_LSB    6
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC1GC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_CFG_DAC0GC
++// Description : dac0 gain control
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_RESET  0x3f
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_BITS   0x0000003f
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_MSB    5
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_LSB    0
++#define VIDEO_OUT_CFG_VDAC_CFG_DAC0GC_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_VDAC_STATUS
++// JTAG access : synchronous
++// Description : Read VDAC status
++#define VIDEO_OUT_CFG_VDAC_STATUS_OFFSET 0x00000008
++#define VIDEO_OUT_CFG_VDAC_STATUS_BITS	 0x00000017
++#define VIDEO_OUT_CFG_VDAC_STATUS_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_RESET	0x0
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_BITS	0x00000010
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_MSB	4
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_LSB	4
++#define VIDEO_OUT_CFG_VDAC_STATUS_ENCTR3_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT
++// Description : None
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_RESET  "-"
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_BITS	  0x00000007
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_MSB	  2
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_LSB	  0
++#define VIDEO_OUT_CFG_VDAC_STATUS_CABLEOUT_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_MEM_PD
++// JTAG access : synchronous
++// Description : Control memory power down
++#define VIDEO_OUT_CFG_MEM_PD_OFFSET 0x0000000c
++#define VIDEO_OUT_CFG_MEM_PD_BITS   0x00000003
++#define VIDEO_OUT_CFG_MEM_PD_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_MEM_PD_VEC
++// Description : None
++#define VIDEO_OUT_CFG_MEM_PD_VEC_RESET	0x0
++#define VIDEO_OUT_CFG_MEM_PD_VEC_BITS	0x00000002
++#define VIDEO_OUT_CFG_MEM_PD_VEC_MSB	1
++#define VIDEO_OUT_CFG_MEM_PD_VEC_LSB	1
++#define VIDEO_OUT_CFG_MEM_PD_VEC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_MEM_PD_DPI
++// Description : None
++#define VIDEO_OUT_CFG_MEM_PD_DPI_RESET	0x0
++#define VIDEO_OUT_CFG_MEM_PD_DPI_BITS	0x00000001
++#define VIDEO_OUT_CFG_MEM_PD_DPI_MSB	0
++#define VIDEO_OUT_CFG_MEM_PD_DPI_LSB	0
++#define VIDEO_OUT_CFG_MEM_PD_DPI_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_TEST_OVERRIDE
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_OFFSET 0x00000010
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_BITS   0xffffffff
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_TEST_OVERRIDE_PAD
++// Description : None
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_RESET  0x0
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_BITS   0x80000000
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_MSB    31
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_LSB    31
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_PAD_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC
++// Description : None
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_RESET	0x0
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_BITS	0x40000000
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_MSB	30
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_LSB	30
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_VDAC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL
++// Description : None
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_RESET  0x00000000
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_BITS	  0x3fffffff
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_MSB	  29
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_LSB	  0
++#define VIDEO_OUT_CFG_TEST_OVERRIDE_RGBVAL_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INTR
++// JTAG access : synchronous
++// Description : Raw Interrupts
++#define VIDEO_OUT_CFG_INTR_OFFSET 0x00000014
++#define VIDEO_OUT_CFG_INTR_BITS	  0x00000003
++#define VIDEO_OUT_CFG_INTR_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTR_DPI
++// Description : None
++#define VIDEO_OUT_CFG_INTR_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_INTR_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_INTR_DPI_MSB    1
++#define VIDEO_OUT_CFG_INTR_DPI_LSB    1
++#define VIDEO_OUT_CFG_INTR_DPI_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTR_VEC
++// Description : None
++#define VIDEO_OUT_CFG_INTR_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_INTR_VEC_BITS   0x00000001
++#define VIDEO_OUT_CFG_INTR_VEC_MSB    0
++#define VIDEO_OUT_CFG_INTR_VEC_LSB    0
++#define VIDEO_OUT_CFG_INTR_VEC_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INTE
++// JTAG access : synchronous
++// Description : Interrupt Enable
++#define VIDEO_OUT_CFG_INTE_OFFSET 0x00000018
++#define VIDEO_OUT_CFG_INTE_BITS	  0x00000003
++#define VIDEO_OUT_CFG_INTE_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTE_DPI
++// Description : None
++#define VIDEO_OUT_CFG_INTE_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_INTE_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_INTE_DPI_MSB    1
++#define VIDEO_OUT_CFG_INTE_DPI_LSB    1
++#define VIDEO_OUT_CFG_INTE_DPI_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTE_VEC
++// Description : None
++#define VIDEO_OUT_CFG_INTE_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_INTE_VEC_BITS   0x00000001
++#define VIDEO_OUT_CFG_INTE_VEC_MSB    0
++#define VIDEO_OUT_CFG_INTE_VEC_LSB    0
++#define VIDEO_OUT_CFG_INTE_VEC_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INTF
++// JTAG access : synchronous
++// Description : Interrupt Force
++#define VIDEO_OUT_CFG_INTF_OFFSET 0x0000001c
++#define VIDEO_OUT_CFG_INTF_BITS	  0x00000003
++#define VIDEO_OUT_CFG_INTF_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTF_DPI
++// Description : None
++#define VIDEO_OUT_CFG_INTF_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_INTF_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_INTF_DPI_MSB    1
++#define VIDEO_OUT_CFG_INTF_DPI_LSB    1
++#define VIDEO_OUT_CFG_INTF_DPI_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTF_VEC
++// Description : None
++#define VIDEO_OUT_CFG_INTF_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_INTF_VEC_BITS   0x00000001
++#define VIDEO_OUT_CFG_INTF_VEC_MSB    0
++#define VIDEO_OUT_CFG_INTF_VEC_LSB    0
++#define VIDEO_OUT_CFG_INTF_VEC_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INTS
++// JTAG access : synchronous
++// Description : Interrupt status after masking & forcing
++#define VIDEO_OUT_CFG_INTS_OFFSET 0x00000020
++#define VIDEO_OUT_CFG_INTS_BITS	  0x00000003
++#define VIDEO_OUT_CFG_INTS_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTS_DPI
++// Description : None
++#define VIDEO_OUT_CFG_INTS_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_INTS_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_INTS_DPI_MSB    1
++#define VIDEO_OUT_CFG_INTS_DPI_LSB    1
++#define VIDEO_OUT_CFG_INTS_DPI_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_INTS_VEC
++// Description : None
++#define VIDEO_OUT_CFG_INTS_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_INTS_VEC_BITS   0x00000001
++#define VIDEO_OUT_CFG_INTS_VEC_MSB    0
++#define VIDEO_OUT_CFG_INTS_VEC_LSB    0
++#define VIDEO_OUT_CFG_INTS_VEC_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_BLOCK_ID
++// JTAG access : synchronous
++// Description : Block Identifier
++//		 Hexadecimal representation of "VOCF"
++#define VIDEO_OUT_CFG_BLOCK_ID_OFFSET 0x00000024
++#define VIDEO_OUT_CFG_BLOCK_ID_BITS   0xffffffff
++#define VIDEO_OUT_CFG_BLOCK_ID_RESET  0x564f4346
++#define VIDEO_OUT_CFG_BLOCK_ID_MSB    31
++#define VIDEO_OUT_CFG_BLOCK_ID_LSB    0
++#define VIDEO_OUT_CFG_BLOCK_ID_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_INSTANCE_ID
++// JTAG access : synchronous
++// Description : Block Instance Identifier
++#define VIDEO_OUT_CFG_INSTANCE_ID_OFFSET 0x00000028
++#define VIDEO_OUT_CFG_INSTANCE_ID_BITS	 0x0000000f
++#define VIDEO_OUT_CFG_INSTANCE_ID_RESET	 0x00000000
++#define VIDEO_OUT_CFG_INSTANCE_ID_MSB	 3
++#define VIDEO_OUT_CFG_INSTANCE_ID_LSB	 0
++#define VIDEO_OUT_CFG_INSTANCE_ID_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_AUTO
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_OFFSET 0x0000002c
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BITS	 0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_RESET	 0x00000007
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC
++// Description : 1 = reset is controlled by the sequencer
++//		 0 = reset is controlled by rstseq_ctrl
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_RESET  0x1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_BITS   0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_MSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_LSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_VEC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI
++// Description : 1 = reset is controlled by the sequencer
++//		 0 = reset is controlled by rstseq_ctrl
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_RESET  0x1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_MSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_LSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_DPI_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER
++// Description : 1 = reset is controlled by the sequencer
++//		 0 = reset is controlled by rstseq_ctrl
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_RESET  0x1
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_BITS   0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_MSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_LSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_AUTO_BUSADAPTER_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_PARALLEL
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_OFFSET 0x00000030
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BITS   0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_RESET  0x00000006
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_RESET	 0x1
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_BITS	 0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_MSB	 2
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_LSB	 2
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_VEC_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_RESET	 0x1
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_BITS	 0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_MSB	 1
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_LSB	 1
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_DPI_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER
++// Description : Is this reset parallel (i.e. not part of the sequence)
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_RESET	0x0
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_BITS	0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_MSB	0
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_LSB	0
++#define VIDEO_OUT_CFG_RSTSEQ_PARALLEL_BUSADAPTER_ACCESS "RO"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_CTRL
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_OFFSET 0x00000034
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BITS	 0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC
++// Description : 1 = keep the reset asserted
++//		 0 = keep the reset deasserted
++//		 This is ignored if rstseq_auto=1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_BITS   0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_MSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_LSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_VEC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI
++// Description : 1 = keep the reset asserted
++//		 0 = keep the reset deasserted
++//		 This is ignored if rstseq_auto=1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_MSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_LSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_DPI_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER
++// Description : 1 = keep the reset asserted
++//		 0 = keep the reset deasserted
++//		 This is ignored if rstseq_auto=1
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_BITS   0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_MSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_LSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_CTRL_BUSADAPTER_ACCESS "RW"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_TRIG
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_OFFSET 0x00000038
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BITS	 0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC
++// Description : Pulses the reset output
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_BITS   0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_MSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_LSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_VEC_ACCESS "SC"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI
++// Description : Pulses the reset output
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_MSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_LSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_DPI_ACCESS "SC"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER
++// Description : Pulses the reset output
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_BITS   0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_MSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_LSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_TRIG_BUSADAPTER_ACCESS "SC"
++// =============================================================================
++// Register    : VIDEO_OUT_CFG_RSTSEQ_DONE
++// JTAG access : synchronous
++// Description : None
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_OFFSET 0x0000003c
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BITS	 0x00000007
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_RESET	 0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_DONE_VEC
++// Description : Indicates the current state of the reset
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_BITS   0x00000004
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_MSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_LSB    2
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_VEC_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_DONE_DPI
++// Description : Indicates the current state of the reset
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_BITS   0x00000002
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_MSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_LSB    1
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_DPI_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER
++// Description : Indicates the current state of the reset
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_RESET  0x0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_BITS   0x00000001
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_MSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_LSB    0
++#define VIDEO_OUT_CFG_RSTSEQ_DONE_BUSADAPTER_ACCESS "RO"
++// =============================================================================
++
++#define CFG_WRITE(reg, val)  writel((val),  vec->hw_base[RP1VEC_HW_BLOCK_CFG] + (reg ## _OFFSET))
++#define CFG_READ(reg)	     readl(vec->hw_base[RP1VEC_HW_BLOCK_CFG] + (reg ## _OFFSET))
++
++void rp1vec_vidout_setup(struct rp1_vec *vec)
++{
++	/*
++	 * We assume DPI and VEC can't be used at the same time (due to
++	 * clashing requirements for PLL_VIDEO, and potentially for VDAC).
++	 * We therefore leave DPI memories powered down.
++	 */
++	CFG_WRITE(VIDEO_OUT_CFG_MEM_PD, VIDEO_OUT_CFG_MEM_PD_DPI_BITS);
++	CFG_WRITE(VIDEO_OUT_CFG_TEST_OVERRIDE, 0x00000000);
++
++	/* DPI->Pads; VEC->VDAC */
++	CFG_WRITE(VIDEO_OUT_CFG_SEL, VIDEO_OUT_CFG_SEL_VDAC_MUX_BITS);
++
++	/* configure VDAC for 1 channel, bandgap on, 1.28V swing */
++	CFG_WRITE(VIDEO_OUT_CFG_VDAC_CFG, 0x0019ffff);
++
++	/* enable VEC interrupt */
++	CFG_WRITE(VIDEO_OUT_CFG_INTE, VIDEO_OUT_CFG_INTE_VEC_BITS);
++}
++
++void rp1vec_vidout_poweroff(struct rp1_vec *vec)
++{
++	/* disable VEC interrupt */
++	CFG_WRITE(VIDEO_OUT_CFG_INTE, 0);
++
++	/* Ensure VDAC is turned off; power down DPI,VEC memories */
++	CFG_WRITE(VIDEO_OUT_CFG_VDAC_CFG, 0);
++	CFG_WRITE(VIDEO_OUT_CFG_MEM_PD, VIDEO_OUT_CFG_MEM_PD_BITS);
++}
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-vec/rp1_vec_hw.c
+@@ -0,0 +1,469 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * DRM Driver for VEC output on Raspberry Pi RP1
++ *
++ * Copyright (c) 2023 Raspberry Pi Limited.
++ */
++
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/mm.h>
++#include <linux/delay.h>
++#include <linux/interrupt.h>
++#include <linux/platform_device.h>
++#include <linux/printk.h>
++#include <drm/drm_fourcc.h>
++#include <drm/drm_print.h>
++#include <drm/drm_vblank.h>
++
++#include "rp1_vec.h"
++#include "vec_regs.h"
++
++#define BITS(field, val) (((val) << (field ## _LSB)) & (field ## _BITS))
++
++#define VEC_WRITE(reg, val) writel((val), vec->hw_base[RP1VEC_HW_BLOCK_VEC] + (reg ## _OFFSET))
++#define VEC_READ(reg)	    readl(vec->hw_base[RP1VEC_HW_BLOCK_VEC] + (reg ## _OFFSET))
++
++int rp1vec_hw_busy(struct rp1_vec *vec)
++{
++	/* Read the undocumented "pline_busy" flag */
++	return VEC_READ(VEC_STATUS) & 1;
++}
++
++/* Table of supported input (in-memory/DMA) pixel formats. */
++struct rp1vec_ipixfmt {
++	u32 format; /* DRM format code				 */
++	u32 mask;   /* RGB masks (10 bits each, left justified)	 */
++	u32 shift;  /* RGB MSB positions in the memory word	 */
++	u32 rgbsz;  /* Shifts used for scaling; also (BPP/8-1)	 */
++};
++
++#define MASK_RGB(r, g, b) \
++	(BITS(VEC_IMASK_MASK_R, r) | BITS(VEC_IMASK_MASK_G, g) | BITS(VEC_IMASK_MASK_B, b))
++#define SHIFT_RGB(r, g, b) \
++	(BITS(VEC_SHIFT_SHIFT_R, r) | BITS(VEC_SHIFT_SHIFT_G, g) | BITS(VEC_SHIFT_SHIFT_B, b))
++
++static const struct rp1vec_ipixfmt my_formats[] = {
++	{
++		.format = DRM_FORMAT_XRGB8888,
++		.mask	= MASK_RGB(0x3fc, 0x3fc, 0x3fc),
++		.shift  = SHIFT_RGB(23, 15, 7),
++		.rgbsz  = BITS(VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1, 3),
++	},
++	{
++		.format = DRM_FORMAT_XBGR8888,
++		.mask	= MASK_RGB(0x3fc, 0x3fc, 0x3fc),
++		.shift  = SHIFT_RGB(7, 15, 23),
++		.rgbsz  = BITS(VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1, 3),
++	},
++	{
++		.format = DRM_FORMAT_RGB888,
++		.mask	= MASK_RGB(0x3fc, 0x3fc, 0x3fc),
++		.shift  = SHIFT_RGB(23, 15, 7),
++		.rgbsz  = BITS(VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1, 2),
++	},
++	{
++		.format = DRM_FORMAT_BGR888,
++		.mask	= MASK_RGB(0x3fc, 0x3fc, 0x3fc),
++		.shift  = SHIFT_RGB(7, 15, 23),
++		.rgbsz  = BITS(VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1, 2),
++	},
++	{
++		.format = DRM_FORMAT_RGB565,
++		.mask	= MASK_RGB(0x3e0, 0x3f0, 0x3e0),
++		.shift  = SHIFT_RGB(15, 10, 4),
++		.rgbsz  = BITS(VEC_RGBSZ_SCALE_R, 5) |
++			  BITS(VEC_RGBSZ_SCALE_G, 6) |
++			  BITS(VEC_RGBSZ_SCALE_B, 5) |
++			  BITS(VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1, 1),
++	}
++};
++
++/*
++ * Hardware mode descriptions (@ 108 MHz clock rate).
++ * These rely largely on "canned" register settings.
++ * TODO: Port the generating software from FP to integer,
++ * or better factorize the differences between modes.
++ */
++
++struct rp1vec_hwmode {
++	u16  total_cols;	/* active columns, plus padding for filter context  */
++	u16  rows_per_field;	/* active lines per field (including partial ones)  */
++	bool interlaced;	/* set for interlaced				    */
++	bool first_field_odd;	/* set for interlaced and 30fps			    */
++	u32  yuv_scaling;	/* three 10-bit fields {Y, U, V} in 2.8 format	    */
++	u32  back_end_regs[28]; /* All registers 0x80 .. 0xEC			    */
++};
++
++/* { NTSC, PAL, PAL-M } x { progressive, interlaced } x { 13.5 MHz, 15.428571 MHz } */
++static const struct rp1vec_hwmode rp1vec_hwmodes[3][2][2] = {
++	{
++		/* NTSC */
++		{
++			{
++				.total_cols = 724,
++				.rows_per_field = 240,
++				.interlaced = false,
++				.first_field_odd = false,
++				.yuv_scaling = 0x1071d0cf,
++				.back_end_regs = {
++					0x039f1a3f, 0x03e10cc6, 0x0d6801fb, 0x023d034c,
++					0x00f80b6d, 0x00000005, 0x0006000b, 0x000c0011,
++					0x000a0106, 0x00000000, 0x00000000, 0x00000000,
++					0x00000000, 0x00170106, 0x00000000, 0x004c020e,
++					0x00000000, 0x007bffff, 0x38518c9a, 0x11195561,
++					0x02000200, 0xc1f07c1f, 0x087c1f07, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x000801ec,
++				},
++			}, {
++				.total_cols = 815,
++				.rows_per_field = 240,
++				.interlaced = false,
++				.first_field_odd = false,
++				.yuv_scaling = 0x1c131962,
++				.back_end_regs = {
++					0x03ce1a17, 0x03e10cc6, 0x0d6801fb, 0x023d034c,
++					0x00f80b6d, 0x00000005, 0x0006000b, 0x000c0011,
++					0x000a0106, 0x00000000, 0x00000000, 0x00000000,
++					0x00000000, 0x00170106, 0x00000000, 0x004c020e,
++					0x00000000, 0x007bffff, 0x38518c9a, 0x11195561,
++					0x02000200, 0xc1f07c1f, 0x087c1f07, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x000801ac,
++				},
++			},
++		}, {
++			{
++				.total_cols = 724,
++				.rows_per_field = 243,
++				.interlaced = true,
++				.first_field_odd = true,
++				.yuv_scaling = 0x1071d0cf,
++				.back_end_regs = {
++					0x039f1a3f, 0x03e10cc6, 0x0d6801fb, 0x023d034c,
++					0x00f80b6d, 0x00000005, 0x0006000b, 0x000c0011,
++					0x000a0107, 0x0111020d, 0x00000000, 0x00000000,
++					0x011c020d, 0x00150106, 0x0107011b, 0x004c020d,
++					0x00000000, 0x007bffff, 0x38518c9a, 0x11195561,
++					0x02000200, 0xc1f07c1f, 0x087c1f07, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x00094dee,
++				},
++			}, {
++				.total_cols = 815,
++				.rows_per_field = 243,
++				.interlaced = true,
++				.first_field_odd = true,
++				.yuv_scaling = 0x1c131962,
++				.back_end_regs = {
++					0x03ce1a17, 0x03e10cc6, 0x0d6801fb, 0x023d034c,
++					0x00f80b6d, 0x00000005, 0x0006000b, 0x000c0011,
++					0x000a0107, 0x0111020d, 0x00000000, 0x00000000,
++					0x011c020d, 0x00150106, 0x0107011b, 0x004c020d,
++					0x00000000, 0x007bffff, 0x38518c9a, 0x11195561,
++					0x02000200, 0xc1f07c1f, 0x087c1f07, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x00094dae,
++				},
++			},
++		},
++	}, {
++		/* PAL */
++		{
++			{
++				.total_cols = 724,
++				.rows_per_field = 288,
++				.interlaced = false,
++				.first_field_odd = false,
++				.yuv_scaling = 0x11c1f8e0,
++				.back_end_regs = {
++					0x04061aa6, 0x046e0cee, 0x0d8001fb, 0x025c034f,
++					0x00fd0b84, 0x026c0270, 0x00000004, 0x00050009,
++					0x00070135, 0x00000000, 0x00000000, 0x00000000,
++					0x00000000, 0x00170136, 0x00000000, 0x000a0270,
++					0x00000000, 0x007bffff, 0x3b1389d8, 0x0caf53b5,
++					0x02000200, 0xcc48c1d1, 0x0a8262b2, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x000801ed,
++				},
++			}, {
++				.total_cols = 804,
++				.rows_per_field = 288,
++				.interlaced = false,
++				.first_field_odd = false,
++				.yuv_scaling = 0x1e635d7f,
++				.back_end_regs = {
++					0x045b1a57, 0x046e0cee, 0x0d8001fb, 0x025c034f,
++					0x00fd0b84, 0x026c0270, 0x00000004, 0x00050009,
++					0x00070135, 0x00000000, 0x00000000, 0x00000000,
++					0x00000000, 0x00170136, 0x00000000, 0x000a0270,
++					0x00000000, 0x007bffff, 0x3b1389d8, 0x0caf53b5,
++					0x02000200, 0xcc48c1d1, 0x0a8262b2, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x000801ad,
++				},
++			},
++		}, {
++			{
++				.total_cols = 724,
++				.rows_per_field = 288,
++				.interlaced = true,
++				.first_field_odd = false,
++				.yuv_scaling = 0x11c1f8e0,
++				.back_end_regs = {
++					0x04061aa6, 0x046e0cee, 0x0d8001fb, 0x025c034f,
++					0x00fd0b84, 0x026c0270, 0x00000004, 0x00050009,
++					0x00070135, 0x013f026d, 0x00060136, 0x0140026e,
++					0x0150026e, 0x00180136, 0x026f0017, 0x000a0271,
++					0x00000000, 0x007bffff, 0x3b1389d8, 0x0caf53b5,
++					0x02000200, 0xcc48c1d1, 0x0a8262b2, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x0009ddef,
++				},
++			}, {
++				.total_cols = 804,
++				.rows_per_field = 288,
++				.interlaced = true,
++				.first_field_odd = false,
++				.yuv_scaling = 0x1e635d7f,
++				.back_end_regs = {
++					0x045b1a57, 0x046e0cee, 0x0d8001fb, 0x025c034f,
++					0x00fd0b84, 0x026c0270, 0x00000004, 0x00050009,
++					0x00070135, 0x013f026d, 0x00060136, 0x0140026e,
++					0x0150026e, 0x00180136, 0x026f0017, 0x000a0271,
++					0x00000000, 0x007bffff, 0x3b1389d8, 0x0caf53b5,
++					0x02000200, 0xcc48c1d1, 0x0a8262b2, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x0009ddaf,
++				},
++			},
++		},
++	}, {
++		/* PAL-M */
++		{
++			{
++				.total_cols = 724,
++				.rows_per_field = 240,
++				.interlaced = false,
++				.first_field_odd = false,
++				.yuv_scaling = 0x11c1f8e0,
++				.back_end_regs = {
++					0x039f1a3f, 0x03e10cc6, 0x0d6801fb, 0x023c034c,
++					0x00f80b6e, 0x00000005, 0x0006000b, 0x000c0011,
++					0x000a0106, 0x00000000, 0x00000000, 0x00000000,
++					0x00000000, 0x00170106, 0x00000000, 0x000a020c,
++					0x00000000, 0x007bffff, 0x385189d8, 0x0d5c53b5,
++					0x02000200, 0xd6d33ea8, 0x0879bbf8, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x000801ed,
++				},
++			}, {
++				.total_cols = 815,
++				.rows_per_field = 240,
++				.interlaced = false,
++				.first_field_odd = false,
++				.yuv_scaling = 0x1e635d7f,
++				.back_end_regs = {
++					0x03ce1a17, 0x03e10cc6, 0x0d6801fb, 0x023c034c,
++					0x00f80b6e, 0x00000005, 0x0006000b, 0x000c0011,
++					0x000a0106, 0x00000000, 0x00000000, 0x00000000,
++					0x00000000, 0x00170106, 0x00000000, 0x000a020c,
++					0x00000000, 0x007bffff, 0x385189d8, 0x0d5c53b5,
++					0x02000200, 0xd6d33ea8, 0x0879bbf8, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x000801ad,
++				},
++			},
++		}, {
++			{
++				.total_cols = 724,
++				.rows_per_field = 243,
++				.interlaced = true,
++				.first_field_odd = true,
++				.yuv_scaling = 0x11c1f8e0,
++				.back_end_regs = {
++					0x039f1a3f, 0x03e10cc6, 0x0d6801fb, 0x023c034c,
++					0x00f80b6e, 0x00140019, 0x00000005, 0x0006000b,
++					0x00090103, 0x010f0209, 0x00080102, 0x010e020a,
++					0x0119020a, 0x00120103, 0x01040118, 0x000a020d,
++					0x00000000, 0x007bffff, 0x385189d8, 0x0d5c53b5,
++					0x02000200, 0xd6d33ea8, 0x0879bbf8, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x0009ddef,
++				},
++			}, {
++				.total_cols = 815,
++				.rows_per_field = 243,
++				.interlaced = true,
++				.first_field_odd = true,
++				.yuv_scaling = 0x1e635d7f,
++				.back_end_regs = {
++					0x03ce1a17, 0x03e10cc6, 0x0d6801fb, 0x023c034c,
++					0x00f80b6e, 0x00140019, 0x00000005, 0x0006000b,
++					0x00090103, 0x010f0209, 0x00080102, 0x010e020a,
++					0x0119020a, 0x00120103, 0x01040118, 0x000a020d,
++					0x00000000, 0x007bffff, 0x385189d8, 0x0d5c53b5,
++					0x02000200, 0xd6d33ea8, 0x0879bbf8, 0x00000000,
++					0x0be20200, 0x20f0f800, 0x265c7f00, 0x0009ddaf,
++				},
++			},
++		},
++	},
++};
++
++void rp1vec_hw_setup(struct rp1_vec *vec,
++		     u32 in_format,
++		     struct drm_display_mode const *mode,
++		     int tvstd)
++{
++	unsigned int i, mode_family, mode_ilaced, mode_narrow;
++	const struct rp1vec_hwmode *hwm;
++	unsigned int w, h;
++
++	/* Pick the appropriate "base" mode, which we may modify */
++	mode_ilaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);
++	if (mode->vtotal > 263 * (1 + mode_ilaced))
++		mode_family = 1;
++	else
++		mode_family = (tvstd == RP1VEC_TVSTD_PAL_M || tvstd == RP1VEC_TVSTD_PAL60) ? 2 : 0;
++	mode_narrow = (mode->clock >= 14336);
++	hwm = &rp1vec_hwmodes[mode_family][mode_ilaced][mode_narrow];
++	dev_info(&vec->pdev->dev,
++		 "%s: in_fmt=\'%c%c%c%c\' mode=%dx%d%s [%d%d%d] tvstd=%d (%s)",
++		__func__, in_format, in_format >> 8, in_format >> 16, in_format >> 24,
++		mode->hdisplay, mode->vdisplay, (mode_ilaced) ? "i" : "",
++		mode_family, mode_ilaced, mode_narrow,
++		tvstd, rp1vec_tvstd_names[tvstd]);
++
++	w = mode->hdisplay;
++	h = mode->vdisplay;
++	if (mode_ilaced)
++		h >>= 1;
++	if (w > hwm->total_cols)
++		w = hwm->total_cols;
++	if (h > hwm->rows_per_field)
++		w = hwm->rows_per_field;
++
++	/* Configure the hardware */
++	VEC_WRITE(VEC_APB_TIMEOUT, 0x38);
++	VEC_WRITE(VEC_QOS,
++		  BITS(VEC_QOS_DQOS, 0x0) |
++		  BITS(VEC_QOS_ULEV, 0x8) |
++		  BITS(VEC_QOS_UQOS, 0x2) |
++		  BITS(VEC_QOS_LLEV, 0x4) |
++		  BITS(VEC_QOS_LQOS, 0x7));
++	VEC_WRITE(VEC_DMA_AREA,
++		  BITS(VEC_DMA_AREA_COLS_MINUS1, w - 1) |
++		  BITS(VEC_DMA_AREA_ROWS_PER_FIELD_MINUS1, h - 1));
++	VEC_WRITE(VEC_YUV_SCALING, hwm->yuv_scaling);
++	VEC_WRITE(VEC_BACK_PORCH,
++		  BITS(VEC_BACK_PORCH_HBP_MINUS1, (hwm->total_cols - w - 1) >> 1) |
++		  BITS(VEC_BACK_PORCH_VBP_MINUS1, (hwm->rows_per_field - h - 1) >> 1));
++	VEC_WRITE(VEC_FRONT_PORCH,
++		  BITS(VEC_FRONT_PORCH_HFP_MINUS1, (hwm->total_cols - w - 2) >> 1) |
++		  BITS(VEC_FRONT_PORCH_VFP_MINUS1, (hwm->rows_per_field - h - 2) >> 1));
++	VEC_WRITE(VEC_MODE,
++		  BITS(VEC_MODE_HIGH_WATER, 0xE0)			  |
++		  BITS(VEC_MODE_ALIGN16, !((w | mode->hdisplay) & 15))	  |
++		  BITS(VEC_MODE_VFP_EN, (hwm->rows_per_field > h + 1))	  |
++		  BITS(VEC_MODE_VBP_EN, (hwm->rows_per_field > h))	  |
++		  BITS(VEC_MODE_HFP_EN, (hwm->total_cols > w + 1))          |
++		  BITS(VEC_MODE_HBP_EN, (hwm->total_cols > w))		  |
++		  BITS(VEC_MODE_FIELDS_PER_FRAME_MINUS1, hwm->interlaced) |
++		  BITS(VEC_MODE_FIRST_FIELD_ODD, hwm->first_field_odd));
++	for (i = 0; i < ARRAY_SIZE(hwm->back_end_regs); ++i) {
++		writel(hwm->back_end_regs[i],
++		       vec->hw_base[RP1VEC_HW_BLOCK_VEC] + 0x80 + 4 * i);
++	}
++
++	/* Apply modifications */
++	if (tvstd == RP1VEC_TVSTD_NTSC_J && mode_family == 0) {
++		/* Reduce pedestal (not quite to zero, for FIR overshoot); increase gain */
++		VEC_WRITE(VEC_DAC_BC,
++			  BITS(VEC_DAC_BC_S11_PEDESTAL, 10) |
++			  (hwm->back_end_regs[(0xBC - 0x80) / 4] & ~VEC_DAC_BC_S11_PEDESTAL_BITS));
++		VEC_WRITE(VEC_DAC_C8,
++			  BITS(VEC_DAC_C8_U16_SCALE_LUMA, 0x9400) |
++			  (hwm->back_end_regs[(0xC8 - 0x80) / 4] &
++							~VEC_DAC_C8_U16_SCALE_LUMA_BITS));
++	} else if ((tvstd == RP1VEC_TVSTD_NTSC_443 || tvstd == RP1VEC_TVSTD_PAL60) &&
++		   mode_family != 1) {
++		/* Change colour carrier frequency to 4433618.75 Hz; disable hard sync */
++		VEC_WRITE(VEC_DAC_D4, 0xcc48c1d1);
++		VEC_WRITE(VEC_DAC_D8, 0x0a8262b2);
++		VEC_WRITE(VEC_DAC_EC,
++			  hwm->back_end_regs[(0xEC - 0x80) / 4] & ~VEC_DAC_EC_SEQ_EN_BITS);
++	} else if (tvstd == RP1VEC_TVSTD_PAL_N && mode_family == 1) {
++		/* Change colour carrier frequency to 3582056.25 Hz */
++		VEC_WRITE(VEC_DAC_D4, 0x9ce075f7);
++		VEC_WRITE(VEC_DAC_D8, 0x087da511);
++	}
++
++	/* Input pixel format conversion */
++	for (i = 0; i < ARRAY_SIZE(my_formats); ++i) {
++		if (my_formats[i].format == in_format)
++			break;
++	}
++	if (i >= ARRAY_SIZE(my_formats)) {
++		dev_err(&vec->pdev->dev, "%s: bad input format\n", __func__);
++		i = 0;
++	}
++	VEC_WRITE(VEC_IMASK, my_formats[i].mask);
++	VEC_WRITE(VEC_SHIFT, my_formats[i].shift);
++	VEC_WRITE(VEC_RGBSZ, my_formats[i].rgbsz);
++
++	VEC_WRITE(VEC_IRQ_FLAGS, 0xffffffff);
++	rp1vec_hw_vblank_ctrl(vec, 1);
++
++	i = rp1vec_hw_busy(vec);
++	if (i)
++		dev_warn(&vec->pdev->dev,
++			 "%s: VEC unexpectedly busy at start (0x%08x)",
++			__func__, VEC_READ(VEC_STATUS));
++
++	VEC_WRITE(VEC_CONTROL,
++		  BITS(VEC_CONTROL_START_ARM, (!i)) |
++		  BITS(VEC_CONTROL_AUTO_REPEAT, 1));
++}
++
++void rp1vec_hw_update(struct rp1_vec *vec, dma_addr_t addr, u32 offset, u32 stride)
++{
++	/*
++	 * Update STRIDE, DMAH and DMAL only. When called after rp1vec_hw_setup(),
++	 * DMA starts immediately; if already running, the buffer will flip at
++	 * the next vertical sync event.
++	 */
++	u64 a = addr + offset;
++
++	VEC_WRITE(VEC_DMA_STRIDE, stride);
++	VEC_WRITE(VEC_DMA_ADDR_H, a >> 32);
++	VEC_WRITE(VEC_DMA_ADDR_L, a & 0xFFFFFFFFu);
++}
++
++void rp1vec_hw_stop(struct rp1_vec *vec)
++{
++	/*
++	 * Stop DMA by turning off the Auto-Repeat flag, and wait up to 100ms for
++	 * the current and any queued frame to end. "Force drain" flags are not used,
++	 * as they seem to prevent DMA from re-starting properly; it's safer to wait.
++	 */
++
++	reinit_completion(&vec->finished);
++	VEC_WRITE(VEC_CONTROL, 0);
++	if (!wait_for_completion_timeout(&vec->finished, HZ / 10))
++		drm_err(vec->drm, "%s: timed out waiting for idle\n", __func__);
++	VEC_WRITE(VEC_IRQ_ENABLES, 0);
++}
++
++void rp1vec_hw_vblank_ctrl(struct rp1_vec *vec, int enable)
++{
++	VEC_WRITE(VEC_IRQ_ENABLES,
++		  BITS(VEC_IRQ_ENABLES_DONE, 1) |
++		  BITS(VEC_IRQ_ENABLES_DMA, (enable ? 1 : 0)) |
++		  BITS(VEC_IRQ_ENABLES_MATCH_ROW, 1023));
++}
++
++irqreturn_t rp1vec_hw_isr(int irq, void *dev)
++{
++	struct rp1_vec *vec = dev;
++	u32 u = VEC_READ(VEC_IRQ_FLAGS);
++
++	if (u) {
++		VEC_WRITE(VEC_IRQ_FLAGS, u);
++		if (u & VEC_IRQ_FLAGS_DMA_BITS)
++			drm_crtc_handle_vblank(&vec->pipe.crtc);
++		if (u & VEC_IRQ_FLAGS_DONE_BITS)
++			complete(&vec->finished);
++	}
++	return u ? IRQ_HANDLED : IRQ_NONE;
++}
+--- /dev/null
++++ b/drivers/gpu/drm/rp1/rp1-vec/vec_regs.h
+@@ -0,0 +1,1420 @@
++/* SPDX-License-Identifier: GPL-2.0-or-later */
++// =============================================================================
++// Copyright Raspberry Pi Ltd. 2023
++// vrbuild version: 56aac1a23c016cbbd229108f3b6efc1343842156-clean
++// THIS FILE IS GENERATED BY VRBUILD - DO NOT EDIT
++// =============================================================================
++// Register block : VEC
++// Version        : 1
++// Bus type       : apb
++// Description    : None
++// =============================================================================
++#ifndef VEC_REGS_DEFINED
++#define VEC_REGS_DEFINED
++#define VEC_REGS_RWTYPE_MSB 13
++#define VEC_REGS_RWTYPE_LSB 12
++// =============================================================================
++// Register    : VEC_CONTROL
++// JTAG access : synchronous
++// Description : None
++#define VEC_CONTROL_OFFSET 0x00000000
++#define VEC_CONTROL_BITS   0x00000007
++#define VEC_CONTROL_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_CONTROL_BARS
++// Description : Write '1' to display colour bar test pattern
++#define VEC_CONTROL_BARS_RESET  0x0
++#define VEC_CONTROL_BARS_BITS   0x00000004
++#define VEC_CONTROL_BARS_MSB    2
++#define VEC_CONTROL_BARS_LSB    2
++#define VEC_CONTROL_BARS_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_CONTROL_AUTO_REPEAT
++// Description : Write '1' to re-display same frame continuously
++#define VEC_CONTROL_AUTO_REPEAT_RESET  0x0
++#define VEC_CONTROL_AUTO_REPEAT_BITS   0x00000002
++#define VEC_CONTROL_AUTO_REPEAT_MSB    1
++#define VEC_CONTROL_AUTO_REPEAT_LSB    1
++#define VEC_CONTROL_AUTO_REPEAT_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_CONTROL_START_ARM
++// Description : Write '1' before first DMA address is written This bit always
++//               reads back as '0'
++#define VEC_CONTROL_START_ARM_RESET  0x0
++#define VEC_CONTROL_START_ARM_BITS   0x00000001
++#define VEC_CONTROL_START_ARM_MSB    0
++#define VEC_CONTROL_START_ARM_LSB    0
++#define VEC_CONTROL_START_ARM_ACCESS "SC"
++// =============================================================================
++// Register    : VEC_IRQ_ENABLES
++// JTAG access : synchronous
++// Description : None
++#define VEC_IRQ_ENABLES_OFFSET 0x00000004
++#define VEC_IRQ_ENABLES_BITS   0x03ff003f
++#define VEC_IRQ_ENABLES_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_ENABLES_MATCH_ROW
++// Description : Raster line at which MATCH interrupt is signalled
++#define VEC_IRQ_ENABLES_MATCH_ROW_RESET  0x000
++#define VEC_IRQ_ENABLES_MATCH_ROW_BITS   0x03ff0000
++#define VEC_IRQ_ENABLES_MATCH_ROW_MSB    25
++#define VEC_IRQ_ENABLES_MATCH_ROW_LSB    16
++#define VEC_IRQ_ENABLES_MATCH_ROW_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_ENABLES_MATCH
++// Description : Output raster == match_row reached
++#define VEC_IRQ_ENABLES_MATCH_RESET  0x0
++#define VEC_IRQ_ENABLES_MATCH_BITS   0x00000020
++#define VEC_IRQ_ENABLES_MATCH_MSB    5
++#define VEC_IRQ_ENABLES_MATCH_LSB    5
++#define VEC_IRQ_ENABLES_MATCH_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_ENABLES_ERROR
++// Description : DMA address overwritten before it was taken
++#define VEC_IRQ_ENABLES_ERROR_RESET  0x0
++#define VEC_IRQ_ENABLES_ERROR_BITS   0x00000010
++#define VEC_IRQ_ENABLES_ERROR_MSB    4
++#define VEC_IRQ_ENABLES_ERROR_LSB    4
++#define VEC_IRQ_ENABLES_ERROR_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_ENABLES_DONE
++// Description : Last word sent to DAC after end of video (= all clear)
++#define VEC_IRQ_ENABLES_DONE_RESET  0x0
++#define VEC_IRQ_ENABLES_DONE_BITS   0x00000008
++#define VEC_IRQ_ENABLES_DONE_MSB    3
++#define VEC_IRQ_ENABLES_DONE_LSB    3
++#define VEC_IRQ_ENABLES_DONE_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_ENABLES_FRAME
++// Description : Start of frame
++#define VEC_IRQ_ENABLES_FRAME_RESET  0x0
++#define VEC_IRQ_ENABLES_FRAME_BITS   0x00000004
++#define VEC_IRQ_ENABLES_FRAME_MSB    2
++#define VEC_IRQ_ENABLES_FRAME_LSB    2
++#define VEC_IRQ_ENABLES_FRAME_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_ENABLES_UNDERFLOW
++// Description : Underflow has occurred
++#define VEC_IRQ_ENABLES_UNDERFLOW_RESET  0x0
++#define VEC_IRQ_ENABLES_UNDERFLOW_BITS   0x00000002
++#define VEC_IRQ_ENABLES_UNDERFLOW_MSB    1
++#define VEC_IRQ_ENABLES_UNDERFLOW_LSB    1
++#define VEC_IRQ_ENABLES_UNDERFLOW_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_ENABLES_DMA
++// Description : DMA ready to accept next frame start address
++#define VEC_IRQ_ENABLES_DMA_RESET  0x0
++#define VEC_IRQ_ENABLES_DMA_BITS   0x00000001
++#define VEC_IRQ_ENABLES_DMA_MSB    0
++#define VEC_IRQ_ENABLES_DMA_LSB    0
++#define VEC_IRQ_ENABLES_DMA_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_IRQ_FLAGS
++// JTAG access : synchronous
++// Description : None
++#define VEC_IRQ_FLAGS_OFFSET 0x00000008
++#define VEC_IRQ_FLAGS_BITS   0x0000003f
++#define VEC_IRQ_FLAGS_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_FLAGS_MATCH
++// Description : Output raster == match_row reached
++#define VEC_IRQ_FLAGS_MATCH_RESET  0x0
++#define VEC_IRQ_FLAGS_MATCH_BITS   0x00000020
++#define VEC_IRQ_FLAGS_MATCH_MSB    5
++#define VEC_IRQ_FLAGS_MATCH_LSB    5
++#define VEC_IRQ_FLAGS_MATCH_ACCESS "WC"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_FLAGS_ERROR
++// Description : DMA address overwritten before it was taken
++#define VEC_IRQ_FLAGS_ERROR_RESET  0x0
++#define VEC_IRQ_FLAGS_ERROR_BITS   0x00000010
++#define VEC_IRQ_FLAGS_ERROR_MSB    4
++#define VEC_IRQ_FLAGS_ERROR_LSB    4
++#define VEC_IRQ_FLAGS_ERROR_ACCESS "WC"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_FLAGS_DONE
++// Description : Last word sent to DAC after end of video (= all clear)
++#define VEC_IRQ_FLAGS_DONE_RESET  0x0
++#define VEC_IRQ_FLAGS_DONE_BITS   0x00000008
++#define VEC_IRQ_FLAGS_DONE_MSB    3
++#define VEC_IRQ_FLAGS_DONE_LSB    3
++#define VEC_IRQ_FLAGS_DONE_ACCESS "WC"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_FLAGS_FRAME
++// Description : Start of frame
++#define VEC_IRQ_FLAGS_FRAME_RESET  0x0
++#define VEC_IRQ_FLAGS_FRAME_BITS   0x00000004
++#define VEC_IRQ_FLAGS_FRAME_MSB    2
++#define VEC_IRQ_FLAGS_FRAME_LSB    2
++#define VEC_IRQ_FLAGS_FRAME_ACCESS "WC"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_FLAGS_UNDERFLOW
++// Description : Underflow has occurred
++#define VEC_IRQ_FLAGS_UNDERFLOW_RESET  0x0
++#define VEC_IRQ_FLAGS_UNDERFLOW_BITS   0x00000002
++#define VEC_IRQ_FLAGS_UNDERFLOW_MSB    1
++#define VEC_IRQ_FLAGS_UNDERFLOW_LSB    1
++#define VEC_IRQ_FLAGS_UNDERFLOW_ACCESS "WC"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IRQ_FLAGS_DMA
++// Description : DMA ready to accept next frame start address
++#define VEC_IRQ_FLAGS_DMA_RESET  0x0
++#define VEC_IRQ_FLAGS_DMA_BITS   0x00000001
++#define VEC_IRQ_FLAGS_DMA_MSB    0
++#define VEC_IRQ_FLAGS_DMA_LSB    0
++#define VEC_IRQ_FLAGS_DMA_ACCESS "WC"
++// =============================================================================
++// Register    : VEC_QOS
++// JTAG access : synchronous
++// Description : This register configures panic levels for the AXI ar_qos
++//               quality of service field. Panic status is driven by the number
++//               of rows held in the SRAM cache:
++#define VEC_QOS_OFFSET 0x0000000c
++#define VEC_QOS_BITS   0x000fffff
++#define VEC_QOS_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_QOS_UQOS
++// Description : Upper AXI QOS
++#define VEC_QOS_UQOS_RESET  0x0
++#define VEC_QOS_UQOS_BITS   0x000f0000
++#define VEC_QOS_UQOS_MSB    19
++#define VEC_QOS_UQOS_LSB    16
++#define VEC_QOS_UQOS_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_QOS_ULEV
++// Description : Upper trip level (resolution = 1 / 16 of cache size)
++#define VEC_QOS_ULEV_RESET  0x0
++#define VEC_QOS_ULEV_BITS   0x0000f000
++#define VEC_QOS_ULEV_MSB    15
++#define VEC_QOS_ULEV_LSB    12
++#define VEC_QOS_ULEV_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_QOS_LQOS
++// Description : Lower AXI QOS
++#define VEC_QOS_LQOS_RESET  0x0
++#define VEC_QOS_LQOS_BITS   0x00000f00
++#define VEC_QOS_LQOS_MSB    11
++#define VEC_QOS_LQOS_LSB    8
++#define VEC_QOS_LQOS_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_QOS_LLEV
++// Description : Lower trip level (resolution = 1 / 16 of cache size)
++#define VEC_QOS_LLEV_RESET  0x0
++#define VEC_QOS_LLEV_BITS   0x000000f0
++#define VEC_QOS_LLEV_MSB    7
++#define VEC_QOS_LLEV_LSB    4
++#define VEC_QOS_LLEV_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_QOS_DQOS
++// Description : Default QOS
++#define VEC_QOS_DQOS_RESET  0x0
++#define VEC_QOS_DQOS_BITS   0x0000000f
++#define VEC_QOS_DQOS_MSB    3
++#define VEC_QOS_DQOS_LSB    0
++#define VEC_QOS_DQOS_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DMA_ADDR_L
++// JTAG access : synchronous
++// Description : Lower 32-bits
++#define VEC_DMA_ADDR_L_OFFSET 0x00000010
++#define VEC_DMA_ADDR_L_BITS   0xffffffff
++#define VEC_DMA_ADDR_L_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DMA_ADDR_L_AXI_ADDR
++// Description : Byte address of DMA transfer frame buffer.
++#define VEC_DMA_ADDR_L_AXI_ADDR_RESET  0x00000000
++#define VEC_DMA_ADDR_L_AXI_ADDR_BITS   0xffffffff
++#define VEC_DMA_ADDR_L_AXI_ADDR_MSB    31
++#define VEC_DMA_ADDR_L_AXI_ADDR_LSB    0
++#define VEC_DMA_ADDR_L_AXI_ADDR_ACCESS "RWF"
++// =============================================================================
++// Register    : VEC_DMA_STRIDE
++// JTAG access : synchronous
++// Description : This register sets the line byte stride.
++#define VEC_DMA_STRIDE_OFFSET 0x00000014
++#define VEC_DMA_STRIDE_BITS   0xffffffff
++#define VEC_DMA_STRIDE_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DMA_STRIDE_STRIDE
++// Description : Byte stride
++#define VEC_DMA_STRIDE_STRIDE_RESET  0x00000000
++#define VEC_DMA_STRIDE_STRIDE_BITS   0xffffffff
++#define VEC_DMA_STRIDE_STRIDE_MSB    31
++#define VEC_DMA_STRIDE_STRIDE_LSB    0
++#define VEC_DMA_STRIDE_STRIDE_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DMA_AREA
++// JTAG access : synchronous
++// Description : Interlaced pixel area. See example driver code.
++#define VEC_DMA_AREA_OFFSET 0x00000018
++#define VEC_DMA_AREA_BITS   0x03ff03ff
++#define VEC_DMA_AREA_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DMA_AREA_COLS_MINUS1
++// Description : Width
++#define VEC_DMA_AREA_COLS_MINUS1_RESET  0x000
++#define VEC_DMA_AREA_COLS_MINUS1_BITS   0x03ff0000
++#define VEC_DMA_AREA_COLS_MINUS1_MSB    25
++#define VEC_DMA_AREA_COLS_MINUS1_LSB    16
++#define VEC_DMA_AREA_COLS_MINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DMA_AREA_ROWS_PER_FIELD_MINUS1
++// Description : Lines per field = half of lines per interlaced frame
++#define VEC_DMA_AREA_ROWS_PER_FIELD_MINUS1_RESET  0x000
++#define VEC_DMA_AREA_ROWS_PER_FIELD_MINUS1_BITS   0x000003ff
++#define VEC_DMA_AREA_ROWS_PER_FIELD_MINUS1_MSB    9
++#define VEC_DMA_AREA_ROWS_PER_FIELD_MINUS1_LSB    0
++#define VEC_DMA_AREA_ROWS_PER_FIELD_MINUS1_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_YUV_SCALING
++// JTAG access : synchronous
++// Description : None
++#define VEC_YUV_SCALING_OFFSET 0x0000001c
++#define VEC_YUV_SCALING_BITS   0x3fffffff
++#define VEC_YUV_SCALING_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_YUV_SCALING_U10_SCALE_Y
++// Description : Y unsigned scaling factor - 8 binary places
++#define VEC_YUV_SCALING_U10_SCALE_Y_RESET  0x000
++#define VEC_YUV_SCALING_U10_SCALE_Y_BITS   0x3ff00000
++#define VEC_YUV_SCALING_U10_SCALE_Y_MSB    29
++#define VEC_YUV_SCALING_U10_SCALE_Y_LSB    20
++#define VEC_YUV_SCALING_U10_SCALE_Y_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_YUV_SCALING_S10_SCALE_U
++// Description : U signed scaling factor - 8 binary places
++#define VEC_YUV_SCALING_S10_SCALE_U_RESET  0x000
++#define VEC_YUV_SCALING_S10_SCALE_U_BITS   0x000ffc00
++#define VEC_YUV_SCALING_S10_SCALE_U_MSB    19
++#define VEC_YUV_SCALING_S10_SCALE_U_LSB    10
++#define VEC_YUV_SCALING_S10_SCALE_U_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_YUV_SCALING_S10_SCALE_V
++// Description : V signed scaling factor - 8 binary please
++#define VEC_YUV_SCALING_S10_SCALE_V_RESET  0x000
++#define VEC_YUV_SCALING_S10_SCALE_V_BITS   0x000003ff
++#define VEC_YUV_SCALING_S10_SCALE_V_MSB    9
++#define VEC_YUV_SCALING_S10_SCALE_V_LSB    0
++#define VEC_YUV_SCALING_S10_SCALE_V_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_BACK_PORCH
++// JTAG access : synchronous
++// Description : None
++#define VEC_BACK_PORCH_OFFSET 0x00000020
++#define VEC_BACK_PORCH_BITS   0x03ff03ff
++#define VEC_BACK_PORCH_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_BACK_PORCH_HBP_MINUS1
++// Description : Horizontal back porch
++#define VEC_BACK_PORCH_HBP_MINUS1_RESET  0x000
++#define VEC_BACK_PORCH_HBP_MINUS1_BITS   0x03ff0000
++#define VEC_BACK_PORCH_HBP_MINUS1_MSB    25
++#define VEC_BACK_PORCH_HBP_MINUS1_LSB    16
++#define VEC_BACK_PORCH_HBP_MINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_BACK_PORCH_VBP_MINUS1
++// Description : Vertical back porch
++#define VEC_BACK_PORCH_VBP_MINUS1_RESET  0x000
++#define VEC_BACK_PORCH_VBP_MINUS1_BITS   0x000003ff
++#define VEC_BACK_PORCH_VBP_MINUS1_MSB    9
++#define VEC_BACK_PORCH_VBP_MINUS1_LSB    0
++#define VEC_BACK_PORCH_VBP_MINUS1_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_FRONT_PORCH
++// JTAG access : synchronous
++// Description : None
++#define VEC_FRONT_PORCH_OFFSET 0x00000024
++#define VEC_FRONT_PORCH_BITS   0x03ff03ff
++#define VEC_FRONT_PORCH_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_FRONT_PORCH_HFP_MINUS1
++// Description : Horizontal front porch
++#define VEC_FRONT_PORCH_HFP_MINUS1_RESET  0x000
++#define VEC_FRONT_PORCH_HFP_MINUS1_BITS   0x03ff0000
++#define VEC_FRONT_PORCH_HFP_MINUS1_MSB    25
++#define VEC_FRONT_PORCH_HFP_MINUS1_LSB    16
++#define VEC_FRONT_PORCH_HFP_MINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_FRONT_PORCH_VFP_MINUS1
++// Description : Vertical front porch
++#define VEC_FRONT_PORCH_VFP_MINUS1_RESET  0x000
++#define VEC_FRONT_PORCH_VFP_MINUS1_BITS   0x000003ff
++#define VEC_FRONT_PORCH_VFP_MINUS1_MSB    9
++#define VEC_FRONT_PORCH_VFP_MINUS1_LSB    0
++#define VEC_FRONT_PORCH_VFP_MINUS1_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_SHIFT
++// JTAG access : synchronous
++// Description : Positions of R,G,B MS bits in the memory word. Note: due to an
++//               unintended red/blue swap, these fields have been renamed since
++//               a previous version. There is no functional change.
++#define VEC_SHIFT_OFFSET 0x00000028
++#define VEC_SHIFT_BITS   0x00007fff
++#define VEC_SHIFT_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_SHIFT_SHIFT_R
++// Description : Red MSB
++#define VEC_SHIFT_SHIFT_R_RESET  0x00
++#define VEC_SHIFT_SHIFT_R_BITS   0x00007c00
++#define VEC_SHIFT_SHIFT_R_MSB    14
++#define VEC_SHIFT_SHIFT_R_LSB    10
++#define VEC_SHIFT_SHIFT_R_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_SHIFT_SHIFT_G
++// Description : Green MSB
++#define VEC_SHIFT_SHIFT_G_RESET  0x00
++#define VEC_SHIFT_SHIFT_G_BITS   0x000003e0
++#define VEC_SHIFT_SHIFT_G_MSB    9
++#define VEC_SHIFT_SHIFT_G_LSB    5
++#define VEC_SHIFT_SHIFT_G_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_SHIFT_SHIFT_B
++// Description : Blue MSB
++#define VEC_SHIFT_SHIFT_B_RESET  0x00
++#define VEC_SHIFT_SHIFT_B_BITS   0x0000001f
++#define VEC_SHIFT_SHIFT_B_MSB    4
++#define VEC_SHIFT_SHIFT_B_LSB    0
++#define VEC_SHIFT_SHIFT_B_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_IMASK
++// JTAG access : synchronous
++// Description : Masks for R,G,B significant bits, left-justified within 10-bit
++//               fields.
++#define VEC_IMASK_OFFSET 0x0000002c
++#define VEC_IMASK_BITS   0x3fffffff
++#define VEC_IMASK_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_IMASK_MASK_R
++// Description : Red mask
++#define VEC_IMASK_MASK_R_RESET  0x000
++#define VEC_IMASK_MASK_R_BITS   0x3ff00000
++#define VEC_IMASK_MASK_R_MSB    29
++#define VEC_IMASK_MASK_R_LSB    20
++#define VEC_IMASK_MASK_R_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IMASK_MASK_G
++// Description : Green mask
++#define VEC_IMASK_MASK_G_RESET  0x000
++#define VEC_IMASK_MASK_G_BITS   0x000ffc00
++#define VEC_IMASK_MASK_G_MSB    19
++#define VEC_IMASK_MASK_G_LSB    10
++#define VEC_IMASK_MASK_G_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_IMASK_MASK_B
++// Description : Blue mask
++#define VEC_IMASK_MASK_B_RESET  0x000
++#define VEC_IMASK_MASK_B_BITS   0x000003ff
++#define VEC_IMASK_MASK_B_MSB    9
++#define VEC_IMASK_MASK_B_LSB    0
++#define VEC_IMASK_MASK_B_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_MODE
++// JTAG access : synchronous
++// Description : None
++#define VEC_MODE_OFFSET 0x00000030
++#define VEC_MODE_BITS   0x01ff003f
++#define VEC_MODE_RESET  0x01c00000
++// -----------------------------------------------------------------------------
++// Field       : VEC_MODE_HIGH_WATER
++// Description : ALWAYS WRITE 8'hE0
++#define VEC_MODE_HIGH_WATER_RESET  0xe0
++#define VEC_MODE_HIGH_WATER_BITS   0x01fe0000
++#define VEC_MODE_HIGH_WATER_MSB    24
++#define VEC_MODE_HIGH_WATER_LSB    17
++#define VEC_MODE_HIGH_WATER_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_MODE_ALIGN16
++// Description : Data: 0=BYTE aligned; 1=BEAT aligned
++#define VEC_MODE_ALIGN16_RESET  0x0
++#define VEC_MODE_ALIGN16_BITS   0x00010000
++#define VEC_MODE_ALIGN16_MSB    16
++#define VEC_MODE_ALIGN16_LSB    16
++#define VEC_MODE_ALIGN16_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_MODE_VFP_EN
++// Description : Enable vertical front porch
++#define VEC_MODE_VFP_EN_RESET  0x0
++#define VEC_MODE_VFP_EN_BITS   0x00000020
++#define VEC_MODE_VFP_EN_MSB    5
++#define VEC_MODE_VFP_EN_LSB    5
++#define VEC_MODE_VFP_EN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_MODE_VBP_EN
++// Description : Enable vertical back porch
++#define VEC_MODE_VBP_EN_RESET  0x0
++#define VEC_MODE_VBP_EN_BITS   0x00000010
++#define VEC_MODE_VBP_EN_MSB    4
++#define VEC_MODE_VBP_EN_LSB    4
++#define VEC_MODE_VBP_EN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_MODE_HFP_EN
++// Description : Enable horizontal front porch
++#define VEC_MODE_HFP_EN_RESET  0x0
++#define VEC_MODE_HFP_EN_BITS   0x00000008
++#define VEC_MODE_HFP_EN_MSB    3
++#define VEC_MODE_HFP_EN_LSB    3
++#define VEC_MODE_HFP_EN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_MODE_HBP_EN
++// Description : Enable horizontal back porch
++#define VEC_MODE_HBP_EN_RESET  0x0
++#define VEC_MODE_HBP_EN_BITS   0x00000004
++#define VEC_MODE_HBP_EN_MSB    2
++#define VEC_MODE_HBP_EN_LSB    2
++#define VEC_MODE_HBP_EN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_MODE_FIELDS_PER_FRAME_MINUS1
++// Description : Interlaced / progressive
++#define VEC_MODE_FIELDS_PER_FRAME_MINUS1_RESET  0x0
++#define VEC_MODE_FIELDS_PER_FRAME_MINUS1_BITS   0x00000002
++#define VEC_MODE_FIELDS_PER_FRAME_MINUS1_MSB    1
++#define VEC_MODE_FIELDS_PER_FRAME_MINUS1_LSB    1
++#define VEC_MODE_FIELDS_PER_FRAME_MINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_MODE_FIRST_FIELD_ODD
++// Description : Interlacing order: odd/even or even/odd
++#define VEC_MODE_FIRST_FIELD_ODD_RESET  0x0
++#define VEC_MODE_FIRST_FIELD_ODD_BITS   0x00000001
++#define VEC_MODE_FIRST_FIELD_ODD_MSB    0
++#define VEC_MODE_FIRST_FIELD_ODD_LSB    0
++#define VEC_MODE_FIRST_FIELD_ODD_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_RGBSZ
++// JTAG access : synchronous
++// Description : None
++#define VEC_RGBSZ_OFFSET 0x00000034
++#define VEC_RGBSZ_BITS   0x00030fff
++#define VEC_RGBSZ_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1
++// Description : Pixel stride
++#define VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1_RESET  0x0
++#define VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1_BITS   0x00030000
++#define VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1_MSB    17
++#define VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1_LSB    16
++#define VEC_RGBSZ_BYTES_PER_PIXEL_MINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_RGBSZ_SCALE_R
++// Description : Red number of bits for shift-and-OR scaling
++#define VEC_RGBSZ_SCALE_R_RESET  0x0
++#define VEC_RGBSZ_SCALE_R_BITS   0x00000f00
++#define VEC_RGBSZ_SCALE_R_MSB    11
++#define VEC_RGBSZ_SCALE_R_LSB    8
++#define VEC_RGBSZ_SCALE_R_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_RGBSZ_SCALE_G
++// Description : Green number of bits for shift-and-OR scaling
++#define VEC_RGBSZ_SCALE_G_RESET  0x0
++#define VEC_RGBSZ_SCALE_G_BITS   0x000000f0
++#define VEC_RGBSZ_SCALE_G_MSB    7
++#define VEC_RGBSZ_SCALE_G_LSB    4
++#define VEC_RGBSZ_SCALE_G_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_RGBSZ_SCALE_B
++// Description : Blue number of bits for shift-and-OR scaling
++#define VEC_RGBSZ_SCALE_B_RESET  0x0
++#define VEC_RGBSZ_SCALE_B_BITS   0x0000000f
++#define VEC_RGBSZ_SCALE_B_MSB    3
++#define VEC_RGBSZ_SCALE_B_LSB    0
++#define VEC_RGBSZ_SCALE_B_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_PANICS
++// JTAG access : synchronous
++// Description : None
++#define VEC_PANICS_OFFSET 0x00000038
++#define VEC_PANICS_BITS   0xffffffff
++#define VEC_PANICS_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_PANICS_UCOUNT
++// Description : Upper panic count
++#define VEC_PANICS_UCOUNT_RESET  0x0000
++#define VEC_PANICS_UCOUNT_BITS   0xffff0000
++#define VEC_PANICS_UCOUNT_MSB    31
++#define VEC_PANICS_UCOUNT_LSB    16
++#define VEC_PANICS_UCOUNT_ACCESS "WC"
++// -----------------------------------------------------------------------------
++// Field       : VEC_PANICS_LCOUNT
++// Description : Lower panic count
++#define VEC_PANICS_LCOUNT_RESET  0x0000
++#define VEC_PANICS_LCOUNT_BITS   0x0000ffff
++#define VEC_PANICS_LCOUNT_MSB    15
++#define VEC_PANICS_LCOUNT_LSB    0
++#define VEC_PANICS_LCOUNT_ACCESS "WC"
++// =============================================================================
++// Register    : VEC_STATUS
++// JTAG access : synchronous
++// Description : None
++#define VEC_STATUS_OFFSET 0x0000003c
++#define VEC_STATUS_BITS   0xff000000
++#define VEC_STATUS_RESET  0x0d000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_STATUS_VERSION
++// Description : VEC module version code
++#define VEC_STATUS_VERSION_RESET  0x0d
++#define VEC_STATUS_VERSION_BITS   0xff000000
++#define VEC_STATUS_VERSION_MSB    31
++#define VEC_STATUS_VERSION_LSB    24
++#define VEC_STATUS_VERSION_ACCESS "RO"
++// =============================================================================
++// Register    : VEC_DMA_ADDR_H
++// JTAG access : synchronous
++// Description : Upper 32-bits
++#define VEC_DMA_ADDR_H_OFFSET 0x00000040
++#define VEC_DMA_ADDR_H_BITS   0xffffffff
++#define VEC_DMA_ADDR_H_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DMA_ADDR_H_AXI_ADDR
++// Description : Byte address of DMA transfer frame buffer.
++#define VEC_DMA_ADDR_H_AXI_ADDR_RESET  0x00000000
++#define VEC_DMA_ADDR_H_AXI_ADDR_BITS   0xffffffff
++#define VEC_DMA_ADDR_H_AXI_ADDR_MSB    31
++#define VEC_DMA_ADDR_H_AXI_ADDR_LSB    0
++#define VEC_DMA_ADDR_H_AXI_ADDR_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_BURST_ADDR_L
++// JTAG access : synchronous
++// Description : None
++#define VEC_BURST_ADDR_L_OFFSET 0x00000044
++#define VEC_BURST_ADDR_L_BITS   0xffffffff
++#define VEC_BURST_ADDR_L_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_BURST_ADDR_L_BURST_ADDR
++// Description : the lower 32-bits of the most recent read request sent to AXI
++//               memory.
++#define VEC_BURST_ADDR_L_BURST_ADDR_RESET  0x00000000
++#define VEC_BURST_ADDR_L_BURST_ADDR_BITS   0xffffffff
++#define VEC_BURST_ADDR_L_BURST_ADDR_MSB    31
++#define VEC_BURST_ADDR_L_BURST_ADDR_LSB    0
++#define VEC_BURST_ADDR_L_BURST_ADDR_ACCESS "RO"
++// =============================================================================
++// Register    : VEC_APB_TIMEOUT
++// JTAG access : synchronous
++// Description : None
++#define VEC_APB_TIMEOUT_OFFSET 0x00000048
++#define VEC_APB_TIMEOUT_BITS   0x000103ff
++#define VEC_APB_TIMEOUT_RESET  0x00000014
++// -----------------------------------------------------------------------------
++// Field       : VEC_APB_TIMEOUT_SLVERR_EN
++// Description : 1 = Assert PREADY and PSLVERR on timeout 0 = Assert PREADY only
++#define VEC_APB_TIMEOUT_SLVERR_EN_RESET  0x0
++#define VEC_APB_TIMEOUT_SLVERR_EN_BITS   0x00010000
++#define VEC_APB_TIMEOUT_SLVERR_EN_MSB    16
++#define VEC_APB_TIMEOUT_SLVERR_EN_LSB    16
++#define VEC_APB_TIMEOUT_SLVERR_EN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_APB_TIMEOUT_TIMEOUT
++// Description : Maximum AXI clock cycles to wait for responses from DAC clock
++//               domain APB block
++#define VEC_APB_TIMEOUT_TIMEOUT_RESET  0x014
++#define VEC_APB_TIMEOUT_TIMEOUT_BITS   0x000003ff
++#define VEC_APB_TIMEOUT_TIMEOUT_MSB    9
++#define VEC_APB_TIMEOUT_TIMEOUT_LSB    0
++#define VEC_APB_TIMEOUT_TIMEOUT_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_80
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_80_OFFSET 0x00000080
++#define VEC_DAC_80_BITS   0x3fff3fff
++#define VEC_DAC_80_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_80_U14_DE_BGN
++// Description : Beginning of active data enable within each visible line
++#define VEC_DAC_80_U14_DE_BGN_RESET  0x0000
++#define VEC_DAC_80_U14_DE_BGN_BITS   0x3fff0000
++#define VEC_DAC_80_U14_DE_BGN_MSB    29
++#define VEC_DAC_80_U14_DE_BGN_LSB    16
++#define VEC_DAC_80_U14_DE_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_80_U14_DE_END
++// Description : End of active data enable within each visible line
++#define VEC_DAC_80_U14_DE_END_RESET  0x0000
++#define VEC_DAC_80_U14_DE_END_BITS   0x00003fff
++#define VEC_DAC_80_U14_DE_END_MSB    13
++#define VEC_DAC_80_U14_DE_END_LSB    0
++#define VEC_DAC_80_U14_DE_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_84
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_84_OFFSET 0x00000084
++#define VEC_DAC_84_BITS   0x1fff1fff
++#define VEC_DAC_84_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_84_U13_ACTIVE_RISE
++// Description : Horizontal blanking interval
++#define VEC_DAC_84_U13_ACTIVE_RISE_RESET  0x0000
++#define VEC_DAC_84_U13_ACTIVE_RISE_BITS   0x1fff0000
++#define VEC_DAC_84_U13_ACTIVE_RISE_MSB    28
++#define VEC_DAC_84_U13_ACTIVE_RISE_LSB    16
++#define VEC_DAC_84_U13_ACTIVE_RISE_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_84_U13_ACTIVE_FALL
++// Description : Horizontal blanking interval
++#define VEC_DAC_84_U13_ACTIVE_FALL_RESET  0x0000
++#define VEC_DAC_84_U13_ACTIVE_FALL_BITS   0x00001fff
++#define VEC_DAC_84_U13_ACTIVE_FALL_MSB    12
++#define VEC_DAC_84_U13_ACTIVE_FALL_LSB    0
++#define VEC_DAC_84_U13_ACTIVE_FALL_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_88
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_88_OFFSET 0x00000088
++#define VEC_DAC_88_BITS   0x1fff1fff
++#define VEC_DAC_88_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_88_U13_HALF_LINE_PERIOD
++// Description : Ratio of DAC clock to horizontal line rate, halved
++#define VEC_DAC_88_U13_HALF_LINE_PERIOD_RESET  0x0000
++#define VEC_DAC_88_U13_HALF_LINE_PERIOD_BITS   0x1fff0000
++#define VEC_DAC_88_U13_HALF_LINE_PERIOD_MSB    28
++#define VEC_DAC_88_U13_HALF_LINE_PERIOD_LSB    16
++#define VEC_DAC_88_U13_HALF_LINE_PERIOD_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_88_U13_HORZ_SYNC
++// Description : Width of horizontal sync pulses
++#define VEC_DAC_88_U13_HORZ_SYNC_RESET  0x0000
++#define VEC_DAC_88_U13_HORZ_SYNC_BITS   0x00001fff
++#define VEC_DAC_88_U13_HORZ_SYNC_MSB    12
++#define VEC_DAC_88_U13_HORZ_SYNC_LSB    0
++#define VEC_DAC_88_U13_HORZ_SYNC_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_8C
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_8C_OFFSET 0x0000008c
++#define VEC_DAC_8C_BITS   0x1fff1fff
++#define VEC_DAC_8C_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_8C_U13_BURST_RISE
++// Description : Start of raised-cosine colour burst envelope
++#define VEC_DAC_8C_U13_BURST_RISE_RESET  0x0000
++#define VEC_DAC_8C_U13_BURST_RISE_BITS   0x1fff0000
++#define VEC_DAC_8C_U13_BURST_RISE_MSB    28
++#define VEC_DAC_8C_U13_BURST_RISE_LSB    16
++#define VEC_DAC_8C_U13_BURST_RISE_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_8C_U13_BURST_FALL
++// Description : End of raised-cosine colour burst envelope
++#define VEC_DAC_8C_U13_BURST_FALL_RESET  0x0000
++#define VEC_DAC_8C_U13_BURST_FALL_BITS   0x00001fff
++#define VEC_DAC_8C_U13_BURST_FALL_MSB    12
++#define VEC_DAC_8C_U13_BURST_FALL_LSB    0
++#define VEC_DAC_8C_U13_BURST_FALL_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_90
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_90_OFFSET 0x00000090
++#define VEC_DAC_90_BITS   0x1fff3fff
++#define VEC_DAC_90_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_90_U13_VERT_EQ
++// Description : Width of vertical equalisation pulses (= half line minus
++//               serration)
++#define VEC_DAC_90_U13_VERT_EQ_RESET  0x0000
++#define VEC_DAC_90_U13_VERT_EQ_BITS   0x1fff0000
++#define VEC_DAC_90_U13_VERT_EQ_MSB    28
++#define VEC_DAC_90_U13_VERT_EQ_LSB    16
++#define VEC_DAC_90_U13_VERT_EQ_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_90_U14_VERT_SYNC
++// Description : Width of vertical sync pulses
++#define VEC_DAC_90_U14_VERT_SYNC_RESET  0x0000
++#define VEC_DAC_90_U14_VERT_SYNC_BITS   0x00003fff
++#define VEC_DAC_90_U14_VERT_SYNC_MSB    13
++#define VEC_DAC_90_U14_VERT_SYNC_LSB    0
++#define VEC_DAC_90_U14_VERT_SYNC_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_94
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_94_OFFSET 0x00000094
++#define VEC_DAC_94_BITS   0x03ff03ff
++#define VEC_DAC_94_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_94_U10_PRE_EQ_BGN
++// Description : Half-lines, inclusive, relative to field datum, where vertical
++//               pre-equalisation pulses start
++#define VEC_DAC_94_U10_PRE_EQ_BGN_RESET  0x000
++#define VEC_DAC_94_U10_PRE_EQ_BGN_BITS   0x03ff0000
++#define VEC_DAC_94_U10_PRE_EQ_BGN_MSB    25
++#define VEC_DAC_94_U10_PRE_EQ_BGN_LSB    16
++#define VEC_DAC_94_U10_PRE_EQ_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_94_U10_PRE_EQ_END
++// Description : Half-lines, inclusive, relative to field datum, where vertical
++//               pre-equalisation pulses end
++#define VEC_DAC_94_U10_PRE_EQ_END_RESET  0x000
++#define VEC_DAC_94_U10_PRE_EQ_END_BITS   0x000003ff
++#define VEC_DAC_94_U10_PRE_EQ_END_MSB    9
++#define VEC_DAC_94_U10_PRE_EQ_END_LSB    0
++#define VEC_DAC_94_U10_PRE_EQ_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_98
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_98_OFFSET 0x00000098
++#define VEC_DAC_98_BITS   0x03ff03ff
++#define VEC_DAC_98_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_98_U10_FIELD_SYNC_BGN
++// Description : Half-lines containing vertical sync pulses (inclusive)
++#define VEC_DAC_98_U10_FIELD_SYNC_BGN_RESET  0x000
++#define VEC_DAC_98_U10_FIELD_SYNC_BGN_BITS   0x03ff0000
++#define VEC_DAC_98_U10_FIELD_SYNC_BGN_MSB    25
++#define VEC_DAC_98_U10_FIELD_SYNC_BGN_LSB    16
++#define VEC_DAC_98_U10_FIELD_SYNC_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_98_U10_FIELD_SYNC_END
++// Description : Half-lines containing vertical sync pulses (inclusive)
++#define VEC_DAC_98_U10_FIELD_SYNC_END_RESET  0x000
++#define VEC_DAC_98_U10_FIELD_SYNC_END_BITS   0x000003ff
++#define VEC_DAC_98_U10_FIELD_SYNC_END_MSB    9
++#define VEC_DAC_98_U10_FIELD_SYNC_END_LSB    0
++#define VEC_DAC_98_U10_FIELD_SYNC_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_9C
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_9C_OFFSET 0x0000009c
++#define VEC_DAC_9C_BITS   0x03ff03ff
++#define VEC_DAC_9C_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_9C_U10_POST_EQ_BGN
++// Description : Half-lines containing vertical post-equalisation pulses
++#define VEC_DAC_9C_U10_POST_EQ_BGN_RESET  0x000
++#define VEC_DAC_9C_U10_POST_EQ_BGN_BITS   0x03ff0000
++#define VEC_DAC_9C_U10_POST_EQ_BGN_MSB    25
++#define VEC_DAC_9C_U10_POST_EQ_BGN_LSB    16
++#define VEC_DAC_9C_U10_POST_EQ_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_9C_U10_POST_EQ_END
++// Description : Half-lines containing vertical post-equalisation pulses
++#define VEC_DAC_9C_U10_POST_EQ_END_RESET  0x000
++#define VEC_DAC_9C_U10_POST_EQ_END_BITS   0x000003ff
++#define VEC_DAC_9C_U10_POST_EQ_END_MSB    9
++#define VEC_DAC_9C_U10_POST_EQ_END_LSB    0
++#define VEC_DAC_9C_U10_POST_EQ_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_A0
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_A0_OFFSET 0x000000a0
++#define VEC_DAC_A0_BITS   0x03ff03ff
++#define VEC_DAC_A0_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_A0_U10_FLD1_BURST_BGN
++// Description : First and last full frame lines (1-based numbering) within the
++//               PAL/NTSC four field sequence which require a colour burst
++#define VEC_DAC_A0_U10_FLD1_BURST_BGN_RESET  0x000
++#define VEC_DAC_A0_U10_FLD1_BURST_BGN_BITS   0x03ff0000
++#define VEC_DAC_A0_U10_FLD1_BURST_BGN_MSB    25
++#define VEC_DAC_A0_U10_FLD1_BURST_BGN_LSB    16
++#define VEC_DAC_A0_U10_FLD1_BURST_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_A0_U10_FLD1_BURST_END
++// Description : First and last full frame lines (1-based numbering) within the
++//               PAL/NTSC four field sequence which require a colour burst
++#define VEC_DAC_A0_U10_FLD1_BURST_END_RESET  0x000
++#define VEC_DAC_A0_U10_FLD1_BURST_END_BITS   0x000003ff
++#define VEC_DAC_A0_U10_FLD1_BURST_END_MSB    9
++#define VEC_DAC_A0_U10_FLD1_BURST_END_LSB    0
++#define VEC_DAC_A0_U10_FLD1_BURST_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_A4
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_A4_OFFSET 0x000000a4
++#define VEC_DAC_A4_BITS   0x03ff03ff
++#define VEC_DAC_A4_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_A4_U10_FLD2_BURST_BGN
++// Description : First and last full frame lines (1-based numbering) within the
++//               PAL/NTSC four field sequence which require a colour burst
++#define VEC_DAC_A4_U10_FLD2_BURST_BGN_RESET  0x000
++#define VEC_DAC_A4_U10_FLD2_BURST_BGN_BITS   0x03ff0000
++#define VEC_DAC_A4_U10_FLD2_BURST_BGN_MSB    25
++#define VEC_DAC_A4_U10_FLD2_BURST_BGN_LSB    16
++#define VEC_DAC_A4_U10_FLD2_BURST_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_A4_U10_FLD2_BURST_END
++// Description : First and last full frame lines (1-based numbering) within the
++//               PAL/NTSC four field sequence which require a colour burst
++#define VEC_DAC_A4_U10_FLD2_BURST_END_RESET  0x000
++#define VEC_DAC_A4_U10_FLD2_BURST_END_BITS   0x000003ff
++#define VEC_DAC_A4_U10_FLD2_BURST_END_MSB    9
++#define VEC_DAC_A4_U10_FLD2_BURST_END_LSB    0
++#define VEC_DAC_A4_U10_FLD2_BURST_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_A8
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_A8_OFFSET 0x000000a8
++#define VEC_DAC_A8_BITS   0x03ff03ff
++#define VEC_DAC_A8_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_A8_U10_FLD3_BURST_BGN
++// Description : First and last full frame lines (1-based numbering) within the
++//               PAL/NTSC four field sequence which require a colour burst
++#define VEC_DAC_A8_U10_FLD3_BURST_BGN_RESET  0x000
++#define VEC_DAC_A8_U10_FLD3_BURST_BGN_BITS   0x03ff0000
++#define VEC_DAC_A8_U10_FLD3_BURST_BGN_MSB    25
++#define VEC_DAC_A8_U10_FLD3_BURST_BGN_LSB    16
++#define VEC_DAC_A8_U10_FLD3_BURST_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_A8_U10_FLD3_BURST_END
++// Description : First and last full frame lines (1-based numbering) within the
++//               PAL/NTSC four field sequence which require a colour burst
++#define VEC_DAC_A8_U10_FLD3_BURST_END_RESET  0x000
++#define VEC_DAC_A8_U10_FLD3_BURST_END_BITS   0x000003ff
++#define VEC_DAC_A8_U10_FLD3_BURST_END_MSB    9
++#define VEC_DAC_A8_U10_FLD3_BURST_END_LSB    0
++#define VEC_DAC_A8_U10_FLD3_BURST_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_AC
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_AC_OFFSET 0x000000ac
++#define VEC_DAC_AC_BITS   0x03ff03ff
++#define VEC_DAC_AC_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_AC_U10_FLD4_BURST_BGN
++// Description : First and last full frame lines (1-based numbering) within the
++//               PAL/NTSC four field sequence which require a colour burst
++#define VEC_DAC_AC_U10_FLD4_BURST_BGN_RESET  0x000
++#define VEC_DAC_AC_U10_FLD4_BURST_BGN_BITS   0x03ff0000
++#define VEC_DAC_AC_U10_FLD4_BURST_BGN_MSB    25
++#define VEC_DAC_AC_U10_FLD4_BURST_BGN_LSB    16
++#define VEC_DAC_AC_U10_FLD4_BURST_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_AC_U10_FLD4_BURST_END
++// Description : First and last full frame lines (1-based numbering) within the
++//               PAL/NTSC four field sequence which require a colour burst
++#define VEC_DAC_AC_U10_FLD4_BURST_END_RESET  0x000
++#define VEC_DAC_AC_U10_FLD4_BURST_END_BITS   0x000003ff
++#define VEC_DAC_AC_U10_FLD4_BURST_END_MSB    9
++#define VEC_DAC_AC_U10_FLD4_BURST_END_LSB    0
++#define VEC_DAC_AC_U10_FLD4_BURST_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_B0
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_B0_OFFSET 0x000000b0
++#define VEC_DAC_B0_BITS   0x03ff03ff
++#define VEC_DAC_B0_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_B0_U10_FLD24_FULL_LINE_BGN
++// Description : First and last full visible lines (1-based numbering) in the
++//               PAL/NTSC four field sequence
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_BGN_RESET  0x000
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_BGN_BITS   0x03ff0000
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_BGN_MSB    25
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_BGN_LSB    16
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_B0_U10_FLD24_FULL_LINE_END
++// Description : First and last full visible lines (1-based numbering) in the
++//               PAL/NTSC four field sequence
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_END_RESET  0x000
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_END_BITS   0x000003ff
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_END_MSB    9
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_END_LSB    0
++#define VEC_DAC_B0_U10_FLD24_FULL_LINE_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_B4
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_B4_OFFSET 0x000000b4
++#define VEC_DAC_B4_BITS   0x03ff03ff
++#define VEC_DAC_B4_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_B4_U10_FLD13_FULL_LINE_BGN
++// Description : First and last full visible lines (1-based numbering) in the
++//               PAL/NTSC four field sequence
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_BGN_RESET  0x000
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_BGN_BITS   0x03ff0000
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_BGN_MSB    25
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_BGN_LSB    16
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_BGN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_B4_U10_FLD13_FULL_LINE_END
++// Description : First and last full visible lines (1-based numbering) in the
++//               PAL/NTSC four field sequence
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_END_RESET  0x000
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_END_BITS   0x000003ff
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_END_MSB    9
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_END_LSB    0
++#define VEC_DAC_B4_U10_FLD13_FULL_LINE_END_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_B8
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_B8_OFFSET 0x000000b8
++#define VEC_DAC_B8_BITS   0x03ff03ff
++#define VEC_DAC_B8_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_B8_U10_BOT_HALF_LINE
++// Description : Top and bottom visible half-lines in 1-based standard full
++//               frame numbering, for interlaced modes. Set to zero to disable.
++#define VEC_DAC_B8_U10_BOT_HALF_LINE_RESET  0x000
++#define VEC_DAC_B8_U10_BOT_HALF_LINE_BITS   0x03ff0000
++#define VEC_DAC_B8_U10_BOT_HALF_LINE_MSB    25
++#define VEC_DAC_B8_U10_BOT_HALF_LINE_LSB    16
++#define VEC_DAC_B8_U10_BOT_HALF_LINE_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_B8_U10_TOP_HALF_LINE
++// Description : Top and bottom visible half-lines in 1-based standard full
++//               frame numbering, for interlaced modes. Set to zero to disable.
++#define VEC_DAC_B8_U10_TOP_HALF_LINE_RESET  0x000
++#define VEC_DAC_B8_U10_TOP_HALF_LINE_BITS   0x000003ff
++#define VEC_DAC_B8_U10_TOP_HALF_LINE_MSB    9
++#define VEC_DAC_B8_U10_TOP_HALF_LINE_LSB    0
++#define VEC_DAC_B8_U10_TOP_HALF_LINE_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_BC
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_BC_OFFSET 0x000000bc
++#define VEC_DAC_BC_BITS   0x07ff07ff
++#define VEC_DAC_BC_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_BC_S11_PEDESTAL
++// Description : NTSC pedestal. For 7.5 IRE, this field is 1024 * 7.5/100. For
++//               PAL, or Japanese NTSC, this field should be zero.
++#define VEC_DAC_BC_S11_PEDESTAL_RESET  0x000
++#define VEC_DAC_BC_S11_PEDESTAL_BITS   0x07ff0000
++#define VEC_DAC_BC_S11_PEDESTAL_MSB    26
++#define VEC_DAC_BC_S11_PEDESTAL_LSB    16
++#define VEC_DAC_BC_S11_PEDESTAL_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_BC_U11_HALF_LINES_PER_FIELD
++// Description : Mode = 625 PAL, Lines per field = 312.5,
++//               u11_half_lines_per_field = 1+2*312 Mode = 525 NTSC, Lines per
++//               field = 262.5, u11_half_lines_per_field = 1+2*262
++#define VEC_DAC_BC_U11_HALF_LINES_PER_FIELD_RESET  0x000
++#define VEC_DAC_BC_U11_HALF_LINES_PER_FIELD_BITS   0x000007ff
++#define VEC_DAC_BC_U11_HALF_LINES_PER_FIELD_MSB    10
++#define VEC_DAC_BC_U11_HALF_LINES_PER_FIELD_LSB    0
++#define VEC_DAC_BC_U11_HALF_LINES_PER_FIELD_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_C0
++// JTAG access : synchronous
++// Description : Synopsis DesignWare control
++#define VEC_DAC_C0_OFFSET 0x000000c0
++#define VEC_DAC_C0_BITS   0x000fffff
++#define VEC_DAC_C0_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C0_DWC_CABLE_ENCTR3
++// Description : Synopsis test input
++#define VEC_DAC_C0_DWC_CABLE_ENCTR3_RESET  0x0
++#define VEC_DAC_C0_DWC_CABLE_ENCTR3_BITS   0x00080000
++#define VEC_DAC_C0_DWC_CABLE_ENCTR3_MSB    19
++#define VEC_DAC_C0_DWC_CABLE_ENCTR3_LSB    19
++#define VEC_DAC_C0_DWC_CABLE_ENCTR3_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C0_DWC_CABLE_CABLEOUT
++// Description : cable detect state
++#define VEC_DAC_C0_DWC_CABLE_CABLEOUT_RESET  0x0
++#define VEC_DAC_C0_DWC_CABLE_CABLEOUT_BITS   0x00070000
++#define VEC_DAC_C0_DWC_CABLE_CABLEOUT_MSB    18
++#define VEC_DAC_C0_DWC_CABLE_CABLEOUT_LSB    16
++#define VEC_DAC_C0_DWC_CABLE_CABLEOUT_ACCESS "RO"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C0_DWC_MUX_2
++// Description : Select DAC channel 2 output
++#define VEC_DAC_C0_DWC_MUX_2_RESET  0x0
++#define VEC_DAC_C0_DWC_MUX_2_BITS   0x0000c000
++#define VEC_DAC_C0_DWC_MUX_2_MSB    15
++#define VEC_DAC_C0_DWC_MUX_2_LSB    14
++#define VEC_DAC_C0_DWC_MUX_2_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C0_DWC_MUX_1
++// Description : Select DAC channel 1 output
++#define VEC_DAC_C0_DWC_MUX_1_RESET  0x0
++#define VEC_DAC_C0_DWC_MUX_1_BITS   0x00003000
++#define VEC_DAC_C0_DWC_MUX_1_MSB    13
++#define VEC_DAC_C0_DWC_MUX_1_LSB    12
++#define VEC_DAC_C0_DWC_MUX_1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C0_DWC_MUX_0
++// Description : Select DAC channel 0 output
++#define VEC_DAC_C0_DWC_MUX_0_RESET  0x0
++#define VEC_DAC_C0_DWC_MUX_0_BITS   0x00000c00
++#define VEC_DAC_C0_DWC_MUX_0_MSB    11
++#define VEC_DAC_C0_DWC_MUX_0_LSB    10
++#define VEC_DAC_C0_DWC_MUX_0_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C0_DWC_TEST
++// Description : Fixed DAC command word
++#define VEC_DAC_C0_DWC_TEST_RESET  0x000
++#define VEC_DAC_C0_DWC_TEST_BITS   0x000003ff
++#define VEC_DAC_C0_DWC_TEST_MSB    9
++#define VEC_DAC_C0_DWC_TEST_LSB    0
++#define VEC_DAC_C0_DWC_TEST_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_C4
++// JTAG access : synchronous
++// Description : Synopsis DAC control
++#define VEC_DAC_C4_OFFSET 0x000000c4
++#define VEC_DAC_C4_BITS   0x1fffffff
++#define VEC_DAC_C4_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C4_ENCTR
++// Description : Always write3'b000
++#define VEC_DAC_C4_ENCTR_RESET  0x0
++#define VEC_DAC_C4_ENCTR_BITS   0x1c000000
++#define VEC_DAC_C4_ENCTR_MSB    28
++#define VEC_DAC_C4_ENCTR_LSB    26
++#define VEC_DAC_C4_ENCTR_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C4_ENSC
++// Description : Enable cable detect - write 3'b000
++#define VEC_DAC_C4_ENSC_RESET  0x0
++#define VEC_DAC_C4_ENSC_BITS   0x03800000
++#define VEC_DAC_C4_ENSC_MSB    25
++#define VEC_DAC_C4_ENSC_LSB    23
++#define VEC_DAC_C4_ENSC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C4_ENDAC
++// Description : Enable DAC channel
++#define VEC_DAC_C4_ENDAC_RESET  0x0
++#define VEC_DAC_C4_ENDAC_BITS   0x00700000
++#define VEC_DAC_C4_ENDAC_MSB    22
++#define VEC_DAC_C4_ENDAC_LSB    20
++#define VEC_DAC_C4_ENDAC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C4_ENVBG
++// Description : Enable internal bandgap reference - write '1'
++#define VEC_DAC_C4_ENVBG_RESET  0x0
++#define VEC_DAC_C4_ENVBG_BITS   0x00080000
++#define VEC_DAC_C4_ENVBG_MSB    19
++#define VEC_DAC_C4_ENVBG_LSB    19
++#define VEC_DAC_C4_ENVBG_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C4_ENEXTREF
++// Description : Enable external reference - write '0'
++#define VEC_DAC_C4_ENEXTREF_RESET  0x0
++#define VEC_DAC_C4_ENEXTREF_BITS   0x00040000
++#define VEC_DAC_C4_ENEXTREF_MSB    18
++#define VEC_DAC_C4_ENEXTREF_LSB    18
++#define VEC_DAC_C4_ENEXTREF_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C4_DAC2GC
++// Description : DAC channel 2 gain control - write 6'd63
++#define VEC_DAC_C4_DAC2GC_RESET  0x00
++#define VEC_DAC_C4_DAC2GC_BITS   0x0003f000
++#define VEC_DAC_C4_DAC2GC_MSB    17
++#define VEC_DAC_C4_DAC2GC_LSB    12
++#define VEC_DAC_C4_DAC2GC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C4_DAC1GC
++// Description : DAC channel 1 gain control - write 6'd63
++#define VEC_DAC_C4_DAC1GC_RESET  0x00
++#define VEC_DAC_C4_DAC1GC_BITS   0x00000fc0
++#define VEC_DAC_C4_DAC1GC_MSB    11
++#define VEC_DAC_C4_DAC1GC_LSB    6
++#define VEC_DAC_C4_DAC1GC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C4_DAC0GC
++// Description : DAC channel 0 gain control - write 6'd63
++#define VEC_DAC_C4_DAC0GC_RESET  0x00
++#define VEC_DAC_C4_DAC0GC_BITS   0x0000003f
++#define VEC_DAC_C4_DAC0GC_MSB    5
++#define VEC_DAC_C4_DAC0GC_LSB    0
++#define VEC_DAC_C4_DAC0GC_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_C8
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_C8_OFFSET 0x000000c8
++#define VEC_DAC_C8_BITS   0xffffffff
++#define VEC_DAC_C8_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C8_U16_SCALE_SYNC
++// Description : Scaling applied prior to final summation to form the DAC
++//               command word(s)
++#define VEC_DAC_C8_U16_SCALE_SYNC_RESET  0x0000
++#define VEC_DAC_C8_U16_SCALE_SYNC_BITS   0xffff0000
++#define VEC_DAC_C8_U16_SCALE_SYNC_MSB    31
++#define VEC_DAC_C8_U16_SCALE_SYNC_LSB    16
++#define VEC_DAC_C8_U16_SCALE_SYNC_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_C8_U16_SCALE_LUMA
++// Description : Scaling applied prior to final summation to form the DAC
++//               command word(s)
++#define VEC_DAC_C8_U16_SCALE_LUMA_RESET  0x0000
++#define VEC_DAC_C8_U16_SCALE_LUMA_BITS   0x0000ffff
++#define VEC_DAC_C8_U16_SCALE_LUMA_MSB    15
++#define VEC_DAC_C8_U16_SCALE_LUMA_LSB    0
++#define VEC_DAC_C8_U16_SCALE_LUMA_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_CC
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_CC_OFFSET 0x000000cc
++#define VEC_DAC_CC_BITS   0xffffffff
++#define VEC_DAC_CC_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_CC_S16_SCALE_BURST
++// Description : Scaling applied prior to final summation to form the DAC
++//               command word(s)
++#define VEC_DAC_CC_S16_SCALE_BURST_RESET  0x0000
++#define VEC_DAC_CC_S16_SCALE_BURST_BITS   0xffff0000
++#define VEC_DAC_CC_S16_SCALE_BURST_MSB    31
++#define VEC_DAC_CC_S16_SCALE_BURST_LSB    16
++#define VEC_DAC_CC_S16_SCALE_BURST_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_CC_S16_SCALE_CHROMA
++// Description : Scaling applied prior to final summation to form the DAC
++//               command word(s)
++#define VEC_DAC_CC_S16_SCALE_CHROMA_RESET  0x0000
++#define VEC_DAC_CC_S16_SCALE_CHROMA_BITS   0x0000ffff
++#define VEC_DAC_CC_S16_SCALE_CHROMA_MSB    15
++#define VEC_DAC_CC_S16_SCALE_CHROMA_LSB    0
++#define VEC_DAC_CC_S16_SCALE_CHROMA_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_D0
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_D0_OFFSET 0x000000d0
++#define VEC_DAC_D0_BITS   0xffffffff
++#define VEC_DAC_D0_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_D0_S16_OFFSET_LUMA
++// Description : These offsets are applied to the chroma and luma channels
++//               before the final MUX
++#define VEC_DAC_D0_S16_OFFSET_LUMA_RESET  0x0000
++#define VEC_DAC_D0_S16_OFFSET_LUMA_BITS   0xffff0000
++#define VEC_DAC_D0_S16_OFFSET_LUMA_MSB    31
++#define VEC_DAC_D0_S16_OFFSET_LUMA_LSB    16
++#define VEC_DAC_D0_S16_OFFSET_LUMA_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_D0_S16_OFFSET_CHRO
++// Description : These offsets are applied to the chroma and luma channels
++//               before the final MUX
++#define VEC_DAC_D0_S16_OFFSET_CHRO_RESET  0x0000
++#define VEC_DAC_D0_S16_OFFSET_CHRO_BITS   0x0000ffff
++#define VEC_DAC_D0_S16_OFFSET_CHRO_MSB    15
++#define VEC_DAC_D0_S16_OFFSET_CHRO_LSB    0
++#define VEC_DAC_D0_S16_OFFSET_CHRO_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_D4
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_D4_OFFSET 0x000000d4
++#define VEC_DAC_D4_BITS   0xffffffff
++#define VEC_DAC_D4_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_D4_NCO_FREQ
++// Description : This 64-bit frequency command is applied to the phase
++//               accumulator of the NCO (numerically controlled oscillator)
++//               which generates the colour sub-carrier. This value is computed
++//               as ratio of sub-carrier frequency to DAC clock multiplied by
++//               2^64.
++#define VEC_DAC_D4_NCO_FREQ_RESET  0x00000000
++#define VEC_DAC_D4_NCO_FREQ_BITS   0xffffffff
++#define VEC_DAC_D4_NCO_FREQ_MSB    31
++#define VEC_DAC_D4_NCO_FREQ_LSB    0
++#define VEC_DAC_D4_NCO_FREQ_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_D8
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_D8_OFFSET 0x000000d8
++#define VEC_DAC_D8_BITS   0xffffffff
++#define VEC_DAC_D8_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_D8_NCO_FREQ
++// Description : This 64-bit frequency command is applied to the phase
++//               accumulator of the NCO (numerically controlled oscillator)
++//               which generates the colour sub-carrier. This value is computed
++//               as ratio of sub-carrier frequency to DAC clock multiplied by
++//               2^64.
++#define VEC_DAC_D8_NCO_FREQ_RESET  0x00000000
++#define VEC_DAC_D8_NCO_FREQ_BITS   0xffffffff
++#define VEC_DAC_D8_NCO_FREQ_MSB    31
++#define VEC_DAC_D8_NCO_FREQ_LSB    0
++#define VEC_DAC_D8_NCO_FREQ_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_DC
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_DC_OFFSET 0x000000dc
++#define VEC_DAC_DC_BITS   0xffffffff
++#define VEC_DAC_DC_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_DC_FIR_COEFF_CHROMA_0_6
++// Description : FIR filter coefficients
++#define VEC_DAC_DC_FIR_COEFF_CHROMA_0_6_RESET  0x0000
++#define VEC_DAC_DC_FIR_COEFF_CHROMA_0_6_BITS   0xffff0000
++#define VEC_DAC_DC_FIR_COEFF_CHROMA_0_6_MSB    31
++#define VEC_DAC_DC_FIR_COEFF_CHROMA_0_6_LSB    16
++#define VEC_DAC_DC_FIR_COEFF_CHROMA_0_6_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_DC_FIR_COEFF_LUMA_0_6
++// Description : FIR filter coefficients
++#define VEC_DAC_DC_FIR_COEFF_LUMA_0_6_RESET  0x0000
++#define VEC_DAC_DC_FIR_COEFF_LUMA_0_6_BITS   0x0000ffff
++#define VEC_DAC_DC_FIR_COEFF_LUMA_0_6_MSB    15
++#define VEC_DAC_DC_FIR_COEFF_LUMA_0_6_LSB    0
++#define VEC_DAC_DC_FIR_COEFF_LUMA_0_6_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_E0
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_E0_OFFSET 0x000000e0
++#define VEC_DAC_E0_BITS   0xffffffff
++#define VEC_DAC_E0_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_E0_FIR_COEFF_CHROMA_1_5
++// Description : FIR filter coefficients
++#define VEC_DAC_E0_FIR_COEFF_CHROMA_1_5_RESET  0x0000
++#define VEC_DAC_E0_FIR_COEFF_CHROMA_1_5_BITS   0xffff0000
++#define VEC_DAC_E0_FIR_COEFF_CHROMA_1_5_MSB    31
++#define VEC_DAC_E0_FIR_COEFF_CHROMA_1_5_LSB    16
++#define VEC_DAC_E0_FIR_COEFF_CHROMA_1_5_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_E0_FIR_COEFF_LUMA_1_5
++// Description : FIR filter coefficients
++#define VEC_DAC_E0_FIR_COEFF_LUMA_1_5_RESET  0x0000
++#define VEC_DAC_E0_FIR_COEFF_LUMA_1_5_BITS   0x0000ffff
++#define VEC_DAC_E0_FIR_COEFF_LUMA_1_5_MSB    15
++#define VEC_DAC_E0_FIR_COEFF_LUMA_1_5_LSB    0
++#define VEC_DAC_E0_FIR_COEFF_LUMA_1_5_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_E4
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_E4_OFFSET 0x000000e4
++#define VEC_DAC_E4_BITS   0xffffffff
++#define VEC_DAC_E4_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_E4_FIR_COEFF_CHROMA_2_4
++// Description : FIR filter coefficients
++#define VEC_DAC_E4_FIR_COEFF_CHROMA_2_4_RESET  0x0000
++#define VEC_DAC_E4_FIR_COEFF_CHROMA_2_4_BITS   0xffff0000
++#define VEC_DAC_E4_FIR_COEFF_CHROMA_2_4_MSB    31
++#define VEC_DAC_E4_FIR_COEFF_CHROMA_2_4_LSB    16
++#define VEC_DAC_E4_FIR_COEFF_CHROMA_2_4_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_E4_FIR_COEFF_LUMA_2_4
++// Description : FIR filter coefficients
++#define VEC_DAC_E4_FIR_COEFF_LUMA_2_4_RESET  0x0000
++#define VEC_DAC_E4_FIR_COEFF_LUMA_2_4_BITS   0x0000ffff
++#define VEC_DAC_E4_FIR_COEFF_LUMA_2_4_MSB    15
++#define VEC_DAC_E4_FIR_COEFF_LUMA_2_4_LSB    0
++#define VEC_DAC_E4_FIR_COEFF_LUMA_2_4_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_E8
++// JTAG access : synchronous
++// Description : None
++#define VEC_DAC_E8_OFFSET 0x000000e8
++#define VEC_DAC_E8_BITS   0xffffffff
++#define VEC_DAC_E8_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_E8_FIR_COEFF_CHROMA_3
++// Description : FIR filter coefficients
++#define VEC_DAC_E8_FIR_COEFF_CHROMA_3_RESET  0x0000
++#define VEC_DAC_E8_FIR_COEFF_CHROMA_3_BITS   0xffff0000
++#define VEC_DAC_E8_FIR_COEFF_CHROMA_3_MSB    31
++#define VEC_DAC_E8_FIR_COEFF_CHROMA_3_LSB    16
++#define VEC_DAC_E8_FIR_COEFF_CHROMA_3_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_E8_FIR_COEFF_LUMA_3
++// Description : FIR filter coefficients
++#define VEC_DAC_E8_FIR_COEFF_LUMA_3_RESET  0x0000
++#define VEC_DAC_E8_FIR_COEFF_LUMA_3_BITS   0x0000ffff
++#define VEC_DAC_E8_FIR_COEFF_LUMA_3_MSB    15
++#define VEC_DAC_E8_FIR_COEFF_LUMA_3_LSB    0
++#define VEC_DAC_E8_FIR_COEFF_LUMA_3_ACCESS "RW"
++// =============================================================================
++// Register    : VEC_DAC_EC
++// JTAG access : synchronous
++// Description : Misc. control
++#define VEC_DAC_EC_OFFSET 0x000000ec
++#define VEC_DAC_EC_BITS   0x001fffff
++#define VEC_DAC_EC_RESET  0x00000000
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_SLOW_CLOCK
++// Description : Doubles the raised-cosine rate
++#define VEC_DAC_EC_SLOW_CLOCK_RESET  0x0
++#define VEC_DAC_EC_SLOW_CLOCK_BITS   0x00100000
++#define VEC_DAC_EC_SLOW_CLOCK_MSB    20
++#define VEC_DAC_EC_SLOW_CLOCK_LSB    20
++#define VEC_DAC_EC_SLOW_CLOCK_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_FIR_RMINUS1
++// Description : Select 1, 3, 5 or 7 FIR taps
++#define VEC_DAC_EC_FIR_RMINUS1_RESET  0x0
++#define VEC_DAC_EC_FIR_RMINUS1_BITS   0x000c0000
++#define VEC_DAC_EC_FIR_RMINUS1_MSB    19
++#define VEC_DAC_EC_FIR_RMINUS1_LSB    18
++#define VEC_DAC_EC_FIR_RMINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_VERT_FULL_NOT_HALF
++// Description : Disable half-line pulses during VBI
++#define VEC_DAC_EC_VERT_FULL_NOT_HALF_RESET  0x0
++#define VEC_DAC_EC_VERT_FULL_NOT_HALF_BITS   0x00020000
++#define VEC_DAC_EC_VERT_FULL_NOT_HALF_MSB    17
++#define VEC_DAC_EC_VERT_FULL_NOT_HALF_LSB    17
++#define VEC_DAC_EC_VERT_FULL_NOT_HALF_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_SEQ_EN
++// Description : Enable NCO reset
++#define VEC_DAC_EC_SEQ_EN_RESET  0x0
++#define VEC_DAC_EC_SEQ_EN_BITS   0x00010000
++#define VEC_DAC_EC_SEQ_EN_MSB    16
++#define VEC_DAC_EC_SEQ_EN_LSB    16
++#define VEC_DAC_EC_SEQ_EN_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_U2_FLD_MASK
++// Description : Field sequence
++#define VEC_DAC_EC_U2_FLD_MASK_RESET  0x0
++#define VEC_DAC_EC_U2_FLD_MASK_BITS   0x0000c000
++#define VEC_DAC_EC_U2_FLD_MASK_MSB    15
++#define VEC_DAC_EC_U2_FLD_MASK_LSB    14
++#define VEC_DAC_EC_U2_FLD_MASK_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_U4_SEQ_MASK
++// Description : NCO reset sequence
++#define VEC_DAC_EC_U4_SEQ_MASK_RESET  0x0
++#define VEC_DAC_EC_U4_SEQ_MASK_BITS   0x00003c00
++#define VEC_DAC_EC_U4_SEQ_MASK_MSB    13
++#define VEC_DAC_EC_U4_SEQ_MASK_LSB    10
++#define VEC_DAC_EC_U4_SEQ_MASK_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_INTERP_RATE_MINUS1
++// Description : Interpolation rate 2<=R<=16
++#define VEC_DAC_EC_INTERP_RATE_MINUS1_RESET  0x0
++#define VEC_DAC_EC_INTERP_RATE_MINUS1_BITS   0x000003c0
++#define VEC_DAC_EC_INTERP_RATE_MINUS1_MSB    9
++#define VEC_DAC_EC_INTERP_RATE_MINUS1_LSB    6
++#define VEC_DAC_EC_INTERP_RATE_MINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_INTERP_SHIFT_MINUS1
++// Description : Power-of-2 scaling after interpolation
++#define VEC_DAC_EC_INTERP_SHIFT_MINUS1_RESET  0x0
++#define VEC_DAC_EC_INTERP_SHIFT_MINUS1_BITS   0x0000003c
++#define VEC_DAC_EC_INTERP_SHIFT_MINUS1_MSB    5
++#define VEC_DAC_EC_INTERP_SHIFT_MINUS1_LSB    2
++#define VEC_DAC_EC_INTERP_SHIFT_MINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_FIELDS_PER_FRAME_MINUS1
++// Description : Interlaced / progressive
++#define VEC_DAC_EC_FIELDS_PER_FRAME_MINUS1_RESET  0x0
++#define VEC_DAC_EC_FIELDS_PER_FRAME_MINUS1_BITS   0x00000002
++#define VEC_DAC_EC_FIELDS_PER_FRAME_MINUS1_MSB    1
++#define VEC_DAC_EC_FIELDS_PER_FRAME_MINUS1_LSB    1
++#define VEC_DAC_EC_FIELDS_PER_FRAME_MINUS1_ACCESS "RW"
++// -----------------------------------------------------------------------------
++// Field       : VEC_DAC_EC_PAL_EN
++// Description : Enable phase alternate line (PAL) mode
++#define VEC_DAC_EC_PAL_EN_RESET  0x0
++#define VEC_DAC_EC_PAL_EN_BITS   0x00000001
++#define VEC_DAC_EC_PAL_EN_MSB    0
++#define VEC_DAC_EC_PAL_EN_LSB    0
++#define VEC_DAC_EC_PAL_EN_ACCESS "RW"
++// =============================================================================
++#endif // VEC_REGS_DEFINED
diff --git a/target/linux/bcm27xx/patches-6.1/950-0888-v4l2-Add-pisp-compression-format-support-to-v4l2.patch b/target/linux/bcm27xx/patches-6.1/950-0888-v4l2-Add-pisp-compression-format-support-to-v4l2.patch
new file mode 100644
index 0000000000..cf0b02c64b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0888-v4l2-Add-pisp-compression-format-support-to-v4l2.patch
@@ -0,0 +1,75 @@
+From 3a419974ba02d32795a5ecfaf3c020f23173b6a1 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Tue, 14 Feb 2023 20:58:59 +0000
+Subject: [PATCH] v4l2: Add pisp compression format support to v4l2
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/v4l2-core/v4l2-ioctl.c  | 12 ++++++++----
+ include/uapi/linux/media-bus-format.h | 14 ++++++++++++++
+ include/uapi/linux/videodev2.h        | 12 ++++++++----
+ 3 files changed, 30 insertions(+), 8 deletions(-)
+
+--- a/drivers/media/v4l2-core/v4l2-ioctl.c
++++ b/drivers/media/v4l2-core/v4l2-ioctl.c
+@@ -1507,10 +1507,14 @@ static void v4l_fill_fmtdesc(struct v4l2
+ 		case V4L2_PIX_FMT_QC08C:	descr = "QCOM Compressed 8-bit Format"; break;
+ 		case V4L2_PIX_FMT_QC10C:	descr = "QCOM Compressed 10-bit Format"; break;
+ 		case V4L2_PIX_FMT_RPI_BE: descr = "PiSP Opaque Format"; break;
+-		case V4L2_PIX_FMT_PISP_COMP_RGGB:
+-		case V4L2_PIX_FMT_PISP_COMP_GRBG:
+-		case V4L2_PIX_FMT_PISP_COMP_GBRG:
+-		case V4L2_PIX_FMT_PISP_COMP_BGGR: descr = "PiSP Bayer Compressed Format"; break;
++		case V4L2_PIX_FMT_PISP_COMP1_RGGB:
++		case V4L2_PIX_FMT_PISP_COMP1_GRBG:
++		case V4L2_PIX_FMT_PISP_COMP1_GBRG:
++		case V4L2_PIX_FMT_PISP_COMP1_BGGR: descr = "PiSP Bayer Comp 1"; break;
++		case V4L2_PIX_FMT_PISP_COMP2_RGGB:
++		case V4L2_PIX_FMT_PISP_COMP2_GRBG:
++		case V4L2_PIX_FMT_PISP_COMP2_GBRG:
++		case V4L2_PIX_FMT_PISP_COMP2_BGGR: descr = "PiSP Bayer Comp 2"; break;
+ 		default:
+ 			if (fmt->description[0])
+ 				return;
+--- a/include/uapi/linux/media-bus-format.h
++++ b/include/uapi/linux/media-bus-format.h
+@@ -175,4 +175,18 @@
+ /* Sensor ancillary metadata formats - next is 0x7002 */
+ #define MEDIA_BUS_FMT_SENSOR_DATA		0x7002
+ 
++/* PiSP Formats */
++#define MEDIA_BUS_FMT_PISP_COMP1_RGGB		0x8001
++#define MEDIA_BUS_FMT_PISP_COMP1_GRBG		0x8002
++#define MEDIA_BUS_FMT_PISP_COMP1_GBRG		0x8003
++#define MEDIA_BUS_FMT_PISP_COMP1_BGGR		0x8004
++#define MEDIA_BUS_FMT_PISP_COMP2_RGGB		0x8005
++#define MEDIA_BUS_FMT_PISP_COMP2_GRBG		0x8006
++#define MEDIA_BUS_FMT_PISP_COMP2_GBRG		0x8007
++#define MEDIA_BUS_FMT_PISP_COMP2_BGGR		0x8008
++
++#define MEDIA_BUS_FMT_PISP_FE_CONFIG		0x8100
++#define MEDIA_BUS_FMT_PISP_FE_STATS		0x8101
++#define MEDIA_BUS_FMT_PISP_BE_CONFIG		0x8200
++
+ #endif /* __LINUX_MEDIA_BUS_FORMAT_H */
+--- a/include/uapi/linux/videodev2.h
++++ b/include/uapi/linux/videodev2.h
+@@ -795,10 +795,14 @@ struct v4l2_pix_format {
+ 
+ /* The pixel format for all our buffers (the precise format is found in the config buffer). */
+ #define V4L2_PIX_FMT_RPI_BE		v4l2_fourcc('R', 'P', 'B', 'P')
+-#define V4L2_PIX_FMT_PISP_COMP_RGGB	v4l2_fourcc('P', 'C', 'R', 'G')
+-#define V4L2_PIX_FMT_PISP_COMP_GRBG	v4l2_fourcc('P', 'C', 'G', 'R')
+-#define V4L2_PIX_FMT_PISP_COMP_GBRG	v4l2_fourcc('P', 'C', 'G', 'B')
+-#define V4L2_PIX_FMT_PISP_COMP_BGGR	v4l2_fourcc('P', 'C', 'B', 'G')
++#define V4L2_PIX_FMT_PISP_COMP1_RGGB	v4l2_fourcc('P', 'C', '1', 'R')
++#define V4L2_PIX_FMT_PISP_COMP1_GRBG	v4l2_fourcc('P', 'C', '1', 'G')
++#define V4L2_PIX_FMT_PISP_COMP1_GBRG	v4l2_fourcc('P', 'C', '1', 'g')
++#define V4L2_PIX_FMT_PISP_COMP1_BGGR	v4l2_fourcc('P', 'C', '1', 'B')
++#define V4L2_PIX_FMT_PISP_COMP2_RGGB	v4l2_fourcc('P', 'C', '2', 'R')
++#define V4L2_PIX_FMT_PISP_COMP2_GRBG	v4l2_fourcc('P', 'C', '2', 'G')
++#define V4L2_PIX_FMT_PISP_COMP2_GBRG	v4l2_fourcc('P', 'C', '2', 'g')
++#define V4L2_PIX_FMT_PISP_COMP2_BGGR	v4l2_fourcc('P', 'C', '2', 'B')
+ 
+ /* SDR formats - used only for Software Defined Radio devices */
+ #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0889-media-rp1-Add-CFE-Camera-Front-End-support.patch b/target/linux/bcm27xx/patches-6.1/950-0889-media-rp1-Add-CFE-Camera-Front-End-support.patch
new file mode 100644
index 0000000000..038633b74e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0889-media-rp1-Add-CFE-Camera-Front-End-support.patch
@@ -0,0 +1,4527 @@
+From 8a31623de7f034f6521b348e9a510e78a6e7e493 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Tue, 14 Feb 2023 17:30:12 +0000
+Subject: [PATCH] media: rp1: Add CFE (Camera Front End) support
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/platform/raspberrypi/Kconfig    |    1 +
+ drivers/media/platform/raspberrypi/Makefile   |    1 +
+ .../platform/raspberrypi/rp1_cfe/Kconfig      |   14 +
+ .../platform/raspberrypi/rp1_cfe/Makefile     |    6 +
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 2186 +++++++++++++++++
+ .../media/platform/raspberrypi/rp1_cfe/cfe.h  |   40 +
+ .../platform/raspberrypi/rp1_cfe/cfe_fmts.h   |  294 +++
+ .../media/platform/raspberrypi/rp1_cfe/csi2.c |  446 ++++
+ .../media/platform/raspberrypi/rp1_cfe/csi2.h |   75 +
+ .../media/platform/raspberrypi/rp1_cfe/dphy.c |  177 ++
+ .../media/platform/raspberrypi/rp1_cfe/dphy.h |   26 +
+ .../raspberrypi/rp1_cfe/pisp_common.h         |   69 +
+ .../platform/raspberrypi/rp1_cfe/pisp_fe.c    |  563 +++++
+ .../platform/raspberrypi/rp1_cfe/pisp_fe.h    |   53 +
+ .../raspberrypi/rp1_cfe/pisp_fe_config.h      |  272 ++
+ .../raspberrypi/rp1_cfe/pisp_statistics.h     |   62 +
+ .../platform/raspberrypi/rp1_cfe/pisp_types.h |  144 ++
+ 17 files changed, 4429 insertions(+)
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/Kconfig
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/Makefile
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/cfe.h
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/dphy.c
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/dphy.h
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/pisp_common.h
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.h
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe_config.h
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/pisp_statistics.h
+ create mode 100644 drivers/media/platform/raspberrypi/rp1_cfe/pisp_types.h
+
+--- a/drivers/media/platform/raspberrypi/Kconfig
++++ b/drivers/media/platform/raspberrypi/Kconfig
+@@ -3,3 +3,4 @@
+ comment "Raspberry Pi media platform drivers"
+ 
+ source "drivers/media/platform/raspberrypi/pisp_be/Kconfig"
++source "drivers/media/platform/raspberrypi/rp1_cfe/Kconfig"
+--- a/drivers/media/platform/raspberrypi/Makefile
++++ b/drivers/media/platform/raspberrypi/Makefile
+@@ -1,3 +1,4 @@
+ # SPDX-License-Identifier: GPL-2.0
+ 
+ obj-y += pisp_be/
++obj-y += rp1_cfe/
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/Kconfig
+@@ -0,0 +1,14 @@
++# RP1 V4L2 camera support
++
++config VIDEO_RP1_CFE
++	tristate "RP1 Camera Frond End (CFE) video capture driver"
++	depends on VIDEO_DEV
++	select VIDEO_V4L2_SUBDEV_API
++	select MEDIA_CONTROLLER
++	select VIDEOBUF2_DMA_CONTIG
++	select V4L2_FWNODE
++	help
++	  Say Y here to enable support for the RP1 Camera Front End.
++
++	  To compile this driver as a module, choose M here. The module will be
++	  called rp1-cfe.
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/Makefile
+@@ -0,0 +1,6 @@
++# SPDX-License-Identifier: GPL-2.0
++#
++# Makefile for RP1 Camera Front End driver
++#
++rp1-cfe-objs := cfe.o csi2.o pisp_fe.o dphy.o
++obj-$(CONFIG_VIDEO_RP1_CFE) += rp1-cfe.o
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -0,0 +1,2186 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * RP1 Camera Front End Driver
++ *
++ * Copyright (C) 2021-2022 - Raspberry Pi Ltd.
++ *
++ */
++
++#include <linux/atomic.h>
++#include <linux/clk.h>
++#include <linux/debugfs.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/dma-mapping.h>
++#include <linux/err.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of_device.h>
++#include <linux/of_graph.h>
++#include <linux/phy/phy.h>
++#include <linux/pinctrl/consumer.h>
++#include <linux/platform_device.h>
++#include <linux/pm_runtime.h>
++#include <linux/seq_file.h>
++#include <linux/slab.h>
++#include <linux/uaccess.h>
++#include <linux/videodev2.h>
++
++#include <media/v4l2-async.h>
++#include <media/v4l2-common.h>
++#include <media/v4l2-ctrls.h>
++#include <media/v4l2-dev.h>
++#include <media/v4l2-device.h>
++#include <media/v4l2-dv-timings.h>
++#include <media/v4l2-event.h>
++#include <media/v4l2-fwnode.h>
++#include <media/v4l2-ioctl.h>
++#include <media/videobuf2-dma-contig.h>
++
++#include "cfe.h"
++#include "cfe_fmts.h"
++#include "csi2.h"
++#include "pisp_fe.h"
++#include "pisp_fe_config.h"
++#include "pisp_statistics.h"
++
++#define CFE_MODULE_NAME	"rp1-cfe"
++#define CFE_VERSION	"1.0"
++
++bool cfe_debug_irq;
++
++#define cfe_dbg_irq(fmt, arg...)                              \
++	do {                                                  \
++		if (cfe_debug_irq)                            \
++			dev_dbg(&cfe->pdev->dev, fmt, ##arg); \
++	} while (0)
++#define cfe_dbg(fmt, arg...) dev_dbg(&cfe->pdev->dev, fmt, ##arg)
++#define cfe_info(fmt, arg...) dev_info(&cfe->pdev->dev, fmt, ##arg)
++#define cfe_err(fmt, arg...) dev_err(&cfe->pdev->dev, fmt, ##arg)
++
++/* MIPICFG registers */
++#define MIPICFG_CFG		0x004
++#define MIPICFG_INTR		0x028
++#define MIPICFG_INTE		0x02c
++#define MIPICFG_INTF		0x030
++#define MIPICFG_INTS		0x034
++
++#define MIPICFG_CFG_SEL_CSI	BIT(0)
++
++#define MIPICFG_INT_CSI_DMA	BIT(0)
++#define MIPICFG_INT_CSI_HOST	BIT(2)
++#define MIPICFG_INT_PISP_FE	BIT(4)
++
++#define BPL_ALIGNMENT 16
++#define MAX_BYTESPERLINE 0xffffff00
++#define MAX_BUFFER_SIZE  0xffffff00
++/*
++ * Max width is therefore determined by the max stride divided by the number of
++ * bits per pixel.
++ *
++ * However, to avoid overflow issues let's use a 16k maximum. This lets us
++ * calculate 16k * 16k * 4 with 32bits. If we need higher maximums, a careful
++ * review and adjustment of the code is needed so that it will deal with
++ * overflows correctly.
++ */
++#define MAX_WIDTH 16384
++#define MAX_HEIGHT MAX_WIDTH
++/* Define a nominal minimum image size */
++#define MIN_WIDTH 16
++#define MIN_HEIGHT 16
++/* Default size of the embedded buffer */
++#define DEFAULT_EMBEDDED_SIZE 8192
++
++const struct v4l2_mbus_framefmt cfe_default_format = {
++	.width = 640,
++	.height = 480,
++	.code = MEDIA_BUS_FMT_SRGGB10_1X10,
++	.field = V4L2_FIELD_NONE,
++	.colorspace = V4L2_COLORSPACE_RAW,
++	.ycbcr_enc = V4L2_YCBCR_ENC_601,
++	.quantization = V4L2_QUANTIZATION_FULL_RANGE,
++	.xfer_func = V4L2_XFER_FUNC_NONE,
++};
++
++const struct v4l2_mbus_framefmt cfe_default_meta_format = {
++	.width = 8192,
++	.height = 1,
++	.code = MEDIA_BUS_FMT_SENSOR_DATA,
++};
++
++enum node_ids {
++	/* CSI2 HW output nodes first. */
++	CSI2_CH0,
++	CSI2_CH1_EMBEDDED,
++	CSI2_CH2,
++	CSI2_CH3,
++	/* FE only nodes from here on. */
++	FE_OUT0,
++	FE_OUT1,
++	FE_STATS,
++	FE_CONFIG,
++	NUM_NODES
++};
++
++struct node_description {
++	unsigned int id;
++	const char *name;
++	enum v4l2_buf_type buf_type;
++	unsigned int cap;
++	unsigned int pad_flags;
++	unsigned int link_pad;
++};
++
++/* Must match the ordering of enum ids */
++static const struct node_description node_desc[NUM_NODES] = {
++	[CSI2_CH0] = {
++		.name = "csi2_ch0",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
++		.cap = V4L2_CAP_VIDEO_CAPTURE,
++		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
++		.link_pad = CSI2_NUM_CHANNELS + 0
++	},
++	/* This node is assigned for the embedded data channel! */
++	[CSI2_CH1_EMBEDDED] = {
++		.name = "embedded",
++		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
++		.cap = V4L2_CAP_META_CAPTURE,
++		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
++		.link_pad = CSI2_NUM_CHANNELS + 1
++	},
++	[CSI2_CH2] = {
++		.name = "csi2_ch2",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
++		.cap = V4L2_CAP_META_CAPTURE,
++		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
++		.link_pad = CSI2_NUM_CHANNELS + 2
++	},
++	[CSI2_CH3] = {
++		.name = "csi2_ch3",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
++		.cap = V4L2_CAP_META_CAPTURE,
++		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
++		.link_pad = CSI2_NUM_CHANNELS + 3
++	},
++	[FE_OUT0] = {
++		.name = "fe_image0",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
++		.cap = V4L2_CAP_VIDEO_CAPTURE,
++		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
++		.link_pad = FE_OUTPUT0_PAD
++	},
++	[FE_OUT1] = {
++		.name = "fe_image1",
++		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
++		.cap = V4L2_CAP_VIDEO_CAPTURE,
++		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
++		.link_pad = FE_OUTPUT1_PAD
++	},
++	[FE_STATS] = {
++		.name = "fe_stats",
++		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
++		.cap = V4L2_CAP_META_CAPTURE,
++		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
++		.link_pad = FE_STATS_PAD
++	},
++	[FE_CONFIG] = {
++		.name = "fe_config",
++		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
++		.cap = V4L2_CAP_META_OUTPUT,
++		.pad_flags = MEDIA_PAD_FL_SOURCE | MEDIA_PAD_FL_MUST_CONNECT,
++		.link_pad = FE_CONFIG_PAD
++	},
++};
++
++#define is_fe_node(node) (((node)->id) >= FE_OUT0)
++#define is_csi2_node(node) (!is_fe_node(node))
++#define is_image_output_node(node)                                               \
++	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
++#define is_meta_output_node(node)                                                \
++	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_META_CAPTURE)
++#define is_meta_input_node(node)                                                 \
++	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_META_OUTPUT)
++#define is_meta_node(node) (is_meta_output_node(node) || is_meta_input_node(node))
++
++/* To track state across all nodes. */
++#define NUM_STATES		5
++#define NODE_REGISTERED		BIT(0)
++#define NODE_ENABLED		BIT(1)
++#define NODE_STREAMING		BIT(2)
++#define FS_INT			BIT(3)
++#define FE_INT			BIT(4)
++
++struct cfe_buffer {
++	struct vb2_v4l2_buffer vb;
++	struct list_head list;
++};
++
++struct cfe_config_buffer {
++	struct cfe_buffer buf;
++	struct pisp_fe_config config;
++};
++
++static inline struct cfe_buffer *to_cfe_buffer(struct vb2_buffer *vb)
++{
++	return container_of(vb, struct cfe_buffer, vb.vb2_buf);
++}
++
++static inline
++struct cfe_config_buffer *to_cfe_config_buffer(struct cfe_buffer *buf)
++{
++	return container_of(buf, struct cfe_config_buffer, buf);
++}
++
++struct cfe_node {
++	unsigned int id;
++	/* Pointer pointing to current v4l2_buffer */
++	struct cfe_buffer *cur_frm;
++	/* Pointer pointing to next v4l2_buffer */
++	struct cfe_buffer *next_frm;
++	/* Used to store current pixel format */
++	struct v4l2_format fmt;
++	/* Buffer queue used in video-buf */
++	struct vb2_queue buffer_queue;
++	/* Queue of filled frames */
++	struct list_head dma_queue;
++	/* lock used to access this structure */
++	struct mutex lock;
++	/* Identifies video device for this channel */
++	struct video_device video_dev;
++	/* Pointer to the parent handle */
++	struct cfe_device *cfe;
++	struct media_pad pad;
++};
++
++struct cfe_device {
++	struct dentry *debugfs;
++	struct kref kref;
++
++	/* V4l2 specific parameters */
++	struct v4l2_async_subdev asd;
++
++	/* peripheral base address */
++	void __iomem *mipi_cfg_base;
++
++	struct clk *clk;
++
++	/* V4l2 device */
++	struct v4l2_device v4l2_dev;
++	struct media_device mdev;
++	struct media_pipeline pipe;
++
++	/* IRQ lock for node state and DMA queues */
++	spinlock_t state_lock;
++	bool job_ready;
++	bool job_queued;
++
++	/* parent device */
++	struct platform_device *pdev;
++	/* subdevice async Notifier */
++	struct v4l2_async_notifier notifier;
++
++	/* ptr to sub device */
++	struct v4l2_subdev *sensor;
++
++	struct cfe_node node[NUM_NODES];
++	DECLARE_BITMAP(node_flags, NUM_STATES * NUM_NODES);
++
++	struct csi2_device csi2;
++	struct pisp_fe_device fe;
++
++	bool sensor_embedded_data;
++	int fe_csi2_channel;
++
++	unsigned int sequence;
++	u64 ts;
++};
++
++static inline bool is_fe_enabled(struct cfe_device *cfe)
++{
++	return cfe->fe_csi2_channel != -1;
++}
++
++static inline struct cfe_device *to_cfe_device(struct v4l2_device *v4l2_dev)
++{
++	return container_of(v4l2_dev, struct cfe_device, v4l2_dev);
++}
++
++static inline u32 cfg_reg_read(struct cfe_device *cfe, u32 offset)
++{
++	return readl(cfe->mipi_cfg_base + offset);
++}
++
++static inline void cfg_reg_write(struct cfe_device *cfe, u32 offset, u32 val)
++{
++	writel(val, cfe->mipi_cfg_base + offset);
++}
++
++static bool check_state(struct cfe_device *cfe, unsigned long state,
++			unsigned int node_id)
++{
++	unsigned long bit;
++
++	for_each_set_bit(bit, &state, sizeof(state)) {
++		if (!test_bit(bit + (node_id * NUM_STATES), cfe->node_flags))
++			return false;
++	}
++	return true;
++}
++
++static void set_state(struct cfe_device *cfe, unsigned long state,
++		      unsigned int node_id)
++{
++	unsigned long bit;
++
++	for_each_set_bit(bit, &state, sizeof(state))
++		set_bit(bit + (node_id * NUM_STATES), cfe->node_flags);
++}
++
++static void clear_state(struct cfe_device *cfe, unsigned long state,
++			unsigned int node_id)
++{
++	unsigned long bit;
++
++	for_each_set_bit(bit, &state, sizeof(state))
++		clear_bit(bit + (node_id * NUM_STATES), cfe->node_flags);
++}
++
++static bool test_any_node(struct cfe_device *cfe, unsigned long cond)
++{
++	unsigned int i;
++
++	for (i = 0; i < NUM_NODES; i++) {
++		if (check_state(cfe, cond, i))
++			return true;
++	}
++
++	return false;
++}
++
++static bool test_all_nodes(struct cfe_device *cfe, unsigned long precond,
++			   unsigned long cond)
++{
++	unsigned int i;
++
++	for (i = 0; i < NUM_NODES; i++) {
++		if (check_state(cfe, precond, i)) {
++			if (!check_state(cfe, cond, i))
++				return false;
++		}
++	}
++
++	return true;
++}
++
++static void clear_all_nodes(struct cfe_device *cfe, unsigned long precond,
++			    unsigned long state)
++{
++	unsigned int i;
++
++	for (i = 0; i < NUM_NODES; i++) {
++		if (check_state(cfe, precond, i))
++			clear_state(cfe, state, i);
++	}
++}
++
++static int mipi_cfg_regs_show(struct seq_file *s, void *data)
++{
++	struct cfe_device *cfe = s->private;
++	int ret;
++
++	ret = pm_runtime_resume_and_get(&cfe->pdev->dev);
++	if (ret)
++		return ret;
++
++#define DUMP(reg) seq_printf(s, #reg " \t0x%08x\n", cfg_reg_read(cfe, reg))
++	DUMP(MIPICFG_CFG);
++	DUMP(MIPICFG_INTR);
++	DUMP(MIPICFG_INTE);
++	DUMP(MIPICFG_INTF);
++	DUMP(MIPICFG_INTS);
++#undef DUMP
++
++	pm_runtime_put(&cfe->pdev->dev);
++
++	return 0;
++}
++
++static int format_show(struct seq_file *s, void *data)
++{
++	struct cfe_device *cfe = s->private;
++	unsigned int i;
++
++	for (i = 0; i < NUM_NODES; i++) {
++		struct cfe_node *node = &cfe->node[i];
++		unsigned long sb, state = 0;
++
++		for (sb = 0; sb < NUM_STATES; sb++) {
++			if (check_state(cfe, BIT(sb), i))
++				state |= BIT(sb);
++		}
++
++		seq_printf(s, "\nNode %u (%s) state: 0x%lx\n", i,
++			   node_desc[i].name, state);
++
++		if (is_image_output_node(node))
++			seq_printf(s, "format: " V4L2_FOURCC_CONV " 0x%x\n"
++				      "resolution: %ux%u\nbpl: %u\nsize: %u\n",
++				   V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.pix.pixelformat),
++				   node->fmt.fmt.pix.pixelformat,
++				   node->fmt.fmt.pix.width,
++				   node->fmt.fmt.pix.height,
++				   node->fmt.fmt.pix.bytesperline,
++				   node->fmt.fmt.pix.sizeimage);
++		else
++			seq_printf(s, "format: " V4L2_FOURCC_CONV " 0x%x\nsize: %u\n",
++				   V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.meta.dataformat),
++				   node->fmt.fmt.meta.dataformat,
++				   node->fmt.fmt.meta.buffersize);
++	}
++
++	return 0;
++}
++
++DEFINE_SHOW_ATTRIBUTE(mipi_cfg_regs);
++DEFINE_SHOW_ATTRIBUTE(format);
++
++/* Format setup functions */
++const struct cfe_fmt *find_format_by_code(u32 code)
++{
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(formats); i++) {
++		if (formats[i].code == code)
++			return &formats[i];
++	}
++
++	return NULL;
++}
++
++static const struct cfe_fmt *find_format_by_pix(u32 pixelformat)
++{
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(formats); i++) {
++		if (formats[i].fourcc == pixelformat)
++			return &formats[i];
++	}
++
++	return NULL;
++}
++
++static int cfe_calc_format_size_bpl(struct cfe_device *cfe,
++				    const struct cfe_fmt *fmt,
++				    struct v4l2_format *f)
++{
++	unsigned int min_bytesperline;
++
++	v4l_bound_align_image(&f->fmt.pix.width, MIN_WIDTH, MAX_WIDTH, 2,
++			      &f->fmt.pix.height, MIN_HEIGHT, MAX_HEIGHT, 0, 0);
++
++	min_bytesperline =
++		ALIGN((f->fmt.pix.width * fmt->depth) >> 3, BPL_ALIGNMENT);
++
++	if (f->fmt.pix.bytesperline > min_bytesperline &&
++	    f->fmt.pix.bytesperline <= MAX_BYTESPERLINE)
++		f->fmt.pix.bytesperline =
++			ALIGN(f->fmt.pix.bytesperline, BPL_ALIGNMENT);
++	else
++		f->fmt.pix.bytesperline = min_bytesperline;
++
++	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
++
++	cfe_dbg("%s: " V4L2_FOURCC_CONV " size: %ux%u bpl:%u img_size:%u\n",
++		__func__, V4L2_FOURCC_CONV_ARGS(f->fmt.pix.pixelformat),
++		f->fmt.pix.width, f->fmt.pix.height,
++		f->fmt.pix.bytesperline, f->fmt.pix.sizeimage);
++
++	return 0;
++}
++
++static void cfe_schedule_next_csi2_job(struct cfe_device *cfe)
++{
++	struct cfe_buffer *buf;
++	unsigned int i;
++	dma_addr_t addr;
++
++	for (i = 0; i < CSI2_NUM_CHANNELS; i++) {
++		struct cfe_node *node = &cfe->node[i];
++		unsigned int stride, size;
++
++		if (!check_state(cfe, NODE_STREAMING, i))
++			continue;
++
++		buf = list_first_entry(&node->dma_queue, struct cfe_buffer,
++				       list);
++		node->next_frm = buf;
++		list_del(&buf->list);
++
++		cfe_dbg("%s: [%s] buffer:%p\n",
++			__func__, node_desc[node->id].name, &buf->vb.vb2_buf);
++
++		if (is_meta_node(node)) {
++			size = node->fmt.fmt.meta.buffersize;
++			stride = 0;
++		} else {
++			size = node->fmt.fmt.pix.sizeimage;
++			stride = node->fmt.fmt.pix.bytesperline;
++		}
++
++		addr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
++		csi2_set_buffer(&cfe->csi2, node->id, addr, stride, size);
++	}
++}
++
++static void cfe_schedule_next_pisp_job(struct cfe_device *cfe)
++{
++	struct vb2_buffer *vb2_bufs[FE_NUM_PADS] = { 0 };
++	struct cfe_config_buffer *config_buf;
++	struct cfe_buffer *buf;
++	unsigned int i;
++
++	for (i = CSI2_NUM_CHANNELS; i < NUM_NODES; i++) {
++		struct cfe_node *node = &cfe->node[i];
++
++		if (!check_state(cfe, NODE_STREAMING, i))
++			continue;
++
++		buf = list_first_entry(&node->dma_queue, struct cfe_buffer,
++				       list);
++
++		cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__,
++			    node_desc[node->id].name, &buf->vb.vb2_buf);
++
++		node->next_frm = buf;
++		vb2_bufs[node_desc[i].link_pad] = &buf->vb.vb2_buf;
++		list_del(&buf->list);
++	}
++
++	config_buf = to_cfe_config_buffer(cfe->node[FE_CONFIG].next_frm);
++	pisp_fe_submit_job(&cfe->fe, vb2_bufs, &config_buf->config);
++}
++
++static bool cfe_check_job_ready(struct cfe_device *cfe)
++{
++	unsigned int i;
++
++	for (i = 0; i < NUM_NODES; i++) {
++		struct cfe_node *node = &cfe->node[i];
++
++		if (!check_state(cfe, NODE_ENABLED, i))
++			continue;
++
++		if (list_empty(&node->dma_queue)) {
++			cfe_dbg_irq("%s: [%s] has no buffer, unable to schedule job\n",
++				    __func__, node_desc[i].name);
++			return false;
++		}
++	}
++
++	return true;
++}
++
++static void cfe_prepare_next_job(struct cfe_device *cfe)
++{
++	cfe->job_queued = true;
++	cfe_schedule_next_csi2_job(cfe);
++	if (is_fe_enabled(cfe))
++		cfe_schedule_next_pisp_job(cfe);
++
++	/* Flag if another job is ready after this. */
++	cfe->job_ready = cfe_check_job_ready(cfe);
++
++	cfe_dbg_irq("%s: end with scheduled job\n", __func__);
++}
++
++static void cfe_process_buffer_complete(struct cfe_node *node,
++					unsigned int sequence)
++{
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__, node_desc[node->id].name,
++		    &node->cur_frm->vb.vb2_buf);
++
++	node->cur_frm->vb.sequence = sequence;
++	vb2_buffer_done(&node->cur_frm->vb.vb2_buf, VB2_BUF_STATE_DONE);
++}
++
++static void cfe_queue_event_sof(struct cfe_node *node)
++{
++	struct v4l2_event event = {
++		.type = V4L2_EVENT_FRAME_SYNC,
++		.u.frame_sync.frame_sequence = node->cfe->sequence,
++	};
++
++	v4l2_event_queue(&node->video_dev, &event);
++}
++
++static void cfe_sof_isr_handler(struct cfe_node *node)
++{
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg_irq("%s: [%s] seq %u\n", __func__, node_desc[node->id].name,
++		    cfe->sequence);
++
++	node->cur_frm = node->next_frm;
++	node->next_frm = NULL;
++
++	/*
++	 * If this is the first node to see a frame start,  sample the
++	 * timestamp to use for all frames across all channels.
++	 */
++	if (!test_any_node(cfe, NODE_STREAMING | FS_INT))
++		cfe->ts = ktime_get_ns();
++
++	set_state(cfe, FS_INT, node->id);
++
++	/* If all nodes have seen a frame start, we can queue another job. */
++	if (test_all_nodes(cfe, NODE_STREAMING, FS_INT))
++		cfe->job_queued = false;
++
++	if (node->cur_frm)
++		node->cur_frm->vb.vb2_buf.timestamp = cfe->ts;
++
++	if (is_image_output_node(node))
++		cfe_queue_event_sof(node);
++}
++
++static void cfe_eof_isr_handler(struct cfe_node *node)
++{
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg_irq("%s: [%s] seq %u\n", __func__, node_desc[node->id].name,
++		    cfe->sequence);
++
++	if (node->cur_frm)
++		cfe_process_buffer_complete(node, cfe->sequence);
++
++	node->cur_frm = NULL;
++	set_state(cfe, FE_INT, node->id);
++
++	/*
++	 * If all nodes have seen a frame end, we can increment
++	 * the sequence counter now.
++	 */
++	if (test_all_nodes(cfe, NODE_STREAMING, FE_INT)) {
++		cfe->sequence++;
++		clear_all_nodes(cfe, NODE_STREAMING, FE_INT | FS_INT);
++	}
++}
++
++static irqreturn_t cfe_isr(int irq, void *dev)
++{
++	struct cfe_device *cfe = dev;
++	unsigned int i;
++	bool sof[NUM_NODES] = {0}, eof[NUM_NODES] = {0}, lci[NUM_NODES] = {0};
++	u32 sts;
++
++	sts = cfg_reg_read(cfe, MIPICFG_INTS);
++
++	if (sts & MIPICFG_INT_CSI_DMA)
++		csi2_isr(&cfe->csi2, sof, eof, lci);
++
++	if (sts & MIPICFG_INT_PISP_FE)
++		pisp_fe_isr(&cfe->fe, sof + CSI2_NUM_CHANNELS,
++			    eof + CSI2_NUM_CHANNELS);
++
++	spin_lock(&cfe->state_lock);
++
++	for (i = 0; i < NUM_NODES; i++) {
++		struct cfe_node *node = &cfe->node[i];
++
++		/*
++		 * The check_state(NODE_STREAMING) is to ensure we do not loop
++		 * over the CSI2_CHx nodes when the FE is active since they
++		 * generate interrupts even though the node is not streaming.
++		 */
++		if (!check_state(cfe, NODE_STREAMING, i) ||
++		    !(sof[i] || eof[i] || lci[i]))
++			continue;
++
++		/*
++		 * There are 3 cases where we could get FS + FE_ACK at
++		 * the same time:
++		 * 1) FE of the current frame, and FS of the next frame.
++		 * 2) FS + FE of the same frame.
++		 * 3) FE of the current frame, and FS + FE of the next
++		 *    frame. To handle this, see the sof handler below.
++		 *
++		 * (1) is handled implicitly by the ordering of the FE and FS
++		 * handlers below.
++		 */
++		if (eof[i]) {
++			/*
++			 * The condition below tests for (2). Run the FS handler
++			 * first before the FE handler, both for the current
++			 * frame.
++			 */
++			if (sof[i] && !check_state(cfe, FS_INT, i)) {
++				cfe_sof_isr_handler(node);
++				sof[i] = false;
++			}
++
++			cfe_eof_isr_handler(node);
++		}
++
++		if (sof[i]) {
++			/*
++			 * The condition below tests for (3). In such cases, we
++			 * come in here with FS flag set in the node state from
++			 * the previous frame since it only gets cleared in
++			 * eof_isr_handler(). Handle the FE for the previous
++			 * frame first before the FS handler for the current
++			 * frame.
++			 */
++			if (check_state(cfe, FS_INT, node->id)) {
++				cfe_dbg("%s: [%s] Handling missing previous FE interrupt\n",
++					__func__, node_desc[node->id].name);
++				cfe_eof_isr_handler(node);
++			}
++
++			cfe_sof_isr_handler(node);
++		}
++
++		if (!cfe->job_queued && cfe->job_ready)
++			cfe_prepare_next_job(cfe);
++	}
++
++	spin_unlock(&cfe->state_lock);
++
++	return IRQ_HANDLED;
++}
++
++/*
++ * Stream helpers
++ */
++
++static void cfe_start_channel(struct cfe_node *node)
++{
++	struct cfe_device *cfe = node->cfe;
++	struct v4l2_subdev_state *state;
++	struct v4l2_mbus_framefmt *source_fmt;
++	const struct cfe_fmt *fmt;
++	unsigned long flags;
++	unsigned int width = 0, height = 0;
++	bool start_fe = is_fe_enabled(cfe) &&
++			test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING);
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	if (start_fe || is_image_output_node(node)) {
++		width = node->fmt.fmt.pix.width;
++		height = node->fmt.fmt.pix.height;
++	}
++
++	state = v4l2_subdev_lock_and_get_active_state(&cfe->csi2.sd);
++
++	if (start_fe) {
++		WARN_ON(!is_fe_enabled(cfe));
++		cfe_dbg("%s: %s using csi2 channel %d\n",
++			__func__, node_desc[FE_OUT0].name,
++			cfe->fe_csi2_channel);
++
++		source_fmt = v4l2_subdev_get_pad_format(&cfe->csi2.sd, state, cfe->fe_csi2_channel);
++		fmt = find_format_by_code(source_fmt->code);
++
++		/*
++		 * Start the associated CSI2 Channel as well.
++		 *
++		 * Must write to the ADDR register to latch the ctrl values
++		 * even if we are connected to the front end. Once running,
++		 * this is handled by the CSI2 AUTO_ARM mode.
++		 */
++		csi2_start_channel(&cfe->csi2, cfe->fe_csi2_channel,
++				   fmt->csi_dt, CSI2_MODE_FE_STREAMING,
++				   true, false, width, height);
++		csi2_set_buffer(&cfe->csi2, cfe->fe_csi2_channel, 0, 0, -1);
++		pisp_fe_start(&cfe->fe);
++	}
++
++	if (is_csi2_node(node)) {
++		u32 mode = CSI2_MODE_NORMAL;
++
++		source_fmt = v4l2_subdev_get_pad_format(&cfe->csi2.sd, state,
++			node_desc[node->id].link_pad - CSI2_NUM_CHANNELS);
++		fmt = find_format_by_code(source_fmt->code);
++
++		if (is_image_output_node(node)) {
++			if (node->fmt.fmt.pix.pixelformat ==
++					fmt->remap[CFE_REMAP_16BIT])
++				mode = CSI2_MODE_REMAP;
++			else if (node->fmt.fmt.pix.pixelformat ==
++					fmt->remap[CFE_REMAP_COMPRESSED]) {
++				mode = CSI2_MODE_COMPRESSED;
++				csi2_set_compression(&cfe->csi2, node->id,
++						     CSI2_COMPRESSION_DELTA, 0,
++						     0);
++			}
++		}
++		/* Unconditionally start this CSI2 channel. */
++		csi2_start_channel(&cfe->csi2, node->id, fmt->csi_dt,
++				   mode,
++				   /* Auto arm */
++				   false,
++				   /* Pack bytes */
++				   node->id == CSI2_CH1_EMBEDDED ? true : false,
++				   width, height);
++	}
++
++	v4l2_subdev_unlock_state(state);
++
++	spin_lock_irqsave(&cfe->state_lock, flags);
++	if (cfe->job_ready && test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING))
++		cfe_prepare_next_job(cfe);
++	spin_unlock_irqrestore(&cfe->state_lock, flags);
++}
++
++static void cfe_stop_channel(struct cfe_node *node, bool fe_stop)
++{
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg("%s: [%s] fe_stop %u\n", __func__,
++		node_desc[node->id].name, fe_stop);
++
++	if (fe_stop) {
++		csi2_stop_channel(&cfe->csi2, cfe->fe_csi2_channel);
++		pisp_fe_stop(&cfe->fe);
++	}
++
++	if (is_csi2_node(node))
++		csi2_stop_channel(&cfe->csi2, node->id);
++}
++
++static void cfe_return_buffers(struct cfe_node *node,
++			       enum vb2_buffer_state state)
++{
++	struct cfe_device *cfe = node->cfe;
++	struct cfe_buffer *buf, *tmp;
++	unsigned long flags;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	spin_lock_irqsave(&cfe->state_lock, flags);
++	list_for_each_entry_safe(buf, tmp, &node->dma_queue, list) {
++		list_del(&buf->list);
++		vb2_buffer_done(&buf->vb.vb2_buf, state);
++	}
++
++	if (node->cur_frm)
++		vb2_buffer_done(&node->cur_frm->vb.vb2_buf, state);
++	if (node->next_frm && node->cur_frm != node->next_frm)
++		vb2_buffer_done(&node->next_frm->vb.vb2_buf, state);
++
++	node->cur_frm = NULL;
++	node->next_frm = NULL;
++	spin_unlock_irqrestore(&cfe->state_lock, flags);
++}
++
++/*
++ * vb2 ops
++ */
++
++static int cfe_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,
++			   unsigned int *nplanes, unsigned int sizes[],
++			   struct device *alloc_devs[])
++{
++	struct cfe_node *node = vb2_get_drv_priv(vq);
++	struct cfe_device *cfe = node->cfe;
++	unsigned int size = is_image_output_node(node) ?
++					  node->fmt.fmt.pix.sizeimage :
++					  node->fmt.fmt.meta.buffersize;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	if (vq->num_buffers + *nbuffers < 3)
++		*nbuffers = 3 - vq->num_buffers;
++
++	if (*nplanes) {
++		if (sizes[0] < size) {
++			cfe_err("sizes[0] %i < size %u\n", sizes[0], size);
++			return -EINVAL;
++		}
++		size = sizes[0];
++	}
++
++	*nplanes = 1;
++	sizes[0] = size;
++
++	return 0;
++}
++
++static int cfe_buffer_prepare(struct vb2_buffer *vb)
++{
++	struct cfe_node *node = vb2_get_drv_priv(vb->vb2_queue);
++	struct cfe_device *cfe = node->cfe;
++	struct cfe_buffer *buf = to_cfe_buffer(vb);
++	unsigned long size;
++
++	cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__, node_desc[node->id].name,
++		    vb);
++
++	size = is_image_output_node(node) ? node->fmt.fmt.pix.sizeimage :
++					    node->fmt.fmt.meta.buffersize;
++	if (vb2_plane_size(vb, 0) < size) {
++		cfe_err("data will not fit into plane (%lu < %lu)\n",
++			vb2_plane_size(vb, 0), size);
++		return -EINVAL;
++	}
++
++	vb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);
++
++	if (node->id == FE_CONFIG) {
++		struct cfe_config_buffer *b = to_cfe_config_buffer(buf);
++		void *addr = vb2_plane_vaddr(vb, 0);
++
++		memcpy(&b->config, addr, sizeof(struct pisp_fe_config));
++		return pisp_fe_validate_config(&cfe->fe, &b->config,
++					       &cfe->node[FE_OUT0].fmt,
++					       &cfe->node[FE_OUT1].fmt);
++	}
++
++	return 0;
++}
++
++static void cfe_buffer_queue(struct vb2_buffer *vb)
++{
++	struct cfe_node *node = vb2_get_drv_priv(vb->vb2_queue);
++	struct cfe_device *cfe = node->cfe;
++	struct cfe_buffer *buf = to_cfe_buffer(vb);
++	unsigned long flags;
++
++	cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__, node_desc[node->id].name,
++		    vb);
++
++	spin_lock_irqsave(&cfe->state_lock, flags);
++
++	list_add_tail(&buf->list, &node->dma_queue);
++
++	if (!cfe->job_ready)
++		cfe->job_ready = cfe_check_job_ready(cfe);
++
++	if (!cfe->job_queued && cfe->job_ready &&
++	    test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING)) {
++		cfe_dbg("Preparing job immediately for channel %u\n",
++			node->id);
++		cfe_prepare_next_job(cfe);
++	}
++
++	spin_unlock_irqrestore(&cfe->state_lock, flags);
++}
++
++static int cfe_start_streaming(struct vb2_queue *vq, unsigned int count)
++{
++	struct v4l2_mbus_config mbus_config = { 0 };
++	struct cfe_node *node = vb2_get_drv_priv(vq);
++	struct cfe_device *cfe = node->cfe;
++	int ret;
++
++	cfe_dbg("%s: [%s] begin.\n", __func__, node_desc[node->id].name);
++
++	if (!check_state(cfe, NODE_ENABLED, node->id)) {
++		cfe_err("%s node link is not enabled.\n",
++			node_desc[node->id].name);
++		return -EINVAL;
++	}
++
++	ret = pm_runtime_resume_and_get(&cfe->pdev->dev);
++	if (ret < 0) {
++		cfe_err("pm_runtime_resume_and_get failed\n");
++		goto err_streaming;
++	}
++
++	ret = media_pipeline_start(&node->pad, &cfe->pipe);
++	if (ret < 0) {
++		cfe_err("Failed to start media pipeline: %d\n", ret);
++		goto err_pm_put;
++	}
++
++	clear_state(cfe, FS_INT | FE_INT, node->id);
++	set_state(cfe, NODE_STREAMING, node->id);
++	cfe_start_channel(node);
++
++	if (!test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING)) {
++		cfe_dbg("Not all nodes are set to streaming yet!\n");
++		return 0;
++	}
++
++	cfg_reg_write(cfe, MIPICFG_CFG, MIPICFG_CFG_SEL_CSI);
++	cfg_reg_write(cfe, MIPICFG_INTE, MIPICFG_INT_CSI_DMA | MIPICFG_INT_PISP_FE);
++
++	cfe->csi2.active_data_lanes = cfe->csi2.dphy.num_lanes;
++	cfe_dbg("Running with %u data lanes\n", cfe->csi2.active_data_lanes);
++
++	ret = v4l2_subdev_call(cfe->sensor, pad, get_mbus_config, 0,
++			       &mbus_config);
++	if (ret < 0 && ret != -ENOIOCTLCMD) {
++		cfe_err("g_mbus_config failed\n");
++		goto err_pm_put;
++	}
++
++	cfe->csi2.active_data_lanes = mbus_config.bus.mipi_csi2.num_data_lanes;
++	if (!cfe->csi2.active_data_lanes)
++		cfe->csi2.active_data_lanes = cfe->csi2.dphy.num_lanes;
++	if (cfe->csi2.active_data_lanes > cfe->csi2.dphy.num_lanes) {
++		cfe_err("Device has requested %u data lanes, which is >%u configured in DT\n",
++			cfe->csi2.active_data_lanes, cfe->csi2.dphy.num_lanes);
++		ret = -EINVAL;
++		goto err_disable_cfe;
++	}
++
++	cfe_dbg("Starting sensor streaming\n");
++
++	csi2_open_rx(&cfe->csi2);
++
++	cfe->sequence = 0;
++	ret = v4l2_subdev_call(cfe->sensor, video, s_stream, 1);
++	if (ret < 0) {
++		cfe_err("stream on failed in subdev\n");
++		goto err_disable_cfe;
++	}
++
++	cfe_dbg("%s: [%s] end.\n", __func__, node_desc[node->id].name);
++
++	return 0;
++
++err_disable_cfe:
++	csi2_close_rx(&cfe->csi2);
++	cfe_stop_channel(node, true);
++	media_pipeline_stop(&node->pad);
++err_pm_put:
++	pm_runtime_put(&cfe->pdev->dev);
++err_streaming:
++	cfe_return_buffers(node, VB2_BUF_STATE_QUEUED);
++	clear_state(cfe, NODE_STREAMING, node->id);
++
++	return ret;
++}
++
++static void cfe_stop_streaming(struct vb2_queue *vq)
++{
++	struct cfe_node *node = vb2_get_drv_priv(vq);
++	struct cfe_device *cfe = node->cfe;
++	unsigned long flags;
++	bool fe_stop;
++
++	cfe_dbg("%s: [%s] begin.\n", __func__, node_desc[node->id].name);
++
++	spin_lock_irqsave(&cfe->state_lock, flags);
++	fe_stop = is_fe_enabled(cfe) &&
++		  test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING);
++
++	cfe->job_ready = false;
++	clear_state(cfe, NODE_STREAMING, node->id);
++	spin_unlock_irqrestore(&cfe->state_lock, flags);
++
++	cfe_stop_channel(node, fe_stop);
++
++	if (!test_any_node(cfe, NODE_STREAMING)) {
++		/* Stop streaming the sensor and disable the peripheral. */
++		if (v4l2_subdev_call(cfe->sensor, video, s_stream, 0) < 0)
++			cfe_err("stream off failed in subdev\n");
++
++		csi2_close_rx(&cfe->csi2);
++
++		cfg_reg_write(cfe, MIPICFG_INTE, 0);
++	}
++
++	media_pipeline_stop(&node->pad);
++
++	/* Clear all queued buffers for the node */
++	cfe_return_buffers(node, VB2_BUF_STATE_ERROR);
++
++	pm_runtime_put(&cfe->pdev->dev);
++
++	cfe_dbg("%s: [%s] end.\n", __func__, node_desc[node->id].name);
++}
++
++static const struct vb2_ops cfe_video_qops = {
++	.wait_prepare = vb2_ops_wait_prepare,
++	.wait_finish = vb2_ops_wait_finish,
++	.queue_setup = cfe_queue_setup,
++	.buf_prepare = cfe_buffer_prepare,
++	.buf_queue = cfe_buffer_queue,
++	.start_streaming = cfe_start_streaming,
++	.stop_streaming = cfe_stop_streaming,
++};
++
++/*
++ * v4l2 ioctl ops
++ */
++
++static int cfe_querycap(struct file *file, void *priv,
++			struct v4l2_capability *cap)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++
++	strscpy(cap->driver, CFE_MODULE_NAME, sizeof(cap->driver));
++	strscpy(cap->card, CFE_MODULE_NAME, sizeof(cap->card));
++
++	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
++		 dev_name(&cfe->pdev->dev));
++
++	cap->capabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_META_CAPTURE |
++			     V4L2_CAP_META_OUTPUT;
++
++	return 0;
++}
++
++static int cfe_enum_fmt_vid_cap(struct file *file, void *priv,
++				struct v4l2_fmtdesc *f)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++	unsigned int i, j;
++
++	if (!is_image_output_node(node))
++		return -EINVAL;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	for (i = 0, j = 0; i < ARRAY_SIZE(formats); i++) {
++		if (f->mbus_code && formats[i].code != f->mbus_code)
++			continue;
++
++		if (formats[i].flags & CFE_FORMAT_FLAG_META_OUT ||
++		    formats[i].flags & CFE_FORMAT_FLAG_META_CAP)
++			continue;
++
++		if (is_fe_node(node) &&
++		    !(formats[i].flags & CFE_FORMAT_FLAG_FE_OUT))
++			continue;
++
++		if (j == f->index) {
++			f->pixelformat = formats[i].fourcc;
++			f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
++			return 0;
++		}
++		j++;
++	}
++
++	return -EINVAL;
++}
++
++static int cfe_g_fmt(struct file *file, void *priv,
++		     struct v4l2_format *f)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	if (f->type != node->buffer_queue.type)
++		return -EINVAL;
++
++	*f = node->fmt;
++
++	return 0;
++}
++
++static int try_fmt_vid_cap(struct cfe_node *node, struct v4l2_format *f)
++{
++	struct cfe_device *cfe = node->cfe;
++	const struct cfe_fmt *fmt;
++
++	cfe_dbg("%s: [%s] %ux%u, V4L2 pix " V4L2_FOURCC_CONV "\n",
++		__func__, node_desc[node->id].name,
++		f->fmt.pix.width, f->fmt.pix.height,
++		V4L2_FOURCC_CONV_ARGS(f->fmt.pix.pixelformat));
++
++	if (!is_image_output_node(node))
++		return -EINVAL;
++
++	/*
++	 * Default to a format that works for both CSI2 and FE.
++	 */
++	fmt = find_format_by_pix(f->fmt.pix.pixelformat);
++	if (!fmt)
++		fmt = find_format_by_code(MEDIA_BUS_FMT_SBGGR10_1X10);
++
++	f->fmt.pix.pixelformat = fmt->fourcc;
++
++	if (is_fe_node(node) && fmt->remap[CFE_REMAP_16BIT]) {
++		f->fmt.pix.pixelformat = fmt->remap[CFE_REMAP_16BIT];
++		fmt = find_format_by_pix(f->fmt.pix.pixelformat);
++	}
++
++	f->fmt.pix.field = V4L2_FIELD_NONE;
++
++	cfe_calc_format_size_bpl(cfe, fmt, f);
++
++	return 0;
++}
++
++static int cfe_s_fmt_vid_cap(struct file *file, void *priv,
++			     struct v4l2_format *f)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++	struct vb2_queue *q = &node->buffer_queue;
++	int ret;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	if (vb2_is_busy(q))
++		return -EBUSY;
++
++	ret = try_fmt_vid_cap(node, f);
++	if (ret)
++		return ret;
++
++	node->fmt = *f;
++
++	cfe_dbg("%s: Set %ux%u, V4L2 pix " V4L2_FOURCC_CONV "\n", __func__,
++		node->fmt.fmt.pix.width, node->fmt.fmt.pix.height,
++		V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.pix.pixelformat));
++
++	return 0;
++}
++
++static int cfe_try_fmt_vid_cap(struct file *file, void *priv,
++			       struct v4l2_format *f)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	return try_fmt_vid_cap(node, f);
++}
++
++static int cfe_enum_fmt_meta(struct file *file, void *priv,
++			     struct v4l2_fmtdesc *f)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	if (!is_meta_node(node) || f->index != 0)
++		return -EINVAL;
++
++	switch (node->id) {
++	case CSI2_CH1_EMBEDDED:
++		f->pixelformat = V4L2_META_FMT_SENSOR_DATA;
++		return 0;
++	case FE_STATS:
++		f->pixelformat = V4L2_META_FMT_RPI_FE_STATS;
++		return 0;
++	case FE_CONFIG:
++		f->pixelformat = V4L2_META_FMT_RPI_FE_CFG;
++		return 0;
++	}
++
++	return -EINVAL;
++}
++
++static int try_fmt_meta(struct cfe_node *node, struct v4l2_format *f)
++{
++	switch (node->id) {
++	case CSI2_CH1_EMBEDDED:
++		f->fmt.meta.dataformat = V4L2_META_FMT_SENSOR_DATA;
++		if (!f->fmt.meta.buffersize)
++			f->fmt.meta.buffersize = DEFAULT_EMBEDDED_SIZE;
++		f->fmt.meta.buffersize =
++			min_t(u32, f->fmt.meta.buffersize, MAX_BUFFER_SIZE);
++		f->fmt.meta.buffersize =
++			ALIGN(f->fmt.meta.buffersize, BPL_ALIGNMENT);
++		return 0;
++	case FE_STATS:
++		f->fmt.meta.dataformat = V4L2_META_FMT_RPI_FE_STATS;
++		f->fmt.meta.buffersize = sizeof(struct pisp_statistics);
++		return 0;
++	case FE_CONFIG:
++		f->fmt.meta.dataformat = V4L2_META_FMT_RPI_FE_CFG;
++		f->fmt.meta.buffersize = sizeof(struct pisp_fe_config);
++		return 0;
++	}
++
++	return -EINVAL;
++}
++
++static int cfe_s_fmt_meta(struct file *file, void *priv, struct v4l2_format *f)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++	struct vb2_queue *q = &node->buffer_queue;
++	int ret;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	if (vb2_is_busy(q))
++		return -EBUSY;
++
++	if (f->type != node->buffer_queue.type)
++		return -EINVAL;
++
++	ret = try_fmt_meta(node, f);
++	if (ret)
++		return ret;
++
++	node->fmt = *f;
++
++	cfe_dbg("%s: Set " V4L2_FOURCC_CONV "\n", __func__,
++		V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.meta.dataformat));
++
++	return 0;
++}
++
++static int cfe_try_fmt_meta(struct file *file, void *priv,
++			    struct v4l2_format *f)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++	return try_fmt_meta(node, f);
++}
++
++static int cfe_enum_framesizes(struct file *file, void *priv,
++			       struct v4l2_frmsizeenum *fsize)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++	const struct cfe_fmt *fmt;
++
++	cfe_dbg("%s [%s]\n", __func__, node_desc[node->id].name);
++
++	if (fsize->index > 0)
++		return -EINVAL;
++
++	/* check for valid format */
++	fmt = find_format_by_pix(fsize->pixel_format);
++	if (!fmt) {
++		cfe_dbg("Invalid pixel code: %x\n", fsize->pixel_format);
++		return -EINVAL;
++	}
++
++	/* TODO: Do we have limits on the step_width? */
++
++	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
++	fsize->stepwise.min_width = MIN_WIDTH;
++	fsize->stepwise.max_width = MAX_WIDTH;
++	fsize->stepwise.step_width = 2;
++	fsize->stepwise.min_height = MIN_HEIGHT;
++	fsize->stepwise.max_height = MAX_HEIGHT;
++	fsize->stepwise.step_height = 1;
++
++	return 0;
++}
++
++static int cfe_subscribe_event(struct v4l2_fh *fh,
++			       const struct v4l2_event_subscription *sub)
++{
++	struct cfe_node *node = video_get_drvdata(fh->vdev);
++
++	switch (sub->type) {
++	case V4L2_EVENT_FRAME_SYNC:
++		if (!is_image_output_node(node))
++			break;
++
++		return v4l2_event_subscribe(fh, sub, 2, NULL);
++	case V4L2_EVENT_SOURCE_CHANGE:
++		if (is_meta_input_node(node))
++			break;
++
++		return v4l2_event_subscribe(fh, sub, 4, NULL);
++	}
++
++	return v4l2_ctrl_subscribe_event(fh, sub);
++}
++
++static const struct v4l2_ioctl_ops cfe_ioctl_ops = {
++	.vidioc_querycap = cfe_querycap,
++	.vidioc_enum_fmt_vid_cap = cfe_enum_fmt_vid_cap,
++	.vidioc_g_fmt_vid_cap = cfe_g_fmt,
++	.vidioc_s_fmt_vid_cap = cfe_s_fmt_vid_cap,
++	.vidioc_try_fmt_vid_cap = cfe_try_fmt_vid_cap,
++
++	.vidioc_enum_fmt_meta_cap = cfe_enum_fmt_meta,
++	.vidioc_g_fmt_meta_cap = cfe_g_fmt,
++	.vidioc_s_fmt_meta_cap = cfe_s_fmt_meta,
++	.vidioc_try_fmt_meta_cap = cfe_try_fmt_meta,
++
++	.vidioc_enum_fmt_meta_out = cfe_enum_fmt_meta,
++	.vidioc_g_fmt_meta_out = cfe_g_fmt,
++	.vidioc_s_fmt_meta_out = cfe_s_fmt_meta,
++	.vidioc_try_fmt_meta_out = cfe_try_fmt_meta,
++
++	.vidioc_enum_framesizes = cfe_enum_framesizes,
++
++	.vidioc_reqbufs = vb2_ioctl_reqbufs,
++	.vidioc_create_bufs = vb2_ioctl_create_bufs,
++	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
++	.vidioc_querybuf = vb2_ioctl_querybuf,
++	.vidioc_qbuf = vb2_ioctl_qbuf,
++	.vidioc_dqbuf = vb2_ioctl_dqbuf,
++	.vidioc_expbuf = vb2_ioctl_expbuf,
++	.vidioc_streamon = vb2_ioctl_streamon,
++	.vidioc_streamoff = vb2_ioctl_streamoff,
++
++	.vidioc_subscribe_event = cfe_subscribe_event,
++	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
++};
++
++static void cfe_notify(struct v4l2_subdev *sd, unsigned int notification,
++		       void *arg)
++{
++	struct cfe_device *cfe = to_cfe_device(sd->v4l2_dev);
++	unsigned int i;
++
++	switch (notification) {
++	case V4L2_DEVICE_NOTIFY_EVENT:
++		for (i = 0; i < NUM_NODES; i++) {
++			struct cfe_node *node = &cfe->node[i];
++
++			if (check_state(cfe, NODE_REGISTERED, i))
++				continue;
++
++			v4l2_event_queue(&node->video_dev, arg);
++		}
++		break;
++	default:
++		break;
++	}
++}
++
++/* cfe capture driver file operations */
++static const struct v4l2_file_operations cfe_fops = {
++	.owner = THIS_MODULE,
++	.open = v4l2_fh_open,
++	.release = vb2_fop_release,
++	.poll = vb2_fop_poll,
++	.unlocked_ioctl = video_ioctl2,
++	.mmap = vb2_fop_mmap,
++};
++
++static int cfe_video_link_validate(struct media_link *link)
++{
++	struct video_device *vd = container_of(link->sink->entity,
++					       struct video_device, entity);
++	struct cfe_node *node = container_of(vd, struct cfe_node, video_dev);
++	struct cfe_device *cfe = node->cfe;
++	struct v4l2_mbus_framefmt *source_fmt;
++	struct v4l2_subdev_state *state;
++	struct v4l2_subdev *source_sd;
++	int ret = 0;
++
++	cfe_dbg("%s: [%s] link \"%s\":%u -> \"%s\":%u\n", __func__,
++		node_desc[node->id].name,
++		link->source->entity->name, link->source->index,
++		link->sink->entity->name, link->sink->index);
++
++	if (!media_entity_remote_source_pad_unique(link->sink->entity)) {
++		cfe_err("video node %s pad not connected\n", vd->name);
++		return -ENOTCONN;
++	}
++
++	source_sd = media_entity_to_v4l2_subdev(link->source->entity);
++
++	state = v4l2_subdev_lock_and_get_active_state(source_sd);
++
++	source_fmt = v4l2_subdev_get_pad_format(source_sd, state,
++						link->source->index);
++	if (!source_fmt) {
++		ret = -EINVAL;
++		goto out;
++	}
++
++	if (is_image_output_node(node)) {
++		struct v4l2_pix_format *pix_fmt = &node->fmt.fmt.pix;
++		const struct cfe_fmt *fmt;
++
++		if (source_fmt->width != pix_fmt->width ||
++		    source_fmt->height != pix_fmt->height) {
++			cfe_err("Wrong width or height %ux%u (remote pad set to %ux%u)\n",
++				pix_fmt->width, pix_fmt->height,
++				source_fmt->width,
++				source_fmt->height);
++			ret = -EINVAL;
++			goto out;
++		}
++
++		fmt = find_format_by_code(source_fmt->code);
++		if (!fmt || fmt->fourcc != pix_fmt->pixelformat) {
++			cfe_err("Format mismatch!\n");
++			ret = -EINVAL;
++			goto out;
++		}
++	} else if (node->id == CSI2_CH1_EMBEDDED) {
++		struct v4l2_meta_format *meta_fmt = &node->fmt.fmt.meta;
++
++		if (source_fmt->width * source_fmt->height !=
++							meta_fmt->buffersize ||
++		    source_fmt->code != MEDIA_BUS_FMT_SENSOR_DATA) {
++			cfe_err("WARNING: Wrong metadata width/height/code %ux%u %08x (remote pad set to %ux%u %08x)\n",
++				meta_fmt->buffersize, 1,
++				MEDIA_BUS_FMT_SENSOR_DATA,
++				source_fmt->width,
++				source_fmt->height,
++				source_fmt->code);
++			/* TODO: this should throw an error eventually */
++		}
++	}
++
++out:
++	v4l2_subdev_unlock_state(state);
++
++	return ret;
++}
++
++static const struct media_entity_operations cfe_media_entity_ops = {
++	.link_validate = cfe_video_link_validate,
++};
++
++static int cfe_video_link_notify(struct media_link *link, u32 flags,
++				 unsigned int notification)
++{
++	struct media_device *mdev = link->graph_obj.mdev;
++	struct cfe_device *cfe = container_of(mdev, struct cfe_device, mdev);
++	struct media_entity *fe = &cfe->fe.sd.entity;
++	struct media_entity *csi2 = &cfe->csi2.sd.entity;
++	unsigned long lock_flags;
++	unsigned int i;
++
++	if (notification != MEDIA_DEV_NOTIFY_POST_LINK_CH)
++		return 0;
++
++	cfe_dbg("%s: %s[%u] -> %s[%u] 0x%x", __func__,
++		link->source->entity->name, link->source->index,
++		link->sink->entity->name, link->sink->index, flags);
++
++	spin_lock_irqsave(&cfe->state_lock, lock_flags);
++
++	for (i = 0; i < NUM_NODES; i++) {
++		if (link->sink->entity != &cfe->node[i].video_dev.entity &&
++		    link->source->entity != &cfe->node[i].video_dev.entity)
++			continue;
++
++		if (link->flags & MEDIA_LNK_FL_ENABLED)
++			set_state(cfe, NODE_ENABLED, i);
++		else
++			clear_state(cfe, NODE_ENABLED, i);
++
++		break;
++	}
++
++	spin_unlock_irqrestore(&cfe->state_lock, lock_flags);
++
++	if (link->source->entity != csi2)
++		return 0;
++	if (link->sink->index != 0)
++		return 0;
++	if (link->source->index == node_desc[CSI2_CH1_EMBEDDED].link_pad)
++		return 0;
++
++	cfe->fe_csi2_channel = -1;
++	if (link->sink->entity == fe && (link->flags & MEDIA_LNK_FL_ENABLED)) {
++		if (link->source->index == node_desc[CSI2_CH0].link_pad)
++			cfe->fe_csi2_channel = CSI2_CH0;
++		else if (link->source->index == node_desc[CSI2_CH2].link_pad)
++			cfe->fe_csi2_channel = CSI2_CH2;
++		else if (link->source->index == node_desc[CSI2_CH3].link_pad)
++			cfe->fe_csi2_channel = CSI2_CH3;
++	}
++
++	if (is_fe_enabled(cfe))
++		cfe_dbg("%s: Found CSI2:%d -> FE:0 link\n", __func__,
++			cfe->fe_csi2_channel);
++	else
++		cfe_dbg("%s: Unable to find CSI2:x -> FE:0 link\n", __func__);
++
++	return 0;
++}
++
++static const struct media_device_ops cfe_media_device_ops = {
++	.link_notify = cfe_video_link_notify,
++};
++
++static void cfe_release(struct kref *kref)
++{
++	struct cfe_device *cfe = container_of(kref, struct cfe_device, kref);
++
++	media_device_cleanup(&cfe->mdev);
++
++	kfree(cfe);
++}
++
++static void cfe_put(struct cfe_device *cfe)
++{
++	kref_put(&cfe->kref, cfe_release);
++}
++
++static void cfe_get(struct cfe_device *cfe)
++{
++	kref_get(&cfe->kref);
++}
++
++static void cfe_node_release(struct video_device *vdev)
++{
++	struct cfe_node *node = video_get_drvdata(vdev);
++
++	cfe_put(node->cfe);
++}
++
++static int cfe_register_node(struct cfe_device *cfe, int id)
++{
++	struct video_device *vdev;
++	const struct cfe_fmt *fmt;
++	struct vb2_queue *q;
++	struct cfe_node *node = &cfe->node[id];
++	int ret;
++
++	node->cfe = cfe;
++	node->id = id;
++
++	if (is_image_output_node(node)) {
++		fmt = find_format_by_code(cfe_default_format.code);
++		if (!fmt) {
++			cfe_err("Failed to find format code\n");
++			return -EINVAL;
++		}
++
++		node->fmt.fmt.pix.pixelformat = fmt->fourcc;
++		v4l2_fill_pix_format(&node->fmt.fmt.pix, &cfe_default_format);
++
++		ret = try_fmt_vid_cap(node, &node->fmt);
++		if (ret)
++			return ret;
++	} else {
++		ret = try_fmt_meta(node, &node->fmt);
++		if (ret)
++			return ret;
++	}
++	node->fmt.type = node_desc[id].buf_type;
++
++	mutex_init(&node->lock);
++
++	q = &node->buffer_queue;
++	q->type = node_desc[id].buf_type;
++	q->io_modes = VB2_MMAP | VB2_DMABUF;
++	q->drv_priv = node;
++	q->ops = &cfe_video_qops;
++	q->mem_ops = &vb2_dma_contig_memops;
++	q->buf_struct_size = id == FE_CONFIG ? sizeof(struct cfe_config_buffer)
++					     : sizeof(struct cfe_buffer);
++	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
++	q->lock = &node->lock;
++	q->min_buffers_needed = 1;
++	q->dev = &cfe->pdev->dev;
++
++	ret = vb2_queue_init(q);
++	if (ret) {
++		cfe_err("vb2_queue_init() failed\n");
++		return ret;
++	}
++
++	INIT_LIST_HEAD(&node->dma_queue);
++
++	vdev = &node->video_dev;
++	vdev->release = cfe_node_release;
++	vdev->fops = &cfe_fops;
++	vdev->ioctl_ops = &cfe_ioctl_ops;
++	vdev->entity.ops = &cfe_media_entity_ops;
++	vdev->v4l2_dev = &cfe->v4l2_dev;
++	vdev->vfl_dir = (is_image_output_node(node) || is_meta_output_node(node))
++				? VFL_DIR_RX : VFL_DIR_TX;
++	vdev->queue = q;
++	vdev->lock = &node->lock;
++	vdev->device_caps = node_desc[id].cap;
++	vdev->device_caps |= V4L2_CAP_STREAMING | V4L2_CAP_IO_MC;
++
++	/* Define the device names */
++	snprintf(vdev->name, sizeof(vdev->name), "%s-%s", CFE_MODULE_NAME,
++		 node_desc[id].name);
++
++	video_set_drvdata(vdev, node);
++	if (node->id == FE_OUT0)
++		vdev->entity.flags |= MEDIA_ENT_FL_DEFAULT;
++	node->pad.flags = node_desc[id].pad_flags;
++	media_entity_pads_init(&vdev->entity, 1, &node->pad);
++
++	if (is_meta_node(node)) {
++		v4l2_disable_ioctl(&node->video_dev,
++				   VIDIOC_ENUM_FRAMEINTERVALS);
++		v4l2_disable_ioctl(&node->video_dev,
++				   VIDIOC_ENUM_FRAMESIZES);
++	}
++
++	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
++	if (ret) {
++		cfe_err("Unable to register video device %s\n", vdev->name);
++		return ret;
++	}
++
++	cfe_info("Registered [%s] node id %d successfully as /dev/video%u\n",
++		 vdev->name, id, vdev->num);
++
++	/*
++	 * Acquire a reference to cfe, which will be released when the video
++	 * device will be unregistered and userspace will have closed all open
++	 * file handles.
++	 */
++	cfe_get(cfe);
++	set_state(cfe, NODE_REGISTERED, id);
++
++	return 0;
++}
++
++static void cfe_unregister_nodes(struct cfe_device *cfe)
++{
++	unsigned int i;
++
++	for (i = 0; i < NUM_NODES; i++) {
++		struct cfe_node *node = &cfe->node[i];
++
++		if (check_state(cfe, NODE_REGISTERED, i)) {
++			clear_state(cfe, NODE_REGISTERED, i);
++			video_unregister_device(&node->video_dev);
++		}
++	}
++}
++
++static int cfe_link_node_pads(struct cfe_device *cfe)
++{
++	unsigned int i;
++	int ret;
++
++	for (i = 0; i < CSI2_NUM_CHANNELS; i++) {
++		struct cfe_node *node = &cfe->node[i];
++
++		if (!check_state(cfe, NODE_REGISTERED, i))
++			continue;
++
++		if (i < cfe->sensor->entity.num_pads) {
++			/* Sensor -> CSI2 */
++			ret = media_create_pad_link(&cfe->sensor->entity, i,
++						    &cfe->csi2.sd.entity, i,
++						    MEDIA_LNK_FL_IMMUTABLE |
++						    MEDIA_LNK_FL_ENABLED);
++			if (ret)
++				return ret;
++		}
++
++		/* CSI2 channel # -> /dev/video# */
++		ret = media_create_pad_link(&cfe->csi2.sd.entity,
++					    node_desc[i].link_pad,
++					    &node->video_dev.entity, 0, 0);
++		if (ret)
++			return ret;
++
++		if (node->id != CSI2_CH1_EMBEDDED) {
++			/* CSI2 channel # -> FE Input */
++			ret = media_create_pad_link(&cfe->csi2.sd.entity,
++						    node_desc[i].link_pad,
++						    &cfe->fe.sd.entity,
++						    FE_STREAM_PAD, 0);
++			if (ret)
++				return ret;
++		}
++	}
++
++	for (; i < NUM_NODES; i++) {
++		struct cfe_node *node = &cfe->node[i];
++		struct media_entity *src, *dst;
++		unsigned int src_pad, dst_pad;
++
++		if (node_desc[i].pad_flags & MEDIA_PAD_FL_SINK) {
++			/* FE -> /dev/video# */
++			src = &cfe->fe.sd.entity;
++			src_pad = node_desc[i].link_pad;
++			dst = &node->video_dev.entity;
++			dst_pad = 0;
++		} else {
++			/* /dev/video# -> FE */
++			dst = &cfe->fe.sd.entity;
++			dst_pad = node_desc[i].link_pad;
++			src = &node->video_dev.entity;
++			src_pad = 0;
++		}
++
++		ret = media_create_pad_link(src, src_pad, dst, dst_pad, 0);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++static int cfe_probe_complete(struct cfe_device *cfe)
++{
++	unsigned int i;
++	int ret;
++
++	cfe->v4l2_dev.notify = cfe_notify;
++
++	cfe->sensor_embedded_data = (cfe->sensor->entity.num_pads >= 2);
++
++	for (i = 0; i < NUM_NODES; i++) {
++		ret = cfe_register_node(cfe, i);
++		if (ret) {
++			cfe_err("Unable to register video node %u.\n", i);
++			goto unregister;
++		}
++	}
++
++	ret = cfe_link_node_pads(cfe);
++	if (ret) {
++		cfe_err("Unable to link node pads.\n");
++		goto unregister;
++	}
++
++	ret = v4l2_device_register_subdev_nodes(&cfe->v4l2_dev);
++	if (ret) {
++		cfe_err("Unable to register subdev nodes.\n");
++		goto unregister;
++	}
++
++	/*
++	 * Release the initial reference, all references are now owned by the
++	 * video devices.
++	 */
++	cfe_put(cfe);
++	return 0;
++
++unregister:
++	cfe_unregister_nodes(cfe);
++	cfe_put(cfe);
++
++	return ret;
++}
++
++static int cfe_async_bound(struct v4l2_async_notifier *notifier,
++			   struct v4l2_subdev *subdev,
++			   struct v4l2_async_subdev *asd)
++{
++	struct cfe_device *cfe = to_cfe_device(notifier->v4l2_dev);
++
++	if (cfe->sensor) {
++		cfe_info("Rejecting subdev %s (Already set!!)", subdev->name);
++		return 0;
++	}
++
++	cfe->sensor = subdev;
++	cfe_info("Using sensor %s for capture\n", subdev->name);
++
++	return 0;
++}
++
++static int cfe_async_complete(struct v4l2_async_notifier *notifier)
++{
++	struct cfe_device *cfe = to_cfe_device(notifier->v4l2_dev);
++
++	return cfe_probe_complete(cfe);
++}
++
++static const struct v4l2_async_notifier_operations cfe_async_ops = {
++	.bound = cfe_async_bound,
++	.complete = cfe_async_complete,
++};
++
++static int of_cfe_connect_subdevs(struct cfe_device *cfe)
++{
++	struct platform_device *pdev = cfe->pdev;
++	struct v4l2_fwnode_endpoint ep = { .bus_type = V4L2_MBUS_CSI2_DPHY };
++	struct device_node *node = pdev->dev.of_node;
++	struct device_node *ep_node;
++	struct device_node *sensor_node;
++	unsigned int lane;
++	int ret = -EINVAL;
++
++	/* Get the local endpoint and remote device. */
++	ep_node = of_graph_get_next_endpoint(node, NULL);
++	if (!ep_node) {
++		cfe_err("can't get next endpoint\n");
++		return -EINVAL;
++	}
++
++	cfe_dbg("ep_node is %pOF\n", ep_node);
++
++	sensor_node = of_graph_get_remote_port_parent(ep_node);
++	if (!sensor_node) {
++		cfe_err("can't get remote parent\n");
++		goto cleanup_exit;
++	}
++
++	cfe_info("found subdevice %pOF\n", sensor_node);
++
++	/* Parse the local endpoint and validate its configuration. */
++	v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep_node), &ep);
++
++	cfe->csi2.multipacket_line =
++		fwnode_property_present(of_fwnode_handle(ep_node),
++					"multipacket-line");
++
++	if (ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
++		cfe_err("endpoint node type != CSI2\n");
++		return -EINVAL;
++	}
++
++	for (lane = 0; lane < ep.bus.mipi_csi2.num_data_lanes; lane++) {
++		if (ep.bus.mipi_csi2.data_lanes[lane] != lane + 1) {
++			cfe_err("subdevice %pOF: data lanes reordering not supported\n",
++				sensor_node);
++			goto cleanup_exit;
++		}
++	}
++
++	/* TODO: Get the frequency from devicetree */
++	cfe->csi2.dphy.dphy_freq = 999;
++	cfe->csi2.dphy.num_lanes = ep.bus.mipi_csi2.num_data_lanes;
++	cfe->csi2.bus_flags = ep.bus.mipi_csi2.flags;
++
++	cfe_dbg("subdevice %pOF: %u data lanes, flags=0x%08x, multipacket_line=%u\n",
++		sensor_node, cfe->csi2.dphy.num_lanes, cfe->csi2.bus_flags,
++		cfe->csi2.multipacket_line);
++
++	/* Initialize and register the async notifier. */
++	v4l2_async_nf_init(&cfe->notifier);
++	cfe->notifier.ops = &cfe_async_ops;
++
++	cfe->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
++	cfe->asd.match.fwnode = of_fwnode_handle(sensor_node);
++	ret = __v4l2_async_nf_add_subdev(&cfe->notifier, &cfe->asd);
++	if (ret) {
++		cfe_err("Error adding subdevice: %d\n", ret);
++		goto cleanup_exit;
++	}
++
++	ret = v4l2_async_nf_register(&cfe->v4l2_dev, &cfe->notifier);
++	if (ret) {
++		cfe_err("Error registering async notifier: %d\n", ret);
++		ret = -EINVAL;
++	}
++
++cleanup_exit:
++	of_node_put(sensor_node);
++	of_node_put(ep_node);
++
++	return ret;
++}
++
++static int cfe_probe(struct platform_device *pdev)
++{
++	struct cfe_device *cfe;
++	char debugfs_name[32];
++	int ret;
++
++	cfe = kzalloc(sizeof(*cfe), GFP_KERNEL);
++	if (!cfe)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, cfe);
++
++	kref_init(&cfe->kref);
++	cfe->pdev = pdev;
++	cfe->fe_csi2_channel = -1;
++	spin_lock_init(&cfe->state_lock);
++
++	cfe->csi2.base = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(cfe->csi2.base)) {
++		dev_err(&pdev->dev, "Failed to get dma io block\n");
++		ret = PTR_ERR(cfe->csi2.base);
++		goto err_cfe_put;
++	}
++
++	cfe->csi2.dphy.base = devm_platform_ioremap_resource(pdev, 1);
++	if (IS_ERR(cfe->csi2.dphy.base)) {
++		dev_err(&pdev->dev, "Failed to get host io block\n");
++		ret = PTR_ERR(cfe->csi2.dphy.base);
++		goto err_cfe_put;
++	}
++
++	cfe->mipi_cfg_base = devm_platform_ioremap_resource(pdev, 2);
++	if (IS_ERR(cfe->mipi_cfg_base)) {
++		dev_err(&pdev->dev, "Failed to get mipi cfg io block\n");
++		ret = PTR_ERR(cfe->mipi_cfg_base);
++		goto err_cfe_put;
++	}
++
++	cfe->fe.base = devm_platform_ioremap_resource(pdev, 3);
++	if (IS_ERR(cfe->fe.base)) {
++		dev_err(&pdev->dev, "Failed to get pisp fe io block\n");
++		ret = PTR_ERR(cfe->fe.base);
++		goto err_cfe_put;
++	}
++
++	ret = platform_get_irq(pdev, 0);
++	if (ret <= 0) {
++		dev_err(&pdev->dev, "No IRQ resource\n");
++		ret = -EINVAL;
++		goto err_cfe_put;
++	}
++
++	ret = devm_request_irq(&pdev->dev, ret, cfe_isr, 0, "rp1-cfe", cfe);
++	if (ret) {
++		dev_err(&pdev->dev, "Unable to request interrupt\n");
++		ret = -EINVAL;
++		goto err_cfe_put;
++	}
++
++	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
++	if (ret) {
++		dev_err(&pdev->dev, "DMA enable failed\n");
++		goto err_cfe_put;
++	}
++
++	/* TODO: Enable clock only when running. */
++	cfe->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(cfe->clk))
++		return dev_err_probe(&pdev->dev, PTR_ERR(cfe->clk),
++				     "clock not found\n");
++
++	cfe->mdev.dev = &pdev->dev;
++	cfe->mdev.ops = &cfe_media_device_ops;
++	strscpy(cfe->mdev.model, CFE_MODULE_NAME, sizeof(cfe->mdev.model));
++	strscpy(cfe->mdev.serial, "", sizeof(cfe->mdev.serial));
++	snprintf(cfe->mdev.bus_info, sizeof(cfe->mdev.bus_info), "platform:%s",
++		 dev_name(&pdev->dev));
++
++	media_device_init(&cfe->mdev);
++
++	cfe->v4l2_dev.mdev = &cfe->mdev;
++
++	ret = v4l2_device_register(&pdev->dev, &cfe->v4l2_dev);
++	if (ret) {
++		cfe_err("Unable to register v4l2 device.\n");
++		goto err_cfe_put;
++	}
++
++	snprintf(debugfs_name, sizeof(debugfs_name), "rp1-cfe:%s",
++		 dev_name(&pdev->dev));
++	cfe->debugfs = debugfs_create_dir(debugfs_name, NULL);
++	debugfs_create_file("format", 0444, cfe->debugfs, cfe, &format_fops);
++	debugfs_create_file("regs", 0444, cfe->debugfs, cfe,
++			    &mipi_cfg_regs_fops);
++
++	/* Enable the block power domain */
++	pm_runtime_enable(&pdev->dev);
++
++	ret = pm_runtime_resume_and_get(&cfe->pdev->dev);
++	if (ret)
++		goto err_runtime_disable;
++
++	cfe->csi2.v4l2_dev = &cfe->v4l2_dev;
++	ret = csi2_init(&cfe->csi2, cfe->debugfs);
++	if (ret) {
++		cfe_err("Failed to init csi2 (%d)\n", ret);
++		goto err_runtime_put;
++	}
++
++	cfe->fe.v4l2_dev = &cfe->v4l2_dev;
++	ret = pisp_fe_init(&cfe->fe, cfe->debugfs);
++	if (ret) {
++		cfe_err("Failed to init pisp fe (%d)\n", ret);
++		goto err_csi2_uninit;
++	}
++
++	cfe->mdev.hw_revision = cfe->fe.hw_revision;
++	ret = media_device_register(&cfe->mdev);
++	if (ret < 0) {
++		cfe_err("Unable to register media-controller device.\n");
++		goto err_pisp_fe_uninit;
++	}
++
++	ret = of_cfe_connect_subdevs(cfe);
++	if (ret) {
++		cfe_err("Failed to connect subdevs\n");
++		goto err_media_unregister;
++	}
++
++	pm_runtime_put(&cfe->pdev->dev);
++
++	return 0;
++
++err_media_unregister:
++	media_device_unregister(&cfe->mdev);
++err_pisp_fe_uninit:
++	pisp_fe_uninit(&cfe->fe);
++err_csi2_uninit:
++	csi2_uninit(&cfe->csi2);
++err_runtime_put:
++	pm_runtime_put(&cfe->pdev->dev);
++err_runtime_disable:
++	pm_runtime_disable(&pdev->dev);
++	debugfs_remove(cfe->debugfs);
++	v4l2_device_unregister(&cfe->v4l2_dev);
++err_cfe_put:
++	cfe_put(cfe);
++
++	return ret;
++}
++
++static int cfe_remove(struct platform_device *pdev)
++{
++	struct cfe_device *cfe = platform_get_drvdata(pdev);
++
++	debugfs_remove(cfe->debugfs);
++
++	v4l2_async_nf_unregister(&cfe->notifier);
++	media_device_unregister(&cfe->mdev);
++	cfe_unregister_nodes(cfe);
++
++	pisp_fe_uninit(&cfe->fe);
++	csi2_uninit(&cfe->csi2);
++
++	pm_runtime_disable(&pdev->dev);
++
++	v4l2_device_unregister(&cfe->v4l2_dev);
++
++	return 0;
++}
++
++static int cfe_runtime_suspend(struct device *dev)
++{
++	struct platform_device *pdev = to_platform_device(dev);
++	struct cfe_device *cfe = platform_get_drvdata(pdev);
++
++	clk_disable_unprepare(cfe->clk);
++
++	return 0;
++}
++
++static int cfe_runtime_resume(struct device *dev)
++{
++	struct platform_device *pdev = to_platform_device(dev);
++	struct cfe_device *cfe = platform_get_drvdata(pdev);
++	int ret;
++
++	ret = clk_prepare_enable(cfe->clk);
++	if (ret) {
++		dev_err(dev, "Unable to enable clock\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static const struct dev_pm_ops cfe_pm_ops = {
++	SET_RUNTIME_PM_OPS(cfe_runtime_suspend, cfe_runtime_resume, NULL)
++	SET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)
++};
++
++static const struct of_device_id cfe_of_match[] = {
++	{ .compatible = "raspberrypi,rp1-cfe" },
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, cfe_of_match);
++
++static struct platform_driver cfe_driver = {
++	.probe		= cfe_probe,
++	.remove		= cfe_remove,
++	.driver = {
++		.name	= CFE_MODULE_NAME,
++		.of_match_table = cfe_of_match,
++		.pm = &cfe_pm_ops,
++	},
++};
++
++module_platform_driver(cfe_driver);
++
++MODULE_AUTHOR("Naushir Patuck <naush@raspberrypi.com>");
++MODULE_DESCRIPTION("RP1 Camera Front End driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(CFE_VERSION);
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.h
+@@ -0,0 +1,40 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * RP1 CFE driver.
++ * Copyright (c) 2021 Raspberry Pi Ltd.
++ *
++ */
++#ifndef _RP1_CFE_
++#define _RP1_CFE_
++
++#include <linux/types.h>
++#include <linux/media-bus-format.h>
++#include <linux/videodev2.h>
++
++extern bool cfe_debug_irq;
++
++enum cfe_remap_types {
++	CFE_REMAP_16BIT,
++	CFE_REMAP_COMPRESSED,
++	CFE_NUM_REMAP,
++};
++
++#define CFE_FORMAT_FLAG_META_OUT	BIT(0)
++#define CFE_FORMAT_FLAG_META_CAP	BIT(1)
++#define CFE_FORMAT_FLAG_FE_OUT		BIT(2)
++
++struct cfe_fmt {
++	u32 fourcc;
++	u32 code;
++	u8 depth;
++	u8 csi_dt;
++	u32 remap[CFE_NUM_REMAP];
++	u32 flags;
++};
++
++extern const struct v4l2_mbus_framefmt cfe_default_format;
++extern const struct v4l2_mbus_framefmt cfe_default_meta_format;
++
++const struct cfe_fmt *find_format_by_code(u32 code);
++
++#endif
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
+@@ -0,0 +1,294 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * RP1 Camera Front End formats definition
++ *
++ * Copyright (C) 2021 - Raspberry Pi Ltd.
++ *
++ */
++#ifndef _CFE_FMTS_H_
++#define _CFE_FMTS_H_
++
++#include "cfe.h"
++
++static const struct cfe_fmt formats[] = {
++	/* YUV Formats */
++	{
++		.fourcc = V4L2_PIX_FMT_YUYV,
++		.code = MEDIA_BUS_FMT_YUYV8_1X16,
++		.depth = 16,
++		.csi_dt = 0x1e,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_UYVY,
++		.code = MEDIA_BUS_FMT_UYVY8_1X16,
++		.depth = 16,
++		.csi_dt = 0x1e,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_YVYU,
++		.code = MEDIA_BUS_FMT_YVYU8_1X16,
++		.depth = 16,
++		.csi_dt = 0x1e,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_VYUY,
++		.code = MEDIA_BUS_FMT_VYUY8_1X16,
++		.depth = 16,
++		.csi_dt = 0x1e,
++	},
++	{
++		/* RGB Formats */
++		.fourcc = V4L2_PIX_FMT_RGB565, /* gggbbbbb rrrrrggg */
++		.code = MEDIA_BUS_FMT_RGB565_2X8_LE,
++		.depth = 16,
++		.csi_dt = 0x22,
++	},
++	{	.fourcc = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
++		.code = MEDIA_BUS_FMT_RGB565_2X8_BE,
++		.depth = 16,
++		.csi_dt = 0x22
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_RGB555, /* gggbbbbb arrrrrgg */
++		.code = MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE,
++		.depth = 16,
++		.csi_dt = 0x21,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_RGB555X, /* arrrrrgg gggbbbbb */
++		.code = MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE,
++		.depth = 16,
++		.csi_dt = 0x21,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_RGB24, /* rgb */
++		.code = MEDIA_BUS_FMT_RGB888_1X24,
++		.depth = 24,
++		.csi_dt = 0x24,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_BGR24, /* bgr */
++		.code = MEDIA_BUS_FMT_BGR888_1X24,
++		.depth = 24,
++		.csi_dt = 0x24,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_RGB32, /* argb */
++		.code = MEDIA_BUS_FMT_ARGB8888_1X32,
++		.depth = 32,
++		.csi_dt = 0x0,
++	},
++
++	/* Bayer Formats */
++	{
++		.fourcc = V4L2_PIX_FMT_SBGGR8,
++		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
++		.depth = 8,
++		.csi_dt = 0x2a,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGBRG8,
++		.code = MEDIA_BUS_FMT_SGBRG8_1X8,
++		.depth = 8,
++		.csi_dt = 0x2a,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGRBG8,
++		.code = MEDIA_BUS_FMT_SGRBG8_1X8,
++		.depth = 8,
++		.csi_dt = 0x2a,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SRGGB8,
++		.code = MEDIA_BUS_FMT_SRGGB8_1X8,
++		.depth = 8,
++		.csi_dt = 0x2a,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SBGGR10P,
++		.code = MEDIA_BUS_FMT_SBGGR10_1X10,
++		.depth = 10,
++		.csi_dt = 0x2b,
++		.remap = { V4L2_PIX_FMT_SBGGR16, V4L2_PIX_FMT_PISP_COMP1_BGGR },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGBRG10P,
++		.code = MEDIA_BUS_FMT_SGBRG10_1X10,
++		.depth = 10,
++		.csi_dt = 0x2b,
++		.remap = { V4L2_PIX_FMT_SGBRG16, V4L2_PIX_FMT_PISP_COMP1_GBRG },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGRBG10P,
++		.code = MEDIA_BUS_FMT_SGRBG10_1X10,
++		.depth = 10,
++		.csi_dt = 0x2b,
++		.remap = { V4L2_PIX_FMT_SGRBG16, V4L2_PIX_FMT_PISP_COMP1_GRBG },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SRGGB10P,
++		.code = MEDIA_BUS_FMT_SRGGB10_1X10,
++		.depth = 10,
++		.csi_dt = 0x2b,
++		.remap = { V4L2_PIX_FMT_SRGGB16, V4L2_PIX_FMT_PISP_COMP1_RGGB },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SBGGR12P,
++		.code = MEDIA_BUS_FMT_SBGGR12_1X12,
++		.depth = 12,
++		.csi_dt = 0x2c,
++		.remap = { V4L2_PIX_FMT_SBGGR16, V4L2_PIX_FMT_PISP_COMP1_BGGR },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGBRG12P,
++		.code = MEDIA_BUS_FMT_SGBRG12_1X12,
++		.depth = 12,
++		.csi_dt = 0x2c,
++		.remap = { V4L2_PIX_FMT_SGBRG16, V4L2_PIX_FMT_PISP_COMP1_GBRG },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGRBG12P,
++		.code = MEDIA_BUS_FMT_SGRBG12_1X12,
++		.depth = 12,
++		.csi_dt = 0x2c,
++		.remap = { V4L2_PIX_FMT_SGRBG16, V4L2_PIX_FMT_PISP_COMP1_GRBG },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SRGGB12P,
++		.code = MEDIA_BUS_FMT_SRGGB12_1X12,
++		.depth = 12,
++		.csi_dt = 0x2c,
++		.remap = { V4L2_PIX_FMT_SRGGB16, V4L2_PIX_FMT_PISP_COMP1_RGGB },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SBGGR14P,
++		.code = MEDIA_BUS_FMT_SBGGR14_1X14,
++		.depth = 14,
++		.csi_dt = 0x2d,
++		.remap = { V4L2_PIX_FMT_SBGGR16, V4L2_PIX_FMT_PISP_COMP1_BGGR },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGBRG14P,
++		.code = MEDIA_BUS_FMT_SGBRG14_1X14,
++		.depth = 14,
++		.csi_dt = 0x2d,
++		.remap = { V4L2_PIX_FMT_SGBRG16, V4L2_PIX_FMT_PISP_COMP1_GBRG },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGRBG14P,
++		.code = MEDIA_BUS_FMT_SGRBG14_1X14,
++		.depth = 14,
++		.csi_dt = 0x2d,
++		.remap = { V4L2_PIX_FMT_SGRBG16, V4L2_PIX_FMT_PISP_COMP1_GRBG },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SRGGB14P,
++		.code = MEDIA_BUS_FMT_SRGGB14_1X14,
++		.depth = 14,
++		.csi_dt = 0x2d,
++		.remap = { V4L2_PIX_FMT_SRGGB16, V4L2_PIX_FMT_PISP_COMP1_RGGB },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SBGGR16,
++		.code = MEDIA_BUS_FMT_SBGGR16_1X16,
++		.depth = 16,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGBRG16,
++		.code = MEDIA_BUS_FMT_SGBRG16_1X16,
++		.depth = 16,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SGRBG16,
++		.code = MEDIA_BUS_FMT_SGRBG16_1X16,
++		.depth = 16,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_SRGGB16,
++		.code = MEDIA_BUS_FMT_SRGGB16_1X16,
++		.depth = 16,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++	/* PiSP Compressed Mode 1 */
++	{
++		.fourcc = V4L2_PIX_FMT_PISP_COMP1_RGGB,
++		.code = MEDIA_BUS_FMT_PISP_COMP1_RGGB,
++		.depth = 8,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_PISP_COMP1_BGGR,
++		.code = MEDIA_BUS_FMT_PISP_COMP1_BGGR,
++		.depth = 8,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_PISP_COMP1_GBRG,
++		.code = MEDIA_BUS_FMT_PISP_COMP1_GBRG,
++		.depth = 8,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_PISP_COMP1_GRBG,
++		.code = MEDIA_BUS_FMT_PISP_COMP1_GRBG,
++		.depth = 8,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++	/* Greyscale format */
++	{
++		.fourcc = V4L2_PIX_FMT_GREY,
++		.code = MEDIA_BUS_FMT_Y8_1X8,
++		.depth = 8,
++		.csi_dt = 0x2a,
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_Y10P,
++		.code = MEDIA_BUS_FMT_Y10_1X10,
++		.depth = 10,
++		.csi_dt = 0x2b,
++		.remap = { V4L2_PIX_FMT_Y16 },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_Y12P,
++		.code = MEDIA_BUS_FMT_Y12_1X12,
++		.depth = 12,
++		.csi_dt = 0x2c,
++		.remap = { V4L2_PIX_FMT_Y16 },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_Y14P,
++		.code = MEDIA_BUS_FMT_Y14_1X14,
++		.depth = 14,
++		.csi_dt = 0x2d,
++		.remap = { V4L2_PIX_FMT_Y16 },
++	},
++	{
++		.fourcc = V4L2_PIX_FMT_Y16,
++		.depth = 16,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
++
++	/* Embedded data format */
++	{
++		.fourcc = V4L2_META_FMT_SENSOR_DATA,
++		.code = MEDIA_BUS_FMT_SENSOR_DATA,
++		.depth = 8,
++		.csi_dt = 0x12,
++		.flags = CFE_FORMAT_FLAG_META_CAP,
++	},
++
++	/* Frontend formats */
++	{
++		.fourcc = V4L2_META_FMT_RPI_FE_CFG,
++		.flags = CFE_FORMAT_FLAG_META_OUT,
++	},
++	{
++		.fourcc = V4L2_META_FMT_RPI_FE_STATS,
++		.flags = CFE_FORMAT_FLAG_META_CAP,
++	},
++};
++
++#endif /* _CFE_FMTS_H_ */
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -0,0 +1,446 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * RP1 CSI-2 Driver
++ *
++ * Copyright (C) 2021 - Raspberry Pi Ltd.
++ *
++ */
++
++#include <linux/delay.h>
++#include <linux/moduleparam.h>
++#include <linux/pm_runtime.h>
++#include <linux/seq_file.h>
++
++#include <media/videobuf2-dma-contig.h>
++
++#include "csi2.h"
++#include "cfe.h"
++
++#define csi2_dbg_irq(fmt, arg...)                                 \
++	do {                                                      \
++		if (cfe_debug_irq)                                \
++			dev_dbg(csi2->v4l2_dev->dev, fmt, ##arg); \
++	} while (0)
++#define csi2_dbg(fmt, arg...) dev_dbg(csi2->v4l2_dev->dev, fmt, ##arg)
++#define csi2_info(fmt, arg...) dev_info(csi2->v4l2_dev->dev, fmt, ##arg)
++#define csi2_err(fmt, arg...) dev_err(csi2->v4l2_dev->dev, fmt, ##arg)
++
++/* CSI2-DMA registers */
++#define CSI2_STATUS		0x000
++#define CSI2_QOS		0x004
++#define CSI2_DISCARDS_OVERFLOW	0x008
++#define CSI2_DISCARDS_INACTIVE	0x00c
++#define CSI2_DISCARDS_UNMATCHED	0x010
++#define CSI2_DISCARDS_LEN_LIMIT	0x014
++#define CSI2_LLEV_PANICS	0x018
++#define CSI2_ULEV_PANICS	0x01c
++#define CSI2_IRQ_MASK		0x020
++#define CSI2_CTRL		0x024
++#define CSI2_CH_CTRL(x)		((x) * 0x40 + 0x28)
++#define CSI2_CH_ADDR0(x)	((x) * 0x40 + 0x2c)
++#define CSI2_CH_ADDR1(x)	((x) * 0x40 + 0x3c)
++#define CSI2_CH_STRIDE(x)	((x) * 0x40 + 0x30)
++#define CSI2_CH_LENGTH(x)	((x) * 0x40 + 0x34)
++#define CSI2_CH_DEBUG(x)	((x) * 0x40 + 0x38)
++#define CSI2_CH_FRAME_SIZE(x)	((x) * 0x40 + 0x40)
++#define CSI2_CH_COMP_CTRL(x)	((x) * 0x40 + 0x44)
++#define CSI2_CH_FE_FRAME_ID(x)	((x) * 0x40 + 0x48)
++
++/* CSI2_STATUS */
++#define IRQ_FS(x)		(BIT(0) << (x))
++#define IRQ_FE(x)		(BIT(4) << (x))
++#define IRQ_FE_ACK(x)		(BIT(8) << (x))
++#define IRQ_LE(x)		(BIT(12) << (x))
++#define IRQ_LE_ACK(x)		(BIT(16) << (x))
++#define IRQ_CH_MASK(x)		(IRQ_FS(x) | IRQ_FE(x) | IRQ_FE_ACK(x) | IRQ_LE(x) | IRQ_LE_ACK(x))
++#define IRQ_OVERFLOW		BIT(20)
++#define IRQ_DISCARD_OVERFLOW	BIT(21)
++#define IRQ_DISCARD_LEN_LIMIT	BIT(22)
++#define IRQ_DISCARD_UNMATCHED	BIT(23)
++#define IRQ_DISCARD_INACTIVE	BIT(24)
++
++/* CSI2_CTRL */
++#define EOP_IS_EOL		BIT(0)
++
++/* CSI2_CH_CTRL */
++#define DMA_EN			BIT(0)
++#define FORCE			BIT(3)
++#define AUTO_ARM		BIT(4)
++#define IRQ_EN_FS		BIT(13)
++#define IRQ_EN_FE		BIT(14)
++#define IRQ_EN_FE_ACK		BIT(15)
++#define IRQ_EN_LE		BIT(16)
++#define IRQ_EN_LE_ACK		BIT(17)
++#define FLUSH_FE		BIT(28)
++#define PACK_LINE		BIT(29)
++#define PACK_BYTES		BIT(30)
++#define CH_MODE_MASK		GENMASK(2, 1)
++#define VC_MASK			GENMASK(6, 5)
++#define DT_MASK			GENMASK(12, 7)
++#define LC_MASK			GENMASK(27, 18)
++
++/* CHx_COMPRESSION_CONTROL */
++#define COMP_OFFSET_MASK	GENMASK(15, 0)
++#define COMP_SHIFT_MASK		GENMASK(19, 16)
++#define COMP_MODE_MASK		GENMASK(25, 24)
++
++static inline u32 csi2_reg_read(struct csi2_device *csi2, u32 offset)
++{
++	return readl(csi2->base + offset);
++}
++
++static inline void csi2_reg_write(struct csi2_device *csi2, u32 offset, u32 val)
++{
++	writel(val, csi2->base + offset);
++}
++
++static inline void set_field(u32 *valp, u32 field, u32 mask)
++{
++	u32 val = *valp;
++
++	val &= ~mask;
++	val |= (field << __ffs(mask)) & mask;
++	*valp = val;
++}
++
++static int csi2_regs_show(struct seq_file *s, void *data)
++{
++	struct csi2_device *csi2 = s->private;
++	unsigned int i;
++	int ret;
++
++	ret = pm_runtime_resume_and_get(csi2->v4l2_dev->dev);
++	if (ret)
++		return ret;
++
++#define DUMP(reg) seq_printf(s, #reg " \t0x%08x\n", csi2_reg_read(csi2, reg))
++#define DUMP_CH(idx, reg) seq_printf(s, #reg "(%u) \t0x%08x\n", idx, csi2_reg_read(csi2, reg(idx)))
++
++	DUMP(CSI2_STATUS);
++	DUMP(CSI2_DISCARDS_OVERFLOW);
++	DUMP(CSI2_DISCARDS_INACTIVE);
++	DUMP(CSI2_DISCARDS_UNMATCHED);
++	DUMP(CSI2_DISCARDS_LEN_LIMIT);
++	DUMP(CSI2_LLEV_PANICS);
++	DUMP(CSI2_ULEV_PANICS);
++	DUMP(CSI2_IRQ_MASK);
++	DUMP(CSI2_CTRL);
++
++	for (i = 0; i < CSI2_NUM_CHANNELS; ++i) {
++		DUMP_CH(i, CSI2_CH_CTRL);
++		DUMP_CH(i, CSI2_CH_ADDR0);
++		DUMP_CH(i, CSI2_CH_ADDR1);
++		DUMP_CH(i, CSI2_CH_STRIDE);
++		DUMP_CH(i, CSI2_CH_LENGTH);
++		DUMP_CH(i, CSI2_CH_DEBUG);
++		DUMP_CH(i, CSI2_CH_FRAME_SIZE);
++		DUMP_CH(i, CSI2_CH_COMP_CTRL);
++		DUMP_CH(i, CSI2_CH_FE_FRAME_ID);
++	}
++
++#undef DUMP
++#undef DUMP_CH
++
++	pm_runtime_put(csi2->v4l2_dev->dev);
++
++	return 0;
++}
++
++DEFINE_SHOW_ATTRIBUTE(csi2_regs);
++
++void csi2_isr(struct csi2_device *csi2, bool *sof, bool *eof, bool *lci)
++{
++	unsigned int i;
++	u32 status;
++
++	status = csi2_reg_read(csi2, CSI2_STATUS);
++	csi2_dbg_irq("ISR: STA: 0x%x\n", status);
++
++	/* Write value back to clear the interrupts */
++	csi2_reg_write(csi2, CSI2_STATUS, status);
++
++	for (i = 0; i < CSI2_NUM_CHANNELS; i++) {
++		u32 dbg;
++
++		if ((status & IRQ_CH_MASK(i)) == 0)
++			continue;
++
++		dbg = csi2_reg_read(csi2, CSI2_CH_DEBUG(i));
++
++		csi2_dbg_irq("ISR: [%u], %s%s%s%s%s frame: %u line: %u\n", i,
++			     (status & IRQ_FS(i)) ? "FS " : "",
++			     (status & IRQ_FE(i)) ? "FE " : "",
++			     (status & IRQ_FE_ACK(i)) ? "FE_ACK " : "",
++			     (status & IRQ_LE(i)) ? "LE " : "",
++			     (status & IRQ_LE_ACK(i)) ? "LE_ACK " : "",
++			     dbg >> 16,
++			     csi2->num_lines[i] ?
++				     ((dbg & 0xffff) % csi2->num_lines[i]) :
++				     0);
++
++		sof[i] = !!(status & IRQ_FS(i));
++		eof[i] = !!(status & IRQ_FE_ACK(i));
++		lci[i] = !!(status & IRQ_LE_ACK(i));
++	}
++}
++
++void csi2_set_buffer(struct csi2_device *csi2, unsigned int channel,
++		     dma_addr_t dmaaddr, unsigned int stride, unsigned int size)
++{
++	u64 addr = dmaaddr;
++	/*
++	 * ADDRESS0 must be written last as it triggers the double buffering
++	 * mechanism for all buffer registers within the hardware.
++	 */
++	addr >>= 4;
++	csi2_reg_write(csi2, CSI2_CH_LENGTH(channel), size >> 4);
++	csi2_reg_write(csi2, CSI2_CH_STRIDE(channel), stride >> 4);
++	csi2_reg_write(csi2, CSI2_CH_ADDR1(channel), addr >> 32);
++	csi2_reg_write(csi2, CSI2_CH_ADDR0(channel), addr & 0xffffffff);
++}
++
++void csi2_set_compression(struct csi2_device *csi2, unsigned int channel,
++			  enum csi2_compression_mode mode, unsigned int shift,
++			  unsigned int offset)
++{
++	u32 compression = 0;
++
++	set_field(&compression, COMP_OFFSET_MASK, offset);
++	set_field(&compression, COMP_SHIFT_MASK, shift);
++	set_field(&compression, COMP_MODE_MASK, mode);
++	csi2_reg_write(csi2, CSI2_CH_COMP_CTRL(channel), compression);
++}
++
++void csi2_start_channel(struct csi2_device *csi2, unsigned int channel,
++			u16 dt, enum csi2_mode mode, bool auto_arm,
++			bool pack_bytes, unsigned int width,
++			unsigned int height)
++{
++	u32 ctrl;
++
++	csi2_dbg("%s [%u]\n", __func__, channel);
++
++	/*
++	 * Disable the channel, but ensure N != 0!  Otherwise we end up with a
++	 * spurious LE + LE_ACK interrupt when re-enabling the channel.
++	 */
++	csi2_reg_write(csi2, CSI2_CH_CTRL(channel), 0x100 << __ffs(LC_MASK));
++	csi2_reg_write(csi2, CSI2_CH_DEBUG(channel), 0);
++	csi2_reg_write(csi2, CSI2_STATUS, IRQ_CH_MASK(channel));
++
++	/* Enable channel and FS/FE/LE interrupts. */
++	ctrl = DMA_EN | IRQ_EN_FS | IRQ_EN_FE_ACK | IRQ_EN_LE_ACK | PACK_LINE;
++	/* PACK_BYTES ensures no striding for embedded data. */
++	if (pack_bytes)
++		ctrl |= PACK_BYTES;
++
++	if (auto_arm)
++		ctrl |= AUTO_ARM;
++
++	if (width && height) {
++		int line_int_freq = height >> 2;
++
++		line_int_freq = min(max(0x80, line_int_freq), 0x3ff);
++		set_field(&ctrl, line_int_freq, LC_MASK);
++		set_field(&ctrl, mode, CH_MODE_MASK);
++		csi2_reg_write(csi2, CSI2_CH_FRAME_SIZE(channel),
++			       (height << 16) | width);
++	} else {
++		/*
++		 * Do not disable line interrupts for the embedded data channel,
++		 * set it to the maximum value.  This avoids spamming the ISR
++		 * with spurious line interrupts.
++		 */
++		set_field(&ctrl, 0x3ff, LC_MASK);
++		set_field(&ctrl, 0x00, CH_MODE_MASK);
++	}
++
++	set_field(&ctrl, dt, DT_MASK);
++	csi2_reg_write(csi2, CSI2_CH_CTRL(channel), ctrl);
++	csi2->num_lines[channel] = height;
++}
++
++void csi2_stop_channel(struct csi2_device *csi2, unsigned int channel)
++{
++	csi2_dbg("%s [%u]\n", __func__, channel);
++
++	/* Channel disable.  Use FORCE to allow stopping mid-frame. */
++	csi2_reg_write(csi2, CSI2_CH_CTRL(channel),
++		       (0x100 << __ffs(LC_MASK)) | FORCE);
++	/* Latch the above change by writing to the ADDR0 register. */
++	csi2_reg_write(csi2, CSI2_CH_ADDR0(channel), 0);
++	/* Write this again, the HW needs it! */
++	csi2_reg_write(csi2, CSI2_CH_ADDR0(channel), 0);
++}
++
++void csi2_open_rx(struct csi2_device *csi2)
++{
++	dphy_start(&csi2->dphy);
++
++	if (!csi2->multipacket_line)
++		csi2_reg_write(csi2, CSI2_CTRL, EOP_IS_EOL);
++}
++
++void csi2_close_rx(struct csi2_device *csi2)
++{
++	dphy_stop(&csi2->dphy);
++}
++
++static struct csi2_device *to_csi2_device(struct v4l2_subdev *subdev)
++{
++	return container_of(subdev, struct csi2_device, sd);
++}
++
++static int csi2_init_cfg(struct v4l2_subdev *sd,
++			 struct v4l2_subdev_state *state)
++{
++	struct v4l2_mbus_framefmt *fmt;
++
++	for (unsigned int i = 0; i < CSI2_NUM_CHANNELS; ++i) {
++		const struct v4l2_mbus_framefmt *def_fmt;
++
++		/* CSI2_CH1_EMBEDDED */
++		if (i == 1)
++			def_fmt = &cfe_default_meta_format;
++		else
++			def_fmt = &cfe_default_format;
++
++		fmt = v4l2_subdev_get_pad_format(sd, state, i);
++		*fmt = *def_fmt;
++
++		fmt = v4l2_subdev_get_pad_format(sd, state, i + CSI2_NUM_CHANNELS);
++		*fmt = *def_fmt;
++	}
++
++	return 0;
++}
++
++static int csi2_pad_set_fmt(struct v4l2_subdev *sd,
++			    struct v4l2_subdev_state *state,
++			    struct v4l2_subdev_format *format)
++{
++	struct v4l2_mbus_framefmt *fmt;
++	const struct cfe_fmt *cfe_fmt;
++
++	/* TODO: format validation */
++
++	cfe_fmt = find_format_by_code(format->format.code);
++	if (!cfe_fmt)
++		cfe_fmt = find_format_by_code(MEDIA_BUS_FMT_SBGGR10_1X10);
++
++	format->format.code = cfe_fmt->code;
++
++	fmt = v4l2_subdev_get_pad_format(sd, state, format->pad);
++	*fmt = format->format;
++
++	if (format->pad < CSI2_NUM_CHANNELS) {
++		/* Propagate to the source pad */
++		fmt = v4l2_subdev_get_pad_format(sd, state,
++						 format->pad + CSI2_NUM_CHANNELS);
++		*fmt = format->format;
++	}
++
++	return 0;
++}
++
++static int csi2_link_validate(struct v4l2_subdev *sd, struct media_link *link,
++			      struct v4l2_subdev_format *source_fmt,
++			      struct v4l2_subdev_format *sink_fmt)
++{
++	struct csi2_device *csi2 = to_csi2_device(sd);
++
++	csi2_dbg("%s: link \"%s\":%u -> \"%s\":%u\n", __func__,
++		 link->source->entity->name, link->source->index,
++		 link->sink->entity->name, link->sink->index);
++
++	if ((link->source->entity == &csi2->sd.entity &&
++	     link->source->index == 1) ||
++	    (link->sink->entity == &csi2->sd.entity &&
++	     link->sink->index == 1)) {
++		csi2_dbg("Ignore metadata pad for now\n");
++		return 0;
++	}
++
++	/* The width, height and code must match. */
++	if (source_fmt->format.width != sink_fmt->format.width ||
++	    source_fmt->format.width != sink_fmt->format.width ||
++	    source_fmt->format.code != sink_fmt->format.code) {
++		csi2_err("%s: format does not match (source %ux%u 0x%x, sink %ux%u 0x%x)\n",
++			 __func__,
++			 source_fmt->format.width, source_fmt->format.height,
++			 source_fmt->format.code,
++			 sink_fmt->format.width, sink_fmt->format.height,
++			 sink_fmt->format.code);
++		return -EPIPE;
++	}
++
++	return 0;
++}
++
++static const struct v4l2_subdev_pad_ops csi2_subdev_pad_ops = {
++	.init_cfg = csi2_init_cfg,
++	.get_fmt = v4l2_subdev_get_fmt,
++	.set_fmt = csi2_pad_set_fmt,
++	.link_validate = csi2_link_validate,
++};
++
++static const struct media_entity_operations csi2_entity_ops = {
++	.link_validate = v4l2_subdev_link_validate,
++};
++
++static const struct v4l2_subdev_ops csi2_subdev_ops = {
++	.pad = &csi2_subdev_pad_ops,
++};
++
++int csi2_init(struct csi2_device *csi2, struct dentry *debugfs)
++{
++	unsigned int i, ret;
++
++	csi2->dphy.dev = csi2->v4l2_dev->dev;
++	dphy_probe(&csi2->dphy);
++
++	debugfs_create_file("csi2_regs", 0444, debugfs, csi2, &csi2_regs_fops);
++
++	for (i = 0; i < CSI2_NUM_CHANNELS * 2; i++)
++		csi2->pad[i].flags = i < CSI2_NUM_CHANNELS ?
++				     MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
++
++	ret = media_entity_pads_init(&csi2->sd.entity, ARRAY_SIZE(csi2->pad),
++				     csi2->pad);
++	if (ret)
++		return ret;
++
++	/* Initialize subdev */
++	v4l2_subdev_init(&csi2->sd, &csi2_subdev_ops);
++	csi2->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
++	csi2->sd.entity.ops = &csi2_entity_ops;
++	csi2->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
++	csi2->sd.owner = THIS_MODULE;
++	snprintf(csi2->sd.name, sizeof(csi2->sd.name), "csi2");
++
++	ret = v4l2_subdev_init_finalize(&csi2->sd);
++	if (ret)
++		goto err_entity_cleanup;
++
++	ret = v4l2_device_register_subdev(csi2->v4l2_dev, &csi2->sd);
++	if (ret) {
++		csi2_err("Failed register csi2 subdev (%d)\n", ret);
++		goto err_subdev_cleanup;
++	}
++
++	return 0;
++
++err_subdev_cleanup:
++	v4l2_subdev_cleanup(&csi2->sd);
++err_entity_cleanup:
++	media_entity_cleanup(&csi2->sd.entity);
++
++	return ret;
++}
++
++void csi2_uninit(struct csi2_device *csi2)
++{
++	v4l2_device_unregister_subdev(&csi2->sd);
++	v4l2_subdev_cleanup(&csi2->sd);
++	media_entity_cleanup(&csi2->sd.entity);
++}
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
+@@ -0,0 +1,75 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * RP1 CSI-2 driver.
++ * Copyright (c) 2021 Raspberry Pi Ltd.
++ *
++ */
++#ifndef _RP1_CSI2_
++#define _RP1_CSI2_
++
++#include <linux/debugfs.h>
++#include <linux/io.h>
++#include <linux/types.h>
++#include <media/v4l2-device.h>
++#include <media/v4l2-subdev.h>
++
++#include "dphy.h"
++
++#define CSI2_NUM_CHANNELS 4
++
++enum csi2_mode {
++	CSI2_MODE_NORMAL,
++	CSI2_MODE_REMAP,
++	CSI2_MODE_COMPRESSED,
++	CSI2_MODE_FE_STREAMING
++};
++
++enum csi2_compression_mode {
++	CSI2_COMPRESSION_DELTA = 1,
++	CSI2_COMPRESSION_SIMPLE = 2,
++	CSI2_COMPRESSION_COMBINED = 3,
++};
++
++struct csi2_cfg {
++	u16 width;
++	u16 height;
++	u32 stride;
++	u32 buffer_size;
++};
++
++struct csi2_device {
++	/* Parent V4l2 device */
++	struct v4l2_device *v4l2_dev;
++
++	void __iomem *base;
++
++	struct dphy_data dphy;
++
++	enum v4l2_mbus_type bus_type;
++	unsigned int bus_flags;
++	u32 active_data_lanes;
++	bool multipacket_line;
++	unsigned int num_lines[CSI2_NUM_CHANNELS];
++
++	struct media_pad pad[CSI2_NUM_CHANNELS * 2];
++	struct v4l2_subdev sd;
++};
++
++void csi2_isr(struct csi2_device *csi2, bool *sof, bool *eof, bool *lci);
++void csi2_set_buffer(struct csi2_device *csi2, unsigned int channel,
++		     dma_addr_t dmaaddr, unsigned int stride,
++		     unsigned int size);
++void csi2_set_compression(struct csi2_device *csi2, unsigned int channel,
++			  enum csi2_compression_mode mode, unsigned int shift,
++			  unsigned int offset);
++void csi2_start_channel(struct csi2_device *csi2, unsigned int channel,
++			u16 dt, enum csi2_mode mode, bool auto_arm,
++			bool pack_bytes, unsigned int width,
++			unsigned int height);
++void csi2_stop_channel(struct csi2_device *csi2, unsigned int channel);
++void csi2_open_rx(struct csi2_device *csi2);
++void csi2_close_rx(struct csi2_device *csi2);
++int csi2_init(struct csi2_device *csi2, struct dentry *debugfs);
++void csi2_uninit(struct csi2_device *csi2);
++
++#endif
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/dphy.c
+@@ -0,0 +1,177 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * RP1 CSI-2 Driver
++ *
++ * Copyright (C) 2021 - Raspberry Pi Ltd.
++ *
++ */
++
++#include <linux/delay.h>
++#include <linux/dev_printk.h>
++#include <linux/pm_runtime.h>
++
++#include "dphy.h"
++
++#define dphy_dbg(fmt, arg...) dev_dbg(dphy->dev, fmt, ##arg)
++#define dphy_info(fmt, arg...) dev_info(dphy->dev, fmt, ##arg)
++#define dphy_err(fmt, arg...) dev_err(dphy->dev, fmt, ##arg)
++
++/* DW dphy Host registers */
++#define VERSION		0x000
++#define N_LANES		0x004
++#define RESETN		0x008
++#define PHY_SHUTDOWNZ	0x040
++#define PHY_RSTZ	0x044
++#define PHY_RX		0x048
++#define	PHY_STOPSTATE	0x04c
++#define PHY_TST_CTRL0	0x050
++#define PHY_TST_CTRL1	0x054
++#define PHY2_TST_CTRL0	0x058
++#define PHY2_TST_CTRL1	0x05c
++
++/* DW dphy Host Transactions */
++#define DPHY_HS_RX_CTRL_LANE0_OFFSET	0x44
++#define DPHY_PLL_INPUT_DIV_OFFSET	0x17
++#define DPHY_PLL_LOOP_DIV_OFFSET	0x18
++#define DPHY_PLL_DIV_CTRL_OFFSET	0x19
++
++static u32 dw_csi2_host_read(struct dphy_data *dphy, u32 offset)
++{
++	return readl(dphy->base + offset);
++}
++
++static void dw_csi2_host_write(struct dphy_data *dphy, u32 offset, u32 data)
++{
++	writel(data, dphy->base + offset);
++}
++
++static void set_tstclr(struct dphy_data *dphy, u32 val)
++{
++	u32 ctrl0 = dw_csi2_host_read(dphy, PHY_TST_CTRL0);
++
++	dw_csi2_host_write(dphy, PHY_TST_CTRL0, (ctrl0 & ~1) | val);
++}
++
++static void set_tstclk(struct dphy_data *dphy, u32 val)
++{
++	u32 ctrl0 = dw_csi2_host_read(dphy, PHY_TST_CTRL0);
++
++	dw_csi2_host_write(dphy, PHY_TST_CTRL0, (ctrl0 & ~2) | (val << 1));
++}
++
++static uint8_t get_tstdout(struct dphy_data *dphy)
++{
++	u32 ctrl1 = dw_csi2_host_read(dphy, PHY_TST_CTRL1);
++
++	return ((ctrl1 >> 8) & 0xff);
++}
++
++static void set_testen(struct dphy_data *dphy, u32 val)
++{
++	u32 ctrl1 = dw_csi2_host_read(dphy, PHY_TST_CTRL1);
++
++	dw_csi2_host_write(dphy, PHY_TST_CTRL1,
++			   (ctrl1 & ~(1 << 16)) | (val << 16));
++}
++
++static void set_testdin(struct dphy_data *dphy, u32 val)
++{
++	u32 ctrl1 = dw_csi2_host_read(dphy, PHY_TST_CTRL1);
++
++	dw_csi2_host_write(dphy, PHY_TST_CTRL1, (ctrl1 & ~0xff) | val);
++}
++
++static uint8_t dphy_transaction(struct dphy_data *dphy, u8 test_code,
++				uint8_t test_data)
++{
++	/* See page 101 of the MIPI DPHY databook. */
++	set_tstclk(dphy, 1);
++	set_testen(dphy, 0);
++	set_testdin(dphy, test_code);
++	set_testen(dphy, 1);
++	set_tstclk(dphy, 0);
++	set_testen(dphy, 0);
++	set_testdin(dphy, test_data);
++	set_tstclk(dphy, 1);
++	return get_tstdout(dphy);
++}
++
++static void dphy_set_hsfreqrange(struct dphy_data *dphy, uint32_t freq_mhz)
++{
++	/* See Table 5-1 on page 65 of dphy databook */
++	static const u16 hsfreqrange_table[][2] = {
++		{ 89, 0b000000 },   { 99, 0b010000 },	{ 109, 0b100000 },
++		{ 129, 0b000001 },  { 139, 0b010001 },	{ 149, 0b100001 },
++		{ 169, 0b000010 },  { 179, 0b010010 },	{ 199, 0b100010 },
++		{ 219, 0b000011 },  { 239, 0b010011 },	{ 249, 0b100011 },
++		{ 269, 0b000100 },  { 299, 0b010100 },	{ 329, 0b000101 },
++		{ 359, 0b010101 },  { 399, 0b100101 },	{ 449, 0b000110 },
++		{ 499, 0b010110 },  { 549, 0b000111 },	{ 599, 0b010111 },
++		{ 649, 0b001000 },  { 699, 0b011000 },	{ 749, 0b001001 },
++		{ 799, 0b011001 },  { 849, 0b101001 },	{ 899, 0b111001 },
++		{ 949, 0b001010 },  { 999, 0b011010 },	{ 1049, 0b101010 },
++		{ 1099, 0b111010 }, { 1149, 0b001011 }, { 1199, 0b011011 },
++		{ 1249, 0b101011 }, { 1299, 0b111011 }, { 1349, 0b001100 },
++		{ 1399, 0b011100 }, { 1449, 0b101100 }, { 1500, 0b111100 },
++	};
++	unsigned int i;
++
++	if (freq_mhz < 80 || freq_mhz > 1500)
++		dphy_err("DPHY: Frequency %u MHz out of range\n", freq_mhz);
++
++	for (i = 0; i < ARRAY_SIZE(hsfreqrange_table) - 1; i++) {
++		if (freq_mhz <= hsfreqrange_table[i][0])
++			break;
++	}
++
++	dphy_transaction(dphy, DPHY_HS_RX_CTRL_LANE0_OFFSET,
++			 hsfreqrange_table[i][1] << 1);
++}
++
++static void dphy_init(struct dphy_data *dphy)
++{
++	dw_csi2_host_write(dphy, PHY_RSTZ, 0);
++	dw_csi2_host_write(dphy, PHY_SHUTDOWNZ, 0);
++	set_tstclk(dphy, 1);
++	set_testen(dphy, 0);
++	set_tstclr(dphy, 1);
++	usleep_range(15, 20);
++	set_tstclr(dphy, 0);
++	usleep_range(15, 20);
++
++	dphy_set_hsfreqrange(dphy, dphy->dphy_freq);
++
++	usleep_range(5, 10);
++	dw_csi2_host_write(dphy, PHY_SHUTDOWNZ, 1);
++	usleep_range(5, 10);
++	dw_csi2_host_write(dphy, PHY_RSTZ, 1);
++}
++
++void dphy_start(struct dphy_data *dphy)
++{
++	dw_csi2_host_write(dphy, N_LANES, (dphy->num_lanes - 1));
++	dphy_init(dphy);
++	dw_csi2_host_write(dphy, RESETN, 0xffffffff);
++	usleep_range(10, 50);
++}
++
++void dphy_stop(struct dphy_data *dphy)
++{
++	/* Set only one lane (lane 0) as active (ON) */
++	dw_csi2_host_write(dphy, N_LANES, 0);
++	dw_csi2_host_write(dphy, RESETN, 0);
++}
++
++void dphy_probe(struct dphy_data *dphy)
++{
++	u32 host_ver;
++	u8 host_ver_major, host_ver_minor;
++
++	host_ver = dw_csi2_host_read(dphy, VERSION);
++	host_ver_major = (u8)((host_ver >> 24) - '0');
++	host_ver_minor = (u8)((host_ver >> 16) - '0');
++	host_ver_minor = host_ver_minor * 10;
++	host_ver_minor += (u8)((host_ver >> 8) - '0');
++
++	dphy_info("DW dphy Host HW v%u.%u\n", host_ver_major, host_ver_minor);
++}
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/dphy.h
+@@ -0,0 +1,26 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Copyright (c) 2021 Raspberry Pi Ltd.
++ *
++ */
++
++#ifndef _RP1_DPHY_
++#define _RP1_DPHY_
++
++#include <linux/io.h>
++#include <linux/types.h>
++
++struct dphy_data {
++	struct device *dev;
++
++	void __iomem *base;
++
++	u32 dphy_freq;
++	u32 num_lanes;
++};
++
++void dphy_probe(struct dphy_data *dphy);
++void dphy_start(struct dphy_data *dphy);
++void dphy_stop(struct dphy_data *dphy);
++
++#endif
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_common.h
+@@ -0,0 +1,69 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * RP1 PiSP common definitions.
++ *
++ * Copyright (C) 2021 - Raspberry Pi Ltd.
++ *
++ */
++#ifndef _PISP_COMMON_H_
++#define _PISP_COMMON_H_
++
++#include "pisp_types.h"
++
++struct pisp_bla_config {
++	u16 black_level_r;
++	u16 black_level_gr;
++	u16 black_level_gb;
++	u16 black_level_b;
++	u16 output_black_level;
++	u8 pad[2];
++};
++
++struct pisp_wbg_config {
++	u16 gain_r;
++	u16 gain_g;
++	u16 gain_b;
++	u8 pad[2];
++};
++
++struct pisp_compress_config {
++	/* value subtracted from incoming data */
++	u16 offset;
++	u8 pad;
++	/* 1 => Companding; 2 => Delta (recommended); 3 => Combined (for HDR) */
++	u8 mode;
++};
++
++struct pisp_decompress_config {
++	/* value added to reconstructed data */
++	u16 offset;
++	u8 pad;
++	/* 1 => Companding; 2 => Delta (recommended); 3 => Combined (for HDR) */
++	u8 mode;
++};
++
++enum pisp_axi_flags {
++	/*
++	 * round down bursts to end at a 32-byte boundary, to align following
++	 * bursts
++	 */
++	PISP_AXI_FLAG_ALIGN = 128,
++	/* for FE writer: force WSTRB high, to pad output to 16-byte boundary */
++	PISP_AXI_FLAG_PAD = 64,
++	/* for FE writer: Use Output FIFO level to trigger "panic" */
++	PISP_AXI_FLAG_PANIC = 32,
++};
++
++struct pisp_axi_config {
++	/*
++	 * burst length minus one, which must be in the range 0:15; OR'd with
++	 * flags
++	 */
++	u8 maxlen_flags;
++	/* { prot[2:0], cache[3:0] } fields, echoed on AXI bus */
++	u8 cache_prot;
++	/* QoS field(s) (4x4 bits for FE writer; 4 bits for other masters) */
++	u16 qos;
++};
++
++#endif /* _PISP_COMMON_H_ */
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+@@ -0,0 +1,563 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * PiSP Front End driver.
++ * Copyright (c) 2021 Raspberry Pi Ltd.
++ *
++ */
++
++#include <linux/bitops.h>
++#include <linux/delay.h>
++#include <linux/moduleparam.h>
++#include <linux/pm_runtime.h>
++#include <linux/seq_file.h>
++
++#include <media/videobuf2-dma-contig.h>
++
++#include "pisp_fe.h"
++#include "cfe.h"
++
++#define FE_VERSION		0x000
++#define FE_CONTROL		0x004
++#define FE_STATUS		0x008
++#define FE_FRAME_STATUS		0x00c
++#define FE_ERROR_STATUS		0x010
++#define FE_OUTPUT_STATUS	0x014
++#define FE_INT_EN		0x018
++#define FE_INT_STATUS		0x01c
++
++/* CONTROL */
++#define FE_CONTROL_QUEUE	BIT(0)
++#define FE_CONTROL_ABORT	BIT(1)
++#define FE_CONTROL_RESET	BIT(2)
++#define FE_CONTROL_LATCH_REGS	BIT(3)
++
++/* INT_EN / INT_STATUS */
++#define FE_INT_EOF		BIT(0)
++#define FE_INT_SOF		BIT(1)
++#define FE_INT_LINES0		BIT(8)
++#define FE_INT_LINES1		BIT(9)
++#define FE_INT_STATS		BIT(16)
++#define FE_INT_QREADY		BIT(24)
++
++/* STATUS */
++#define FE_STATUS_QUEUED	BIT(0)
++#define FE_STATUS_WAITING	BIT(1)
++#define FE_STATUS_ACTIVE	BIT(2)
++
++#define PISP_FE_CONFIG_BASE_OFFSET	0x0040
++
++#define PISP_FE_ENABLE_STATS_CLUSTER \
++	(PISP_FE_ENABLE_STATS_CROP | PISP_FE_ENABLE_DECIMATE    | \
++	 PISP_FE_ENABLE_BLC        | PISP_FE_ENABLE_CDAF_STATS  | \
++	 PISP_FE_ENABLE_AWB_STATS  | PISP_FE_ENABLE_RGBY        | \
++	 PISP_FE_ENABLE_LSC        | PISP_FE_ENABLE_AGC_STATS)
++
++#define PISP_FE_ENABLE_OUTPUT_CLUSTER(i)				\
++	((PISP_FE_ENABLE_CROP0     | PISP_FE_ENABLE_DOWNSCALE0 |	\
++	  PISP_FE_ENABLE_COMPRESS0 | PISP_FE_ENABLE_OUTPUT0) << (4 * (i)))
++
++struct pisp_fe_config_param {
++	u32 dirty_flags;
++	u32 dirty_flags_extra;
++	size_t offset;
++	size_t size;
++};
++
++static const struct pisp_fe_config_param pisp_fe_config_map[] = {
++	/* *_dirty_flag_extra types */
++	{ 0, PISP_FE_DIRTY_GLOBAL,     offsetof(struct pisp_fe_config, global),
++					sizeof(struct pisp_fe_global_config)         },
++	{ 0, PISP_FE_DIRTY_FLOATING,   offsetof(struct pisp_fe_config, floating_stats),
++					sizeof(struct pisp_fe_floating_stats_config) },
++	{ 0, PISP_FE_DIRTY_OUTPUT_AXI, offsetof(struct pisp_fe_config, output_axi),
++					sizeof(struct pisp_fe_output_axi_config)     },
++	/* *_dirty_flag types */
++	{ PISP_FE_ENABLE_INPUT,      0, offsetof(struct pisp_fe_config, input),
++					sizeof(struct pisp_fe_input_config)          },
++	{ PISP_FE_ENABLE_DECOMPRESS, 0, offsetof(struct pisp_fe_config, decompress),
++					sizeof(struct pisp_decompress_config)        },
++	{ PISP_FE_ENABLE_DECOMPAND,  0, offsetof(struct pisp_fe_config, decompand),
++					sizeof(struct pisp_fe_decompand_config)      },
++	{ PISP_FE_ENABLE_BLA,        0, offsetof(struct pisp_fe_config, bla),
++					sizeof(struct pisp_bla_config)               },
++	{ PISP_FE_ENABLE_DPC,        0, offsetof(struct pisp_fe_config, dpc),
++					sizeof(struct pisp_fe_dpc_config)            },
++	{ PISP_FE_ENABLE_STATS_CROP, 0, offsetof(struct pisp_fe_config, stats_crop),
++					sizeof(struct pisp_fe_crop_config)           },
++	{ PISP_FE_ENABLE_BLC,	     0, offsetof(struct pisp_fe_config, blc),
++					sizeof(struct pisp_bla_config)               },
++	{ PISP_FE_ENABLE_CDAF_STATS, 0, offsetof(struct pisp_fe_config, cdaf_stats),
++					sizeof(struct pisp_fe_cdaf_stats_config)     },
++	{ PISP_FE_ENABLE_AWB_STATS,  0, offsetof(struct pisp_fe_config, awb_stats),
++					sizeof(struct pisp_fe_awb_stats_config)      },
++	{ PISP_FE_ENABLE_RGBY,       0, offsetof(struct pisp_fe_config, rgby),
++					sizeof(struct pisp_fe_rgby_config)           },
++	{ PISP_FE_ENABLE_LSC,        0, offsetof(struct pisp_fe_config, lsc),
++					sizeof(struct pisp_fe_lsc_config)            },
++	{ PISP_FE_ENABLE_AGC_STATS,  0, offsetof(struct pisp_fe_config, agc_stats),
++					sizeof(struct pisp_agc_statistics)           },
++	{ PISP_FE_ENABLE_CROP0,      0, offsetof(struct pisp_fe_config, ch[0].crop),
++					sizeof(struct pisp_fe_crop_config)           },
++	{ PISP_FE_ENABLE_DOWNSCALE0, 0, offsetof(struct pisp_fe_config, ch[0].downscale),
++					sizeof(struct pisp_fe_downscale_config)      },
++	{ PISP_FE_ENABLE_COMPRESS0,  0, offsetof(struct pisp_fe_config, ch[0].compress),
++					sizeof(struct pisp_compress_config)          },
++	{ PISP_FE_ENABLE_OUTPUT0,    0, offsetof(struct pisp_fe_config, ch[0].output),
++					sizeof(struct pisp_fe_output_config)         },
++	{ PISP_FE_ENABLE_CROP1,      0, offsetof(struct pisp_fe_config, ch[1].crop),
++					sizeof(struct pisp_fe_crop_config)           },
++	{ PISP_FE_ENABLE_DOWNSCALE1, 0, offsetof(struct pisp_fe_config, ch[1].downscale),
++					sizeof(struct pisp_fe_downscale_config)      },
++	{ PISP_FE_ENABLE_COMPRESS1,  0, offsetof(struct pisp_fe_config, ch[1].compress),
++					sizeof(struct pisp_compress_config)          },
++	{ PISP_FE_ENABLE_OUTPUT1,    0, offsetof(struct pisp_fe_config, ch[1].output),
++					sizeof(struct pisp_fe_output_config)         },
++};
++
++#define pisp_fe_dbg_irq(fmt, arg...)                            \
++	do {                                                    \
++		if (cfe_debug_irq)                              \
++			dev_dbg(fe->v4l2_dev->dev, fmt, ##arg); \
++	} while (0)
++#define pisp_fe_dbg(fmt, arg...) dev_dbg(fe->v4l2_dev->dev, fmt, ##arg)
++#define pisp_fe_info(fmt, arg...) dev_info(fe->v4l2_dev->dev, fmt, ##arg)
++#define pisp_fe_err(fmt, arg...) dev_err(fe->v4l2_dev->dev, fmt, ##arg)
++
++static inline u32 pisp_fe_reg_read(struct pisp_fe_device *fe, u32 offset)
++{
++	return readl(fe->base + offset);
++}
++
++static inline void pisp_fe_reg_write(struct pisp_fe_device *fe, u32 offset,
++				     u32 val)
++{
++	writel(val, fe->base + offset);
++}
++
++static inline void pisp_fe_reg_write_relaxed(struct pisp_fe_device *fe, u32 offset,
++					     u32 val)
++{
++	writel_relaxed(val, fe->base + offset);
++}
++
++static int pisp_regs_show(struct seq_file *s, void *data)
++{
++	struct pisp_fe_device *fe = s->private;
++	int ret;
++
++	ret = pm_runtime_resume_and_get(fe->v4l2_dev->dev);
++	if (ret)
++		return ret;
++
++	pisp_fe_reg_write(fe, FE_CONTROL, FE_CONTROL_LATCH_REGS);
++
++#define DUMP(reg) seq_printf(s, #reg " \t0x%08x\n", pisp_fe_reg_read(fe, reg))
++	DUMP(FE_VERSION);
++	DUMP(FE_CONTROL);
++	DUMP(FE_STATUS);
++	DUMP(FE_FRAME_STATUS);
++	DUMP(FE_ERROR_STATUS);
++	DUMP(FE_OUTPUT_STATUS);
++	DUMP(FE_INT_EN);
++	DUMP(FE_INT_STATUS);
++#undef DUMP
++
++	pm_runtime_put(fe->v4l2_dev->dev);
++
++	return 0;
++}
++
++DEFINE_SHOW_ATTRIBUTE(pisp_regs);
++
++static void pisp_config_write(struct pisp_fe_device *fe,
++			      struct pisp_fe_config *config,
++			      unsigned int start_offset,
++			      unsigned int size)
++{
++	const unsigned int max_offset =
++		offsetof(struct pisp_fe_config, ch[PISP_FE_NUM_OUTPUTS]);
++	unsigned int i, end_offset;
++	u32 *cfg = (u32 *)config;
++
++	start_offset = min(start_offset, max_offset);
++	end_offset = min(start_offset + size, max_offset);
++
++	cfg += start_offset >> 2;
++	for (i = start_offset; i < end_offset; i += 4, cfg++)
++		pisp_fe_reg_write_relaxed(fe, PISP_FE_CONFIG_BASE_OFFSET + i,
++					  *cfg);
++}
++
++void pisp_fe_isr(struct pisp_fe_device *fe, bool *sof, bool *eof)
++{
++	u32 status, int_status, out_status, frame_status, error_status;
++	unsigned int i;
++
++	pisp_fe_reg_write(fe, FE_CONTROL, FE_CONTROL_LATCH_REGS);
++	status = pisp_fe_reg_read(fe, FE_STATUS);
++	out_status = pisp_fe_reg_read(fe, FE_OUTPUT_STATUS);
++	frame_status = pisp_fe_reg_read(fe, FE_FRAME_STATUS);
++	error_status = pisp_fe_reg_read(fe, FE_ERROR_STATUS);
++
++	int_status = pisp_fe_reg_read(fe, FE_INT_STATUS);
++	pisp_fe_reg_write(fe, FE_INT_STATUS, int_status);
++
++	pisp_fe_dbg_irq("%s: status 0x%x out 0x%x frame 0x%x error 0x%x int 0x%x\n",
++			__func__, status, out_status, frame_status, error_status,
++			int_status);
++
++	/* We do not report interrupts for the input/stream pad. */
++	for (i = 0; i < FE_NUM_PADS - 1; i++) {
++		sof[i] = !!(int_status & FE_INT_SOF);
++		eof[i] = !!(int_status & FE_INT_EOF);
++	}
++}
++
++static bool pisp_fe_validate_output(struct pisp_fe_config const *cfg,
++				    unsigned int c, struct v4l2_format const *f)
++{
++	unsigned int wbytes;
++
++	wbytes = cfg->ch[c].output.format.width;
++	if (cfg->ch[c].output.format.format & PISP_IMAGE_FORMAT_BPS_MASK)
++		wbytes *= 2;
++
++	/* Check output image dimensions are nonzero and not too big */
++	if (cfg->ch[c].output.format.width < 2 ||
++	    cfg->ch[c].output.format.height < 2 ||
++	    cfg->ch[c].output.format.height > f->fmt.pix.height ||
++	    cfg->ch[c].output.format.stride > f->fmt.pix.bytesperline ||
++	    wbytes > f->fmt.pix.bytesperline)
++		return false;
++
++	/* Check for zero-sized crops, which could cause lockup */
++	if ((cfg->global.enables & PISP_FE_ENABLE_CROP(c)) &&
++	    ((cfg->ch[c].crop.offset_x >= (cfg->input.format.width & ~1) ||
++	      cfg->ch[c].crop.offset_y >= cfg->input.format.height ||
++	      cfg->ch[c].crop.width < 2 ||
++	      cfg->ch[c].crop.height < 2)))
++		return false;
++
++	if ((cfg->global.enables & PISP_FE_ENABLE_DOWNSCALE(c)) &&
++	    (cfg->ch[c].downscale.output_width < 2 ||
++	     cfg->ch[c].downscale.output_height < 2))
++		return false;
++
++	return true;
++}
++
++static bool pisp_fe_validate_stats(struct pisp_fe_config const *cfg)
++{
++	/* Check for zero-sized crop, which could cause lockup */
++	return (!(cfg->global.enables & PISP_FE_ENABLE_STATS_CROP) ||
++		(cfg->stats_crop.offset_x < (cfg->input.format.width & ~1) &&
++		 cfg->stats_crop.offset_y < cfg->input.format.height &&
++		 cfg->stats_crop.width >= 2 &&
++		 cfg->stats_crop.height >= 2));
++}
++
++int pisp_fe_validate_config(struct pisp_fe_device *fe,
++			    struct pisp_fe_config *cfg,
++			    struct v4l2_format const *f0,
++			    struct v4l2_format const *f1)
++{
++	unsigned int i;
++
++	/*
++	 * Check the input is enabled, streaming and has nonzero size;
++	 * to avoid cases where the hardware might lock up or try to
++	 * read inputs from memory (which this driver doesn't support).
++	 */
++	if (!(cfg->global.enables & PISP_FE_ENABLE_INPUT) ||
++	    cfg->input.streaming != 1 || cfg->input.format.width < 2 ||
++	    cfg->input.format.height < 2) {
++		pisp_fe_err("%s: Input config not valid", __func__);
++		return -EINVAL;
++	}
++
++	for (i = 0; i < PISP_FE_NUM_OUTPUTS; i++) {
++		if (!(cfg->global.enables & PISP_FE_ENABLE_OUTPUT(i))) {
++			if (cfg->global.enables &
++					PISP_FE_ENABLE_OUTPUT_CLUSTER(i)) {
++				pisp_fe_err("%s: Output %u not valid",
++					    __func__, i);
++				return -EINVAL;
++			}
++			continue;
++		}
++
++		if (!pisp_fe_validate_output(cfg, i, i ? f1 : f0))
++			return -EINVAL;
++	}
++
++	if ((cfg->global.enables & PISP_FE_ENABLE_STATS_CLUSTER) &&
++	    !pisp_fe_validate_stats(cfg)) {
++		pisp_fe_err("%s: Stats config not valid", __func__);
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++void pisp_fe_submit_job(struct pisp_fe_device *fe, struct vb2_buffer **vb2_bufs,
++			struct pisp_fe_config *cfg)
++{
++	unsigned int i;
++	u64 addr;
++	u32 status;
++
++	/*
++	 * Check output buffers exist and outputs are correctly configured.
++	 * If valid, set the buffer's DMA address; otherwise disable.
++	 */
++	for (i = 0; i < PISP_FE_NUM_OUTPUTS; i++) {
++		struct vb2_buffer *buf = vb2_bufs[FE_OUTPUT0_PAD + i];
++
++		if (!(cfg->global.enables & PISP_FE_ENABLE_OUTPUT(i)))
++			continue;
++
++		addr = vb2_dma_contig_plane_dma_addr(buf, 0);
++		cfg->output_buffer[i].addr_lo = addr & 0xffffffff;
++		cfg->output_buffer[i].addr_hi = addr >> 32;
++	}
++
++	if (vb2_bufs[FE_STATS_PAD]) {
++		addr = vb2_dma_contig_plane_dma_addr(vb2_bufs[FE_STATS_PAD], 0);
++		cfg->stats_buffer.addr_lo = addr & 0xffffffff;
++		cfg->stats_buffer.addr_hi = addr >> 32;
++	}
++
++	/* Set up ILINES interrupts 3/4 of the way down each output */
++	cfg->ch[0].output.ilines =
++		max(0x80u, (3u * cfg->ch[0].output.format.height) >> 2);
++	cfg->ch[1].output.ilines =
++		max(0x80u, (3u * cfg->ch[1].output.format.height) >> 2);
++
++	/*
++	 * The hardware must have consumed the previous config by now.
++	 * This read of status also serves as a memory barrier before the
++	 * sequence of relaxed writes which follow.
++	 */
++	status = pisp_fe_reg_read(fe, FE_STATUS);
++	pisp_fe_dbg_irq("%s: status = 0x%x\n", __func__, status);
++	if (WARN_ON(status & FE_STATUS_QUEUED))
++		return;
++
++	/*
++	 * Unconditionally write buffers, global and input parameters.
++	 * Write cropping and output parameters whenever they are enabled.
++	 * Selectively write other parameters that have been marked as
++	 * changed through the dirty flags.
++	 */
++	pisp_config_write(fe, cfg, 0,
++			  offsetof(struct pisp_fe_config, decompress));
++	cfg->dirty_flags_extra &= ~PISP_FE_DIRTY_GLOBAL;
++	cfg->dirty_flags &= ~PISP_FE_ENABLE_INPUT;
++	cfg->dirty_flags |= (cfg->global.enables &
++			     (PISP_FE_ENABLE_STATS_CROP        |
++			      PISP_FE_ENABLE_OUTPUT_CLUSTER(0) |
++			      PISP_FE_ENABLE_OUTPUT_CLUSTER(1)));
++	for (i = 0; i < ARRAY_SIZE(pisp_fe_config_map); i++) {
++		const struct pisp_fe_config_param *p = &pisp_fe_config_map[i];
++
++		if (cfg->dirty_flags & p->dirty_flags ||
++		    cfg->dirty_flags_extra & p->dirty_flags_extra)
++			pisp_config_write(fe, cfg, p->offset, p->size);
++	}
++
++	/* This final non-relaxed write serves as a memory barrier */
++	pisp_fe_reg_write(fe, FE_CONTROL, FE_CONTROL_QUEUE);
++}
++
++void pisp_fe_start(struct pisp_fe_device *fe)
++{
++	pisp_fe_reg_write(fe, FE_CONTROL, FE_CONTROL_RESET);
++	pisp_fe_reg_write(fe, FE_INT_STATUS, -1);
++	pisp_fe_reg_write(fe, FE_INT_EN, FE_INT_EOF | FE_INT_SOF | FE_INT_LINES0 | FE_INT_LINES1);
++	fe->inframe_count = 0;
++}
++
++void pisp_fe_stop(struct pisp_fe_device *fe)
++{
++	pisp_fe_reg_write(fe, FE_INT_EN, 0);
++	pisp_fe_reg_write(fe, FE_CONTROL, FE_CONTROL_ABORT);
++	usleep_range(1000, 2000);
++	WARN_ON(pisp_fe_reg_read(fe, FE_STATUS));
++	pisp_fe_reg_write(fe, FE_INT_STATUS, -1);
++}
++
++static struct pisp_fe_device *to_pisp_fe_device(struct v4l2_subdev *subdev)
++{
++	return container_of(subdev, struct pisp_fe_device, sd);
++}
++
++static int pisp_fe_init_cfg(struct v4l2_subdev *sd,
++			    struct v4l2_subdev_state *state)
++{
++	struct v4l2_mbus_framefmt *fmt;
++
++	fmt = v4l2_subdev_get_pad_format(sd, state, FE_STREAM_PAD);
++	*fmt = cfe_default_format;
++	fmt->code = MEDIA_BUS_FMT_SRGGB16_1X16;
++
++	fmt = v4l2_subdev_get_pad_format(sd, state, FE_CONFIG_PAD);
++	*fmt = cfe_default_meta_format;
++	fmt->code = MEDIA_BUS_FMT_PISP_FE_CONFIG;
++
++	fmt = v4l2_subdev_get_pad_format(sd, state, FE_OUTPUT0_PAD);
++	*fmt = cfe_default_format;
++	fmt->code = MEDIA_BUS_FMT_SRGGB16_1X16;
++
++	fmt = v4l2_subdev_get_pad_format(sd, state, FE_OUTPUT1_PAD);
++	*fmt = cfe_default_format;
++	fmt->code = MEDIA_BUS_FMT_SRGGB16_1X16;
++
++	fmt = v4l2_subdev_get_pad_format(sd, state, FE_STATS_PAD);
++	*fmt = cfe_default_meta_format;
++	fmt->code = MEDIA_BUS_FMT_PISP_FE_STATS;
++
++	return 0;
++}
++
++static int pisp_fe_pad_set_fmt(struct v4l2_subdev *sd,
++			       struct v4l2_subdev_state *state,
++			       struct v4l2_subdev_format *format)
++{
++	struct v4l2_mbus_framefmt *fmt;
++	const struct cfe_fmt *cfe_fmt;
++
++	/* TODO: format propagation to source pads */
++	/* TODO: format validation */
++
++	switch (format->pad) {
++	case FE_STREAM_PAD:
++	case FE_OUTPUT0_PAD:
++	case FE_OUTPUT1_PAD:
++		cfe_fmt = find_format_by_code(format->format.code);
++		if (!cfe_fmt || !(cfe_fmt->flags & CFE_FORMAT_FLAG_FE_OUT))
++			cfe_fmt = find_format_by_code(MEDIA_BUS_FMT_SBGGR10_1X10);
++
++		format->format.code = cfe_fmt->code;
++
++		break;
++
++	case FE_CONFIG_PAD:
++		format->format.code = MEDIA_BUS_FMT_PISP_FE_CONFIG;
++		break;
++
++	case FE_STATS_PAD:
++		format->format.code = MEDIA_BUS_FMT_PISP_FE_STATS;
++		break;
++	}
++
++	fmt = v4l2_subdev_get_pad_format(sd, state, format->pad);
++	*fmt = format->format;
++
++	return 0;
++}
++
++static int pisp_fe_link_validate(struct v4l2_subdev *sd,
++				 struct media_link *link,
++				 struct v4l2_subdev_format *source_fmt,
++				 struct v4l2_subdev_format *sink_fmt)
++{
++	struct pisp_fe_device *fe = to_pisp_fe_device(sd);
++
++	pisp_fe_dbg("%s: link \"%s\":%u -> \"%s\":%u\n", __func__,
++		    link->source->entity->name, link->source->index,
++		    link->sink->entity->name, link->sink->index);
++
++	/* The width, height and code must match. */
++	if (source_fmt->format.width != sink_fmt->format.width ||
++	    source_fmt->format.width != sink_fmt->format.width ||
++	    source_fmt->format.code != sink_fmt->format.code) {
++		pisp_fe_err("%s: format does not match (source %ux%u 0x%x, sink %ux%u 0x%x)\n",
++			    __func__,
++			     source_fmt->format.width,
++			     source_fmt->format.height,
++			     source_fmt->format.code,
++			     sink_fmt->format.width,
++			     sink_fmt->format.height,
++			     sink_fmt->format.code);
++		return -EPIPE;
++	}
++
++	return 0;
++}
++
++static const struct v4l2_subdev_pad_ops pisp_fe_subdev_pad_ops = {
++	.init_cfg = pisp_fe_init_cfg,
++	.get_fmt = v4l2_subdev_get_fmt,
++	.set_fmt = pisp_fe_pad_set_fmt,
++	.link_validate = pisp_fe_link_validate,
++};
++
++static const struct media_entity_operations pisp_fe_entity_ops = {
++	.link_validate = v4l2_subdev_link_validate,
++};
++
++static const struct v4l2_subdev_ops pisp_fe_subdev_ops = {
++	.pad = &pisp_fe_subdev_pad_ops,
++};
++
++int pisp_fe_init(struct pisp_fe_device *fe, struct dentry *debugfs)
++{
++	int ret;
++
++	debugfs_create_file("pisp_regs", 0444, debugfs, fe, &pisp_regs_fops);
++
++	fe->hw_revision = pisp_fe_reg_read(fe, FE_VERSION);
++	pisp_fe_info("PiSP FE HW v%u.%u\n",
++		     (fe->hw_revision >> 24) & 0xff,
++		     (fe->hw_revision >> 20) & 0x0f);
++
++	fe->pad[FE_STREAM_PAD].flags =
++		MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;
++	fe->pad[FE_CONFIG_PAD].flags = MEDIA_PAD_FL_SINK;
++	fe->pad[FE_OUTPUT0_PAD].flags = MEDIA_PAD_FL_SOURCE;
++	fe->pad[FE_OUTPUT1_PAD].flags = MEDIA_PAD_FL_SOURCE;
++	fe->pad[FE_STATS_PAD].flags = MEDIA_PAD_FL_SOURCE;
++
++	ret = media_entity_pads_init(&fe->sd.entity, ARRAY_SIZE(fe->pad),
++				     fe->pad);
++	if (ret)
++		return ret;
++
++	/* Initialize subdev */
++	v4l2_subdev_init(&fe->sd, &pisp_fe_subdev_ops);
++	fe->sd.entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;
++	fe->sd.entity.ops = &pisp_fe_entity_ops;
++	fe->sd.entity.name = "pisp-fe";
++	fe->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
++	fe->sd.owner = THIS_MODULE;
++	snprintf(fe->sd.name, sizeof(fe->sd.name), "pisp-fe");
++
++	ret = v4l2_subdev_init_finalize(&fe->sd);
++	if (ret)
++		goto err_entity_cleanup;
++
++	ret = v4l2_device_register_subdev(fe->v4l2_dev, &fe->sd);
++	if (ret) {
++		pisp_fe_err("Failed register pisp fe subdev (%d)\n", ret);
++		goto err_subdev_cleanup;
++	}
++
++	/* Must be in IDLE state (STATUS == 0) here. */
++	WARN_ON(pisp_fe_reg_read(fe, FE_STATUS));
++
++	return 0;
++
++err_subdev_cleanup:
++	v4l2_subdev_cleanup(&fe->sd);
++err_entity_cleanup:
++	media_entity_cleanup(&fe->sd.entity);
++
++	return ret;
++}
++
++void pisp_fe_uninit(struct pisp_fe_device *fe)
++{
++	v4l2_device_unregister_subdev(&fe->sd);
++	v4l2_subdev_cleanup(&fe->sd);
++	media_entity_cleanup(&fe->sd.entity);
++}
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.h
+@@ -0,0 +1,53 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * PiSP Front End driver.
++ * Copyright (c) 2021 Raspberry Pi Ltd.
++ *
++ */
++#ifndef _PISP_FE_H_
++#define _PISP_FE_H_
++
++#include <linux/debugfs.h>
++#include <linux/io.h>
++#include <linux/types.h>
++#include <linux/videodev2.h>
++
++#include <media/media-device.h>
++#include <media/v4l2-device.h>
++#include <media/v4l2-subdev.h>
++
++#include "pisp_fe_config.h"
++
++enum pisp_fe_pads {
++	FE_STREAM_PAD,
++	FE_CONFIG_PAD,
++	FE_OUTPUT0_PAD,
++	FE_OUTPUT1_PAD,
++	FE_STATS_PAD,
++	FE_NUM_PADS
++};
++
++struct pisp_fe_device {
++	/* Parent V4l2 device */
++	struct v4l2_device *v4l2_dev;
++	void __iomem *base;
++	u32 hw_revision;
++
++	u16 inframe_count;
++	struct media_pad pad[FE_NUM_PADS];
++	struct v4l2_subdev sd;
++};
++
++void pisp_fe_isr(struct pisp_fe_device *fe, bool *sof, bool *eof);
++int pisp_fe_validate_config(struct pisp_fe_device *fe,
++			    struct pisp_fe_config *cfg,
++			    struct v4l2_format const *f0,
++			    struct v4l2_format const *f1);
++void pisp_fe_submit_job(struct pisp_fe_device *fe, struct vb2_buffer **vb2_bufs,
++			struct pisp_fe_config *cfg);
++void pisp_fe_start(struct pisp_fe_device *fe);
++void pisp_fe_stop(struct pisp_fe_device *fe);
++int pisp_fe_init(struct pisp_fe_device *fe, struct dentry *debugfs);
++void pisp_fe_uninit(struct pisp_fe_device *fe);
++
++#endif
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe_config.h
+@@ -0,0 +1,272 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * RP1 PiSP Front End Driver Configuration structures
++ *
++ * Copyright (C) 2021 - Raspberry Pi Ltd.
++ *
++ */
++#ifndef _PISP_FE_CONFIG_
++#define _PISP_FE_CONFIG_
++
++#include <media/raspberrypi/pisp_common.h>
++
++#include "pisp_statistics.h"
++
++#define PISP_FE_NUM_OUTPUTS 2
++
++enum pisp_fe_enable {
++	PISP_FE_ENABLE_INPUT = 0x000001,
++	PISP_FE_ENABLE_DECOMPRESS = 0x000002,
++	PISP_FE_ENABLE_DECOMPAND = 0x000004,
++	PISP_FE_ENABLE_BLA = 0x000008,
++	PISP_FE_ENABLE_DPC = 0x000010,
++	PISP_FE_ENABLE_STATS_CROP = 0x000020,
++	PISP_FE_ENABLE_DECIMATE = 0x000040,
++	PISP_FE_ENABLE_BLC = 0x000080,
++	PISP_FE_ENABLE_CDAF_STATS = 0x000100,
++	PISP_FE_ENABLE_AWB_STATS = 0x000200,
++	PISP_FE_ENABLE_RGBY = 0x000400,
++	PISP_FE_ENABLE_LSC = 0x000800,
++	PISP_FE_ENABLE_AGC_STATS = 0x001000,
++	PISP_FE_ENABLE_CROP0 = 0x010000,
++	PISP_FE_ENABLE_DOWNSCALE0 = 0x020000,
++	PISP_FE_ENABLE_COMPRESS0 = 0x040000,
++	PISP_FE_ENABLE_OUTPUT0 = 0x080000,
++	PISP_FE_ENABLE_CROP1 = 0x100000,
++	PISP_FE_ENABLE_DOWNSCALE1 = 0x200000,
++	PISP_FE_ENABLE_COMPRESS1 = 0x400000,
++	PISP_FE_ENABLE_OUTPUT1 = 0x800000
++};
++
++#define PISP_FE_ENABLE_CROP(i) (PISP_FE_ENABLE_CROP0 << (4 * (i)))
++#define PISP_FE_ENABLE_DOWNSCALE(i) (PISP_FE_ENABLE_DOWNSCALE0 << (4 * (i)))
++#define PISP_FE_ENABLE_COMPRESS(i) (PISP_FE_ENABLE_COMPRESS0 << (4 * (i)))
++#define PISP_FE_ENABLE_OUTPUT(i) (PISP_FE_ENABLE_OUTPUT0 << (4 * (i)))
++
++/*
++ * We use the enable flags to show when blocks are "dirty", but we need some
++ * extra ones too.
++ */
++enum pisp_fe_dirty {
++	PISP_FE_DIRTY_GLOBAL = 0x0001,
++	PISP_FE_DIRTY_FLOATING = 0x0002,
++	PISP_FE_DIRTY_OUTPUT_AXI = 0x0004
++};
++
++struct pisp_fe_global_config {
++	u32 enables;
++	u8 bayer_order;
++	u8 pad[3];
++};
++
++struct pisp_fe_input_axi_config {
++	/* burst length minus one, in the range 0..15; OR'd with flags */
++	u8 maxlen_flags;
++	/* { prot[2:0], cache[3:0] } fields */
++	u8 cache_prot;
++	/* QoS (only 4 LS bits are used) */
++	u16 qos;
++};
++
++struct pisp_fe_output_axi_config {
++	/* burst length minus one, in the range 0..15; OR'd with flags */
++	u8 maxlen_flags;
++	/* { prot[2:0], cache[3:0] } fields */
++	u8 cache_prot;
++	/* QoS (4 bitfields of 4 bits each for different panic levels) */
++	u16 qos;
++	/*  For Panic mode: Output FIFO panic threshold */
++	u16 thresh;
++	/*  For Panic mode: Output FIFO statistics throttle threshold */
++	u16 throttle;
++};
++
++struct pisp_fe_input_config {
++	u8 streaming;
++	u8 pad[3];
++	struct pisp_image_format_config format;
++	struct pisp_fe_input_axi_config axi;
++	/* Extra cycles delay before issuing each burst request */
++	u8 holdoff;
++	u8 pad2[3];
++};
++
++struct pisp_fe_output_config {
++	struct pisp_image_format_config format;
++	u16 ilines;
++	u8 pad[2];
++};
++
++struct pisp_fe_input_buffer_config {
++	u32 addr_lo;
++	u32 addr_hi;
++	u16 frame_id;
++	u16 pad;
++};
++
++#define PISP_FE_DECOMPAND_LUT_SIZE 65
++
++struct pisp_fe_decompand_config {
++	u16 lut[PISP_FE_DECOMPAND_LUT_SIZE];
++	u16 pad;
++};
++
++struct pisp_fe_dpc_config {
++	u8 coeff_level;
++	u8 coeff_range;
++	u8 coeff_range2;
++#define PISP_FE_DPC_FLAG_FOLDBACK 1
++#define PISP_FE_DPC_FLAG_VFLAG 2
++	u8 flags;
++};
++
++#define PISP_FE_LSC_LUT_SIZE 16
++
++struct pisp_fe_lsc_config {
++	u8 shift;
++	u8 pad0;
++	u16 scale;
++	u16 centre_x;
++	u16 centre_y;
++	u16 lut[PISP_FE_LSC_LUT_SIZE];
++};
++
++struct pisp_fe_rgby_config {
++	u16 gain_r;
++	u16 gain_g;
++	u16 gain_b;
++	u8 maxflag;
++	u8 pad;
++};
++
++struct pisp_fe_agc_stats_config {
++	u16 offset_x;
++	u16 offset_y;
++	u16 size_x;
++	u16 size_y;
++	/* each weight only 4 bits */
++	u8 weights[PISP_AGC_STATS_NUM_ZONES / 2];
++	u16 row_offset_x;
++	u16 row_offset_y;
++	u16 row_size_x;
++	u16 row_size_y;
++	u8 row_shift;
++	u8 float_shift;
++	u8 pad1[2];
++};
++
++struct pisp_fe_awb_stats_config {
++	u16 offset_x;
++	u16 offset_y;
++	u16 size_x;
++	u16 size_y;
++	u8 shift;
++	u8 pad[3];
++	u16 r_lo;
++	u16 r_hi;
++	u16 g_lo;
++	u16 g_hi;
++	u16 b_lo;
++	u16 b_hi;
++};
++
++struct pisp_fe_floating_stats_region {
++	u16 offset_x;
++	u16 offset_y;
++	u16 size_x;
++	u16 size_y;
++};
++
++struct pisp_fe_floating_stats_config {
++	struct pisp_fe_floating_stats_region
++					regions[PISP_FLOATING_STATS_NUM_ZONES];
++};
++
++#define PISP_FE_CDAF_NUM_WEIGHTS 8
++
++struct pisp_fe_cdaf_stats_config {
++	u16 noise_constant;
++	u16 noise_slope;
++	u16 offset_x;
++	u16 offset_y;
++	u16 size_x;
++	u16 size_y;
++	u16 skip_x;
++	u16 skip_y;
++	u32 mode;
++};
++
++struct pisp_fe_stats_buffer_config {
++	u32 addr_lo;
++	u32 addr_hi;
++};
++
++struct pisp_fe_crop_config {
++	u16 offset_x;
++	u16 offset_y;
++	u16 width;
++	u16 height;
++};
++
++enum pisp_fe_downscale_flags {
++	DOWNSCALE_BAYER =
++		1, /* downscale the four Bayer components independently... */
++	DOWNSCALE_BIN =
++		2 /* ...without trying to preserve their spatial relationship */
++};
++
++struct pisp_fe_downscale_config {
++	u8 xin;
++	u8 xout;
++	u8 yin;
++	u8 yout;
++	u8 flags; /* enum pisp_fe_downscale_flags */
++	u8 pad[3];
++	u16 output_width;
++	u16 output_height;
++};
++
++struct pisp_fe_output_buffer_config {
++	u32 addr_lo;
++	u32 addr_hi;
++};
++
++/* Each of the two output channels/branches: */
++struct pisp_fe_output_branch_config {
++	struct pisp_fe_crop_config crop;
++	struct pisp_fe_downscale_config downscale;
++	struct pisp_compress_config compress;
++	struct pisp_fe_output_config output;
++	u32 pad;
++};
++
++/* And finally one to rule them all: */
++struct pisp_fe_config {
++	/* I/O configuration: */
++	struct pisp_fe_stats_buffer_config stats_buffer;
++	struct pisp_fe_output_buffer_config output_buffer[PISP_FE_NUM_OUTPUTS];
++	struct pisp_fe_input_buffer_config input_buffer;
++	/* processing configuration: */
++	struct pisp_fe_global_config global;
++	struct pisp_fe_input_config input;
++	struct pisp_decompress_config decompress;
++	struct pisp_fe_decompand_config decompand;
++	struct pisp_bla_config bla;
++	struct pisp_fe_dpc_config dpc;
++	struct pisp_fe_crop_config stats_crop;
++	u32 spare1; /* placeholder for future decimate configuration */
++	struct pisp_bla_config blc;
++	struct pisp_fe_rgby_config rgby;
++	struct pisp_fe_lsc_config lsc;
++	struct pisp_fe_agc_stats_config agc_stats;
++	struct pisp_fe_awb_stats_config awb_stats;
++	struct pisp_fe_cdaf_stats_config cdaf_stats;
++	struct pisp_fe_floating_stats_config floating_stats;
++	struct pisp_fe_output_axi_config output_axi;
++	struct pisp_fe_output_branch_config ch[PISP_FE_NUM_OUTPUTS];
++	/* non-register fields: */
++	u32 dirty_flags; /* these use pisp_fe_enable */
++	u32 dirty_flags_extra; /* these use pisp_fe_dirty */
++};
++
++#endif /* _PISP_FE_CONFIG_ */
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_statistics.h
+@@ -0,0 +1,62 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * RP1 PiSP Front End statistics definitions
++ *
++ * Copyright (C) 2021 - Raspberry Pi Ltd.
++ *
++ */
++#ifndef _PISP_FE_STATISTICS_H_
++#define _PISP_FE_STATISTICS_H_
++
++#define PISP_FLOATING_STATS_NUM_ZONES 4
++#define PISP_AGC_STATS_NUM_BINS 1024
++#define PISP_AGC_STATS_SIZE 16
++#define PISP_AGC_STATS_NUM_ZONES (PISP_AGC_STATS_SIZE * PISP_AGC_STATS_SIZE)
++#define PISP_AGC_STATS_NUM_ROW_SUMS 512
++
++struct pisp_agc_statistics_zone {
++	u64 Y_sum;
++	u32 counted;
++	u32 pad;
++};
++
++struct pisp_agc_statistics {
++	u32 row_sums[PISP_AGC_STATS_NUM_ROW_SUMS];
++	/*
++	 * 32-bits per bin means an image (just less than) 16384x16384 pixels
++	 * in size can weight every pixel from 0 to 15.
++	 */
++	u32 histogram[PISP_AGC_STATS_NUM_BINS];
++	struct pisp_agc_statistics_zone floating[PISP_FLOATING_STATS_NUM_ZONES];
++};
++
++#define PISP_AWB_STATS_SIZE 32
++#define PISP_AWB_STATS_NUM_ZONES (PISP_AWB_STATS_SIZE * PISP_AWB_STATS_SIZE)
++
++struct pisp_awb_statistics_zone {
++	u32 R_sum;
++	u32 G_sum;
++	u32 B_sum;
++	u32 counted;
++};
++
++struct pisp_awb_statistics {
++	struct pisp_awb_statistics_zone zones[PISP_AWB_STATS_NUM_ZONES];
++	struct pisp_awb_statistics_zone floating[PISP_FLOATING_STATS_NUM_ZONES];
++};
++
++#define PISP_CDAF_STATS_SIZE 8
++#define PISP_CDAF_STATS_NUM_FOMS (PISP_CDAF_STATS_SIZE * PISP_CDAF_STATS_SIZE)
++
++struct pisp_cdaf_statistics {
++	u64 foms[PISP_CDAF_STATS_NUM_FOMS];
++	u64 floating[PISP_FLOATING_STATS_NUM_ZONES];
++};
++
++struct pisp_statistics {
++	struct pisp_awb_statistics awb;
++	struct pisp_agc_statistics agc;
++	struct pisp_cdaf_statistics cdaf;
++};
++
++#endif /* _PISP_FE_STATISTICS_H_ */
+--- /dev/null
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_types.h
+@@ -0,0 +1,144 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * RP1 PiSP Front End image definitions.
++ *
++ * Copyright (C) 2021 - Raspberry Pi Ltd.
++ *
++ */
++#ifndef _PISP_FE_TYPES_H_
++#define _PISP_FE_TYPES_H_
++
++/* This definition must match the format description in the hardware exactly! */
++struct pisp_image_format_config {
++	/* size in pixels */
++	u16 width, height;
++	/* must match struct pisp_image_format below */
++	u32 format;
++	s32 stride;
++	/* some planar image formats will need a second stride */
++	s32 stride2;
++};
++
++static_assert(sizeof(struct pisp_image_format_config) == 16);
++
++enum pisp_bayer_order {
++	/*
++	 * Note how bayer_order&1 tells you if G is on the even pixels of the
++	 * checkerboard or not, and bayer_order&2 tells you if R is on the even
++	 * rows or is swapped with B. Note that if the top (of the 8) bits is
++	 * set, this denotes a monochrome or greyscale image, and the lower bits
++	 * should all be ignored.
++	 */
++	PISP_BAYER_ORDER_RGGB = 0,
++	PISP_BAYER_ORDER_GBRG = 1,
++	PISP_BAYER_ORDER_BGGR = 2,
++	PISP_BAYER_ORDER_GRBG = 3,
++	PISP_BAYER_ORDER_GREYSCALE = 128
++};
++
++enum pisp_image_format {
++	/*
++	 * Precise values are mostly tbd. Generally these will be portmanteau
++	 * values comprising bit fields and flags. This format must be shared
++	 * throughout the PiSP.
++	 */
++	PISP_IMAGE_FORMAT_BPS_8 = 0x00000000,
++	PISP_IMAGE_FORMAT_BPS_10 = 0x00000001,
++	PISP_IMAGE_FORMAT_BPS_12 = 0x00000002,
++	PISP_IMAGE_FORMAT_BPS_16 = 0x00000003,
++	PISP_IMAGE_FORMAT_BPS_MASK = 0x00000003,
++
++	PISP_IMAGE_FORMAT_PLANARITY_INTERLEAVED = 0x00000000,
++	PISP_IMAGE_FORMAT_PLANARITY_SEMI_PLANAR = 0x00000010,
++	PISP_IMAGE_FORMAT_PLANARITY_PLANAR = 0x00000020,
++	PISP_IMAGE_FORMAT_PLANARITY_MASK = 0x00000030,
++
++	PISP_IMAGE_FORMAT_SAMPLING_444 = 0x00000000,
++	PISP_IMAGE_FORMAT_SAMPLING_422 = 0x00000100,
++	PISP_IMAGE_FORMAT_SAMPLING_420 = 0x00000200,
++	PISP_IMAGE_FORMAT_SAMPLING_MASK = 0x00000300,
++
++	PISP_IMAGE_FORMAT_ORDER_NORMAL = 0x00000000,
++	PISP_IMAGE_FORMAT_ORDER_SWAPPED = 0x00001000,
++
++	PISP_IMAGE_FORMAT_SHIFT_0 = 0x00000000,
++	PISP_IMAGE_FORMAT_SHIFT_1 = 0x00010000,
++	PISP_IMAGE_FORMAT_SHIFT_2 = 0x00020000,
++	PISP_IMAGE_FORMAT_SHIFT_3 = 0x00030000,
++	PISP_IMAGE_FORMAT_SHIFT_4 = 0x00040000,
++	PISP_IMAGE_FORMAT_SHIFT_5 = 0x00050000,
++	PISP_IMAGE_FORMAT_SHIFT_6 = 0x00060000,
++	PISP_IMAGE_FORMAT_SHIFT_7 = 0x00070000,
++	PISP_IMAGE_FORMAT_SHIFT_8 = 0x00080000,
++	PISP_IMAGE_FORMAT_SHIFT_MASK = 0x000f0000,
++
++	PISP_IMAGE_FORMAT_UNCOMPRESSED = 0x00000000,
++	PISP_IMAGE_FORMAT_COMPRESSION_MODE_1 = 0x01000000,
++	PISP_IMAGE_FORMAT_COMPRESSION_MODE_2 = 0x02000000,
++	PISP_IMAGE_FORMAT_COMPRESSION_MODE_3 = 0x03000000,
++	PISP_IMAGE_FORMAT_COMPRESSION_MASK = 0x03000000,
++
++	PISP_IMAGE_FORMAT_HOG_SIGNED = 0x04000000,
++	PISP_IMAGE_FORMAT_HOG_UNSIGNED = 0x08000000,
++	PISP_IMAGE_FORMAT_INTEGRAL_IMAGE = 0x10000000,
++	PISP_IMAGE_FORMAT_WALLPAPER_ROLL = 0x20000000,
++	PISP_IMAGE_FORMAT_THREE_CHANNEL = 0x40000000,
++
++	/* Lastly a few specific instantiations of the above. */
++	PISP_IMAGE_FORMAT_SINGLE_16 = PISP_IMAGE_FORMAT_BPS_16,
++	PISP_IMAGE_FORMAT_THREE_16 =
++		PISP_IMAGE_FORMAT_BPS_16 | PISP_IMAGE_FORMAT_THREE_CHANNEL
++};
++
++#define PISP_IMAGE_FORMAT_bps_8(fmt)                                           \
++	(((fmt) & PISP_IMAGE_FORMAT_BPS_MASK) == PISP_IMAGE_FORMAT_BPS_8)
++#define PISP_IMAGE_FORMAT_bps_10(fmt)                                          \
++	(((fmt) & PISP_IMAGE_FORMAT_BPS_MASK) == PISP_IMAGE_FORMAT_BPS_10)
++#define PISP_IMAGE_FORMAT_bps_12(fmt)                                          \
++	(((fmt) & PISP_IMAGE_FORMAT_BPS_MASK) == PISP_IMAGE_FORMAT_BPS_12)
++#define PISP_IMAGE_FORMAT_bps_16(fmt)                                          \
++	(((fmt) & PISP_IMAGE_FORMAT_BPS_MASK) == PISP_IMAGE_FORMAT_BPS_16)
++#define PISP_IMAGE_FORMAT_bps(fmt)                                             \
++	(((fmt) & PISP_IMAGE_FORMAT_BPS_MASK) ?                                \
++		       8 + (2 << (((fmt) & PISP_IMAGE_FORMAT_BPS_MASK) - 1)) : \
++		       8)
++#define PISP_IMAGE_FORMAT_shift(fmt)                                           \
++	(((fmt) & PISP_IMAGE_FORMAT_SHIFT_MASK) / PISP_IMAGE_FORMAT_SHIFT_1)
++#define PISP_IMAGE_FORMAT_three_channel(fmt)                                   \
++	((fmt) & PISP_IMAGE_FORMAT_THREE_CHANNEL)
++#define PISP_IMAGE_FORMAT_single_channel(fmt)                                  \
++	(!((fmt) & PISP_IMAGE_FORMAT_THREE_CHANNEL))
++#define PISP_IMAGE_FORMAT_compressed(fmt)                                      \
++	(((fmt) & PISP_IMAGE_FORMAT_COMPRESSION_MASK) !=                       \
++	 PISP_IMAGE_FORMAT_UNCOMPRESSED)
++#define PISP_IMAGE_FORMAT_sampling_444(fmt)                                    \
++	(((fmt) & PISP_IMAGE_FORMAT_SAMPLING_MASK) ==                          \
++	 PISP_IMAGE_FORMAT_SAMPLING_444)
++#define PISP_IMAGE_FORMAT_sampling_422(fmt)                                    \
++	(((fmt) & PISP_IMAGE_FORMAT_SAMPLING_MASK) ==                          \
++	 PISP_IMAGE_FORMAT_SAMPLING_422)
++#define PISP_IMAGE_FORMAT_sampling_420(fmt)                                    \
++	(((fmt) & PISP_IMAGE_FORMAT_SAMPLING_MASK) ==                          \
++	 PISP_IMAGE_FORMAT_SAMPLING_420)
++#define PISP_IMAGE_FORMAT_order_normal(fmt)                                    \
++	(!((fmt) & PISP_IMAGE_FORMAT_ORDER_SWAPPED))
++#define PISP_IMAGE_FORMAT_order_swapped(fmt)                                   \
++	((fmt) & PISP_IMAGE_FORMAT_ORDER_SWAPPED)
++#define PISP_IMAGE_FORMAT_interleaved(fmt)                                     \
++	(((fmt) & PISP_IMAGE_FORMAT_PLANARITY_MASK) ==                         \
++	 PISP_IMAGE_FORMAT_PLANARITY_INTERLEAVED)
++#define PISP_IMAGE_FORMAT_semiplanar(fmt)                                      \
++	(((fmt) & PISP_IMAGE_FORMAT_PLANARITY_MASK) ==                         \
++	 PISP_IMAGE_FORMAT_PLANARITY_SEMI_PLANAR)
++#define PISP_IMAGE_FORMAT_planar(fmt)                                          \
++	(((fmt) & PISP_IMAGE_FORMAT_PLANARITY_MASK) ==                         \
++	 PISP_IMAGE_FORMAT_PLANARITY_PLANAR)
++#define PISP_IMAGE_FORMAT_wallpaper(fmt)                                       \
++	((fmt) & PISP_IMAGE_FORMAT_WALLPAPER_ROLL)
++#define PISP_IMAGE_FORMAT_HOG(fmt)                                             \
++	((fmt) &                                                               \
++	 (PISP_IMAGE_FORMAT_HOG_SIGNED | PISP_IMAGE_FORMAT_HOG_UNSIGNED))
++
++#define PISP_WALLPAPER_WIDTH 128 // in bytes
++
++#endif /* _PISP_FE_TYPES_H_ */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0890-dt-bindings-net-cdns-macb-AXI-tuning-properties.patch b/target/linux/bcm27xx/patches-6.1/950-0890-dt-bindings-net-cdns-macb-AXI-tuning-properties.patch
new file mode 100644
index 0000000000..7d81e03429
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0890-dt-bindings-net-cdns-macb-AXI-tuning-properties.patch
@@ -0,0 +1,38 @@
+From 2be65d1fd1f7d3cf6f59b58b53e285400f04a160 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 15 Feb 2023 09:46:35 +0000
+Subject: [PATCH] dt-bindings: net: cdns,macb: AXI tuning properties
+
+Add optional properties to tune the AXI interface -
+cdns,aw2w-max-pipe, cdns,ar2r-max-pipe and cdns,use-aw2b-fill.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ .../devicetree/bindings/net/cdns,macb.yaml       | 16 ++++++++++++++++
+ 1 file changed, 16 insertions(+)
+
+--- a/Documentation/devicetree/bindings/net/cdns,macb.yaml
++++ b/Documentation/devicetree/bindings/net/cdns,macb.yaml
+@@ -121,6 +121,22 @@ properties:
+       Node containing PHY children. If this node is not present, then PHYs will
+       be direct children.
+ 
++  cdns,aw2w-max-pipe:
++    $ref: /schemas/types.yaml#/definitions/uint32
++    description:
++      Maximum number of outstanding AXI write requests
++
++  cdns,ar2r-max-pipe:
++    $ref: /schemas/types.yaml#/definitions/uint32
++    description:
++      Maximum number of outstanding AXI read requests
++
++  cdns,use-aw2b-fill:
++    type: boolean
++    description:
++      If set, the maximum number of outstanding write transactions operates
++      between the AW to B AXI channel, instead of the AW to W AXI channel.
++
+ patternProperties:
+   "^ethernet-phy@[0-9a-f]$":
+     type: object
diff --git a/target/linux/bcm27xx/patches-6.1/950-0891-ASoC-dwc-list-all-supported-sample-sizes.patch b/target/linux/bcm27xx/patches-6.1/950-0891-ASoC-dwc-list-all-supported-sample-sizes.patch
new file mode 100644
index 0000000000..06d69c7c4c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0891-ASoC-dwc-list-all-supported-sample-sizes.patch
@@ -0,0 +1,29 @@
+From 9ef0615a5c5f93cb72af8df3a2dae6d23b106eb5 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 21 Feb 2023 21:26:16 +0000
+Subject: [PATCH] ASoC: dwc: list all supported sample sizes
+
+The hardware configuration determines the maximum-supported sample size
+for each channel, but TCRx allows smaller sizes to be specified at run
+time. Include the smaller supported sizes in the formats array.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -448,9 +448,9 @@ static const u32 bus_widths[COMP_MAX_DAT
+ static const u32 formats[COMP_MAX_WORDSIZE] = {
+ 	SNDRV_PCM_FMTBIT_S16_LE,
+ 	SNDRV_PCM_FMTBIT_S16_LE,
+-	SNDRV_PCM_FMTBIT_S24_LE,
+-	SNDRV_PCM_FMTBIT_S24_LE,
+-	SNDRV_PCM_FMTBIT_S32_LE,
++	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
++	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
++	SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
+ 	0,
+ 	0,
+ 	0
diff --git a/target/linux/bcm27xx/patches-6.1/950-0892-ASoC-dwc-Support-set_bclk_ratio.patch b/target/linux/bcm27xx/patches-6.1/950-0892-ASoC-dwc-Support-set_bclk_ratio.patch
new file mode 100644
index 0000000000..b18e5f888f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0892-ASoC-dwc-Support-set_bclk_ratio.patch
@@ -0,0 +1,59 @@
+From 06f794e8cb227249e03893e4b4923ff58556eb60 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 4 Mar 2021 14:49:23 +0000
+Subject: [PATCH] ASoC: dwc: Support set_bclk_ratio
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 35 +++++++++++++++++++++++++++++++++++
+ 1 file changed, 35 insertions(+)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -351,11 +351,46 @@ static int dw_i2s_set_fmt(struct snd_soc
+ 	return ret;
+ }
+ 
++static int dw_i2s_set_bclk_ratio(struct snd_soc_dai *cpu_dai,
++				 unsigned int ratio)
++{
++	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
++	struct i2s_clk_config_data *config = &dev->config;
++
++	dev_err(dev->dev, "%s(%d)\n", __func__, ratio);
++	switch (ratio) {
++	case 32:
++		config->data_width = 16;
++		dev->ccr = 0x00;
++		dev->xfer_resolution = 0x02;
++		break;
++
++	case 48:
++		config->data_width = 24;
++		dev->ccr = 0x08;
++		dev->xfer_resolution = 0x04;
++		break;
++
++	case 64:
++		config->data_width = 32;
++		dev->ccr = 0x10;
++		dev->xfer_resolution = 0x05;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	i2s_write_reg(dev->i2s_base, CCR, dev->ccr);
++
++	return 0;
++}
++
+ static const struct snd_soc_dai_ops dw_i2s_dai_ops = {
+ 	.hw_params	= dw_i2s_hw_params,
+ 	.prepare	= dw_i2s_prepare,
+ 	.trigger	= dw_i2s_trigger,
+ 	.set_fmt	= dw_i2s_set_fmt,
++	.set_bclk_ratio	= dw_i2s_set_bclk_ratio,
+ };
+ 
+ #ifdef CONFIG_PM
diff --git a/target/linux/bcm27xx/patches-6.1/950-0893-ASoC-dwc-Add-DMACR-handling.patch b/target/linux/bcm27xx/patches-6.1/950-0893-ASoC-dwc-Add-DMACR-handling.patch
new file mode 100644
index 0000000000..474903c327
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0893-ASoC-dwc-Add-DMACR-handling.patch
@@ -0,0 +1,81 @@
+From b3b1177092d4d2ba6df74042d39aa42c5055f687 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 3 Jul 2023 09:08:16 +0100
+Subject: [PATCH] ASoC: dwc: Add DMACR handling
+
+Add control of the DMACR register, which is required for paced DMA
+(i.e. DREQ) support.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 13 ++++++++++---
+ sound/soc/dwc/local.h   | 13 +++++++++++++
+ 2 files changed, 23 insertions(+), 3 deletions(-)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -185,9 +185,9 @@ static void i2s_stop(struct dw_i2s_dev *
+ 
+ static void dw_i2s_config(struct dw_i2s_dev *dev, int stream)
+ {
+-	u32 ch_reg;
+ 	struct i2s_clk_config_data *config = &dev->config;
+-
++	u32 ch_reg;
++	u32 dmacr = 0;
+ 
+ 	i2s_disable_channels(dev, stream);
+ 
+@@ -198,15 +198,22 @@ static void dw_i2s_config(struct dw_i2s_
+ 			i2s_write_reg(dev->i2s_base, TFCR(ch_reg),
+ 				      dev->fifo_th - 1);
+ 			i2s_write_reg(dev->i2s_base, TER(ch_reg), 1);
++			dmacr |= (DMACR_DMAEN_TXCH0 << ch_reg);
+ 		} else {
+ 			i2s_write_reg(dev->i2s_base, RCR(ch_reg),
+ 				      dev->xfer_resolution);
+ 			i2s_write_reg(dev->i2s_base, RFCR(ch_reg),
+ 				      dev->fifo_th - 1);
+ 			i2s_write_reg(dev->i2s_base, RER(ch_reg), 1);
++			dmacr |= (DMACR_DMAEN_RXCH0 << ch_reg);
+ 		}
+-
+ 	}
++	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
++		dmacr |= DMACR_DMAEN_TX;
++	else if (stream == SNDRV_PCM_STREAM_CAPTURE)
++		dmacr |= DMACR_DMAEN_RX;
++
++	i2s_write_reg(dev->i2s_base, DMACR, dmacr);
+ }
+ 
+ static int dw_i2s_hw_params(struct snd_pcm_substream *substream,
+--- a/sound/soc/dwc/local.h
++++ b/sound/soc/dwc/local.h
+@@ -25,6 +25,8 @@
+ #define RXFFR		0x014
+ #define TXFFR		0x018
+ 
++#define DMACR   0x200
++
+ /* Interrupt status register fields */
+ #define ISR_TXFO	BIT(5)
+ #define ISR_TXFE	BIT(4)
+@@ -47,6 +49,17 @@
+ #define RFF(x)		(0x40 * x + 0x050)
+ #define TFF(x)		(0x40 * x + 0x054)
+ 
++#define DMACR_DMAEN_TX		BIT(17)
++#define DMACR_DMAEN_RX		BIT(16)
++#define DMACR_DMAEN_TXCH3	BIT(11)
++#define DMACR_DMAEN_TXCH2	BIT(10)
++#define DMACR_DMAEN_TXCH1	BIT(9)
++#define DMACR_DMAEN_TXCH0	BIT(8)
++#define DMACR_DMAEN_RXCH3	BIT(3)
++#define DMACR_DMAEN_RXCH2	BIT(2)
++#define DMACR_DMAEN_RXCH1	BIT(1)
++#define DMACR_DMAEN_RXCH0	BIT(0)
++
+ /* I2SCOMPRegisters */
+ #define I2S_COMP_PARAM_2	0x01F0
+ #define I2S_COMP_PARAM_1	0x01F4
diff --git a/target/linux/bcm27xx/patches-6.1/950-0894-ASOC-dwc-Improve-DMA-shutdown.patch b/target/linux/bcm27xx/patches-6.1/950-0894-ASOC-dwc-Improve-DMA-shutdown.patch
new file mode 100644
index 0000000000..73704a8be3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0894-ASOC-dwc-Improve-DMA-shutdown.patch
@@ -0,0 +1,128 @@
+From e6baee4502c0228c79408b047096a1259a84353f Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 3 Jul 2023 10:14:43 +0100
+Subject: [PATCH] ASOC: dwc: Improve DMA shutdown
+
+Disabling the I2S interface with outstanding transfers prevents the
+DMAC from shutting down, so keep it partially active after a stop.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 72 ++++++++++++++++++++++++++++++++++++-----
+ 1 file changed, 64 insertions(+), 8 deletions(-)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -165,24 +165,26 @@ static void i2s_start(struct dw_i2s_dev
+ 	i2s_write_reg(dev->i2s_base, CER, 1);
+ }
+ 
+-static void i2s_stop(struct dw_i2s_dev *dev,
+-		struct snd_pcm_substream *substream)
++static void i2s_pause(struct dw_i2s_dev *dev, struct snd_pcm_substream *substream)
+ {
+ 
+ 	i2s_clear_irqs(dev, substream->stream);
+-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+-		i2s_write_reg(dev->i2s_base, ITER, 0);
+-	else
+-		i2s_write_reg(dev->i2s_base, IRER, 0);
+ 
+ 	i2s_disable_irqs(dev, substream->stream, 8);
+ 
+ 	if (!dev->active) {
+ 		i2s_write_reg(dev->i2s_base, CER, 0);
+-		i2s_write_reg(dev->i2s_base, IER, 0);
++		/* Keep the device enabled until the shutdown - do not clear IER */
+ 	}
+ }
+ 
++static void i2s_stop(struct dw_i2s_dev *dev, struct snd_pcm_substream *substream)
++{
++	i2s_clear_irqs(dev, substream->stream);
++
++	i2s_disable_irqs(dev, substream->stream, 8);
++}
++
+ static void dw_i2s_config(struct dw_i2s_dev *dev, int stream)
+ {
+ 	struct i2s_clk_config_data *config = &dev->config;
+@@ -288,6 +290,55 @@ static int dw_i2s_hw_params(struct snd_p
+ 	return 0;
+ }
+ 
++static int dw_i2s_startup(struct snd_pcm_substream *substream,
++			  struct snd_soc_dai *cpu_dai)
++{
++	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
++	union dw_i2s_snd_dma_data *dma_data = NULL;
++	u32 dmacr;
++
++	dev_dbg(dev->dev, "%s(%s)\n", __func__, substream->name);
++	if (!(dev->capability & DWC_I2S_RECORD) &&
++	    substream->stream == SNDRV_PCM_STREAM_CAPTURE)
++		return -EINVAL;
++
++	if (!(dev->capability & DWC_I2S_PLAY) &&
++	    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		return -EINVAL;
++
++	dw_i2s_config(dev, substream->stream);
++	dmacr = i2s_read_reg(dev->i2s_base, DMACR);
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		dma_data = &dev->play_dma_data;
++	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
++		dma_data = &dev->capture_dma_data;
++
++	snd_soc_dai_set_dma_data(cpu_dai, substream, (void *)dma_data);
++	i2s_write_reg(dev->i2s_base, DMACR, dmacr);
++
++	return 0;
++}
++
++static void dw_i2s_shutdown(struct snd_pcm_substream *substream,
++			    struct snd_soc_dai *dai)
++{
++	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
++
++	dev_dbg(dev->dev, "%s(%s)\n", __func__, substream->name);
++	i2s_disable_channels(dev, substream->stream);
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		i2s_write_reg(dev->i2s_base, ITER, 0);
++	else
++		i2s_write_reg(dev->i2s_base, IRER, 0);
++
++	i2s_disable_irqs(dev, substream->stream, 8);
++
++	if (!dev->active) {
++		i2s_write_reg(dev->i2s_base, CER, 0);
++		i2s_write_reg(dev->i2s_base, IER, 0);
++	}
++}
++
+ static int dw_i2s_prepare(struct snd_pcm_substream *substream,
+ 			  struct snd_soc_dai *dai)
+ {
+@@ -315,9 +366,12 @@ static int dw_i2s_trigger(struct snd_pcm
+ 		i2s_start(dev, substream);
+ 		break;
+ 
++	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
++		dev->active--;
++		i2s_pause(dev, substream);
++		break;
+ 	case SNDRV_PCM_TRIGGER_STOP:
+ 	case SNDRV_PCM_TRIGGER_SUSPEND:
+-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+ 		dev->active--;
+ 		i2s_stop(dev, substream);
+ 		break;
+@@ -394,6 +448,8 @@ static int dw_i2s_set_bclk_ratio(struct
+ 
+ static const struct snd_soc_dai_ops dw_i2s_dai_ops = {
+ 	.hw_params	= dw_i2s_hw_params,
++	.startup	= dw_i2s_startup,
++	.shutdown	= dw_i2s_shutdown,
+ 	.prepare	= dw_i2s_prepare,
+ 	.trigger	= dw_i2s_trigger,
+ 	.set_fmt	= dw_i2s_set_fmt,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0895-ASOC-dwc-Fix-16-bit-audio-handling.patch b/target/linux/bcm27xx/patches-6.1/950-0895-ASOC-dwc-Fix-16-bit-audio-handling.patch
new file mode 100644
index 0000000000..fa5eb61044
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0895-ASOC-dwc-Fix-16-bit-audio-handling.patch
@@ -0,0 +1,88 @@
+From 9c6694c24f26ea435165431d41c72451fadbd753 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 21 Jul 2023 12:07:16 +0100
+Subject: [PATCH] ASOC: dwc: Fix 16-bit audio handling
+
+IMO the Synopsys datasheet could be clearer in this area, but it seems
+that the DMA data ports (DMATX and DMARX) expect left and right samples
+in alternate writes; if a stereo pair is pushed in a single 32-bit
+write, the upper half is ignored, leading to double speed audio with a
+confused stereo image. Make sure the necessary changes happen by
+updating the DMA configuration data in the hw_params method.
+
+The set_bclk_ratio change was made at a time when it looked like it
+could be causing an error, but I think the division of responsibilities
+is clearer this way (and the kernel log clearer without the info-level
+message).
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 22 +++++++++++++++-------
+ 1 file changed, 15 insertions(+), 7 deletions(-)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -223,23 +223,34 @@ static int dw_i2s_hw_params(struct snd_p
+ {
+ 	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+ 	struct i2s_clk_config_data *config = &dev->config;
++	union dw_i2s_snd_dma_data *dma_data = NULL;
+ 	int ret;
+ 
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		dma_data = &dev->play_dma_data;
++	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
++		dma_data = &dev->capture_dma_data;
++	else
++		return -1;
++
+ 	switch (params_format(params)) {
+ 	case SNDRV_PCM_FORMAT_S16_LE:
+ 		config->data_width = 16;
++		dma_data->dt.addr_width = 2;
+ 		dev->ccr = 0x00;
+ 		dev->xfer_resolution = 0x02;
+ 		break;
+ 
+ 	case SNDRV_PCM_FORMAT_S24_LE:
+ 		config->data_width = 24;
++		dma_data->dt.addr_width = 4;
+ 		dev->ccr = 0x08;
+ 		dev->xfer_resolution = 0x04;
+ 		break;
+ 
+ 	case SNDRV_PCM_FORMAT_S32_LE:
+ 		config->data_width = 32;
++		dma_data->dt.addr_width = 4;
+ 		dev->ccr = 0x10;
+ 		dev->xfer_resolution = 0x05;
+ 		break;
+@@ -418,24 +429,21 @@ static int dw_i2s_set_bclk_ratio(struct
+ 	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+ 	struct i2s_clk_config_data *config = &dev->config;
+ 
+-	dev_err(dev->dev, "%s(%d)\n", __func__, ratio);
++	dev_dbg(dev->dev, "%s(%d)\n", __func__, ratio);
++	if (ratio < config->data_width * 2)
++		return -EINVAL;
++
+ 	switch (ratio) {
+ 	case 32:
+-		config->data_width = 16;
+ 		dev->ccr = 0x00;
+-		dev->xfer_resolution = 0x02;
+ 		break;
+ 
+ 	case 48:
+-		config->data_width = 24;
+ 		dev->ccr = 0x08;
+-		dev->xfer_resolution = 0x04;
+ 		break;
+ 
+ 	case 64:
+-		config->data_width = 32;
+ 		dev->ccr = 0x10;
+-		dev->xfer_resolution = 0x05;
+ 		break;
+ 	default:
+ 		return -EINVAL;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0896-ASoC-bcm-Remove-dependency-on-BCM2835-I2S.patch b/target/linux/bcm27xx/patches-6.1/950-0896-ASoC-bcm-Remove-dependency-on-BCM2835-I2S.patch
new file mode 100644
index 0000000000..9f4f7a0c9a
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0896-ASoC-bcm-Remove-dependency-on-BCM2835-I2S.patch
@@ -0,0 +1,304 @@
+From f476db1b71e8b82e5299168f963a2fefb7a395e2 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 1 Sep 2023 14:07:48 +0100
+Subject: [PATCH] ASoC: bcm: Remove dependency on BCM2835 I2S
+
+These soundcard drivers don't rely on a specific I2S interface, so
+remove the dependency declarations.
+
+See: https://github.com/raspberrypi/linux-2712/issues/111
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/bcm/Kconfig | 40 +---------------------------------------
+ 1 file changed, 1 insertion(+), 39 deletions(-)
+
+--- a/sound/soc/bcm/Kconfig
++++ b/sound/soc/bcm/Kconfig
+@@ -29,13 +29,11 @@ config SND_BCM63XX_I2S_WHISTLER
+ 
+ config SND_BCM2708_SOC_CHIPDIP_DAC
+          tristate "Support for the ChipDip DAC"
+-         depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+          help
+           Say Y or M if you want to add support for the ChipDip DAC soundcard
+ 
+ config SND_BCM2708_SOC_GOOGLEVOICEHAT_SOUNDCARD
+ 	tristate "Support for Google voiceHAT soundcard"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_VOICEHAT
+ 	select SND_RPI_SIMPLE_SOUNDCARD
+ 	help
+@@ -43,7 +41,6 @@ config SND_BCM2708_SOC_GOOGLEVOICEHAT_SO
+ 
+ config SND_BCM2708_SOC_HIFIBERRY_DAC
+         tristate "Support for HifiBerry DAC"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_PCM5102A
+         select SND_RPI_SIMPLE_SOUNDCARD
+         help
+@@ -51,7 +48,6 @@ config SND_BCM2708_SOC_HIFIBERRY_DAC
+ 
+ config SND_BCM2708_SOC_HIFIBERRY_DACPLUS
+         tristate "Support for HifiBerry DAC+"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_PCM512x
+         select SND_SOC_TPA6130A2
+         select COMMON_CLK_HIFIBERRY_DACPRO
+@@ -60,7 +56,6 @@ config SND_BCM2708_SOC_HIFIBERRY_DACPLUS
+ 
+ config SND_BCM2708_SOC_HIFIBERRY_DACPLUSHD
+         tristate "Support for HifiBerry DAC+ HD"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_PCM179X_I2C
+         select COMMON_CLK_HIFIBERRY_DACPLUSHD
+         help
+@@ -68,7 +63,6 @@ config SND_BCM2708_SOC_HIFIBERRY_DACPLUS
+ 
+ config SND_BCM2708_SOC_HIFIBERRY_DACPLUSADC
+         tristate "Support for HifiBerry DAC+ADC"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_PCM512x_I2C
+ 	select SND_SOC_DMIC
+         select COMMON_CLK_HIFIBERRY_DACPRO
+@@ -77,7 +71,6 @@ config SND_BCM2708_SOC_HIFIBERRY_DACPLUS
+ 
+ config SND_BCM2708_SOC_HIFIBERRY_DACPLUSADCPRO
+         tristate "Support for HifiBerry DAC+ADC PRO"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_PCM512x_I2C
+         select SND_SOC_PCM186X_I2C
+         select SND_SOC_TPA6130A2
+@@ -87,29 +80,25 @@ config SND_BCM2708_SOC_HIFIBERRY_DACPLUS
+ 
+ config SND_BCM2708_SOC_HIFIBERRY_DACPLUSDSP
+         tristate "Support for HifiBerry DAC+DSP"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_RPI_SIMPLE_SOUNDCARD
+         help
+          Say Y or M if you want to add support for HifiBerry DSP-DAC.
+ 
+ config SND_BCM2708_SOC_HIFIBERRY_DIGI
+         tristate "Support for HifiBerry Digi"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_WM8804
+         help
+          Say Y or M if you want to add support for HifiBerry Digi S/PDIF output board.
+ 
+ config SND_BCM2708_SOC_HIFIBERRY_AMP
+         tristate "Support for the HifiBerry Amp"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_TAS5713
+         select SND_RPI_SIMPLE_SOUNDCARD
+         help
+          Say Y or M if you want to add support for the HifiBerry Amp amplifier board.
+ 
+- config SND_BCM2708_SOC_PIFI_40
++config SND_BCM2708_SOC_PIFI_40
+          tristate "Support for the PiFi-40 amp"
+-         depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+          select SND_SOC_TAS571X
+          select SND_PIFI_40
+          help
+@@ -117,7 +106,6 @@ config SND_BCM2708_SOC_HIFIBERRY_AMP
+ 
+ config SND_BCM2708_SOC_RPI_CIRRUS
+         tristate "Support for Cirrus Logic Audio Card"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_WM5102
+         select SND_SOC_WM8804
+         help
+@@ -126,7 +114,6 @@ config SND_BCM2708_SOC_RPI_CIRRUS
+ 
+ config SND_BCM2708_SOC_RPI_DAC
+         tristate "Support for RPi-DAC"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_PCM1794A
+         select SND_RPI_SIMPLE_SOUNDCARD
+         help
+@@ -134,14 +121,12 @@ config SND_BCM2708_SOC_RPI_DAC
+ 
+ config SND_BCM2708_SOC_RPI_PROTO
+ 	tristate "Support for Rpi-PROTO"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_WM8731_I2C
+ 	help
+ 	  Say Y or M if you want to add support for Audio Codec Board PROTO (WM8731).
+ 
+ config SND_BCM2708_SOC_JUSTBOOM_BOTH
+ 	tristate "Support for simultaneous JustBoom Digi and JustBoom DAC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_WM8804
+ 	select SND_SOC_PCM512x
+ 	help
+@@ -153,14 +138,12 @@ config SND_BCM2708_SOC_JUSTBOOM_BOTH
+ 
+ config SND_BCM2708_SOC_JUSTBOOM_DAC
+ 	tristate "Support for JustBoom DAC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_PCM512x
+ 	help
+ 	  Say Y or M if you want to add support for JustBoom DAC.
+ 
+ config SND_BCM2708_SOC_JUSTBOOM_DIGI
+ 	tristate "Support for JustBoom Digi"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_WM8804
+         select SND_RPI_WM8804_SOUNDCARD
+ 	help
+@@ -168,21 +151,18 @@ config SND_BCM2708_SOC_JUSTBOOM_DIGI
+ 
+ config SND_BCM2708_SOC_IQAUDIO_CODEC
+ 	tristate "Support for IQaudIO-CODEC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_DA7213
+ 	help
+ 	  Say Y or M if you want to add support for IQaudIO-CODEC.
+ 
+ config SND_BCM2708_SOC_IQAUDIO_DAC
+ 	tristate "Support for IQaudIO-DAC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_PCM512x_I2C
+ 	help
+ 	  Say Y or M if you want to add support for IQaudIO-DAC.
+ 
+ config SND_BCM2708_SOC_IQAUDIO_DIGI
+ 	tristate "Support for IQAudIO Digi"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_WM8804
+ 	select SND_RPI_WM8804_SOUNDCARD
+ 	help
+@@ -190,14 +170,12 @@ config SND_BCM2708_SOC_IQAUDIO_DIGI
+ 
+ config SND_BCM2708_SOC_I_SABRE_Q2M
+         tristate "Support for Audiophonics I-Sabre Q2M DAC"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_I_SABRE_CODEC
+         help
+         Say Y or M if you want to add support for Audiophonics I-SABRE Q2M DAC
+ 
+ config SND_BCM2708_SOC_ADAU1977_ADC
+ 	tristate "Support for ADAU1977 ADC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_ADAU1977_I2C
+ 	select SND_RPI_SIMPLE_SOUNDCARD
+ 	help
+@@ -205,35 +183,30 @@ config SND_BCM2708_SOC_ADAU1977_ADC
+ 
+ config SND_AUDIOINJECTOR_PI_SOUNDCARD
+ 	tristate "Support for audioinjector.net Pi add on soundcard"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_WM8731_I2C
+ 	help
+ 	  Say Y or M if you want to add support for audioinjector.net Pi Hat
+ 
+ config SND_AUDIOINJECTOR_OCTO_SOUNDCARD
+ 	tristate "Support for audioinjector.net Octo channel (Hat) soundcard"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_CS42XX8_I2C
+ 	help
+ 	  Say Y or M if you want to add support for audioinjector.net octo add on
+ 
+ config SND_AUDIOINJECTOR_ISOLATED_SOUNDCARD
+ 	tristate "Support for audioinjector.net isolated DAC and ADC soundcard"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_CS4271_I2C
+ 	help
+ 	  Say Y or M if you want to add support for audioinjector.net isolated soundcard
+ 
+ config SND_AUDIOSENSE_PI
+ 	tristate "Support for AudioSense Add-On Soundcard"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_TLV320AIC32X4_I2C
+ 	help
+ 	  Say Y or M if you want to add support for tlv320aic32x4 add-on
+ 
+ config SND_DIGIDAC1_SOUNDCARD
+         tristate "Support for Red Rocks Audio DigiDAC1"
+-        depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+         select SND_SOC_WM8804
+         select SND_SOC_WM8741
+         help
+@@ -241,35 +214,30 @@ config SND_DIGIDAC1_SOUNDCARD
+ 
+ config SND_BCM2708_SOC_DIONAUDIO_LOCO
+ 	tristate "Support for Dion Audio LOCO DAC-AMP"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_PCM5102a
+ 	help
+ 	  Say Y or M if you want to add support for Dion Audio LOCO.
+ 
+ config SND_BCM2708_SOC_DIONAUDIO_LOCO_V2
+ 	tristate "Support for Dion Audio LOCO-V2 DAC-AMP"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_PCM5122
+ 	help
+ 	  Say Y or M if you want to add support for Dion Audio LOCO-V2.
+ 
+ config SND_BCM2708_SOC_ALLO_PIANO_DAC
+ 	tristate "Support for Allo Piano DAC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_PCM512x_I2C
+ 	help
+ 	  Say Y or M if you want to add support for Allo Piano DAC.
+ 
+ config SND_BCM2708_SOC_ALLO_PIANO_DAC_PLUS
+ 	tristate "Support for Allo Piano DAC Plus"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_PCM512x_I2C
+ 	help
+ 	  Say Y or M if you want to add support for Allo Piano DAC Plus.
+ 
+ config SND_BCM2708_SOC_ALLO_BOSS_DAC
+ 	tristate "Support for Allo Boss DAC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_PCM512x_I2C
+ 	select COMMON_CLK_HIFIBERRY_DACPRO
+ 	help
+@@ -277,7 +245,6 @@ config SND_BCM2708_SOC_ALLO_BOSS_DAC
+ 
+ config SND_BCM2708_SOC_ALLO_BOSS2_DAC
+ 	tristate "Support for Allo Boss2 DAC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	depends on I2C
+ 	select REGMAP_I2C
+ 	select SND_AUDIO_GRAPH_CARD
+@@ -286,7 +253,6 @@ config SND_BCM2708_SOC_ALLO_BOSS2_DAC
+ 
+ config SND_BCM2708_SOC_ALLO_DIGIONE
+ 	tristate "Support for Allo DigiOne"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_WM8804
+ 	select SND_RPI_WM8804_SOUNDCARD
+ 	help
+@@ -294,7 +260,6 @@ config SND_BCM2708_SOC_ALLO_DIGIONE
+ 
+ config SND_BCM2708_SOC_ALLO_KATANA_DAC
+ 	tristate "Support for Allo Katana DAC"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	depends on I2C
+ 	select REGMAP_I2C
+ 	select SND_AUDIO_GRAPH_CARD
+@@ -303,14 +268,12 @@ config SND_BCM2708_SOC_ALLO_KATANA_DAC
+ 
+ config SND_BCM2708_SOC_FE_PI_AUDIO
+ 	tristate "Support for Fe-Pi-Audio"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_SGTL5000
+ 	help
+ 	  Say Y or M if you want to add support for Fe-Pi-Audio.
+ 
+ config SND_PISOUND
+ 	tristate "Support for Blokas Labs pisound"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_RAWMIDI
+ 	help
+ 	  Say Y or M if you want to add support for Blokas Labs pisound.
+@@ -328,7 +291,6 @@ config SND_RPI_WM8804_SOUNDCARD
+ 
+ config SND_DACBERRY400
+ 	tristate "Support for DACBERRY400 Soundcard"
+-	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
+ 	select SND_SOC_TLV320AIC3X_I2C
+ 	help
+ 	  Say Y or M if you want to add support for tlv320aic3x add-on
diff --git a/target/linux/bcm27xx/patches-6.1/950-0897-hwmon-Add-RP1-ADC-and-temperature-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0897-hwmon-Add-RP1-ADC-and-temperature-driver.patch
new file mode 100644
index 0000000000..c3cf21455b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0897-hwmon-Add-RP1-ADC-and-temperature-driver.patch
@@ -0,0 +1,343 @@
+From cad3c92ff0c1a5fa539d08b695b0f6b326924890 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 2 Mar 2023 18:04:42 +0000
+Subject: [PATCH] hwmon: Add RP1 ADC and temperature driver
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/hwmon/Kconfig   |   7 +
+ drivers/hwmon/Makefile  |   1 +
+ drivers/hwmon/rp1-adc.c | 301 ++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 309 insertions(+)
+ create mode 100644 drivers/hwmon/rp1-adc.c
+
+--- a/drivers/hwmon/Kconfig
++++ b/drivers/hwmon/Kconfig
+@@ -2331,6 +2331,13 @@ config SENSORS_INTEL_M10_BMC_HWMON
+ 	  sensors monitor various telemetry data of different components on the
+ 	  card, e.g. board temperature, FPGA core temperature/voltage/current.
+ 
++config SENSORS_RP1_ADC
++	tristate "RP1 ADC and temperature sensor driver"
++	depends on MFD_RP1
++	help
++	  Say yes here to enable support for the voltage and temperature
++	  sensors of the Raspberry Pi RP1 peripheral chip.
++
+ if ACPI
+ 
+ comment "ACPI drivers"
+--- a/drivers/hwmon/Makefile
++++ b/drivers/hwmon/Makefile
+@@ -173,6 +173,7 @@ obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591
+ obj-$(CONFIG_SENSORS_POWR1220)  += powr1220.o
+ obj-$(CONFIG_SENSORS_PWM_FAN)	+= pwm-fan.o
+ obj-$(CONFIG_SENSORS_RASPBERRYPI_HWMON)	+= raspberrypi-hwmon.o
++obj-$(CONFIG_SENSORS_RP1_ADC)	+= rp1-adc.o
+ obj-$(CONFIG_SENSORS_S3C)	+= s3c-hwmon.o
+ obj-$(CONFIG_SENSORS_SBTSI)	+= sbtsi_temp.o
+ obj-$(CONFIG_SENSORS_SBRMI)	+= sbrmi.o
+--- /dev/null
++++ b/drivers/hwmon/rp1-adc.c
+@@ -0,0 +1,301 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Driver for the RP1 ADC and temperature sensor
++ * Copyright (C) 2023 Raspberry Pi Ltd.
++ */
++
++#include <linux/clk.h>
++#include <linux/err.h>
++#include <linux/hwmon.h>
++#include <linux/hwmon-sysfs.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/mod_devicetable.h>
++#include <linux/platform_device.h>
++#include <linux/regulator/consumer.h>
++
++#define MODULE_NAME	"rp1-adc"
++
++#define RP1_ADC_CS		0x00
++#define RP1_ADC_RESULT		0x04
++#define RP1_ADC_FCS		0x08
++#define RP1_ADC_FIFO		0x0c
++#define RP1_ADC_DIV		0x10
++
++#define RP1_ADC_INTR		0x14
++#define RP1_ADC_INTE		0x18
++#define RP1_ADC_INTF		0x1c
++#define RP1_ADC_INTS		0x20
++
++#define RP1_ADC_RWTYPE_SET	0x2000
++#define RP1_ADC_RWTYPE_CLR	0x3000
++
++#define RP1_ADC_CS_RROBIN_MASK	0x1f
++#define RP1_ADC_CS_RROBIN_SHIFT	16
++#define RP1_ADC_CS_AINSEL_MASK	0x7
++#define RP1_ADC_CS_AINSEL_SHIFT	12
++#define RP1_ADC_CS_ERR_STICKY	0x400
++#define RP1_ADC_CS_ERR		0x200
++#define RP1_ADC_CS_READY	0x100
++#define RP1_ADC_CS_START_MANY	0x8
++#define RP1_ADC_CS_START_ONCE	0x4
++#define RP1_ADC_CS_TS_EN	0x2
++#define RP1_ADC_CS_EN		0x1
++
++#define RP1_ADC_FCS_THRESH_MASK	0xf
++#define RP1_ADC_FCS_THRESH_SHIFT	24
++#define RP1_ADC_FCS_LEVEL_MASK	0xf
++#define RP1_ADC_FCS_LEVEL_SHIFT	16
++#define RP1_ADC_FCS_OVER	0x800
++#define RP1_ADC_FCS_UNDER	0x400
++#define RP1_ADC_FCS_FULL	0x200
++#define RP1_ADC_FCS_EMPTY	0x100
++#define RP1_ADC_FCS_DREQ_EN	0x8
++#define RP1_ADC_FCS_ERR		0x4
++#define RP1_ADC_FCS_SHIFR	0x2
++#define RP1_ADC_FCS_EN		0x1
++
++#define RP1_ADC_FIFO_ERR	0x8000
++#define RP1_ADC_FIFO_VAL_MASK	0xfff
++
++#define RP1_ADC_DIV_INT_MASK	0xffff
++#define RP1_ADC_DIV_INT_SHIFT	8
++#define RP1_ADC_DIV_FRAC_MASK	0xff
++#define RP1_ADC_DIV_FRAC_SHIFT	0
++
++struct rp1_adc_data {
++	void __iomem *base;
++	spinlock_t lock;
++	struct device *hwmon_dev;
++	int vref_mv;
++};
++
++static int rp1_adc_ready_wait(struct rp1_adc_data *data)
++{
++	int retries = 10;
++
++	while (retries && !(readl(data->base + RP1_ADC_CS) & RP1_ADC_CS_READY))
++		retries--;
++
++	return retries ? 0 : -EIO;
++}
++
++static int rp1_adc_read(struct rp1_adc_data *data,
++			struct device_attribute *devattr, unsigned int *val)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	int channel = attr->index;
++	int ret;
++
++	spin_lock(&data->lock);
++
++	writel(RP1_ADC_CS_AINSEL_MASK << RP1_ADC_CS_AINSEL_SHIFT,
++	       data->base + RP1_ADC_RWTYPE_CLR + RP1_ADC_CS);
++	writel(channel << RP1_ADC_CS_AINSEL_SHIFT,
++	       data->base + RP1_ADC_RWTYPE_SET + RP1_ADC_CS);
++	writel(RP1_ADC_CS_START_ONCE,
++	       data->base + RP1_ADC_RWTYPE_SET + RP1_ADC_CS);
++
++	ret = rp1_adc_ready_wait(data);
++	if (!ret)
++		*val = readl(data->base + RP1_ADC_RESULT);
++
++	spin_unlock(&data->lock);
++
++	return ret;
++}
++
++static int rp1_adc_to_mv(struct rp1_adc_data *data, unsigned int val)
++{
++	return ((u64)data->vref_mv * val) / 0xfff;
++}
++
++static ssize_t rp1_adc_show(struct device *dev,
++			    struct device_attribute *devattr,
++			    char *buf)
++{
++	struct rp1_adc_data *data = dev_get_drvdata(dev);
++	unsigned int val;
++	int ret;
++
++	ret = rp1_adc_read(data, devattr, &val);
++	if (ret)
++		return ret;
++
++	return sprintf(buf, "%d\n", rp1_adc_to_mv(data, val));
++}
++
++static ssize_t rp1_adc_temp_show(struct device *dev,
++				 struct device_attribute *devattr,
++				 char *buf)
++{
++	struct rp1_adc_data *data = dev_get_drvdata(dev);
++	unsigned int val;
++	int ret, mv, mc;
++
++	writel(RP1_ADC_CS_TS_EN,
++	       data->base + RP1_ADC_RWTYPE_SET + RP1_ADC_CS);
++	ret = rp1_adc_read(data, devattr, &val);
++	if (ret)
++		return ret;
++
++	mv = rp1_adc_to_mv(data, val);
++
++	/* T = 27 - (ADC_voltage - 0.706)/0.001721 */
++
++	mc = 27000 - DIV_ROUND_CLOSEST((mv - 706) * (s64)1000000, 1721);
++
++	return sprintf(buf, "%d\n", mc);
++}
++
++static ssize_t rp1_adc_raw_show(struct device *dev,
++				struct device_attribute *devattr,
++				char *buf)
++{
++	struct rp1_adc_data *data = dev_get_drvdata(dev);
++	unsigned int val;
++	int ret = rp1_adc_read(data, devattr, &val);
++
++	if (ret)
++		return ret;
++
++	return sprintf(buf, "%u\n", val);
++}
++
++static ssize_t rp1_adc_temp_raw_show(struct device *dev,
++				     struct device_attribute *devattr,
++				     char *buf)
++{
++	struct rp1_adc_data *data = dev_get_drvdata(dev);
++	unsigned int val;
++	int ret = rp1_adc_read(data, devattr, &val);
++
++	if (ret)
++		return ret;
++
++	return sprintf(buf, "%u\n", val);
++}
++
++static SENSOR_DEVICE_ATTR_RO(in1_input, rp1_adc, 0);
++static SENSOR_DEVICE_ATTR_RO(in2_input, rp1_adc, 1);
++static SENSOR_DEVICE_ATTR_RO(in3_input, rp1_adc, 2);
++static SENSOR_DEVICE_ATTR_RO(in4_input, rp1_adc, 3);
++static SENSOR_DEVICE_ATTR_RO(temp1_input, rp1_adc_temp, 4);
++static SENSOR_DEVICE_ATTR_RO(in1_raw, rp1_adc_raw, 0);
++static SENSOR_DEVICE_ATTR_RO(in2_raw, rp1_adc_raw, 1);
++static SENSOR_DEVICE_ATTR_RO(in3_raw, rp1_adc_raw, 2);
++static SENSOR_DEVICE_ATTR_RO(in4_raw, rp1_adc_raw, 3);
++static SENSOR_DEVICE_ATTR_RO(temp1_raw, rp1_adc_temp_raw, 4);
++
++static struct attribute *rp1_adc_attrs[] = {
++	&sensor_dev_attr_in1_input.dev_attr.attr,
++	&sensor_dev_attr_in2_input.dev_attr.attr,
++	&sensor_dev_attr_in3_input.dev_attr.attr,
++	&sensor_dev_attr_in4_input.dev_attr.attr,
++	&sensor_dev_attr_temp1_input.dev_attr.attr,
++	&sensor_dev_attr_in1_raw.dev_attr.attr,
++	&sensor_dev_attr_in2_raw.dev_attr.attr,
++	&sensor_dev_attr_in3_raw.dev_attr.attr,
++	&sensor_dev_attr_in4_raw.dev_attr.attr,
++	&sensor_dev_attr_temp1_raw.dev_attr.attr,
++	NULL
++};
++
++static umode_t rp1_adc_is_visible(struct kobject *kobj,
++				  struct attribute *attr, int index)
++{
++	return 0444;
++}
++
++static const struct attribute_group rp1_adc_group = {
++	.attrs = rp1_adc_attrs,
++	.is_visible = rp1_adc_is_visible,
++};
++__ATTRIBUTE_GROUPS(rp1_adc);
++
++static int __init rp1_adc_probe(struct platform_device *pdev)
++{
++	struct rp1_adc_data *data;
++	struct regulator *reg;
++	struct clk *clk;
++	int vref_uv, ret;
++
++	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	spin_lock_init(&data->lock);
++
++	data->base = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(data->base))
++		return PTR_ERR(data->base);
++
++	platform_set_drvdata(pdev, data);
++
++	clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(clk))
++		return -ENODEV;
++
++	clk_set_rate(clk, 50000000);
++	clk_prepare_enable(clk);
++
++	reg = devm_regulator_get(&pdev->dev, "vref");
++	if (IS_ERR(reg))
++		return PTR_ERR(reg);
++
++	vref_uv = regulator_get_voltage(reg);
++	data->vref_mv = DIV_ROUND_CLOSEST(vref_uv, 1000);
++
++	data->hwmon_dev =
++	    devm_hwmon_device_register_with_groups(&pdev->dev,
++						   "rp1_adc",
++						   data,
++						   rp1_adc_groups);
++	if (IS_ERR(data->hwmon_dev)) {
++		ret = PTR_ERR(data->hwmon_dev);
++		dev_err(&pdev->dev, "hwmon_device_register failed with %d.\n", ret);
++		goto err_register;
++	}
++
++	/* Disable interrupts */
++	writel(0, data->base + RP1_ADC_INTE);
++
++	/* Enable the block, clearing any sticky error */
++	writel(RP1_ADC_CS_EN | RP1_ADC_CS_ERR_STICKY, data->base + RP1_ADC_CS);
++
++	return 0;
++
++err_register:
++	sysfs_remove_group(&pdev->dev.kobj, &rp1_adc_group);
++
++	return ret;
++}
++
++static int rp1_adc_remove(struct platform_device *pdev)
++{
++	struct rp1_adc_data *data = platform_get_drvdata(pdev);
++
++	hwmon_device_unregister(data->hwmon_dev);
++
++	return 0;
++}
++
++static const struct of_device_id rp1_adc_dt_ids[] = {
++	{ .compatible = "raspberrypi,rp1-adc", },
++	{ }
++};
++MODULE_DEVICE_TABLE(of, rp1_adc_dt_ids);
++
++static struct platform_driver rp1_adc_driver = {
++	.remove		= rp1_adc_remove,
++	.driver		= {
++		.name	= MODULE_NAME,
++		.of_match_table = rp1_adc_dt_ids,
++	},
++};
++
++module_platform_driver_probe(rp1_adc_driver, rp1_adc_probe);
++
++MODULE_DESCRIPTION("RP1 ADC driver");
++MODULE_AUTHOR("Phil Elwell <phil@raspberrypi.com>");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/bcm27xx/patches-6.1/950-0898-mfd-bcm2835-pm-Add-support-for-BCM2712.patch b/target/linux/bcm27xx/patches-6.1/950-0898-mfd-bcm2835-pm-Add-support-for-BCM2712.patch
new file mode 100644
index 0000000000..37210173db
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0898-mfd-bcm2835-pm-Add-support-for-BCM2712.patch
@@ -0,0 +1,69 @@
+From 0c7aeb96fd3ab68011ba6c24239c501190890308 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 8 Mar 2023 14:27:58 +0000
+Subject: [PATCH] mfd: bcm2835-pm: Add support for BCM2712
+
+BCM2712 lacks the "asb" and "rpivid_asb" register ranges, but still
+requires the use of the bcm2835-power driver to reset the V3D block.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/mfd/bcm2835-pm.c | 28 +++++++++++++++++++---------
+ 1 file changed, 19 insertions(+), 9 deletions(-)
+
+--- a/drivers/mfd/bcm2835-pm.c
++++ b/drivers/mfd/bcm2835-pm.c
+@@ -69,12 +69,30 @@ static int bcm2835_pm_get_pdata(struct p
+ 	return 0;
+ }
+ 
++static const struct of_device_id bcm2835_pm_of_match[] = {
++	{ .compatible = "brcm,bcm2835-pm-wdt", },
++	{ .compatible = "brcm,bcm2835-pm", },
++	{ .compatible = "brcm,bcm2711-pm", },
++	{ .compatible = "brcm,bcm2712-pm", .data = (const void *)1},
++	{},
++};
++MODULE_DEVICE_TABLE(of, bcm2835_pm_of_match);
++
+ static int bcm2835_pm_probe(struct platform_device *pdev)
+ {
++	const struct of_device_id *of_id;
+ 	struct device *dev = &pdev->dev;
+ 	struct bcm2835_pm *pm;
++	bool is_2712;
+ 	int ret;
+ 
++	of_id = of_match_node(bcm2835_pm_of_match, pdev->dev.of_node);
++	if (!of_id) {
++		dev_err(&pdev->dev, "Failed to match compatible string\n");
++		return -EINVAL;
++	}
++	is_2712 = !!of_id->data;
++
+ 	pm = devm_kzalloc(dev, sizeof(*pm), GFP_KERNEL);
+ 	if (!pm)
+ 		return -ENOMEM;
+@@ -97,21 +115,13 @@ static int bcm2835_pm_probe(struct platf
+ 	 * bcm2835-pm binding as the key for whether we can reference
+ 	 * the full PM register range and support power domains.
+ 	 */
+-	if (pm->asb)
++	if (pm->asb || is_2712)
+ 		return devm_mfd_add_devices(dev, -1, bcm2835_power_devs,
+ 					    ARRAY_SIZE(bcm2835_power_devs),
+ 					    NULL, 0, NULL);
+ 	return 0;
+ }
+ 
+-static const struct of_device_id bcm2835_pm_of_match[] = {
+-	{ .compatible = "brcm,bcm2835-pm-wdt", },
+-	{ .compatible = "brcm,bcm2835-pm", },
+-	{ .compatible = "brcm,bcm2711-pm", },
+-	{},
+-};
+-MODULE_DEVICE_TABLE(of, bcm2835_pm_of_match);
+-
+ static struct platform_driver bcm2835_pm_driver = {
+ 	.probe		= bcm2835_pm_probe,
+ 	.driver = {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0899-soc-bcm-bcm2835-power-Add-support-for-BCM2712.patch b/target/linux/bcm27xx/patches-6.1/950-0899-soc-bcm-bcm2835-power-Add-support-for-BCM2712.patch
new file mode 100644
index 0000000000..e7e3652d91
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0899-soc-bcm-bcm2835-power-Add-support-for-BCM2712.patch
@@ -0,0 +1,76 @@
+From 9cf85a95eeb239a079a3485bd1d0447431bdc7f1 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 8 Mar 2023 14:42:48 +0000
+Subject: [PATCH] soc: bcm: bcm2835-power: Add support for BCM2712
+
+BCM2712 has a PM block but neither ASB nor RPIVID_ASB. Use the absence
+of the "asb" register range to indicate BCM2712 and its different PM
+register range.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/soc/bcm/bcm2835-power.c | 29 +++++++++++++++++++----------
+ 1 file changed, 19 insertions(+), 10 deletions(-)
+
+--- a/drivers/soc/bcm/bcm2835-power.c
++++ b/drivers/soc/bcm/bcm2835-power.c
+@@ -79,6 +79,7 @@
+ #define PM_IMAGE			0x108
+ #define PM_GRAFX			0x10c
+ #define PM_PROC				0x110
++#define PM_GRAFX_2712			0x304
+ #define PM_ENAB				BIT(12)
+ #define PM_ISPRSTN			BIT(8)
+ #define PM_H264RSTN			BIT(7)
+@@ -381,6 +382,9 @@ static int bcm2835_power_pd_power_on(str
+ 		return bcm2835_power_power_on(pd, PM_GRAFX);
+ 
+ 	case BCM2835_POWER_DOMAIN_GRAFX_V3D:
++		if (!power->asb)
++			return bcm2835_asb_power_on(pd, PM_GRAFX_2712,
++						    0, 0, PM_V3DRSTN);
+ 		return bcm2835_asb_power_on(pd, PM_GRAFX,
+ 					    ASB_V3D_M_CTRL, ASB_V3D_S_CTRL,
+ 					    PM_V3DRSTN);
+@@ -447,6 +451,9 @@ static int bcm2835_power_pd_power_off(st
+ 		return bcm2835_power_power_off(pd, PM_GRAFX);
+ 
+ 	case BCM2835_POWER_DOMAIN_GRAFX_V3D:
++		if (!power->asb)
++			return bcm2835_asb_power_off(pd, PM_GRAFX_2712,
++						    0, 0, PM_V3DRSTN);
+ 		return bcm2835_asb_power_off(pd, PM_GRAFX,
+ 					     ASB_V3D_M_CTRL, ASB_V3D_S_CTRL,
+ 					     PM_V3DRSTN);
+@@ -642,19 +649,21 @@ static int bcm2835_power_probe(struct pl
+ 	power->asb = pm->asb;
+ 	power->rpivid_asb = pm->rpivid_asb;
+ 
+-	id = readl(power->asb + ASB_AXI_BRDG_ID);
+-	if (id != BCM2835_BRDG_ID /* "BRDG" */) {
+-		dev_err(dev, "ASB register ID returned 0x%08x\n", id);
+-		return -ENODEV;
+-	}
+-
+-	if (power->rpivid_asb) {
+-		id = readl(power->rpivid_asb + ASB_AXI_BRDG_ID);
++	if (power->asb) {
++		id = readl(power->asb + ASB_AXI_BRDG_ID);
+ 		if (id != BCM2835_BRDG_ID /* "BRDG" */) {
+-			dev_err(dev, "RPiVid ASB register ID returned 0x%08x\n",
+-				     id);
++			dev_err(dev, "ASB register ID returned 0x%08x\n", id);
+ 			return -ENODEV;
+ 		}
++
++		if (power->rpivid_asb) {
++			id = readl(power->rpivid_asb + ASB_AXI_BRDG_ID);
++			if (id != BCM2835_BRDG_ID /* "BRDG" */) {
++				dev_err(dev, "RPiVid ASB register ID returned 0x%08x\n",
++					id);
++				return -ENODEV;
++			}
++		}
+ 	}
+ 
+ 	power->pd_xlate.domains = devm_kcalloc(dev,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0900-drivers-spi-Fix-spi-gpio-to-correctly-implement-sck-.patch b/target/linux/bcm27xx/patches-6.1/950-0900-drivers-spi-Fix-spi-gpio-to-correctly-implement-sck-.patch
new file mode 100644
index 0000000000..ff8471411f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0900-drivers-spi-Fix-spi-gpio-to-correctly-implement-sck-.patch
@@ -0,0 +1,150 @@
+From 380c336af070edf85826abbb0057bf92a03ec466 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Wed, 1 Mar 2023 17:57:11 +0000
+Subject: [PATCH] drivers: spi: Fix spi-gpio to correctly implement
+ sck-idle-input
+
+Formerly, if configured using DT, CS GPIOs were driven from spi.c
+and it was possible for CS to be asserted (low) *before* starting
+to drive SCK. CS GPIOs have been brought under control of this
+driver in both ACPI and DT cases, with a fixup for GPIO polarity.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/spi/spi-gpio.c | 74 +++++++++++++++++++++++++++++-------------
+ 1 file changed, 51 insertions(+), 23 deletions(-)
+
+--- a/drivers/spi/spi-gpio.c
++++ b/drivers/spi/spi-gpio.c
+@@ -37,6 +37,7 @@ struct spi_gpio {
+ 	struct gpio_desc		*mosi;
+ 	bool				sck_idle_input;
+ 	struct gpio_desc		**cs_gpios;
++	bool                            cs_dont_invert;
+ };
+ 
+ /*----------------------------------------------------------------------*/
+@@ -233,12 +234,18 @@ static void spi_gpio_chipselect(struct s
+ 			gpiod_set_value_cansleep(spi_gpio->sck, spi->mode & SPI_CPOL);
+ 	}
+ 
+-	/* Drive chip select line, if we have one */
++	/*
++	 * Drive chip select line, if we have one.
++	 * SPI chip selects are normally active-low, but when
++	 * cs_dont_invert is set, we assume their polarity is
++	 * controlled by the GPIO, and write '1' to assert.
++	 */
+ 	if (spi_gpio->cs_gpios) {
+ 		struct gpio_desc *cs = spi_gpio->cs_gpios[spi->chip_select];
++		int val = ((spi->mode & SPI_CS_HIGH) || spi_gpio->cs_dont_invert) ?
++			is_active : !is_active;
+ 
+-		/* SPI chip selects are normally active-low */
+-		gpiod_set_value_cansleep(cs, (spi->mode & SPI_CS_HIGH) ? is_active : !is_active);
++		gpiod_set_value_cansleep(cs, val);
+ 	}
+ 
+ 	if (spi_gpio->sck_idle_input && !is_active)
+@@ -254,12 +261,14 @@ static int spi_gpio_setup(struct spi_dev
+ 	/*
+ 	 * The CS GPIOs have already been
+ 	 * initialized from the descriptor lookup.
++	 * Here we set them to the non-asserted state.
+ 	 */
+ 	if (spi_gpio->cs_gpios) {
+ 		cs = spi_gpio->cs_gpios[spi->chip_select];
+ 		if (!spi->controller_state && cs)
+ 			status = gpiod_direction_output(cs,
+-						  !(spi->mode & SPI_CS_HIGH));
++							!((spi->mode & SPI_CS_HIGH) ||
++							   spi_gpio->cs_dont_invert));
+ 	}
+ 
+ 	if (!status)
+@@ -336,6 +345,38 @@ static int spi_gpio_request(struct devic
+ 	return PTR_ERR_OR_ZERO(spi_gpio->sck);
+ }
+ 
++/*
++ * In order to implement "sck-idle-input" (which requires SCK
++ * direction and CS level to be switched in a particular order),
++ * we need to control GPIO chip selects from within this driver.
++ */
++
++static int spi_gpio_probe_get_cs_gpios(struct device *dev,
++				       struct spi_master *master,
++				       bool gpio_defines_polarity)
++{
++	int i;
++	struct spi_gpio *spi_gpio = spi_master_get_devdata(master);
++
++	spi_gpio->cs_dont_invert = gpio_defines_polarity;
++	spi_gpio->cs_gpios = devm_kcalloc(dev, master->num_chipselect,
++					  sizeof(*spi_gpio->cs_gpios),
++					  GFP_KERNEL);
++	if (!spi_gpio->cs_gpios)
++		return -ENOMEM;
++
++	for (i = 0; i < master->num_chipselect; i++) {
++		spi_gpio->cs_gpios[i] =
++			devm_gpiod_get_index(dev, "cs", i,
++					     gpio_defines_polarity ?
++						GPIOD_OUT_LOW : GPIOD_OUT_HIGH);
++		if (IS_ERR(spi_gpio->cs_gpios[i]))
++			return PTR_ERR(spi_gpio->cs_gpios[i]);
++	}
++
++	return 0;
++}
++
+ #ifdef CONFIG_OF
+ static const struct of_device_id spi_gpio_dt_ids[] = {
+ 	{ .compatible = "spi-gpio" },
+@@ -346,10 +387,12 @@ MODULE_DEVICE_TABLE(of, spi_gpio_dt_ids)
+ static int spi_gpio_probe_dt(struct platform_device *pdev,
+ 			     struct spi_master *master)
+ {
+-	master->dev.of_node = pdev->dev.of_node;
+-	master->use_gpio_descriptors = true;
++	struct device *dev = &pdev->dev;
+ 
+-	return 0;
++	master->dev.of_node = dev->of_node;
++	master->num_chipselect = gpiod_count(dev, "cs");
++
++	return spi_gpio_probe_get_cs_gpios(dev, master, true);
+ }
+ #else
+ static inline int spi_gpio_probe_dt(struct platform_device *pdev,
+@@ -364,8 +407,6 @@ static int spi_gpio_probe_pdata(struct p
+ {
+ 	struct device *dev = &pdev->dev;
+ 	struct spi_gpio_platform_data *pdata = dev_get_platdata(dev);
+-	struct spi_gpio *spi_gpio = spi_master_get_devdata(master);
+-	int i;
+ 
+ #ifdef GENERIC_BITBANG
+ 	if (!pdata || !pdata->num_chipselect)
+@@ -377,20 +418,7 @@ static int spi_gpio_probe_pdata(struct p
+ 	 */
+ 	master->num_chipselect = pdata->num_chipselect ?: 1;
+ 
+-	spi_gpio->cs_gpios = devm_kcalloc(dev, master->num_chipselect,
+-					  sizeof(*spi_gpio->cs_gpios),
+-					  GFP_KERNEL);
+-	if (!spi_gpio->cs_gpios)
+-		return -ENOMEM;
+-
+-	for (i = 0; i < master->num_chipselect; i++) {
+-		spi_gpio->cs_gpios[i] = devm_gpiod_get_index(dev, "cs", i,
+-							     GPIOD_OUT_HIGH);
+-		if (IS_ERR(spi_gpio->cs_gpios[i]))
+-			return PTR_ERR(spi_gpio->cs_gpios[i]);
+-	}
+-
+-	return 0;
++	return spi_gpio_probe_get_cs_gpios(dev, master, false);
+ }
+ 
+ static int spi_gpio_probe(struct platform_device *pdev)
diff --git a/target/linux/bcm27xx/patches-6.1/950-0901-spi-spi-gpio-Implement-spidelay-when-requested-bit-r.patch b/target/linux/bcm27xx/patches-6.1/950-0901-spi-spi-gpio-Implement-spidelay-when-requested-bit-r.patch
new file mode 100644
index 0000000000..1b7952ab18
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0901-spi-spi-gpio-Implement-spidelay-when-requested-bit-r.patch
@@ -0,0 +1,55 @@
+From 586f87307e75552292cfc6c76b81cd38d5ec31e2 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Mon, 4 Sep 2023 10:57:47 +0100
+Subject: [PATCH] spi: spi-gpio: Implement spidelay when requested bit rate <=
+ 1 Mbps
+
+Formerly the delay was omitted as bit-banged SPI seldom achieved
+even one Mbit/s; but some modern platforms can run faster, and
+some SPI devices may need to be clocked slower.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/spi/spi-gpio.c | 18 ++++++++++++------
+ 1 file changed, 12 insertions(+), 6 deletions(-)
+
+--- a/drivers/spi/spi-gpio.c
++++ b/drivers/spi/spi-gpio.c
+@@ -11,12 +11,12 @@
+ #include <linux/gpio/consumer.h>
+ #include <linux/of.h>
+ #include <linux/of_device.h>
++#include <linux/delay.h>
+ 
+ #include <linux/spi/spi.h>
+ #include <linux/spi/spi_bitbang.h>
+ #include <linux/spi/spi_gpio.h>
+ 
+-
+ /*
+  * This bitbanging SPI master driver should help make systems usable
+  * when a native hardware SPI engine is not available, perhaps because
+@@ -111,12 +111,18 @@ static inline int getmiso(const struct s
+ }
+ 
+ /*
+- * NOTE:  this clocks "as fast as we can".  It "should" be a function of the
+- * requested device clock.  Software overhead means we usually have trouble
+- * reaching even one Mbit/sec (except when we can inline bitops), so for now
+- * we'll just assume we never need additional per-bit slowdowns.
++ * Generic bit-banged GPIO SPI might free-run at something in the range
++ * 1Mbps ~ 10Mbps (depending on the platform), and some SPI devices may
++ * need to be clocked at a lower rate. ndelay() is often implemented by
++ * udelay() with rounding up, so do the delay only for nsecs >= 500
++ * (<= 1Mbps). The conditional test adds a small overhead.
+  */
+-#define spidelay(nsecs)	do {} while (0)
++
++static inline void spidelay(unsigned long nsecs)
++{
++	if (nsecs >= 500)
++		ndelay(nsecs);
++}
+ 
+ #include "spi-bitbang-txrx.h"
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0902-drm-v3d-fix-up-register-addresses-for-V3D-7.x.patch b/target/linux/bcm27xx/patches-6.1/950-0902-drm-v3d-fix-up-register-addresses-for-V3D-7.x.patch
new file mode 100644
index 0000000000..1a51a85660
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0902-drm-v3d-fix-up-register-addresses-for-V3D-7.x.patch
@@ -0,0 +1,672 @@
+From 3f949caeef21269afc67dd62ae9826204f215934 Mon Sep 17 00:00:00 2001
+From: Iago Toral Quiroga <itoral@igalia.com>
+Date: Thu, 2 Mar 2023 11:49:46 +0100
+Subject: [PATCH] drm/v3d: fix up register addresses for V3D 7.x
+
+v2: fix kernel panic with debug-fs interface to list registers
+---
+ drivers/gpu/drm/v3d/v3d_debugfs.c | 177 +++++++++++++++++-------------
+ drivers/gpu/drm/v3d/v3d_gem.c     |   3 +
+ drivers/gpu/drm/v3d/v3d_irq.c     |  47 ++++----
+ drivers/gpu/drm/v3d/v3d_regs.h    |  51 ++++++++-
+ drivers/gpu/drm/v3d/v3d_sched.c   |  41 ++++---
+ 5 files changed, 204 insertions(+), 115 deletions(-)
+
+--- a/drivers/gpu/drm/v3d/v3d_debugfs.c
++++ b/drivers/gpu/drm/v3d/v3d_debugfs.c
+@@ -13,69 +13,83 @@
+ #include "v3d_drv.h"
+ #include "v3d_regs.h"
+ 
+-#define REGDEF(reg) { reg, #reg }
++#define REGDEF(min_ver, max_ver, reg) { min_ver, max_ver, reg, #reg }
+ struct v3d_reg_def {
++	u32 min_ver;
++	u32 max_ver;
+ 	u32 reg;
+ 	const char *name;
+ };
+ 
+ static const struct v3d_reg_def v3d_hub_reg_defs[] = {
+-	REGDEF(V3D_HUB_AXICFG),
+-	REGDEF(V3D_HUB_UIFCFG),
+-	REGDEF(V3D_HUB_IDENT0),
+-	REGDEF(V3D_HUB_IDENT1),
+-	REGDEF(V3D_HUB_IDENT2),
+-	REGDEF(V3D_HUB_IDENT3),
+-	REGDEF(V3D_HUB_INT_STS),
+-	REGDEF(V3D_HUB_INT_MSK_STS),
+-
+-	REGDEF(V3D_MMU_CTL),
+-	REGDEF(V3D_MMU_VIO_ADDR),
+-	REGDEF(V3D_MMU_VIO_ID),
+-	REGDEF(V3D_MMU_DEBUG_INFO),
++	REGDEF(33, 42, V3D_HUB_AXICFG),
++	REGDEF(33, 71, V3D_HUB_UIFCFG),
++	REGDEF(33, 71, V3D_HUB_IDENT0),
++	REGDEF(33, 71, V3D_HUB_IDENT1),
++	REGDEF(33, 71, V3D_HUB_IDENT2),
++	REGDEF(33, 71, V3D_HUB_IDENT3),
++	REGDEF(33, 71, V3D_HUB_INT_STS),
++	REGDEF(33, 71, V3D_HUB_INT_MSK_STS),
++
++	REGDEF(33, 71, V3D_MMU_CTL),
++	REGDEF(33, 71, V3D_MMU_VIO_ADDR),
++	REGDEF(33, 71, V3D_MMU_VIO_ID),
++	REGDEF(33, 71, V3D_MMU_DEBUG_INFO),
++
++	REGDEF(71, 71, V3D_V7_GMP_STATUS),
++	REGDEF(71, 71, V3D_V7_GMP_CFG),
++	REGDEF(71, 71, V3D_V7_GMP_VIO_ADDR),
+ };
+ 
+ static const struct v3d_reg_def v3d_gca_reg_defs[] = {
+-	REGDEF(V3D_GCA_SAFE_SHUTDOWN),
+-	REGDEF(V3D_GCA_SAFE_SHUTDOWN_ACK),
++	REGDEF(33, 33, V3D_GCA_SAFE_SHUTDOWN),
++	REGDEF(33, 33, V3D_GCA_SAFE_SHUTDOWN_ACK),
+ };
+ 
+ static const struct v3d_reg_def v3d_core_reg_defs[] = {
+-	REGDEF(V3D_CTL_IDENT0),
+-	REGDEF(V3D_CTL_IDENT1),
+-	REGDEF(V3D_CTL_IDENT2),
+-	REGDEF(V3D_CTL_MISCCFG),
+-	REGDEF(V3D_CTL_INT_STS),
+-	REGDEF(V3D_CTL_INT_MSK_STS),
+-	REGDEF(V3D_CLE_CT0CS),
+-	REGDEF(V3D_CLE_CT0CA),
+-	REGDEF(V3D_CLE_CT0EA),
+-	REGDEF(V3D_CLE_CT1CS),
+-	REGDEF(V3D_CLE_CT1CA),
+-	REGDEF(V3D_CLE_CT1EA),
+-
+-	REGDEF(V3D_PTB_BPCA),
+-	REGDEF(V3D_PTB_BPCS),
+-
+-	REGDEF(V3D_GMP_STATUS),
+-	REGDEF(V3D_GMP_CFG),
+-	REGDEF(V3D_GMP_VIO_ADDR),
+-
+-	REGDEF(V3D_ERR_FDBGO),
+-	REGDEF(V3D_ERR_FDBGB),
+-	REGDEF(V3D_ERR_FDBGS),
+-	REGDEF(V3D_ERR_STAT),
++	REGDEF(33, 71, V3D_CTL_IDENT0),
++	REGDEF(33, 71, V3D_CTL_IDENT1),
++	REGDEF(33, 71, V3D_CTL_IDENT2),
++	REGDEF(33, 71, V3D_CTL_MISCCFG),
++	REGDEF(33, 71, V3D_CTL_INT_STS),
++	REGDEF(33, 71, V3D_CTL_INT_MSK_STS),
++	REGDEF(33, 71, V3D_CLE_CT0CS),
++	REGDEF(33, 71, V3D_CLE_CT0CA),
++	REGDEF(33, 71, V3D_CLE_CT0EA),
++	REGDEF(33, 71, V3D_CLE_CT1CS),
++	REGDEF(33, 71, V3D_CLE_CT1CA),
++	REGDEF(33, 71, V3D_CLE_CT1EA),
++
++	REGDEF(33, 71, V3D_PTB_BPCA),
++	REGDEF(33, 71, V3D_PTB_BPCS),
++
++	REGDEF(33, 41, V3D_GMP_STATUS),
++	REGDEF(33, 41, V3D_GMP_CFG),
++	REGDEF(33, 41, V3D_GMP_VIO_ADDR),
++
++	REGDEF(33, 71, V3D_ERR_FDBGO),
++	REGDEF(33, 71, V3D_ERR_FDBGB),
++	REGDEF(33, 71, V3D_ERR_FDBGS),
++	REGDEF(33, 71, V3D_ERR_STAT),
+ };
+ 
+ static const struct v3d_reg_def v3d_csd_reg_defs[] = {
+-	REGDEF(V3D_CSD_STATUS),
+-	REGDEF(V3D_CSD_CURRENT_CFG0),
+-	REGDEF(V3D_CSD_CURRENT_CFG1),
+-	REGDEF(V3D_CSD_CURRENT_CFG2),
+-	REGDEF(V3D_CSD_CURRENT_CFG3),
+-	REGDEF(V3D_CSD_CURRENT_CFG4),
+-	REGDEF(V3D_CSD_CURRENT_CFG5),
+-	REGDEF(V3D_CSD_CURRENT_CFG6),
++	REGDEF(41, 71, V3D_CSD_STATUS),
++	REGDEF(41, 41, V3D_CSD_CURRENT_CFG0),
++	REGDEF(41, 41, V3D_CSD_CURRENT_CFG1),
++	REGDEF(41, 41, V3D_CSD_CURRENT_CFG2),
++	REGDEF(41, 41, V3D_CSD_CURRENT_CFG3),
++	REGDEF(41, 41, V3D_CSD_CURRENT_CFG4),
++	REGDEF(41, 41, V3D_CSD_CURRENT_CFG5),
++	REGDEF(41, 41, V3D_CSD_CURRENT_CFG6),
++	REGDEF(71, 71, V3D_V7_CSD_CURRENT_CFG0),
++	REGDEF(71, 71, V3D_V7_CSD_CURRENT_CFG1),
++	REGDEF(71, 71, V3D_V7_CSD_CURRENT_CFG2),
++	REGDEF(71, 71, V3D_V7_CSD_CURRENT_CFG3),
++	REGDEF(71, 71, V3D_V7_CSD_CURRENT_CFG4),
++	REGDEF(71, 71, V3D_V7_CSD_CURRENT_CFG5),
++	REGDEF(71, 71, V3D_V7_CSD_CURRENT_CFG6),
++	REGDEF(71, 71, V3D_V7_CSD_CURRENT_CFG7),
+ };
+ 
+ static int v3d_v3d_debugfs_regs(struct seq_file *m, void *unused)
+@@ -86,38 +100,41 @@ static int v3d_v3d_debugfs_regs(struct s
+ 	int i, core;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(v3d_hub_reg_defs); i++) {
+-		seq_printf(m, "%s (0x%04x): 0x%08x\n",
+-			   v3d_hub_reg_defs[i].name, v3d_hub_reg_defs[i].reg,
+-			   V3D_READ(v3d_hub_reg_defs[i].reg));
++		const struct v3d_reg_def *def = &v3d_hub_reg_defs[i];
++
++		if (v3d->ver >= def->min_ver && v3d->ver <= def->max_ver) {
++			seq_printf(m, "%s (0x%04x): 0x%08x\n",
++				   def->name, def->reg, V3D_READ(def->reg));
++		}
+ 	}
+ 
+-	if (v3d->ver < 41) {
+-		for (i = 0; i < ARRAY_SIZE(v3d_gca_reg_defs); i++) {
++	for (i = 0; i < ARRAY_SIZE(v3d_gca_reg_defs); i++) {
++		const struct v3d_reg_def *def = &v3d_gca_reg_defs[i];
++
++		if (v3d->ver >= def->min_ver && v3d->ver <= def->max_ver) {
+ 			seq_printf(m, "%s (0x%04x): 0x%08x\n",
+-				   v3d_gca_reg_defs[i].name,
+-				   v3d_gca_reg_defs[i].reg,
+-				   V3D_GCA_READ(v3d_gca_reg_defs[i].reg));
++				   def->name, def->reg, V3D_GCA_READ(def->reg));
+ 		}
+ 	}
+ 
+ 	for (core = 0; core < v3d->cores; core++) {
+ 		for (i = 0; i < ARRAY_SIZE(v3d_core_reg_defs); i++) {
+-			seq_printf(m, "core %d %s (0x%04x): 0x%08x\n",
+-				   core,
+-				   v3d_core_reg_defs[i].name,
+-				   v3d_core_reg_defs[i].reg,
+-				   V3D_CORE_READ(core,
+-						 v3d_core_reg_defs[i].reg));
++			const struct v3d_reg_def *def = &v3d_core_reg_defs[i];
++
++			if (v3d->ver >= def->min_ver && v3d->ver <= def->max_ver) {
++				seq_printf(m, "core %d %s (0x%04x): 0x%08x\n",
++					   core, def->name, def->reg,
++					   V3D_CORE_READ(core, def->reg));
++			}
+ 		}
+ 
+-		if (v3d_has_csd(v3d)) {
+-			for (i = 0; i < ARRAY_SIZE(v3d_csd_reg_defs); i++) {
++		for (i = 0; i < ARRAY_SIZE(v3d_csd_reg_defs); i++) {
++			const struct v3d_reg_def *def = &v3d_csd_reg_defs[i];
++
++			if (v3d->ver >= def->min_ver && v3d->ver <= def->max_ver) {
+ 				seq_printf(m, "core %d %s (0x%04x): 0x%08x\n",
+-					   core,
+-					   v3d_csd_reg_defs[i].name,
+-					   v3d_csd_reg_defs[i].reg,
+-					   V3D_CORE_READ(core,
+-							 v3d_csd_reg_defs[i].reg));
++					   core, def->name, def->reg,
++					   V3D_CORE_READ(core, def->reg));
+ 			}
+ 		}
+ 	}
+@@ -148,8 +165,10 @@ static int v3d_v3d_debugfs_ident(struct
+ 		   str_yes_no(ident2 & V3D_HUB_IDENT2_WITH_MMU));
+ 	seq_printf(m, "TFU:        %s\n",
+ 		   str_yes_no(ident1 & V3D_HUB_IDENT1_WITH_TFU));
+-	seq_printf(m, "TSY:        %s\n",
+-		   str_yes_no(ident1 & V3D_HUB_IDENT1_WITH_TSY));
++	if (v3d->ver <= 42) {
++		seq_printf(m, "TSY:        %s\n",
++			   str_yes_no(ident1 & V3D_HUB_IDENT1_WITH_TSY));
++	}
+ 	seq_printf(m, "MSO:        %s\n",
+ 		   str_yes_no(ident1 & V3D_HUB_IDENT1_WITH_MSO));
+ 	seq_printf(m, "L3C:        %s (%dkb)\n",
+@@ -178,10 +197,14 @@ static int v3d_v3d_debugfs_ident(struct
+ 		seq_printf(m, "  QPUs:         %d\n", nslc * qups);
+ 		seq_printf(m, "  Semaphores:   %d\n",
+ 			   V3D_GET_FIELD(ident1, V3D_IDENT1_NSEM));
+-		seq_printf(m, "  BCG int:      %d\n",
+-			   (ident2 & V3D_IDENT2_BCG_INT) != 0);
+-		seq_printf(m, "  Override TMU: %d\n",
+-			   (misccfg & V3D_MISCCFG_OVRTMUOUT) != 0);
++		if (v3d->ver <= 42) {
++			seq_printf(m, "  BCG int:      %d\n",
++				   (ident2 & V3D_IDENT2_BCG_INT) != 0);
++		}
++		if (v3d->ver < 40) {
++			seq_printf(m, "  Override TMU: %d\n",
++				   (misccfg & V3D_MISCCFG_OVRTMUOUT) != 0);
++		}
+ 	}
+ 
+ 	return 0;
+@@ -289,8 +312,10 @@ static int v3d_measure_clock(struct seq_
+ 	int measure_ms = 1000;
+ 
+ 	if (v3d->ver >= 40) {
++		int cycle_count_reg = v3d->ver < 71 ?
++			V3D_PCTR_CYCLE_COUNT : V3D_V7_PCTR_CYCLE_COUNT;
+ 		V3D_CORE_WRITE(core, V3D_V4_PCTR_0_SRC_0_3,
+-			       V3D_SET_FIELD(V3D_PCTR_CYCLE_COUNT,
++			       V3D_SET_FIELD(cycle_count_reg,
+ 					     V3D_PCTR_S0));
+ 		V3D_CORE_WRITE(core, V3D_V4_PCTR_0_CLR, 1);
+ 		V3D_CORE_WRITE(core, V3D_V4_PCTR_0_EN, 1);
+--- a/drivers/gpu/drm/v3d/v3d_gem.c
++++ b/drivers/gpu/drm/v3d/v3d_gem.c
+@@ -88,6 +88,9 @@ v3d_init_hw_state(struct v3d_dev *v3d)
+ static void
+ v3d_idle_axi(struct v3d_dev *v3d, int core)
+ {
++	if (v3d->ver >= 71)
++		return;
++
+ 	V3D_CORE_WRITE(core, V3D_GMP_CFG, V3D_GMP_CFG_STOP_REQ);
+ 
+ 	if (wait_for((V3D_CORE_READ(core, V3D_GMP_STATUS) &
+--- a/drivers/gpu/drm/v3d/v3d_irq.c
++++ b/drivers/gpu/drm/v3d/v3d_irq.c
+@@ -20,16 +20,17 @@
+ #include "v3d_regs.h"
+ #include "v3d_trace.h"
+ 
+-#define V3D_CORE_IRQS ((u32)(V3D_INT_OUTOMEM |	\
+-			     V3D_INT_FLDONE |	\
+-			     V3D_INT_FRDONE |	\
+-			     V3D_INT_CSDDONE |	\
+-			     V3D_INT_GMPV))
+-
+-#define V3D_HUB_IRQS ((u32)(V3D_HUB_INT_MMU_WRV |	\
+-			    V3D_HUB_INT_MMU_PTI |	\
+-			    V3D_HUB_INT_MMU_CAP |	\
+-			    V3D_HUB_INT_TFUC))
++#define V3D_CORE_IRQS(ver) ((u32)(V3D_INT_OUTOMEM |	\
++				  V3D_INT_FLDONE |	\
++				  V3D_INT_FRDONE |	\
++				  (ver < 71 ? V3D_INT_CSDDONE : V3D_V7_INT_CSDDONE) |	\
++				  (ver < 71 ? V3D_INT_GMPV : 0)))
++
++#define V3D_HUB_IRQS(ver) ((u32)(V3D_HUB_INT_MMU_WRV |	\
++				 V3D_HUB_INT_MMU_PTI |	\
++				 V3D_HUB_INT_MMU_CAP |	\
++				 V3D_HUB_INT_TFUC |		\
++				 (ver >= 71 ? V3D_V7_HUB_INT_GMPV : 0)))
+ 
+ static irqreturn_t
+ v3d_hub_irq(int irq, void *arg);
+@@ -118,7 +119,8 @@ v3d_irq(int irq, void *arg)
+ 		status = IRQ_HANDLED;
+ 	}
+ 
+-	if (intsts & V3D_INT_CSDDONE) {
++	if ((v3d->ver < 71 && (intsts & V3D_INT_CSDDONE)) ||
++	    (v3d->ver >= 71 && (intsts & V3D_V7_INT_CSDDONE))) {
+ 		struct v3d_fence *fence =
+ 			to_v3d_fence(v3d->csd_job->base.irq_fence);
+ 		v3d->gpu_queue_stats[V3D_CSD].last_exec_end = local_clock();
+@@ -131,7 +133,7 @@ v3d_irq(int irq, void *arg)
+ 	/* We shouldn't be triggering these if we have GMP in
+ 	 * always-allowed mode.
+ 	 */
+-	if (intsts & V3D_INT_GMPV)
++	if (v3d->ver < 71 && (intsts & V3D_INT_GMPV))
+ 		dev_err(v3d->drm.dev, "GMP violation\n");
+ 
+ 	/* V3D 4.2 wires the hub and core IRQs together, so if we &
+@@ -205,6 +207,11 @@ v3d_hub_irq(int irq, void *arg)
+ 		status = IRQ_HANDLED;
+ 	}
+ 
++	if (v3d->ver >= 71 && intsts & V3D_V7_HUB_INT_GMPV) {
++		dev_err(v3d->drm.dev, "GMP Violation\n");
++		status = IRQ_HANDLED;
++	}
++
+ 	return status;
+ }
+ 
+@@ -219,8 +226,8 @@ v3d_irq_init(struct v3d_dev *v3d)
+ 	 * for us.
+ 	 */
+ 	for (core = 0; core < v3d->cores; core++)
+-		V3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS);
+-	V3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS);
++		V3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS(v3d->ver));
++	V3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS(v3d->ver));
+ 
+ 	irq1 = platform_get_irq_optional(v3d_to_pdev(v3d), 1);
+ 	if (irq1 == -EPROBE_DEFER)
+@@ -264,12 +271,12 @@ v3d_irq_enable(struct v3d_dev *v3d)
+ 
+ 	/* Enable our set of interrupts, masking out any others. */
+ 	for (core = 0; core < v3d->cores; core++) {
+-		V3D_CORE_WRITE(core, V3D_CTL_INT_MSK_SET, ~V3D_CORE_IRQS);
+-		V3D_CORE_WRITE(core, V3D_CTL_INT_MSK_CLR, V3D_CORE_IRQS);
++		V3D_CORE_WRITE(core, V3D_CTL_INT_MSK_SET, ~V3D_CORE_IRQS(v3d->ver));
++		V3D_CORE_WRITE(core, V3D_CTL_INT_MSK_CLR, V3D_CORE_IRQS(v3d->ver));
+ 	}
+ 
+-	V3D_WRITE(V3D_HUB_INT_MSK_SET, ~V3D_HUB_IRQS);
+-	V3D_WRITE(V3D_HUB_INT_MSK_CLR, V3D_HUB_IRQS);
++	V3D_WRITE(V3D_HUB_INT_MSK_SET, ~V3D_HUB_IRQS(v3d->ver));
++	V3D_WRITE(V3D_HUB_INT_MSK_CLR, V3D_HUB_IRQS(v3d->ver));
+ }
+ 
+ void
+@@ -284,8 +291,8 @@ v3d_irq_disable(struct v3d_dev *v3d)
+ 
+ 	/* Clear any pending interrupts we might have left. */
+ 	for (core = 0; core < v3d->cores; core++)
+-		V3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS);
+-	V3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS);
++		V3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS(v3d->ver));
++	V3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS(v3d->ver));
+ 
+ 	cancel_work_sync(&v3d->overflow_mem_work);
+ }
+--- a/drivers/gpu/drm/v3d/v3d_regs.h
++++ b/drivers/gpu/drm/v3d/v3d_regs.h
+@@ -57,6 +57,7 @@
+ #define V3D_HUB_INT_MSK_STS                            0x0005c
+ #define V3D_HUB_INT_MSK_SET                            0x00060
+ #define V3D_HUB_INT_MSK_CLR                            0x00064
++# define V3D_V7_HUB_INT_GMPV                           BIT(6)
+ # define V3D_HUB_INT_MMU_WRV                           BIT(5)
+ # define V3D_HUB_INT_MMU_PTI                           BIT(4)
+ # define V3D_HUB_INT_MMU_CAP                           BIT(3)
+@@ -64,6 +65,7 @@
+ # define V3D_HUB_INT_TFUC                              BIT(1)
+ # define V3D_HUB_INT_TFUF                              BIT(0)
+ 
++/* GCA registers only exist in V3D < 41 */
+ #define V3D_GCA_CACHE_CTRL                             0x0000c
+ # define V3D_GCA_CACHE_CTRL_FLUSH                      BIT(0)
+ 
+@@ -87,6 +89,7 @@
+ # define V3D_TOP_GR_BRIDGE_SW_INIT_1_V3D_CLK_108_SW_INIT BIT(0)
+ 
+ #define V3D_TFU_CS                                     0x00400
++#define V3D_V7_TFU_CS                                  0x00700
+ /* Stops current job, empties input fifo. */
+ # define V3D_TFU_CS_TFURST                             BIT(31)
+ # define V3D_TFU_CS_CVTCT_MASK                         V3D_MASK(23, 16)
+@@ -96,6 +99,7 @@
+ # define V3D_TFU_CS_BUSY                               BIT(0)
+ 
+ #define V3D_TFU_SU                                     0x00404
++#define V3D_V7_TFU_SU                                  0x00704
+ /* Interrupt when FINTTHR input slots are free (0 = disabled) */
+ # define V3D_TFU_SU_FINTTHR_MASK                       V3D_MASK(13, 8)
+ # define V3D_TFU_SU_FINTTHR_SHIFT                      8
+@@ -107,38 +111,53 @@
+ # define V3D_TFU_SU_THROTTLE_SHIFT                     0
+ 
+ #define V3D_TFU_ICFG                                   0x00408
++#define V3D_V7_TFU_ICFG                                0x00708
+ /* Interrupt when the conversion is complete. */
+ # define V3D_TFU_ICFG_IOC                              BIT(0)
+ 
+ /* Input Image Address */
+ #define V3D_TFU_IIA                                    0x0040c
++#define V3D_V7_TFU_IIA                                 0x0070c
+ /* Input Chroma Address */
+ #define V3D_TFU_ICA                                    0x00410
++#define V3D_V7_TFU_ICA                                 0x00710
+ /* Input Image Stride */
+ #define V3D_TFU_IIS                                    0x00414
++#define V3D_V7_TFU_IIS                                 0x00714
+ /* Input Image U-Plane Address */
+ #define V3D_TFU_IUA                                    0x00418
++#define V3D_V7_TFU_IUA                                 0x00718
++/* Image output config (VD 7.x only) */
++#define V3D_V7_TFU_IOC                                 0x0071c
+ /* Output Image Address */
+ #define V3D_TFU_IOA                                    0x0041c
++#define V3D_V7_TFU_IOA                                 0x00720
+ /* Image Output Size */
+ #define V3D_TFU_IOS                                    0x00420
++#define V3D_V7_TFU_IOS                                 0x00724
+ /* TFU YUV Coefficient 0 */
+ #define V3D_TFU_COEF0                                  0x00424
+-/* Use these regs instead of the defaults. */
++#define V3D_V7_TFU_COEF0                               0x00728
++/* Use these regs instead of the defaults (V3D 4.x only) */
+ # define V3D_TFU_COEF0_USECOEF                         BIT(31)
+ /* TFU YUV Coefficient 1 */
+ #define V3D_TFU_COEF1                                  0x00428
++#define V3D_V7_TFU_COEF1                               0x0072c
+ /* TFU YUV Coefficient 2 */
+ #define V3D_TFU_COEF2                                  0x0042c
++#define V3D_V7_TFU_COEF2                               0x00730
+ /* TFU YUV Coefficient 3 */
+ #define V3D_TFU_COEF3                                  0x00430
++#define V3D_V7_TFU_COEF3                               0x00734
+ 
++/* V3D 4.x only */
+ #define V3D_TFU_CRC                                    0x00434
+ 
+ /* Per-MMU registers. */
+ 
+ #define V3D_MMUC_CONTROL                               0x01000
+ # define V3D_MMUC_CONTROL_CLEAR                        BIT(3)
++# define V3D_V7_MMUC_CONTROL_CLEAR                     BIT(11)
+ # define V3D_MMUC_CONTROL_FLUSHING                     BIT(2)
+ # define V3D_MMUC_CONTROL_FLUSH                        BIT(1)
+ # define V3D_MMUC_CONTROL_ENABLE                       BIT(0)
+@@ -246,7 +265,6 @@
+ 
+ #define V3D_CTL_L2TCACTL                               0x00030
+ # define V3D_L2TCACTL_TMUWCF                           BIT(8)
+-# define V3D_L2TCACTL_L2T_NO_WM                        BIT(4)
+ /* Invalidates cache lines. */
+ # define V3D_L2TCACTL_FLM_FLUSH                        0
+ /* Removes cachelines without writing dirty lines back. */
+@@ -268,7 +286,9 @@
+ # define V3D_INT_QPU_MASK                              V3D_MASK(27, 16)
+ # define V3D_INT_QPU_SHIFT                             16
+ # define V3D_INT_CSDDONE                               BIT(7)
++# define V3D_V7_INT_CSDDONE                            BIT(6)
+ # define V3D_INT_PCTR                                  BIT(6)
++# define V3D_V7_INT_PCTR                               BIT(5)
+ # define V3D_INT_GMPV                                  BIT(5)
+ # define V3D_INT_TRFB                                  BIT(4)
+ # define V3D_INT_SPILLUSE                              BIT(3)
+@@ -350,14 +370,19 @@
+ #define V3D_V4_PCTR_0_SRC_X(x)                         (V3D_V4_PCTR_0_SRC_0_3 + \
+ 							4 * (x))
+ # define V3D_PCTR_S0_MASK                              V3D_MASK(6, 0)
++# define V3D_V7_PCTR_S0_MASK                           V3D_MASK(7, 0)
+ # define V3D_PCTR_S0_SHIFT                             0
+ # define V3D_PCTR_S1_MASK                              V3D_MASK(14, 8)
++# define V3D_V7_PCTR_S1_MASK                           V3D_MASK(15, 8)
+ # define V3D_PCTR_S1_SHIFT                             8
+ # define V3D_PCTR_S2_MASK                              V3D_MASK(22, 16)
++# define V3D_V7_PCTR_S2_MASK                           V3D_MASK(23, 16)
+ # define V3D_PCTR_S2_SHIFT                             16
+ # define V3D_PCTR_S3_MASK                              V3D_MASK(30, 24)
++# define V3D_V7_PCTR_S3_MASK                           V3D_MASK(31, 24)
+ # define V3D_PCTR_S3_SHIFT                             24
+ # define V3D_PCTR_CYCLE_COUNT                          32
++# define V3D_V7_PCTR_CYCLE_COUNT                       0
+ 
+ /* Output values of the counters. */
+ #define V3D_PCTR_0_PCTR0                               0x00680
+@@ -365,6 +390,7 @@
+ #define V3D_PCTR_0_PCTRX(x)                            (V3D_PCTR_0_PCTR0 + \
+ 							4 * (x))
+ #define V3D_GMP_STATUS                                 0x00800
++#define V3D_V7_GMP_STATUS                              0x00600
+ # define V3D_GMP_STATUS_GMPRST                         BIT(31)
+ # define V3D_GMP_STATUS_WR_COUNT_MASK                  V3D_MASK(30, 24)
+ # define V3D_GMP_STATUS_WR_COUNT_SHIFT                 24
+@@ -378,12 +404,14 @@
+ # define V3D_GMP_STATUS_VIO                            BIT(0)
+ 
+ #define V3D_GMP_CFG                                    0x00804
++#define V3D_V7_GMP_CFG                                 0x00604
+ # define V3D_GMP_CFG_LBURSTEN                          BIT(3)
+ # define V3D_GMP_CFG_PGCRSEN                           BIT()
+ # define V3D_GMP_CFG_STOP_REQ                          BIT(1)
+ # define V3D_GMP_CFG_PROT_ENABLE                       BIT(0)
+ 
+ #define V3D_GMP_VIO_ADDR                               0x00808
++#define V3D_V7_GMP_VIO_ADDR                            0x00608
+ #define V3D_GMP_VIO_TYPE                               0x0080c
+ #define V3D_GMP_TABLE_ADDR                             0x00810
+ #define V3D_GMP_CLEAR_LOAD                             0x00814
+@@ -399,24 +427,28 @@
+ # define V3D_CSD_STATUS_HAVE_QUEUED_DISPATCH           BIT(0)
+ 
+ #define V3D_CSD_QUEUED_CFG0                            0x00904
++#define V3D_V7_CSD_QUEUED_CFG0                         0x00930
+ # define V3D_CSD_QUEUED_CFG0_NUM_WGS_X_MASK            V3D_MASK(31, 16)
+ # define V3D_CSD_QUEUED_CFG0_NUM_WGS_X_SHIFT           16
+ # define V3D_CSD_QUEUED_CFG0_WG_X_OFFSET_MASK          V3D_MASK(15, 0)
+ # define V3D_CSD_QUEUED_CFG0_WG_X_OFFSET_SHIFT         0
+ 
+ #define V3D_CSD_QUEUED_CFG1                            0x00908
++#define V3D_V7_CSD_QUEUED_CFG1                         0x00934
+ # define V3D_CSD_QUEUED_CFG1_NUM_WGS_Y_MASK            V3D_MASK(31, 16)
+ # define V3D_CSD_QUEUED_CFG1_NUM_WGS_Y_SHIFT           16
+ # define V3D_CSD_QUEUED_CFG1_WG_Y_OFFSET_MASK          V3D_MASK(15, 0)
+ # define V3D_CSD_QUEUED_CFG1_WG_Y_OFFSET_SHIFT         0
+ 
+ #define V3D_CSD_QUEUED_CFG2                            0x0090c
++#define V3D_V7_CSD_QUEUED_CFG2                         0x00938
+ # define V3D_CSD_QUEUED_CFG2_NUM_WGS_Z_MASK            V3D_MASK(31, 16)
+ # define V3D_CSD_QUEUED_CFG2_NUM_WGS_Z_SHIFT           16
+ # define V3D_CSD_QUEUED_CFG2_WG_Z_OFFSET_MASK          V3D_MASK(15, 0)
+ # define V3D_CSD_QUEUED_CFG2_WG_Z_OFFSET_SHIFT         0
+ 
+ #define V3D_CSD_QUEUED_CFG3                            0x00910
++#define V3D_V7_CSD_QUEUED_CFG3                         0x0093c
+ # define V3D_CSD_QUEUED_CFG3_OVERLAP_WITH_PREV         BIT(26)
+ # define V3D_CSD_QUEUED_CFG3_MAX_SG_ID_MASK            V3D_MASK(25, 20)
+ # define V3D_CSD_QUEUED_CFG3_MAX_SG_ID_SHIFT           20
+@@ -429,22 +461,36 @@
+ 
+ /* Number of batches, minus 1 */
+ #define V3D_CSD_QUEUED_CFG4                            0x00914
++#define V3D_V7_CSD_QUEUED_CFG4                         0x00940
+ 
+ /* Shader address, pnan, singleseg, threading, like a shader record. */
+ #define V3D_CSD_QUEUED_CFG5                            0x00918
++#define V3D_V7_CSD_QUEUED_CFG5                         0x00944
+ 
+ /* Uniforms address (4 byte aligned) */
+ #define V3D_CSD_QUEUED_CFG6                            0x0091c
++#define V3D_V7_CSD_QUEUED_CFG6                         0x00948
++
++#define V3D_V7_CSD_QUEUED_CFG7                         0x0094c
+ 
+ #define V3D_CSD_CURRENT_CFG0                          0x00920
++#define V3D_V7_CSD_CURRENT_CFG0                       0x00958
+ #define V3D_CSD_CURRENT_CFG1                          0x00924
++#define V3D_V7_CSD_CURRENT_CFG1                       0x0095c
+ #define V3D_CSD_CURRENT_CFG2                          0x00928
++#define V3D_V7_CSD_CURRENT_CFG2                       0x00960
+ #define V3D_CSD_CURRENT_CFG3                          0x0092c
++#define V3D_V7_CSD_CURRENT_CFG3                       0x00964
+ #define V3D_CSD_CURRENT_CFG4                          0x00930
++#define V3D_V7_CSD_CURRENT_CFG4                       0x00968
+ #define V3D_CSD_CURRENT_CFG5                          0x00934
++#define V3D_V7_CSD_CURRENT_CFG5                       0x0096c
+ #define V3D_CSD_CURRENT_CFG6                          0x00938
++#define V3D_V7_CSD_CURRENT_CFG6                       0x00970
++#define V3D_V7_CSD_CURRENT_CFG7                       0x00974
+ 
+ #define V3D_CSD_CURRENT_ID0                            0x0093c
++#define V3D_V7_CSD_CURRENT_ID0                         0x00978
+ # define V3D_CSD_CURRENT_ID0_WG_X_MASK                 V3D_MASK(31, 16)
+ # define V3D_CSD_CURRENT_ID0_WG_X_SHIFT                16
+ # define V3D_CSD_CURRENT_ID0_WG_IN_SG_MASK             V3D_MASK(11, 8)
+@@ -453,6 +499,7 @@
+ # define V3D_CSD_CURRENT_ID0_L_IDX_SHIFT               0
+ 
+ #define V3D_CSD_CURRENT_ID1                            0x00940
++#define V3D_V7_CSD_CURRENT_ID1                         0x0097c
+ # define V3D_CSD_CURRENT_ID0_WG_Z_MASK                 V3D_MASK(31, 16)
+ # define V3D_CSD_CURRENT_ID0_WG_Z_SHIFT                16
+ # define V3D_CSD_CURRENT_ID0_WG_Y_MASK                 V3D_MASK(15, 0)
+--- a/drivers/gpu/drm/v3d/v3d_sched.c
++++ b/drivers/gpu/drm/v3d/v3d_sched.c
+@@ -282,6 +282,8 @@ static struct dma_fence *v3d_render_job_
+ 	return fence;
+ }
+ 
++#define V3D_TFU_REG(name) ((v3d->ver < 71) ? V3D_TFU_ ## name : V3D_V7_TFU_ ## name)
++
+ static struct dma_fence *
+ v3d_tfu_job_run(struct drm_sched_job *sched_job)
+ {
+@@ -302,20 +304,22 @@ v3d_tfu_job_run(struct drm_sched_job *sc
+ 	trace_v3d_submit_tfu(dev, to_v3d_fence(fence)->seqno);
+ 
+ 	v3d_sched_stats_add_job(&v3d->gpu_queue_stats[V3D_TFU], sched_job);
+-	V3D_WRITE(V3D_TFU_IIA, job->args.iia);
+-	V3D_WRITE(V3D_TFU_IIS, job->args.iis);
+-	V3D_WRITE(V3D_TFU_ICA, job->args.ica);
+-	V3D_WRITE(V3D_TFU_IUA, job->args.iua);
+-	V3D_WRITE(V3D_TFU_IOA, job->args.ioa);
+-	V3D_WRITE(V3D_TFU_IOS, job->args.ios);
+-	V3D_WRITE(V3D_TFU_COEF0, job->args.coef[0]);
+-	if (job->args.coef[0] & V3D_TFU_COEF0_USECOEF) {
+-		V3D_WRITE(V3D_TFU_COEF1, job->args.coef[1]);
+-		V3D_WRITE(V3D_TFU_COEF2, job->args.coef[2]);
+-		V3D_WRITE(V3D_TFU_COEF3, job->args.coef[3]);
++	V3D_WRITE(V3D_TFU_REG(IIA), job->args.iia);
++	V3D_WRITE(V3D_TFU_REG(IIS), job->args.iis);
++	V3D_WRITE(V3D_TFU_REG(ICA), job->args.ica);
++	V3D_WRITE(V3D_TFU_REG(IUA), job->args.iua);
++	V3D_WRITE(V3D_TFU_REG(IOA), job->args.ioa);
++	if (v3d->ver >= 71)
++		V3D_WRITE(V3D_V7_TFU_IOC, job->args.v71.ioc);
++	V3D_WRITE(V3D_TFU_REG(IOS), job->args.ios);
++	V3D_WRITE(V3D_TFU_REG(COEF0), job->args.coef[0]);
++	if (v3d->ver >= 71 || (job->args.coef[0] & V3D_TFU_COEF0_USECOEF)) {
++		V3D_WRITE(V3D_TFU_REG(COEF1), job->args.coef[1]);
++		V3D_WRITE(V3D_TFU_REG(COEF2), job->args.coef[2]);
++		V3D_WRITE(V3D_TFU_REG(COEF3), job->args.coef[3]);
+ 	}
+ 	/* ICFG kicks off the job. */
+-	V3D_WRITE(V3D_TFU_ICFG, job->args.icfg | V3D_TFU_ICFG_IOC);
++	V3D_WRITE(V3D_TFU_REG(ICFG), job->args.icfg | V3D_TFU_ICFG_IOC);
+ 
+ 	return fence;
+ }
+@@ -327,7 +331,7 @@ v3d_csd_job_run(struct drm_sched_job *sc
+ 	struct v3d_dev *v3d = job->base.v3d;
+ 	struct drm_device *dev = &v3d->drm;
+ 	struct dma_fence *fence;
+-	int i;
++	int i, csd_cfg0_reg, csd_cfg_reg_count;
+ 
+ 	v3d->csd_job = job;
+ 
+@@ -346,10 +350,12 @@ v3d_csd_job_run(struct drm_sched_job *sc
+ 	v3d_sched_stats_add_job(&v3d->gpu_queue_stats[V3D_CSD], sched_job);
+ 	v3d_switch_perfmon(v3d, &job->base);
+ 
+-	for (i = 1; i <= 6; i++)
+-		V3D_CORE_WRITE(0, V3D_CSD_QUEUED_CFG0 + 4 * i, job->args.cfg[i]);
++	csd_cfg0_reg = v3d->ver < 71 ? V3D_CSD_QUEUED_CFG0 : V3D_V7_CSD_QUEUED_CFG0;
++	csd_cfg_reg_count = v3d->ver < 71 ? 6 : 7;
++	for (i = 1; i <= csd_cfg_reg_count; i++)
++		V3D_CORE_WRITE(0, csd_cfg0_reg + 4 * i, job->args.cfg[i]);
+ 	/* CFG0 write kicks off the job. */
+-	V3D_CORE_WRITE(0, V3D_CSD_QUEUED_CFG0, job->args.cfg[0]);
++	V3D_CORE_WRITE(0, csd_cfg0_reg, job->args.cfg[0]);
+ 
+ 	return fence;
+ }
+@@ -452,7 +458,8 @@ v3d_csd_job_timedout(struct drm_sched_jo
+ {
+ 	struct v3d_csd_job *job = to_csd_job(sched_job);
+ 	struct v3d_dev *v3d = job->base.v3d;
+-	u32 batches = V3D_CORE_READ(0, V3D_CSD_CURRENT_CFG4);
++	u32 batches = V3D_CORE_READ(0, (v3d->ver < 71 ? V3D_CSD_CURRENT_CFG4 :
++							V3D_V7_CSD_CURRENT_CFG4));
+ 
+ 	/* If we've made progress, skip reset and let the timer get
+ 	 * rearmed.
diff --git a/target/linux/bcm27xx/patches-6.1/950-0903-drm-v3d-update-UAPI-to-match-user-space-for-V3D-7.x.patch b/target/linux/bcm27xx/patches-6.1/950-0903-drm-v3d-update-UAPI-to-match-user-space-for-V3D-7.x.patch
new file mode 100644
index 0000000000..ed1d5f05df
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0903-drm-v3d-update-UAPI-to-match-user-space-for-V3D-7.x.patch
@@ -0,0 +1,24 @@
+From 22fb30936524ae96151789741885edbc45efb53d Mon Sep 17 00:00:00 2001
+From: Iago Toral Quiroga <itoral@igalia.com>
+Date: Thu, 2 Mar 2023 11:52:08 +0100
+Subject: [PATCH] drm/v3d: update UAPI to match user-space for V3D 7.x
+
+V3D t.x takes a new parameter to configure TFU jobs that needs
+to be provided by user space.
+---
+ include/uapi/drm/v3d_drm.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/include/uapi/drm/v3d_drm.h
++++ b/include/uapi/drm/v3d_drm.h
+@@ -319,6 +319,10 @@ struct drm_v3d_submit_tfu {
+ 
+ 	/* Pointer to an array of ioctl extensions*/
+ 	__u64 extensions;
++
++	struct {
++		__u32 ioc;
++	} v71;
+ };
+ 
+ /* Submits a compute shader for dispatch.  This job will block on any
diff --git a/target/linux/bcm27xx/patches-6.1/950-0904-drm-v3d-add-brcm-2712-v3d-as-a-compatible-V3D-device.patch b/target/linux/bcm27xx/patches-6.1/950-0904-drm-v3d-add-brcm-2712-v3d-as-a-compatible-V3D-device.patch
new file mode 100644
index 0000000000..64189338e6
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0904-drm-v3d-add-brcm-2712-v3d-as-a-compatible-V3D-device.patch
@@ -0,0 +1,19 @@
+From 18bc419d38eda06ded78c7b702c0e21e5af8f24c Mon Sep 17 00:00:00 2001
+From: Iago Toral Quiroga <itoral@igalia.com>
+Date: Thu, 2 Mar 2023 11:54:45 +0100
+Subject: [PATCH] drm/v3d: add brcm,2712-v3d as a compatible V3D device
+
+---
+ drivers/gpu/drm/v3d/v3d_drv.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/gpu/drm/v3d/v3d_drv.c
++++ b/drivers/gpu/drm/v3d/v3d_drv.c
+@@ -193,6 +193,7 @@ static const struct drm_driver v3d_drm_d
+ };
+ 
+ static const struct of_device_id v3d_of_match[] = {
++	{ .compatible = "brcm,2712-v3d" },
+ 	{ .compatible = "brcm,2711-v3d" },
+ 	{ .compatible = "brcm,7268-v3d" },
+ 	{ .compatible = "brcm,7278-v3d" },
diff --git a/target/linux/bcm27xx/patches-6.1/950-0905-drm-v3d-Improve-MMU-support-for-larger-pages.patch b/target/linux/bcm27xx/patches-6.1/950-0905-drm-v3d-Improve-MMU-support-for-larger-pages.patch
new file mode 100644
index 0000000000..3c53996ff0
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0905-drm-v3d-Improve-MMU-support-for-larger-pages.patch
@@ -0,0 +1,64 @@
+From 12c7ea43b930976f35ce75d11fd3f55438868e13 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 4 Aug 2023 11:26:10 +0100
+Subject: [PATCH] drm/v3d: Improve MMU support for larger pages
+
+The built-in MMU driver went most of the way towards supporting larger
+kernel pages, but dropped the ball when it comes to calculating indexes
+into the page table. Fix it.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/gpu/drm/v3d/v3d_mmu.c | 15 ++++++++-------
+ 1 file changed, 8 insertions(+), 7 deletions(-)
+
+--- a/drivers/gpu/drm/v3d/v3d_mmu.c
++++ b/drivers/gpu/drm/v3d/v3d_mmu.c
+@@ -22,6 +22,7 @@
+ #include "v3d_regs.h"
+ 
+ #define V3D_MMU_PAGE_SHIFT 12
++#define V3D_PAGE_FACTOR (PAGE_SIZE >> V3D_MMU_PAGE_SHIFT)
+ 
+ /* Note: All PTEs for the 1MB superpage must be filled with the
+  * superpage bit set.
+@@ -88,7 +89,7 @@ void v3d_mmu_insert_ptes(struct v3d_bo *
+ {
+ 	struct drm_gem_shmem_object *shmem_obj = &bo->base;
+ 	struct v3d_dev *v3d = to_v3d_dev(shmem_obj->base.dev);
+-	u32 page = bo->node.start;
++	u32 page = bo->node.start * V3D_PAGE_FACTOR;
+ 	u32 page_prot = V3D_PTE_WRITEABLE | V3D_PTE_VALID;
+ 	struct sg_dma_page_iter dma_iter;
+ 
+@@ -98,13 +99,13 @@ void v3d_mmu_insert_ptes(struct v3d_bo *
+ 		u32 pte = page_prot | page_address;
+ 		u32 i;
+ 
+-		BUG_ON(page_address + (PAGE_SIZE >> V3D_MMU_PAGE_SHIFT) >=
++		BUG_ON(page_address + V3D_PAGE_FACTOR >=
+ 		       BIT(24));
+-		for (i = 0; i < PAGE_SIZE >> V3D_MMU_PAGE_SHIFT; i++)
++		for (i = 0; i < V3D_PAGE_FACTOR; i++)
+ 			v3d->pt[page++] = pte + i;
+ 	}
+ 
+-	WARN_ON_ONCE(page - bo->node.start !=
++	WARN_ON_ONCE(page - (bo->node.start * V3D_PAGE_FACTOR) !=
+ 		     shmem_obj->base.size >> V3D_MMU_PAGE_SHIFT);
+ 
+ 	if (v3d_mmu_flush_all(v3d))
+@@ -115,10 +116,10 @@ void v3d_mmu_remove_ptes(struct v3d_bo *
+ {
+ 	struct v3d_dev *v3d = to_v3d_dev(bo->base.base.dev);
+ 	u32 npages = bo->base.base.size >> V3D_MMU_PAGE_SHIFT;
+-	u32 page;
++	u32 page = bo->node.start * V3D_PAGE_FACTOR;
+ 
+-	for (page = bo->node.start; page < bo->node.start + npages; page++)
+-		v3d->pt[page] = 0;
++	while (npages--)
++		v3d->pt[page++] = 0;
+ 
+ 	if (v3d_mmu_flush_all(v3d))
+ 		dev_err(v3d->drm.dev, "MMU flush timeout\n");
diff --git a/target/linux/bcm27xx/patches-6.1/950-0906-dt-bindings-gpu-v3d-Add-BCM2712-to-compatibility-lis.patch b/target/linux/bcm27xx/patches-6.1/950-0906-dt-bindings-gpu-v3d-Add-BCM2712-to-compatibility-lis.patch
new file mode 100644
index 0000000000..43c5c395c9
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0906-dt-bindings-gpu-v3d-Add-BCM2712-to-compatibility-lis.patch
@@ -0,0 +1,19 @@
+From 5970fa51663511d7f773db7109ff6fa2504f186a Mon Sep 17 00:00:00 2001
+From: Iago Toral Quiroga <itoral@igalia.com>
+Date: Thu, 2 Mar 2023 11:56:52 +0100
+Subject: [PATCH] dt-bindings: gpu: v3d: Add BCM2712 to compatibility list
+
+---
+ Documentation/devicetree/bindings/gpu/brcm,bcm-v3d.yaml | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/Documentation/devicetree/bindings/gpu/brcm,bcm-v3d.yaml
++++ b/Documentation/devicetree/bindings/gpu/brcm,bcm-v3d.yaml
+@@ -16,6 +16,7 @@ properties:
+ 
+   compatible:
+     enum:
++      - brcm,2712-v3d
+       - brcm,2711-v3d
+       - brcm,7268-v3d
+       - brcm,7278-v3d
diff --git a/target/linux/bcm27xx/patches-6.1/950-0907-drivers-char-add-generic-gpiomem-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0907-drivers-char-add-generic-gpiomem-driver.patch
new file mode 100644
index 0000000000..14e6b0a9e4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0907-drivers-char-add-generic-gpiomem-driver.patch
@@ -0,0 +1,328 @@
+From fdf9cab5eaa849e90b12e17718bc47130a91433c Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Tue, 25 Apr 2023 15:52:13 +0100
+Subject: [PATCH] drivers: char: add generic gpiomem driver
+
+Based on bcm2835-gpiomem.
+
+We allow export of the "GPIO registers" to userspace via a chardev as
+this allows for finer access control (e.g. users must be group gpio, root
+not required).
+
+This driver allows access to either rp1-gpiomem or gpiomem, depending on
+which nodes are populated in devicetree.
+
+RP1 has a different look-and-feel to BCM283x SoCs as it has split ranges
+for IO controls and the parallel registered OE/IN/OUT access. To handle
+this, the driver concatenates the ranges for an IO bank and the
+corresponding RIO instance into a contiguous buffer.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/char/Kconfig               |   8 +
+ drivers/char/Makefile              |   1 +
+ drivers/char/raspberrypi-gpiomem.c | 276 +++++++++++++++++++++++++++++
+ 3 files changed, 285 insertions(+)
+ create mode 100644 drivers/char/raspberrypi-gpiomem.c
+
+--- a/drivers/char/Kconfig
++++ b/drivers/char/Kconfig
+@@ -461,4 +461,12 @@ config RANDOM_TRUST_BOOTLOADER
+ 	  believe its RNG facilities may be faulty. This may also be configured
+ 	  at boot time with "random.trust_bootloader=on/off".
+ 
++config RASPBERRYPI_GPIOMEM
++        tristate "Rootless GPIO access via mmap() on Raspberry Pi boards"
++        default n
++        help
++                Provides users with root-free access to the GPIO registers
++                on the board. Calling mmap(/dev/gpiomem) will map the GPIO
++                register page to the user's pointer.
++
+ endmenu
+--- a/drivers/char/Makefile
++++ b/drivers/char/Makefile
+@@ -46,3 +46,4 @@ obj-$(CONFIG_XILLYBUS_CLASS)	+= xillybus
+ obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
+ obj-$(CONFIG_ADI)		+= adi.o
+ obj-$(CONFIG_BRCM_CHAR_DRIVERS) += broadcom/
++obj-$(CONFIG_RASPBERRYPI_GPIOMEM) += raspberrypi-gpiomem.o
+--- /dev/null
++++ b/drivers/char/raspberrypi-gpiomem.c
+@@ -0,0 +1,276 @@
++// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
++/**
++ * raspberrypi-gpiomem.c
++ *
++ * Provides MMIO access to discontiguous section of Device memory as a linear
++ * user mapping. Successor to bcm2835-gpiomem.c.
++ *
++ * Copyright (c) 2023, Raspberry Pi Ltd.
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/mm.h>
++#include <linux/slab.h>
++#include <linux/cdev.h>
++#include <linux/pagemap.h>
++#include <linux/io.h>
++
++#define DRIVER_NAME "rpi-gpiomem"
++#define DEVICE_MINOR 0
++
++/*
++ * Sensible max for a hypothetical "gpio" controller that splits pads,
++ * IO controls, GPIO in/out/enable, and function selection into different
++ * ranges. Most use only one or two.
++ */
++#define MAX_RANGES 4
++
++struct io_windows {
++	unsigned long phys_base;
++	unsigned long len;
++};
++
++struct rpi_gpiomem_priv {
++	dev_t devid;
++	struct class *class;
++	struct cdev rpi_gpiomem_cdev;
++	struct device *dev;
++	const char *name;
++	unsigned int nr_wins;
++	struct io_windows iowins[4];
++};
++
++static int rpi_gpiomem_open(struct inode *inode, struct file *file)
++{
++	int dev = iminor(inode);
++	int ret = 0;
++	struct rpi_gpiomem_priv *priv;
++
++	if (dev != DEVICE_MINOR)
++		ret = -ENXIO;
++
++	priv = container_of(inode->i_cdev, struct rpi_gpiomem_priv,
++				rpi_gpiomem_cdev);
++	if (!priv)
++		return -EINVAL;
++	file->private_data = priv;
++	return ret;
++}
++
++static int rpi_gpiomem_release(struct inode *inode, struct file *file)
++{
++	int dev = iminor(inode);
++	int ret = 0;
++
++	if (dev != DEVICE_MINOR)
++		ret = -ENXIO;
++
++	return ret;
++}
++
++static const struct vm_operations_struct rpi_gpiomem_vm_ops = {
++#ifdef CONFIG_HAVE_IOREMAP_PROT
++	.access = generic_access_phys
++#endif
++};
++
++static int rpi_gpiomem_mmap(struct file *file, struct vm_area_struct *vma)
++{
++	int i;
++	struct rpi_gpiomem_priv *priv;
++	unsigned long base;
++	unsigned long len = 0;
++	unsigned long offset;
++
++	priv = file->private_data;
++	/*
++	 * Userspace must provide a virtual address space at least
++	 * the size of the concatenated ranges.
++	 */
++	for (i = 0; i < priv->nr_wins; i++)
++		len += priv->iowins[i].len;
++	if (len > vma->vm_end - vma->vm_start + 1)
++		return -EINVAL;
++
++	vma->vm_ops = &rpi_gpiomem_vm_ops;
++	offset = vma->vm_start;
++	for (i = 0; i < priv->nr_wins; i++) {
++		base = priv->iowins[i].phys_base >> PAGE_SHIFT;
++		len = priv->iowins[i].len;
++		vma->vm_page_prot = phys_mem_access_prot(file, base, len,
++							 vma->vm_page_prot);
++		if (remap_pfn_range(vma, offset,
++			    base, len,
++			    vma->vm_page_prot))
++			break;
++		offset += len;
++	}
++
++	if (i < priv->nr_wins)
++		return -EAGAIN;
++
++	return 0;
++}
++
++static const struct file_operations rpi_gpiomem_fops = {
++	.owner = THIS_MODULE,
++	.open = rpi_gpiomem_open,
++	.release = rpi_gpiomem_release,
++	.mmap = rpi_gpiomem_mmap,
++};
++
++static const struct of_device_id rpi_gpiomem_of_match[];
++
++static int rpi_gpiomem_probe(struct platform_device *pdev)
++{
++	int err, i;
++	const struct of_device_id *id;
++	struct device *dev = &pdev->dev;
++	struct device_node *node = dev->of_node;
++	struct resource *ioresource;
++	struct rpi_gpiomem_priv *priv;
++
++	/* Allocate buffers and instance data */
++
++	priv = kzalloc(sizeof(struct rpi_gpiomem_priv), GFP_KERNEL);
++
++	if (!priv) {
++		err = -ENOMEM;
++		goto failed_inst_alloc;
++	}
++	platform_set_drvdata(pdev, priv);
++
++	priv->dev = dev;
++	id = of_match_device(rpi_gpiomem_of_match, dev);
++	if (!id)
++		return -EINVAL;
++
++	/*
++	 * Device node naming - for legacy (bcm2835) DT bindings, the driver
++	 * created the node based on a hardcoded name - for new bindings,
++	 * take the node name from DT.
++	 */
++	if (id == &rpi_gpiomem_of_match[0]) {
++		priv->name = "gpiomem";
++	} else {
++		err = of_property_read_string(node, "chardev-name", &priv->name);
++		if (err)
++			return -EINVAL;
++	}
++
++	/*
++	 * Go find the register ranges associated with this instance
++	 */
++	for (i = 0; i < MAX_RANGES; i++) {
++		ioresource = platform_get_resource(pdev, IORESOURCE_MEM, i);
++		if (!ioresource && i == 0) {
++			dev_err(priv->dev, "failed to get IO resource - no ranges available\n");
++			err = -ENOENT;
++			goto failed_get_resource;
++		}
++		if (!ioresource)
++			break;
++
++		priv->iowins[i].phys_base = ioresource->start;
++		priv->iowins[i].len = (ioresource->end + 1) - ioresource->start;
++		dev_info(&pdev->dev, "window base 0x%08lx size 0x%08lx\n",
++			 priv->iowins[i].phys_base, priv->iowins[i].len);
++		priv->nr_wins++;
++	}
++
++	/* Create character device entries */
++
++	err = alloc_chrdev_region(&priv->devid,
++				  DEVICE_MINOR, 1, priv->name);
++	if (err != 0) {
++		dev_err(priv->dev, "unable to allocate device number");
++		goto failed_alloc_chrdev;
++	}
++	cdev_init(&priv->rpi_gpiomem_cdev, &rpi_gpiomem_fops);
++	priv->rpi_gpiomem_cdev.owner = THIS_MODULE;
++	err = cdev_add(&priv->rpi_gpiomem_cdev, priv->devid, 1);
++	if (err != 0) {
++		dev_err(priv->dev, "unable to register device");
++		goto failed_cdev_add;
++	}
++
++	/* Create sysfs entries */
++
++	priv->class = class_create(THIS_MODULE, priv->name);
++	if (IS_ERR(priv->class)) {
++		err = PTR_ERR(priv->class);
++		goto failed_class_create;
++	}
++
++	dev = device_create(priv->class, NULL, priv->devid, NULL, priv->name);
++	if (IS_ERR(dev)) {
++		err = PTR_ERR(dev);
++		goto failed_device_create;
++	}
++
++	dev_info(priv->dev, "initialised %u regions as /dev/%s\n",
++		 priv->nr_wins, priv->name);
++
++	return 0;
++
++failed_device_create:
++	class_destroy(priv->class);
++failed_class_create:
++	cdev_del(&priv->rpi_gpiomem_cdev);
++failed_cdev_add:
++	unregister_chrdev_region(priv->devid, 1);
++failed_alloc_chrdev:
++failed_get_resource:
++	kfree(priv);
++failed_inst_alloc:
++	dev_err(&pdev->dev, "could not load rpi_gpiomem");
++	return err;
++}
++
++static int rpi_gpiomem_remove(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct rpi_gpiomem_priv *priv = platform_get_drvdata(pdev);
++
++	device_destroy(priv->class, priv->devid);
++	class_destroy(priv->class);
++	cdev_del(&priv->rpi_gpiomem_cdev);
++	unregister_chrdev_region(priv->devid, 1);
++	kfree(priv);
++
++	dev_info(dev, "%s driver removed - OK", priv->name);
++	return 0;
++}
++
++static const struct of_device_id rpi_gpiomem_of_match[] = {
++	{
++		.compatible = "brcm,bcm2835-gpiomem",
++	},
++	{
++		.compatible = "raspberrypi,gpiomem",
++	},
++	{ /* sentinel */ },
++};
++
++MODULE_DEVICE_TABLE(of, rpi_gpiomem_of_match);
++
++static struct platform_driver rpi_gpiomem_driver = {
++	.probe = rpi_gpiomem_probe,
++	.remove = rpi_gpiomem_remove,
++	.driver = {
++		   .name = DRIVER_NAME,
++		   .owner = THIS_MODULE,
++		   .of_match_table = rpi_gpiomem_of_match,
++		   },
++};
++
++module_platform_driver(rpi_gpiomem_driver);
++
++MODULE_ALIAS("platform:rpi-gpiomem");
++MODULE_LICENSE("Dual BSD/GPL");
++MODULE_DESCRIPTION("Driver for accessing GPIOs from userspace");
++MODULE_AUTHOR("Jonathan Bell <jonathan@raspberrypi.com>");
diff --git a/target/linux/bcm27xx/patches-6.1/950-0909-drivers-char-delete-bcm2835-gpiomem.patch b/target/linux/bcm27xx/patches-6.1/950-0909-drivers-char-delete-bcm2835-gpiomem.patch
new file mode 100644
index 0000000000..5d6eb16fb2
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0909-drivers-char-delete-bcm2835-gpiomem.patch
@@ -0,0 +1,301 @@
+From 27bda80061b46e18fe83be11228df5365363b377 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Wed, 26 Apr 2023 13:44:15 +0100
+Subject: [PATCH] drivers: char: delete bcm2835-gpiomem
+
+This functionality is now provided by raspberrypi-gpiomem.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/char/broadcom/Kconfig           |   8 -
+ drivers/char/broadcom/Makefile          |   1 -
+ drivers/char/broadcom/bcm2835-gpiomem.c | 258 ------------------------
+ 3 files changed, 267 deletions(-)
+ delete mode 100644 drivers/char/broadcom/bcm2835-gpiomem.c
+
+--- a/drivers/char/broadcom/Kconfig
++++ b/drivers/char/broadcom/Kconfig
+@@ -23,14 +23,6 @@ config BCM_VCIO
+ 
+ endif
+ 
+-config BCM2835_DEVGPIOMEM
+-	tristate "/dev/gpiomem rootless GPIO access via mmap() on the BCM2835"
+-	default m
+-	help
+-		Provides users with root-free access to the GPIO registers
+-		on the 2835. Calling mmap(/dev/gpiomem) will map the GPIO
+-		register page to the user's pointer.
+-
+ config BCM2835_SMI_DEV
+ 	tristate "Character device driver for BCM2835 Secondary Memory Interface"
+ 	depends on BCM2835_SMI
+--- a/drivers/char/broadcom/Makefile
++++ b/drivers/char/broadcom/Makefile
+@@ -1,5 +1,4 @@
+ obj-$(CONFIG_BCM2708_VCMEM)	+= vc_mem.o
+ obj-$(CONFIG_BCM_VCIO)		+= vcio.o
+-obj-$(CONFIG_BCM2835_DEVGPIOMEM)+= bcm2835-gpiomem.o
+ obj-$(CONFIG_BCM2835_SMI_DEV)	+= bcm2835_smi_dev.o
+ obj-$(CONFIG_RPIVID_MEM)	+= rpivid-mem.o
+--- a/drivers/char/broadcom/bcm2835-gpiomem.c
++++ /dev/null
+@@ -1,258 +0,0 @@
+-/**
+- * GPIO memory device driver
+- *
+- * Creates a chardev /dev/gpiomem which will provide user access to
+- * the BCM2835's GPIO registers when it is mmap()'d.
+- * No longer need root for user GPIO access, but without relaxing permissions
+- * on /dev/mem.
+- *
+- * Written by Luke Wren <luke@raspberrypi.org>
+- * Copyright (c) 2015, Raspberry Pi (Trading) Ltd.
+- *
+- * Redistribution and use in source and binary forms, with or without
+- * modification, are permitted provided that the following conditions
+- * are met:
+- * 1. Redistributions of source code must retain the above copyright
+- *    notice, this list of conditions, and the following disclaimer,
+- *    without modification.
+- * 2. Redistributions in binary form must reproduce the above copyright
+- *    notice, this list of conditions and the following disclaimer in the
+- *    documentation and/or other materials provided with the distribution.
+- * 3. The names of the above-listed copyright holders may not be used
+- *    to endorse or promote products derived from this software without
+- *    specific prior written permission.
+- *
+- * ALTERNATIVELY, this software may be distributed under the terms of the
+- * GNU General Public License ("GPL") version 2, as published by the Free
+- * Software Foundation.
+- *
+- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+- */
+-
+-#include <linux/kernel.h>
+-#include <linux/module.h>
+-#include <linux/of.h>
+-#include <linux/platform_device.h>
+-#include <linux/mm.h>
+-#include <linux/slab.h>
+-#include <linux/cdev.h>
+-#include <linux/pagemap.h>
+-#include <linux/io.h>
+-
+-#define DEVICE_NAME "bcm2835-gpiomem"
+-#define DRIVER_NAME "gpiomem-bcm2835"
+-#define DEVICE_MINOR 0
+-
+-struct bcm2835_gpiomem_instance {
+-	unsigned long gpio_regs_phys;
+-	struct device *dev;
+-};
+-
+-static struct cdev bcm2835_gpiomem_cdev;
+-static dev_t bcm2835_gpiomem_devid;
+-static struct class *bcm2835_gpiomem_class;
+-static struct device *bcm2835_gpiomem_dev;
+-static struct bcm2835_gpiomem_instance *inst;
+-
+-
+-/****************************************************************************
+-*
+-*   GPIO mem chardev file ops
+-*
+-***************************************************************************/
+-
+-static int bcm2835_gpiomem_open(struct inode *inode, struct file *file)
+-{
+-	int dev = iminor(inode);
+-	int ret = 0;
+-
+-	if (dev != DEVICE_MINOR) {
+-		dev_err(inst->dev, "Unknown minor device: %d", dev);
+-		ret = -ENXIO;
+-	}
+-	return ret;
+-}
+-
+-static int bcm2835_gpiomem_release(struct inode *inode, struct file *file)
+-{
+-	int dev = iminor(inode);
+-	int ret = 0;
+-
+-	if (dev != DEVICE_MINOR) {
+-		dev_err(inst->dev, "Unknown minor device %d", dev);
+-		ret = -ENXIO;
+-	}
+-	return ret;
+-}
+-
+-static const struct vm_operations_struct bcm2835_gpiomem_vm_ops = {
+-#ifdef CONFIG_HAVE_IOREMAP_PROT
+-	.access = generic_access_phys
+-#endif
+-};
+-
+-static int bcm2835_gpiomem_mmap(struct file *file, struct vm_area_struct *vma)
+-{
+-	/* Ignore what the user says - they're getting the GPIO regs
+-	   whether they like it or not! */
+-	unsigned long gpio_page = inst->gpio_regs_phys >> PAGE_SHIFT;
+-
+-	vma->vm_page_prot = phys_mem_access_prot(file, gpio_page,
+-						 PAGE_SIZE,
+-						 vma->vm_page_prot);
+-	vma->vm_ops = &bcm2835_gpiomem_vm_ops;
+-	if (remap_pfn_range(vma, vma->vm_start,
+-			gpio_page,
+-			PAGE_SIZE,
+-			vma->vm_page_prot)) {
+-		return -EAGAIN;
+-	}
+-	return 0;
+-}
+-
+-static const struct file_operations
+-bcm2835_gpiomem_fops = {
+-	.owner = THIS_MODULE,
+-	.open = bcm2835_gpiomem_open,
+-	.release = bcm2835_gpiomem_release,
+-	.mmap = bcm2835_gpiomem_mmap,
+-};
+-
+-
+- /****************************************************************************
+-*
+-*   Probe and remove functions
+-*
+-***************************************************************************/
+-
+-
+-static int bcm2835_gpiomem_probe(struct platform_device *pdev)
+-{
+-	int err;
+-	void *ptr_err;
+-	struct device *dev = &pdev->dev;
+-	struct resource *ioresource;
+-
+-	/* Allocate buffers and instance data */
+-
+-	inst = kzalloc(sizeof(struct bcm2835_gpiomem_instance), GFP_KERNEL);
+-
+-	if (!inst) {
+-		err = -ENOMEM;
+-		goto failed_inst_alloc;
+-	}
+-
+-	inst->dev = dev;
+-
+-	ioresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+-	if (ioresource) {
+-		inst->gpio_regs_phys = ioresource->start;
+-	} else {
+-		dev_err(inst->dev, "failed to get IO resource");
+-		err = -ENOENT;
+-		goto failed_get_resource;
+-	}
+-
+-	/* Create character device entries */
+-
+-	err = alloc_chrdev_region(&bcm2835_gpiomem_devid,
+-				  DEVICE_MINOR, 1, DEVICE_NAME);
+-	if (err != 0) {
+-		dev_err(inst->dev, "unable to allocate device number");
+-		goto failed_alloc_chrdev;
+-	}
+-	cdev_init(&bcm2835_gpiomem_cdev, &bcm2835_gpiomem_fops);
+-	bcm2835_gpiomem_cdev.owner = THIS_MODULE;
+-	err = cdev_add(&bcm2835_gpiomem_cdev, bcm2835_gpiomem_devid, 1);
+-	if (err != 0) {
+-		dev_err(inst->dev, "unable to register device");
+-		goto failed_cdev_add;
+-	}
+-
+-	/* Create sysfs entries */
+-
+-	bcm2835_gpiomem_class = class_create(THIS_MODULE, DEVICE_NAME);
+-	ptr_err = bcm2835_gpiomem_class;
+-	if (IS_ERR(ptr_err))
+-		goto failed_class_create;
+-
+-	bcm2835_gpiomem_dev = device_create(bcm2835_gpiomem_class, NULL,
+-					bcm2835_gpiomem_devid, NULL,
+-					"gpiomem");
+-	ptr_err = bcm2835_gpiomem_dev;
+-	if (IS_ERR(ptr_err))
+-		goto failed_device_create;
+-
+-	dev_info(inst->dev, "Initialised: Registers at 0x%08lx",
+-		inst->gpio_regs_phys);
+-
+-	return 0;
+-
+-failed_device_create:
+-	class_destroy(bcm2835_gpiomem_class);
+-failed_class_create:
+-	cdev_del(&bcm2835_gpiomem_cdev);
+-	err = PTR_ERR(ptr_err);
+-failed_cdev_add:
+-	unregister_chrdev_region(bcm2835_gpiomem_devid, 1);
+-failed_alloc_chrdev:
+-failed_get_resource:
+-	kfree(inst);
+-failed_inst_alloc:
+-	dev_err(inst->dev, "could not load bcm2835_gpiomem");
+-	return err;
+-}
+-
+-static int bcm2835_gpiomem_remove(struct platform_device *pdev)
+-{
+-	struct device *dev = inst->dev;
+-
+-	kfree(inst);
+-	device_destroy(bcm2835_gpiomem_class, bcm2835_gpiomem_devid);
+-	class_destroy(bcm2835_gpiomem_class);
+-	cdev_del(&bcm2835_gpiomem_cdev);
+-	unregister_chrdev_region(bcm2835_gpiomem_devid, 1);
+-
+-	dev_info(dev, "GPIO mem driver removed - OK");
+-	return 0;
+-}
+-
+- /****************************************************************************
+-*
+-*   Register the driver with device tree
+-*
+-***************************************************************************/
+-
+-static const struct of_device_id bcm2835_gpiomem_of_match[] = {
+-	{.compatible = "brcm,bcm2835-gpiomem",},
+-	{ /* sentinel */ },
+-};
+-
+-MODULE_DEVICE_TABLE(of, bcm2835_gpiomem_of_match);
+-
+-static struct platform_driver bcm2835_gpiomem_driver = {
+-	.probe = bcm2835_gpiomem_probe,
+-	.remove = bcm2835_gpiomem_remove,
+-	.driver = {
+-		   .name = DRIVER_NAME,
+-		   .owner = THIS_MODULE,
+-		   .of_match_table = bcm2835_gpiomem_of_match,
+-		   },
+-};
+-
+-module_platform_driver(bcm2835_gpiomem_driver);
+-
+-MODULE_ALIAS("platform:gpiomem-bcm2835");
+-MODULE_LICENSE("GPL");
+-MODULE_DESCRIPTION("gpiomem driver for accessing GPIO from userspace");
+-MODULE_AUTHOR("Luke Wren <luke@raspberrypi.org>");
diff --git a/target/linux/bcm27xx/patches-6.1/950-0910-drivers-hwmon-rp1-adc-check-conversion-validity-befo.patch b/target/linux/bcm27xx/patches-6.1/950-0910-drivers-hwmon-rp1-adc-check-conversion-validity-befo.patch
new file mode 100644
index 0000000000..557b7ac406
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0910-drivers-hwmon-rp1-adc-check-conversion-validity-befo.patch
@@ -0,0 +1,34 @@
+From 3cafcfbab9b5f3f1357b415b6ca09911eeb405d6 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Thu, 4 May 2023 15:48:53 +0100
+Subject: [PATCH] drivers: hwmon: rp1-adc: check conversion validity before
+ supplying value
+
+The SAR ADC architecture may complete a conversion but instability in the
+comparator can corrupt the result. Such corruption is signalled in the CS
+ERR bit, asserted alongside each conversion result.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/hwmon/rp1-adc.c | 10 ++++++++--
+ 1 file changed, 8 insertions(+), 2 deletions(-)
+
+--- a/drivers/hwmon/rp1-adc.c
++++ b/drivers/hwmon/rp1-adc.c
+@@ -97,8 +97,14 @@ static int rp1_adc_read(struct rp1_adc_d
+ 	       data->base + RP1_ADC_RWTYPE_SET + RP1_ADC_CS);
+ 
+ 	ret = rp1_adc_ready_wait(data);
+-	if (!ret)
+-		*val = readl(data->base + RP1_ADC_RESULT);
++	if (ret)
++		return ret;
++
++	/* Asserted if the completed conversion had a convergence error */
++	if (readl(data->base + RP1_ADC_CS) & RP1_ADC_CS_ERR)
++		return -EIO;
++
++	*val = readl(data->base + RP1_ADC_RESULT);
+ 
+ 	spin_unlock(&data->lock);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0911-dmaengine-bcm2835-Add-BCM2712-support.patch b/target/linux/bcm27xx/patches-6.1/950-0911-dmaengine-bcm2835-Add-BCM2712-support.patch
new file mode 100644
index 0000000000..58095cf8fd
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0911-dmaengine-bcm2835-Add-BCM2712-support.patch
@@ -0,0 +1,36 @@
+From 87c5545f9a66984894384da5f8c2eeb60983732a Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 8 Mar 2023 16:53:38 +0000
+Subject: [PATCH] dmaengine: bcm2835: Add BCM2712 support
+
+BCM2712 has 6 40-bit channels - DMA6 to DMA11. Add a new compatible
+string to indicate that the current platform is BCM2712.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/dma/bcm2835-dma.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+--- a/drivers/dma/bcm2835-dma.c
++++ b/drivers/dma/bcm2835-dma.c
+@@ -331,6 +331,12 @@ static const struct bcm2835_dma_cfg_data
+ 	.dma_mask = DMA_BIT_MASK(36),
+ };
+ 
++static const struct bcm2835_dma_cfg_data bcm2712_dma_cfg = {
++	.chan_40bit_mask = BIT(6) | BIT(7) | BIT(8) | BIT(9) |
++				 BIT(10) | BIT(11),
++	.dma_mask = DMA_BIT_MASK(40),
++};
++
+ static inline size_t bcm2835_dma_max_frame_length(struct bcm2835_chan *c)
+ {
+ 	/* lite and normal channels have different max frame length */
+@@ -1260,6 +1266,7 @@ EXPORT_SYMBOL(bcm2711_dma40_memcpy);
+ static const struct of_device_id bcm2835_dma_of_match[] = {
+ 	{ .compatible = "brcm,bcm2835-dma", .data = &bcm2835_dma_cfg },
+ 	{ .compatible = "brcm,bcm2711-dma", .data = &bcm2711_dma_cfg },
++	{ .compatible = "brcm,bcm2712-dma", .data = &bcm2712_dma_cfg },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, bcm2835_dma_of_match);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0912-dmaengine-bcm2835-HACK-Support-DMA-Lite-channels.patch b/target/linux/bcm27xx/patches-6.1/950-0912-dmaengine-bcm2835-HACK-Support-DMA-Lite-channels.patch
new file mode 100644
index 0000000000..6f651a65f6
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0912-dmaengine-bcm2835-HACK-Support-DMA-Lite-channels.patch
@@ -0,0 +1,57 @@
+From a671a2774cb3bcfb144622149757f6821aa0604c Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 13 Apr 2023 16:52:19 +0200
+Subject: [PATCH] dmaengine: bcm2835: HACK: Support DMA-Lite channels
+
+The BCM2712 has a DMA-Lite controller that is basically a BCM2835-style
+DMA controller that supports 40 bits DMA addresses.
+
+We need it for HDMI audio to work, but this breaks BCM2835-38 so we
+should rework this later.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/dma/bcm2835-dma.c | 11 +++++++----
+ 1 file changed, 7 insertions(+), 4 deletions(-)
+
+--- a/drivers/dma/bcm2835-dma.c
++++ b/drivers/dma/bcm2835-dma.c
+@@ -550,7 +550,7 @@ static struct bcm2835_desc *bcm2835_dma_
+ 			control_block->info = info;
+ 			control_block->src = src;
+ 			control_block->dst = dst;
+-			control_block->stride = 0;
++			control_block->stride = (upper_32_bits(dst) << 8) | upper_32_bits(src);
+ 			control_block->next = 0;
+ 		}
+ 
+@@ -575,7 +575,7 @@ static struct bcm2835_desc *bcm2835_dma_
+ 			 d->cb_list[frame - 1].cb)->next_cb =
+ 				to_bcm2711_cbaddr(cb_entry->paddr);
+ 		if (frame && !c->is_40bit_channel)
+-			d->cb_list[frame - 1].cb->next = cb_entry->paddr;
++			d->cb_list[frame - 1].cb->next = to_bcm2711_cbaddr(cb_entry->paddr);
+ 
+ 		/* update src and dst and length */
+ 		if (src && (info & BCM2835_DMA_S_INC)) {
+@@ -760,7 +760,10 @@ static void bcm2835_dma_start_desc(struc
+ 		writel(BCM2711_DMA40_ACTIVE | BCM2711_DMA40_PROT | BCM2711_DMA40_CS_FLAGS(c->dreq),
+ 		       c->chan_base + BCM2711_DMA40_CS);
+ 	} else {
+-		writel(d->cb_list[0].paddr, c->chan_base + BCM2835_DMA_ADDR);
++		writel(BIT(31), c->chan_base + BCM2835_DMA_CS);
++
++		writel(to_bcm2711_cbaddr(d->cb_list[0].paddr),
++		       c->chan_base + BCM2835_DMA_ADDR);
+ 		writel(BCM2835_DMA_ACTIVE | BCM2835_DMA_CS_FLAGS(c->dreq),
+ 		       c->chan_base + BCM2835_DMA_CS);
+ 	}
+@@ -1129,7 +1132,7 @@ static struct dma_async_tx_descriptor *b
+ 		 d->cb_list[frames - 1].cb)->next_cb =
+ 			to_bcm2711_cbaddr(d->cb_list[0].paddr);
+ 	else
+-		d->cb_list[d->frames - 1].cb->next = d->cb_list[0].paddr;
++		d->cb_list[d->frames - 1].cb->next = to_bcm2711_cbaddr(d->cb_list[0].paddr);
+ 
+ 	return vchan_tx_prep(&c->vc, &d->vd, flags);
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0913-clk-bcm-rpi-Add-disp-clock.patch b/target/linux/bcm27xx/patches-6.1/950-0913-clk-bcm-rpi-Add-disp-clock.patch
new file mode 100644
index 0000000000..6f5e55d956
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0913-clk-bcm-rpi-Add-disp-clock.patch
@@ -0,0 +1,46 @@
+From c8fd69c6f567bd43ba084b95a987532940465ef5 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 24 Feb 2023 14:12:50 +0100
+Subject: [PATCH] clk: bcm: rpi: Add disp clock
+
+BCM2712 has an extra clock exposed by the firmware called DISP, and used
+by (at least) the HVS. Let's add it to the list of clocks to register in
+Linux.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/clk/bcm/clk-raspberrypi.c          | 5 +++++
+ include/soc/bcm2835/raspberrypi-firmware.h | 1 +
+ 2 files changed, 6 insertions(+)
+
+--- a/drivers/clk/bcm/clk-raspberrypi.c
++++ b/drivers/clk/bcm/clk-raspberrypi.c
+@@ -34,6 +34,7 @@ static char *rpi_firmware_clk_names[] =
+ 	[RPI_FIRMWARE_M2MC_CLK_ID]	= "m2mc",
+ 	[RPI_FIRMWARE_PIXEL_BVB_CLK_ID]	= "pixel-bvb",
+ 	[RPI_FIRMWARE_VEC_CLK_ID]	= "vec",
++	[RPI_FIRMWARE_DISP_CLK_ID]	= "disp",
+ };
+ 
+ #define RPI_FIRMWARE_STATE_ENABLE_BIT	BIT(0)
+@@ -139,6 +140,10 @@ raspberrypi_clk_variants[RPI_FIRMWARE_NU
+ 		.export = true,
+ 		.minimize = true,
+ 	},
++	[RPI_FIRMWARE_DISP_CLK_ID] = {
++		.export = true,
++		.minimize = true,
++	},
+ };
+ 
+ /*
+--- a/include/soc/bcm2835/raspberrypi-firmware.h
++++ b/include/soc/bcm2835/raspberrypi-firmware.h
+@@ -176,6 +176,7 @@ enum rpi_firmware_clk_id {
+ 	RPI_FIRMWARE_M2MC_CLK_ID,
+ 	RPI_FIRMWARE_PIXEL_BVB_CLK_ID,
+ 	RPI_FIRMWARE_VEC_CLK_ID,
++	RPI_FIRMWARE_DISP_CLK_ID,
+ 	RPI_FIRMWARE_NUM_CLK_ID,
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0914-net-phy-broadcom-optionally-enable-link-down-powersa.patch b/target/linux/bcm27xx/patches-6.1/950-0914-net-phy-broadcom-optionally-enable-link-down-powersa.patch
new file mode 100644
index 0000000000..2df48297b5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0914-net-phy-broadcom-optionally-enable-link-down-powersa.patch
@@ -0,0 +1,26 @@
+From 6370a6cd16a5aa9726bf209c0f0a3179f4011cb1 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Mon, 22 May 2023 15:31:17 +0100
+Subject: [PATCH] net: phy: broadcom: optionally enable link-down powersave
+ based on DT
+
+It's really a function of the board whether or not to use this feature
+as it may require MAC compatibility as well as interop testing.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/net/phy/broadcom.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/net/phy/broadcom.c
++++ b/drivers/net/phy/broadcom.c
+@@ -370,6 +370,9 @@ static int bcm54xx_config_init(struct ph
+ 	    (phydev->dev_flags & PHY_BRCM_CLEAR_RGMII_MODE))
+ 		bcm_phy_write_shadow(phydev, BCM54XX_SHD_RGMII_MODE, 0);
+ 
++	if (of_property_read_bool(np, "brcm,powerdown-enable"))
++		phydev->dev_flags |= PHY_BRCM_AUTO_PWRDWN_ENABLE;
++
+ 	bcm54xx_adjust_rxrefclk(phydev);
+ 
+ 	switch (BRCM_PHY_MODEL(phydev)) {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0915-dmaengine-bcm2835-Rename-to_bcm2711_cbaddr-to-to_40b.patch b/target/linux/bcm27xx/patches-6.1/950-0915-dmaengine-bcm2835-Rename-to_bcm2711_cbaddr-to-to_40b.patch
new file mode 100644
index 0000000000..ce59f6072b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0915-dmaengine-bcm2835-Rename-to_bcm2711_cbaddr-to-to_40b.patch
@@ -0,0 +1,75 @@
+From cfad3f71fc450639fc259d576d0903e9132fe34a Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Thu, 25 May 2023 14:48:28 +0100
+Subject: [PATCH] dmaengine: bcm2835: Rename to_bcm2711_cbaddr to
+ to_40bit_cbaddr
+
+As the shifted address also applies to bcm2712,
+give the function a more specific name.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/dma/bcm2835-dma.c | 16 ++++++++--------
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+--- a/drivers/dma/bcm2835-dma.c
++++ b/drivers/dma/bcm2835-dma.c
+@@ -390,7 +390,7 @@ static inline uint32_t to_bcm2711_dsti(u
+ 	       BCM2711_DMA40_BURST_LEN(BCM2835_DMA_GET_BURST_LENGTH(info));
+ }
+ 
+-static inline uint32_t to_bcm2711_cbaddr(dma_addr_t addr)
++static inline uint32_t to_40bit_cbaddr(dma_addr_t addr)
+ {
+ 	BUG_ON(addr & 0x1f);
+ 	return (addr >> 5);
+@@ -573,9 +573,9 @@ static struct bcm2835_desc *bcm2835_dma_
+ 		if (frame && c->is_40bit_channel)
+ 			((struct bcm2711_dma40_scb *)
+ 			 d->cb_list[frame - 1].cb)->next_cb =
+-				to_bcm2711_cbaddr(cb_entry->paddr);
++				to_40bit_cbaddr(cb_entry->paddr);
+ 		if (frame && !c->is_40bit_channel)
+-			d->cb_list[frame - 1].cb->next = to_bcm2711_cbaddr(cb_entry->paddr);
++			d->cb_list[frame - 1].cb->next = to_40bit_cbaddr(cb_entry->paddr);
+ 
+ 		/* update src and dst and length */
+ 		if (src && (info & BCM2835_DMA_S_INC)) {
+@@ -755,14 +755,14 @@ static void bcm2835_dma_start_desc(struc
+ 	c->desc = d = to_bcm2835_dma_desc(&vd->tx);
+ 
+ 	if (c->is_40bit_channel) {
+-		writel(to_bcm2711_cbaddr(d->cb_list[0].paddr),
++		writel(to_40bit_cbaddr(d->cb_list[0].paddr),
+ 		       c->chan_base + BCM2711_DMA40_CB);
+ 		writel(BCM2711_DMA40_ACTIVE | BCM2711_DMA40_PROT | BCM2711_DMA40_CS_FLAGS(c->dreq),
+ 		       c->chan_base + BCM2711_DMA40_CS);
+ 	} else {
+ 		writel(BIT(31), c->chan_base + BCM2835_DMA_CS);
+ 
+-		writel(to_bcm2711_cbaddr(d->cb_list[0].paddr),
++		writel(to_40bit_cbaddr(d->cb_list[0].paddr),
+ 		       c->chan_base + BCM2835_DMA_ADDR);
+ 		writel(BCM2835_DMA_ACTIVE | BCM2835_DMA_CS_FLAGS(c->dreq),
+ 		       c->chan_base + BCM2835_DMA_CS);
+@@ -1130,9 +1130,9 @@ static struct dma_async_tx_descriptor *b
+ 	if (c->is_40bit_channel)
+ 		((struct bcm2711_dma40_scb *)
+ 		 d->cb_list[frames - 1].cb)->next_cb =
+-			to_bcm2711_cbaddr(d->cb_list[0].paddr);
++			to_40bit_cbaddr(d->cb_list[0].paddr);
+ 	else
+-		d->cb_list[d->frames - 1].cb->next = to_bcm2711_cbaddr(d->cb_list[0].paddr);
++		d->cb_list[d->frames - 1].cb->next = to_40bit_cbaddr(d->cb_list[0].paddr);
+ 
+ 	return vchan_tx_prep(&c->vc, &d->vd, flags);
+ }
+@@ -1252,7 +1252,7 @@ void bcm2711_dma40_memcpy(dma_addr_t dst
+ 	scb->len = size;
+ 	scb->next_cb = 0;
+ 
+-	writel(to_bcm2711_cbaddr(memcpy_scb_dma), memcpy_chan + BCM2711_DMA40_CB);
++	writel(to_40bit_cbaddr(memcpy_scb_dma), memcpy_chan + BCM2711_DMA40_CB);
+ 	writel(BCM2711_DMA40_MEMCPY_FLAGS | BCM2711_DMA40_ACTIVE | BCM2711_DMA40_PROT,
+ 	       memcpy_chan + BCM2711_DMA40_CS);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0916-dmaengine-bcm2835-Fix-dma-driver-for-BCM2835-38.patch b/target/linux/bcm27xx/patches-6.1/950-0916-dmaengine-bcm2835-Fix-dma-driver-for-BCM2835-38.patch
new file mode 100644
index 0000000000..a2ff2a6bb0
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0916-dmaengine-bcm2835-Fix-dma-driver-for-BCM2835-38.patch
@@ -0,0 +1,77 @@
+From 75f44d1416c5de17865247d6d012c37f7650437c Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Wed, 24 May 2023 19:32:16 +0100
+Subject: [PATCH] dmaengine: bcm2835: Fix dma driver for BCM2835-38
+
+The previous commit broke support on older devices.
+Make the breaking parts of patch conditional on
+the device being used.
+
+Fixes: 6e1856ac7c39 ("dmaengine: bcm2835: HACK: Support DMA-Lite channels")
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/dma/bcm2835-dma.c | 17 +++++++++++++----
+ 1 file changed, 13 insertions(+), 4 deletions(-)
+
+--- a/drivers/dma/bcm2835-dma.c
++++ b/drivers/dma/bcm2835-dma.c
+@@ -102,6 +102,7 @@ struct bcm2835_chan {
+ 
+ 	bool is_lite_channel;
+ 	bool is_40bit_channel;
++	bool is_2712;
+ };
+ 
+ struct bcm2835_desc {
+@@ -550,7 +551,11 @@ static struct bcm2835_desc *bcm2835_dma_
+ 			control_block->info = info;
+ 			control_block->src = src;
+ 			control_block->dst = dst;
+-			control_block->stride = (upper_32_bits(dst) << 8) | upper_32_bits(src);
++			if (c->is_2712)
++				control_block->stride = (upper_32_bits(dst) << 8) |
++							upper_32_bits(src);
++			else
++				control_block->stride = 0;
+ 			control_block->next = 0;
+ 		}
+ 
+@@ -575,7 +580,8 @@ static struct bcm2835_desc *bcm2835_dma_
+ 			 d->cb_list[frame - 1].cb)->next_cb =
+ 				to_40bit_cbaddr(cb_entry->paddr);
+ 		if (frame && !c->is_40bit_channel)
+-			d->cb_list[frame - 1].cb->next = to_40bit_cbaddr(cb_entry->paddr);
++			d->cb_list[frame - 1].cb->next = c->is_2712 ?
++			to_40bit_cbaddr(cb_entry->paddr) : cb_entry->paddr;
+ 
+ 		/* update src and dst and length */
+ 		if (src && (info & BCM2835_DMA_S_INC)) {
+@@ -762,7 +768,7 @@ static void bcm2835_dma_start_desc(struc
+ 	} else {
+ 		writel(BIT(31), c->chan_base + BCM2835_DMA_CS);
+ 
+-		writel(to_40bit_cbaddr(d->cb_list[0].paddr),
++		writel(c->is_2712 ? to_40bit_cbaddr(d->cb_list[0].paddr) : d->cb_list[0].paddr,
+ 		       c->chan_base + BCM2835_DMA_ADDR);
+ 		writel(BCM2835_DMA_ACTIVE | BCM2835_DMA_CS_FLAGS(c->dreq),
+ 		       c->chan_base + BCM2835_DMA_CS);
+@@ -1132,7 +1138,8 @@ static struct dma_async_tx_descriptor *b
+ 		 d->cb_list[frames - 1].cb)->next_cb =
+ 			to_40bit_cbaddr(d->cb_list[0].paddr);
+ 	else
+-		d->cb_list[d->frames - 1].cb->next = to_40bit_cbaddr(d->cb_list[0].paddr);
++		d->cb_list[d->frames - 1].cb->next = c->is_2712 ?
++		to_40bit_cbaddr(d->cb_list[0].paddr) : d->cb_list[0].paddr;
+ 
+ 	return vchan_tx_prep(&c->vc, &d->vd, flags);
+ }
+@@ -1199,6 +1206,8 @@ static int bcm2835_dma_chan_init(struct
+ 	else if (readl(c->chan_base + BCM2835_DMA_DEBUG) &
+ 		 BCM2835_DMA_DEBUG_LITE)
+ 		c->is_lite_channel = true;
++	if (d->cfg_data->dma_mask == DMA_BIT_MASK(40))
++		c->is_2712 = true;
+ 
+ 	return 0;
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0917-drivers-iommu-Add-BCM2712-IOMMU.patch b/target/linux/bcm27xx/patches-6.1/950-0917-drivers-iommu-Add-BCM2712-IOMMU.patch
new file mode 100644
index 0000000000..92f43fa71b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0917-drivers-iommu-Add-BCM2712-IOMMU.patch
@@ -0,0 +1,855 @@
+From 5fd6ee7fd084838e09d4e463ae53cd9aaa7fce70 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Thu, 11 May 2023 16:37:34 +0100
+Subject: [PATCH] drivers: iommu: Add BCM2712 IOMMU
+
+Add a driver for BCM2712 IOMMUs.
+There is a small driver for the Shared IOMMU TLB Cache.
+Each IOMMU instance is a separate device.
+
+IOMMUs are set up with a "pass-through" range covering
+the lowest 40BGytes (which should cover all of SDRAM)
+for the benefit of non-IOMMU-aware devices that share
+a physical IOMMU; and translation for addresses in the
+range 40GB to 42GB.
+
+An optional parameter adds a DMA offset (which otherwise
+would be lost?) to virtual addresses for DMA masters on a
+bus such as PCIe.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/iommu/Kconfig               |   7 +
+ drivers/iommu/Makefile              |   1 +
+ drivers/iommu/bcm2712-iommu-cache.c |  77 ++++
+ drivers/iommu/bcm2712-iommu.c       | 672 ++++++++++++++++++++++++++++
+ drivers/iommu/bcm2712-iommu.h       |  45 ++
+ 5 files changed, 802 insertions(+)
+ create mode 100644 drivers/iommu/bcm2712-iommu-cache.c
+ create mode 100644 drivers/iommu/bcm2712-iommu.c
+ create mode 100644 drivers/iommu/bcm2712-iommu.h
+
+--- a/drivers/iommu/Kconfig
++++ b/drivers/iommu/Kconfig
+@@ -506,4 +506,11 @@ config SPRD_IOMMU
+ 
+ 	  Say Y here if you want to use the multimedia devices listed above.
+ 
++config BCM2712_IOMMU
++       tristate "BCM2712 IOMMU driver"
++       depends on ARM64 && ARCH_BCM
++       select IOMMU_API
++       help
++	 IOMMU driver for BCM2712
++
+ endif # IOMMU_SUPPORT
+--- a/drivers/iommu/Makefile
++++ b/drivers/iommu/Makefile
+@@ -31,3 +31,4 @@ obj-$(CONFIG_VIRTIO_IOMMU) += virtio-iom
+ obj-$(CONFIG_IOMMU_SVA) += iommu-sva-lib.o io-pgfault.o
+ obj-$(CONFIG_SPRD_IOMMU) += sprd-iommu.o
+ obj-$(CONFIG_APPLE_DART) += apple-dart.o
++obj-$(CONFIG_BCM2712_IOMMU) += bcm2712-iommu.o bcm2712-iommu-cache.o
+--- /dev/null
++++ b/drivers/iommu/bcm2712-iommu-cache.c
+@@ -0,0 +1,77 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * IOMMU driver for BCM2712
++ *
++ * Copyright (c) 2023 Raspberry Pi Ltd.
++ */
++
++#include "bcm2712-iommu.h"
++
++#include <linux/err.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/spinlock.h>
++
++#define MMUC_CONTROL_ENABLE   1
++#define MMUC_CONTROL_FLUSH    2
++#define MMUC_CONTROL_FLUSHING 4
++
++void bcm2712_iommu_cache_flush(struct bcm2712_iommu_cache *cache)
++{
++	unsigned long flags;
++	int i;
++
++	spin_lock_irqsave(&cache->hw_lock, flags);
++	if (cache->reg_base) {
++		/* Enable and flush the TLB cache */
++		writel(MMUC_CONTROL_ENABLE | MMUC_CONTROL_FLUSH,
++		       cache->reg_base);
++
++		/* Wait for flush to complete: it should be very quick */
++		for (i = 0; i < 1024; i++) {
++			if (!(MMUC_CONTROL_FLUSHING & readl(cache->reg_base)))
++				break;
++			cpu_relax();
++		}
++	}
++	spin_unlock_irqrestore(&cache->hw_lock, flags);
++}
++
++static int bcm2712_iommu_cache_probe(struct platform_device *pdev)
++{
++	struct bcm2712_iommu_cache *cache;
++
++	dev_info(&pdev->dev, __func__);
++	cache = devm_kzalloc(&pdev->dev, sizeof(*cache), GFP_KERNEL);
++	if (!cache)
++		return -ENOMEM;
++
++	cache->dev = &pdev->dev;
++	platform_set_drvdata(pdev, cache);
++	spin_lock_init(&cache->hw_lock);
++
++	/* Get IOMMUC registers; we only use the first register (IOMMUC_CTRL) */
++	cache->reg_base = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(cache->reg_base)) {
++		dev_err(&pdev->dev, "Failed to get IOMMU Cache registers address\n");
++		cache->reg_base = NULL;
++	}
++	return 0;
++}
++
++static const struct of_device_id bcm2712_iommu_cache_of_match[] = {
++	{
++		. compatible = "brcm,bcm2712-iommuc"
++	},
++	{ /* sentinel */ },
++};
++
++static struct platform_driver bcm2712_iommu_cache_driver = {
++	.probe = bcm2712_iommu_cache_probe,
++	.driver = {
++		.name = "bcm2712-iommu-cache",
++		.of_match_table = bcm2712_iommu_cache_of_match
++	},
++};
++
++builtin_platform_driver(bcm2712_iommu_cache_driver);
+--- /dev/null
++++ b/drivers/iommu/bcm2712-iommu.c
+@@ -0,0 +1,672 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * IOMMU driver for BCM2712
++ *
++ * Copyright (c) 2023 Raspberry Pi Ltd.
++ */
++
++#include "bcm2712-iommu.h"
++
++#include <linux/dma-mapping.h>
++#include <linux/err.h>
++#include <linux/iommu.h>
++#include <linux/of_platform.h>
++#include <linux/platform_device.h>
++#include <linux/spinlock.h>
++
++#define MMU_WR(off, val)   writel(val, mmu->reg_base + (off))
++#define MMU_RD(off)        readl(mmu->reg_base + (off))
++
++#define domain_to_mmu(d) (container_of(d, struct bcm2712_iommu_domain, base)->mmu)
++
++#define MMMU_CTRL_OFFSET                       0x00
++#define MMMU_CTRL_CAP_EXCEEDED                 BIT(27)
++#define MMMU_CTRL_CAP_EXCEEDED_ABORT_EN        BIT(26)
++#define MMMU_CTRL_CAP_EXCEEDED_INT_EN          BIT(25)
++#define MMMU_CTRL_CAP_EXCEEDED_EXCEPTION_EN    BIT(24)
++#define MMMU_CTRL_PT_INVALID                   BIT(20)
++#define MMMU_CTRL_PT_INVALID_ABORT_EN          BIT(19)
++#define MMMU_CTRL_PT_INVALID_EXCEPTION_EN      BIT(18)
++#define MMMU_CTRL_PT_INVALID_EN                BIT(17)
++#define MMMU_CTRL_WRITE_VIOLATION              BIT(12)
++#define MMMU_CTRL_WRITE_VIOLATION_ABORT_EN     BIT(11)
++#define MMMU_CTRL_WRITE_VIOLATION_INT_EN       BIT(10)
++#define MMMU_CTRL_WRITE_VIOLATION_EXCEPTION_EN BIT(9)
++#define MMMU_CTRL_BYPASS                       BIT(8)
++#define MMMU_CTRL_TLB_CLEARING                 BIT(7)
++#define MMMU_CTRL_STATS_CLEAR                  BIT(3)
++#define MMMU_CTRL_TLB_CLEAR                    BIT(2)
++#define MMMU_CTRL_STATS_ENABLE                 BIT(1)
++#define MMMU_CTRL_ENABLE                       BIT(0)
++
++#define MMMU_PT_PA_BASE_OFFSET                 0x04
++
++#define MMMU_HIT_OFFSET                        0x08
++#define MMMU_MISS_OFFSET                       0x0C
++#define MMMU_STALL_OFFSET                      0x10
++
++#define MMMU_ADDR_CAP_OFFSET                   0x14
++#define MMMU_ADDR_CAP_ENABLE                   BIT(31)
++#define ADDR_CAP_SHIFT 28 /* ADDR_CAP is defined to be in 256 MByte units */
++
++#define MMMU_SHOOT_DOWN_OFFSET                 0x18
++#define MMMU_SHOOT_DOWN_SHOOTING               BIT(31)
++#define MMMU_SHOOT_DOWN_SHOOT                  BIT(30)
++
++#define MMMU_BYPASS_START_OFFSET               0x1C
++#define MMMU_BYPASS_START_ENABLE               BIT(31)
++#define MMMU_BYPASS_START_INVERT               BIT(30)
++
++#define MMMU_BYPASS_END_OFFSET                 0x20
++#define MMMU_BYPASS_END_ENABLE                 BIT(31)
++
++#define MMMU_MISC_OFFSET                       0x24
++#define MMMU_MISC_SINGLE_TABLE                 BIT(31)
++
++#define MMMU_ILLEGAL_ADR_OFFSET                0x30
++#define MMMU_ILLEGAL_ADR_ENABLE                BIT(31)
++
++#define MMMU_DEBUG_INFO_OFFSET                 0x38
++#define MMMU_DEBUG_INFO_VERSION_MASK           0x0000000Fu
++#define MMMU_DEBUG_INFO_VA_WIDTH_MASK          0x000000F0u
++#define MMMU_DEBUG_INFO_PA_WIDTH_MASK          0x00000F00u
++#define MMMU_DEBUG_INFO_BIGPAGE_WIDTH_MASK     0x000FF000u
++#define MMMU_DEBUG_INFO_SUPERPAGE_WIDTH_MASK   0x0FF00000u
++#define MMMU_DEBUG_INFO_BYPASS_4M              BIT(28)
++#define MMMU_DEBUG_INFO_BYPASS                 BIT(29)
++
++#define MMMU_PTE_PAGESIZE_MASK                 0xC0000000u
++#define MMMU_PTE_WRITEABLE                     BIT(29)
++#define MMMU_PTE_VALID                         BIT(28)
++
++/*
++ * BCM2712 IOMMU is organized around 4Kbyte pages (MMU_PAGE_SIZE).
++ * Linux PAGE_SIZE must not be smaller but may be larger (e.g. 4K, 16K).
++ *
++ * Unlike many larger MMUs, this one uses a 4-byte word size, allowing
++ * 1024 entries within each 4K table page, and two-level translation.
++ *
++ * Let's allocate enough table space for 2GB of translated memory (IOVA).
++ * This requires 512 4K pages (2MB) of level-2 tables, one page of
++ * top-level table (only half-filled in this particular configuration),
++ * plus one "default" page to catch illegal requests.
++ *
++ * The translated virtual address region is between 40GB and 42GB;
++ * addresses below this range pass straight through to the SDRAM.
++ *
++ * Currently we assume a 1:1:1 correspondence of IOMMU, group and domain.
++ */
++
++#define MMU_PAGE_SHIFT    12
++#define MMU_PAGE_SIZE     BIT(MMU_PAGE_SHIFT)
++
++#define PAGEWORDS_SHIFT   (MMU_PAGE_SHIFT - 2)
++#define HUGEPAGE_SHIFT    (MMU_PAGE_SHIFT + PAGEWORDS_SHIFT)
++#define L1_CHUNK_SHIFT    (MMU_PAGE_SHIFT + 2 * PAGEWORDS_SHIFT)
++
++#define APERTURE_BASE     (40ul << 30)
++#define APERTURE_SIZE     (2ul << 30)
++#define APERTURE_TOP      (APERTURE_BASE + APERTURE_SIZE)
++#define TRANSLATED_PAGES  (APERTURE_SIZE >> MMU_PAGE_SHIFT)
++#define L2_PAGES          (TRANSLATED_PAGES >> PAGEWORDS_SHIFT)
++#define TABLES_ALLOC_SIZE (L2_PAGES * MMU_PAGE_SIZE + 2 * PAGE_SIZE)
++
++static void bcm2712_iommu_init(struct bcm2712_iommu *mmu)
++{
++	unsigned int i, bypass_shift;
++	struct sg_dma_page_iter it;
++	u32 u = MMU_RD(MMMU_DEBUG_INFO_OFFSET);
++
++	/*
++	 * Check IOMMU version and hardware configuration.
++	 * This driver is for VC IOMMU version >= 4 (with 2-level tables)
++	 * and assumes at least 36 bits of virtual and physical address space.
++	 * Bigpage and superpage sizes are typically 64K and 1M, but may vary
++	 * (hugepage size is fixed at 4M, the range covered by an L2 page).
++	 */
++	dev_info(mmu->dev, "%s: DEBUG_INFO = 0x%08x\n", __func__, u);
++	WARN_ON(FIELD_GET(MMMU_DEBUG_INFO_VERSION_MASK, u) < 4 ||
++		FIELD_GET(MMMU_DEBUG_INFO_VA_WIDTH_MASK, u) < 6 ||
++		FIELD_GET(MMMU_DEBUG_INFO_PA_WIDTH_MASK, u) < 6 ||
++		!(u & MMMU_DEBUG_INFO_BYPASS));
++
++	mmu->bigpage_mask =
++		((1u << FIELD_GET(MMMU_DEBUG_INFO_BIGPAGE_WIDTH_MASK, u)) - 1u) << MMU_PAGE_SHIFT;
++	mmu->superpage_mask =
++		((1u << FIELD_GET(MMMU_DEBUG_INFO_SUPERPAGE_WIDTH_MASK, u)) - 1u) << MMU_PAGE_SHIFT;
++	bypass_shift = (u & MMMU_DEBUG_INFO_BYPASS_4M) ?
++		HUGEPAGE_SHIFT : ADDR_CAP_SHIFT;
++
++	/* Disable MMU and clear sticky flags; meanwhile flush the TLB */
++	MMU_WR(MMMU_CTRL_OFFSET,
++	       MMMU_CTRL_CAP_EXCEEDED    |
++	       MMMU_CTRL_PT_INVALID      |
++	       MMMU_CTRL_WRITE_VIOLATION |
++	       MMMU_CTRL_STATS_CLEAR     |
++	       MMMU_CTRL_TLB_CLEAR);
++
++	/*
++	 * Put MMU into 2-level mode; set address cap and "bypass" range
++	 * (note that some of these registers have unintuitive off-by-ones).
++	 * Addresses below APERTURE_BASE are passed unchanged: this is
++	 * useful for blocks which share an IOMMU with other blocks
++	 * whose drivers are not IOMMU-aware.
++	 */
++	MMU_WR(MMMU_MISC_OFFSET,
++	       MMU_RD(MMMU_MISC_OFFSET) & ~MMMU_MISC_SINGLE_TABLE);
++	MMU_WR(MMMU_ADDR_CAP_OFFSET,
++	       MMMU_ADDR_CAP_ENABLE +
++	       (APERTURE_TOP >> ADDR_CAP_SHIFT) - 1);
++	if (APERTURE_BASE > 0) {
++		MMU_WR(MMMU_BYPASS_START_OFFSET,
++		       MMMU_BYPASS_START_ENABLE + MMMU_BYPASS_START_INVERT +
++		       (APERTURE_BASE >> bypass_shift) - 1);
++		MMU_WR(MMMU_BYPASS_END_OFFSET,
++		       MMMU_BYPASS_END_ENABLE +
++		       (APERTURE_TOP >> bypass_shift));
++	} else {
++		MMU_WR(MMMU_BYPASS_START_OFFSET, 0);
++		MMU_WR(MMMU_BYPASS_END_OFFSET, 0);
++	}
++
++	/* Ensure tables are zeroed (which marks all pages as invalid) */
++	dma_sync_sgtable_for_cpu(mmu->dev, mmu->sgt, DMA_TO_DEVICE);
++	memset(mmu->tables, 0, TABLES_ALLOC_SIZE);
++	mmu->nmapped_pages = 0;
++
++	/* Initialize the high-level table to point to the low-level pages */
++	__sg_page_iter_start(&it.base, mmu->sgt->sgl, mmu->sgt->nents, 0);
++	for (i = 0; i < L2_PAGES; i++) {
++		if (!(i % (PAGE_SIZE / MMU_PAGE_SIZE))) {
++			__sg_page_iter_dma_next(&it);
++			u = (sg_page_iter_dma_address(&it) >> MMU_PAGE_SHIFT);
++		} else {
++			u++;
++		}
++		mmu->tables[TRANSLATED_PAGES + i] = MMMU_PTE_VALID + u;
++	}
++
++	/*
++	 * Configure the addresses of the top-level table (offset because
++	 * the aperture does not start from zero), and of the default page.
++	 * For simplicity, both these regions are whole Linux pages.
++	 */
++	__sg_page_iter_dma_next(&it);
++	u = (sg_page_iter_dma_address(&it) >> MMU_PAGE_SHIFT);
++	MMU_WR(MMMU_PT_PA_BASE_OFFSET, u - (APERTURE_BASE >> L1_CHUNK_SHIFT));
++	__sg_page_iter_dma_next(&it);
++	u = (sg_page_iter_dma_address(&it) >> MMU_PAGE_SHIFT);
++	MMU_WR(MMMU_ILLEGAL_ADR_OFFSET, MMMU_ILLEGAL_ADR_ENABLE + u);
++	dma_sync_sgtable_for_device(mmu->dev, mmu->sgt, DMA_TO_DEVICE);
++	mmu->dirty = false;
++
++	/* Flush (and enable) the shared TLB cache; enable this MMU. */
++	if (mmu->cache)
++		bcm2712_iommu_cache_flush(mmu->cache);
++	MMU_WR(MMMU_CTRL_OFFSET,
++	       MMMU_CTRL_CAP_EXCEEDED_ABORT_EN    |
++	       MMMU_CTRL_PT_INVALID_ABORT_EN      |
++	       MMMU_CTRL_WRITE_VIOLATION_ABORT_EN |
++	       MMMU_CTRL_STATS_ENABLE             |
++	       MMMU_CTRL_ENABLE);
++}
++
++static int bcm2712_iommu_attach_dev(struct iommu_domain *domain, struct device *dev)
++{
++	struct bcm2712_iommu *mmu = dev ? dev_iommu_priv_get(dev) : 0;
++	struct bcm2712_iommu_domain *mydomain =
++		container_of(domain, struct bcm2712_iommu_domain, base);
++
++	dev_info(dev, "%s: MMU %s\n",
++		 __func__, mmu ? dev_name(mmu->dev) : "");
++
++	if (mmu) {
++		mydomain->mmu = mmu;
++		mmu->domain = mydomain;
++
++		if (mmu->dma_iova_offset) {
++			domain->geometry.aperture_start =
++				mmu->dma_iova_offset + APERTURE_BASE;
++			domain->geometry.aperture_end =
++				mmu->dma_iova_offset + APERTURE_TOP - 1ul;
++		}
++
++		return 0;
++	}
++	return -EINVAL;
++}
++
++static void bcm2712_iommu_detach_dev(struct iommu_domain *domain, struct device *dev)
++{
++	(void)domain;
++	(void)dev;
++}
++
++static int bcm2712_iommu_map(struct iommu_domain *domain, unsigned long iova,
++			     phys_addr_t pa, size_t bytes, int prot, gfp_t gfp)
++{
++	struct bcm2712_iommu *mmu = domain_to_mmu(domain);
++
++	(void)gfp;
++	iova -= mmu->dma_iova_offset;
++	if (iova >= APERTURE_BASE && iova + bytes <= APERTURE_TOP) {
++		unsigned int p;
++		u32 entry = MMMU_PTE_VALID | (pa >> MMU_PAGE_SHIFT);
++		u32 align = (u32)(iova | pa | bytes);
++
++		/* large page and write enable flags */
++		if (!(align & ((1 << HUGEPAGE_SHIFT) - 1)))
++			entry |= FIELD_PREP(MMMU_PTE_PAGESIZE_MASK, 3);
++		else if (!(align & mmu->superpage_mask) && mmu->superpage_mask)
++			entry |= FIELD_PREP(MMMU_PTE_PAGESIZE_MASK, 2);
++		else if (!(align &  mmu->bigpage_mask) && mmu->bigpage_mask)
++			entry |= FIELD_PREP(MMMU_PTE_PAGESIZE_MASK, 1);
++		if (prot & IOMMU_WRITE)
++			entry |= MMMU_PTE_WRITEABLE;
++
++		/* Ensure tables are cache-coherent with CPU */
++		if (!mmu->dirty) {
++			dma_sync_sgtable_for_cpu(mmu->dev, mmu->sgt, DMA_TO_DEVICE);
++			mmu->dirty = true;
++		}
++
++		iova -= APERTURE_BASE;
++		for (p = iova >> MMU_PAGE_SHIFT;
++		     p < (iova + bytes) >> MMU_PAGE_SHIFT; p++) {
++			mmu->nmapped_pages += !(mmu->tables[p]);
++			mmu->tables[p] = entry++;
++		}
++	} else if (iova + bytes > APERTURE_BASE || iova != pa) {
++		dev_warn(mmu->dev, "%s: iova=0x%lx pa=0x%llx size=0x%llx OUT OF RANGE!\n",
++			 __func__, iova,
++			 (unsigned long long)pa, (unsigned long long)bytes);
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static size_t bcm2712_iommu_unmap(struct iommu_domain *domain, unsigned long iova,
++				  size_t bytes, struct iommu_iotlb_gather *gather)
++{
++	struct bcm2712_iommu *mmu = domain_to_mmu(domain);
++
++	if (iova >= mmu->dma_iova_offset + APERTURE_BASE &&
++	    iova + bytes <= mmu->dma_iova_offset + APERTURE_TOP) {
++		unsigned int p;
++
++		/* Record just the lower and upper bounds in "gather" */
++		if (gather) {
++			bool empty = (gather->end <= gather->start);
++
++			if (empty || gather->start < iova)
++				gather->start = iova;
++			if (empty || gather->end < iova + bytes)
++				gather->end = iova + bytes;
++		}
++
++		/* Ensure tables are cache-coherent with CPU */
++		if (!mmu->dirty) {
++			dma_sync_sgtable_for_cpu(mmu->dev, mmu->sgt, DMA_TO_DEVICE);
++			mmu->dirty = true;
++		}
++
++		/* Clear table entries, this marks the addresses as illegal */
++		iova -= (mmu->dma_iova_offset + APERTURE_BASE);
++		for (p = iova >> MMU_PAGE_SHIFT;
++		     p < (iova + bytes) >> MMU_PAGE_SHIFT;
++		     p++) {
++			mmu->nmapped_pages -= !!(mmu->tables[p]);
++			mmu->tables[p] = 0;
++		}
++	}
++
++	return bytes;
++}
++
++static void bcm2712_iommu_sync_range(struct iommu_domain *domain,
++				     unsigned long iova, size_t size)
++{
++	struct bcm2712_iommu *mmu = domain_to_mmu(domain);
++	unsigned long iova_end;
++	unsigned int i, p4;
++
++	if (!mmu || !mmu->dirty)
++		return;
++
++	/* Ensure tables are cleaned from CPU cache or write-buffer */
++	dma_sync_sgtable_for_device(mmu->dev, mmu->sgt, DMA_TO_DEVICE);
++	mmu->dirty = false;
++
++	/* Flush the shared TLB cache */
++	if (mmu->cache)
++		bcm2712_iommu_cache_flush(mmu->cache);
++
++	/*
++	 * When flushing a large range or when nothing needs to be kept,
++	 * it's quicker to use the"TLB_CLEAR" flag. Otherwise, invalidate
++	 * TLB entries in lines of 4 words each. Each flush/clear operation
++	 * should complete almost instantaneously.
++	 */
++	iova -= mmu->dma_iova_offset;
++	iova_end = min(APERTURE_TOP, iova + size);
++	iova = max(APERTURE_BASE, iova);
++	if (mmu->nmapped_pages == 0 || iova_end - iova >= APERTURE_SIZE / 8) {
++		MMU_WR(MMMU_CTRL_OFFSET,
++		       MMMU_CTRL_CAP_EXCEEDED_ABORT_EN    |
++		       MMMU_CTRL_PT_INVALID_ABORT_EN      |
++		       MMMU_CTRL_WRITE_VIOLATION_ABORT_EN |
++		       MMMU_CTRL_TLB_CLEAR                |
++		       MMMU_CTRL_STATS_ENABLE             |
++		       MMMU_CTRL_ENABLE);
++		for (i = 0; i < 1024; i++) {
++			if (!(MMMU_CTRL_TLB_CLEARING & MMU_RD(MMMU_CTRL_OFFSET)))
++				break;
++			cpu_relax();
++		}
++	} else {
++		for (p4 = iova >> (MMU_PAGE_SHIFT + 2);
++		     p4 < (iova_end + 3 * MMU_PAGE_SIZE) >> (MMU_PAGE_SHIFT + 2);
++		     p4++) {
++			MMU_WR(MMMU_SHOOT_DOWN_OFFSET,
++			       MMMU_SHOOT_DOWN_SHOOT + (p4 << 2));
++			for (i = 0; i < 1024; i++) {
++				if (!(MMMU_SHOOT_DOWN_SHOOTING & MMU_RD(MMMU_SHOOT_DOWN_OFFSET)))
++					break;
++				cpu_relax();
++			}
++		}
++	}
++}
++
++static void bcm2712_iommu_sync(struct iommu_domain *domain,
++			       struct iommu_iotlb_gather *gather)
++{
++	bcm2712_iommu_sync_range(domain, gather->start,
++				 gather->end - gather->start);
++}
++
++static void bcm2712_iommu_sync_all(struct iommu_domain *domain)
++{
++	bcm2712_iommu_sync_range(domain, APERTURE_BASE, APERTURE_SIZE);
++}
++
++static phys_addr_t bcm2712_iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova)
++{
++	struct bcm2712_iommu *mmu = domain_to_mmu(domain);
++	u32 p;
++
++	iova -= mmu->dma_iova_offset;
++	if (iova  >= APERTURE_BASE && iova < APERTURE_TOP) {
++		p = (iova - APERTURE_BASE) >> MMU_PAGE_SHIFT;
++		p = mmu->tables[p] & 0x0FFFFFFFu;
++		return (((phys_addr_t)p) << MMU_PAGE_SHIFT) + (iova & (MMU_PAGE_SIZE - 1u));
++	} else if (iova < APERTURE_BASE) {
++		return (phys_addr_t)iova;
++	} else {
++		return (phys_addr_t)-EINVAL;
++	}
++}
++
++static void bcm2712_iommu_domain_free(struct iommu_domain *domain)
++{
++	struct bcm2712_iommu_domain *mydomain =
++		container_of(domain, struct bcm2712_iommu_domain, base);
++
++	kfree(mydomain);
++}
++
++static const struct iommu_domain_ops bcm2712_iommu_domain_ops = {
++	.attach_dev	 = bcm2712_iommu_attach_dev,
++	.detach_dev	 = bcm2712_iommu_detach_dev,
++	.map		 = bcm2712_iommu_map,
++	.unmap		 = bcm2712_iommu_unmap,
++	.iotlb_sync      = bcm2712_iommu_sync,
++	.iotlb_sync_map  = bcm2712_iommu_sync_range,
++	.flush_iotlb_all = bcm2712_iommu_sync_all,
++	.iova_to_phys	 = bcm2712_iommu_iova_to_phys,
++	.free		 = bcm2712_iommu_domain_free,
++};
++
++static struct iommu_domain *bcm2712_iommu_domain_alloc(unsigned int type)
++{
++	struct bcm2712_iommu_domain *domain;
++
++	if (type != IOMMU_DOMAIN_UNMANAGED && type != IOMMU_DOMAIN_DMA)
++		return NULL;
++
++	domain = kzalloc(sizeof(*domain), GFP_KERNEL);
++	if (!domain)
++		return NULL;
++
++	domain->base.type = type;
++	domain->base.ops  = &bcm2712_iommu_domain_ops;
++	domain->base.geometry.aperture_start = APERTURE_BASE;
++	domain->base.geometry.aperture_end   = APERTURE_TOP - 1ul;
++	domain->base.geometry.force_aperture = true;
++	return &domain->base;
++}
++
++static struct iommu_device *bcm2712_iommu_probe_device(struct device *dev)
++{
++	struct bcm2712_iommu *mmu;
++
++	/*
++	 * For reasons I don't fully understand, we need to try both
++	 * cases (dev_iommu_priv_get() and platform_get_drvdata())
++	 * in order to get both GPU and ISP-BE to probe successfully.
++	 */
++	mmu = dev_iommu_priv_get(dev);
++	if (!mmu) {
++		struct device_node *np;
++		struct platform_device *pdev;
++
++		/* Ignore devices that don't have an "iommus" property with exactly one phandle */
++		if (!dev->of_node ||
++		    of_property_count_elems_of_size(dev->of_node, "iommus", sizeof(phandle)) != 1)
++			return ERR_PTR(-ENODEV);
++
++		np = of_parse_phandle(dev->of_node, "iommus", 0);
++		if (!np)
++			return ERR_PTR(-EINVAL);
++
++		pdev = of_find_device_by_node(np);
++		of_node_put(np);
++		if (pdev)
++			mmu = platform_get_drvdata(pdev);
++
++		if (!mmu)
++			return ERR_PTR(-ENODEV);
++	}
++
++	dev_info(dev, "%s: MMU %s\n", __func__, dev_name(mmu->dev));
++	dev_iommu_priv_set(dev, mmu);
++	return &mmu->iommu;
++}
++
++static void bcm2712_iommu_release_device(struct device *dev)
++{
++	dev_iommu_priv_set(dev, NULL);
++}
++
++static struct iommu_group *bcm2712_iommu_device_group(struct device *dev)
++{
++	struct bcm2712_iommu *mmu = dev_iommu_priv_get(dev);
++
++	if (!mmu || !mmu->group)
++		return ERR_PTR(-EINVAL);
++
++	dev_info(dev, "%s: MMU %s\n", __func__, dev_name(mmu->dev));
++	return iommu_group_ref_get(mmu->group);
++}
++
++static int bcm2712_iommu_of_xlate(struct device *dev,
++				  struct of_phandle_args *args)
++{
++	struct platform_device *iommu_dev;
++	struct bcm2712_iommu *mmu;
++
++	iommu_dev = of_find_device_by_node(args->np);
++	mmu = platform_get_drvdata(iommu_dev);
++	dev_iommu_priv_set(dev, mmu);
++	dev_info(dev, "%s: MMU %s\n", __func__, dev_name(mmu->dev));
++
++	return 0;
++}
++
++static bool bcm2712_iommu_capable(struct device *dev, enum iommu_cap cap)
++{
++	return false;
++}
++
++static const struct iommu_ops bcm2712_iommu_ops = {
++	.capable        = bcm2712_iommu_capable,
++	.domain_alloc	= bcm2712_iommu_domain_alloc,
++	.probe_device	= bcm2712_iommu_probe_device,
++	.release_device	= bcm2712_iommu_release_device,
++	.device_group	= bcm2712_iommu_device_group,
++	/* Advertise native page sizes as well as 2M, 16K which Linux may prefer */
++	.pgsize_bitmap	= (SZ_4M | SZ_2M | SZ_1M | SZ_64K | SZ_16K | SZ_4K),
++	.default_domain_ops = &bcm2712_iommu_domain_ops,
++	.of_xlate = bcm2712_iommu_of_xlate,
++};
++
++static int bcm2712_iommu_probe(struct platform_device *pdev)
++{
++	struct bcm2712_iommu *mmu;
++	struct bcm2712_iommu_cache *cache = NULL;
++	int ret;
++
++	/* First of all, check for an IOMMU shared cache */
++	if (pdev->dev.of_node) {
++		struct device_node *cache_np;
++		struct platform_device *cache_pdev;
++
++		cache_np = of_parse_phandle(pdev->dev.of_node, "cache", 0);
++		if (cache_np) {
++			cache_pdev = of_find_device_by_node(cache_np);
++			of_node_put(cache_np);
++			if (cache_pdev && !IS_ERR(cache_pdev))
++				cache = platform_get_drvdata(cache_pdev);
++			if (!cache)
++				return -EPROBE_DEFER;
++		}
++	}
++
++	/* Allocate private data */
++	mmu = devm_kzalloc(&pdev->dev, sizeof(*mmu), GFP_KERNEL);
++	if (!mmu)
++		return -ENOMEM;
++
++	mmu->name = dev_name(&pdev->dev);
++	mmu->dev = &pdev->dev;
++	mmu->cache = cache;
++	platform_set_drvdata(pdev, mmu);
++	spin_lock_init(&mmu->hw_lock);
++
++	/*
++	 * XXX When an IOMMU is downstream of a PCIe RC or some other chip/bus
++	 * and serves some of the masters thereon (others using pass-through),
++	 * we seem to fumble and lose the "dma-ranges" address offset for
++	 * masters using IOMMU. This property restores it, where needed.
++	 */
++	if (!pdev->dev.of_node ||
++	    of_property_read_u64(pdev->dev.of_node, "dma-iova-offset",
++				 &mmu->dma_iova_offset))
++		mmu->dma_iova_offset = 0;
++
++	/*
++	 * The IOMMU is itself a device that allocates DMA-able memory
++	 * to hold its translation tables. Provided the IOVA aperture
++	 * is no larger than 4 GBytes (so that the L1 table fits within
++	 * a single 4K page), we don't need the tables to be contiguous.
++	 * Assume we can address at least 36 bits (64 GB).
++	 */
++	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(36));
++	WARN_ON(ret);
++	mmu->sgt = dma_alloc_noncontiguous(&pdev->dev, TABLES_ALLOC_SIZE,
++					   DMA_TO_DEVICE, GFP_KERNEL,
++					   DMA_ATTR_ALLOC_SINGLE_PAGES);
++	if (!mmu->sgt) {
++		ret = -ENOMEM;
++		goto done_err;
++	}
++	mmu->tables = dma_vmap_noncontiguous(&pdev->dev, TABLES_ALLOC_SIZE,
++					     mmu->sgt);
++	if (!mmu->tables) {
++		ret = -ENOMEM;
++		goto done_err;
++	}
++
++	/* Get IOMMU registers */
++	mmu->reg_base = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(mmu->reg_base)) {
++		dev_err(&pdev->dev, "Failed to get IOMMU registers address\n");
++		ret = PTR_ERR(mmu->reg_base);
++		goto done_err;
++	}
++
++	/* Stuff */
++	mmu->group = iommu_group_alloc();
++	if (IS_ERR(mmu->group)) {
++		ret = PTR_ERR(mmu->group);
++		mmu->group = NULL;
++		goto done_err;
++	}
++	ret = iommu_device_sysfs_add(&mmu->iommu, mmu->dev, NULL, mmu->name);
++	if (ret)
++		goto done_err;
++
++	/* Initialize table and hardware */
++	bcm2712_iommu_init(mmu);
++	ret = iommu_device_register(&mmu->iommu, &bcm2712_iommu_ops, &pdev->dev);
++
++	dev_info(&pdev->dev, "%s: Success\n", __func__);
++	return 0;
++
++done_err:
++	dev_info(&pdev->dev, "%s: Failure %d\n", __func__, ret);
++	if (mmu->group)
++		iommu_group_put(mmu->group);
++	if (mmu->tables)
++		dma_vunmap_noncontiguous(&pdev->dev,
++					 (void *)(mmu->tables));
++	mmu->tables = NULL;
++	if (mmu->sgt)
++		dma_free_noncontiguous(&pdev->dev, TABLES_ALLOC_SIZE,
++				       mmu->sgt, DMA_TO_DEVICE);
++	mmu->sgt = NULL;
++	kfree(mmu);
++	return ret;
++}
++
++static int bcm2712_iommu_remove(struct platform_device *pdev)
++{
++	struct bcm2712_iommu *mmu = platform_get_drvdata(pdev);
++
++	if (mmu->reg_base)
++		MMU_WR(MMMU_CTRL_OFFSET, 0); /* disable the MMU */
++	if (mmu->sgt)
++		dma_free_noncontiguous(&pdev->dev, TABLES_ALLOC_SIZE,
++				       mmu->sgt, DMA_TO_DEVICE);
++
++	return 0;
++}
++
++static const struct of_device_id bcm2712_iommu_of_match[] = {
++	{
++		. compatible = "brcm,bcm2712-iommu"
++	},
++	{ /* sentinel */ },
++};
++
++static struct platform_driver bcm2712_iommu_driver = {
++	.probe = bcm2712_iommu_probe,
++	.remove = bcm2712_iommu_remove,
++	.driver = {
++		.name = "bcm2712-iommu",
++		.of_match_table = bcm2712_iommu_of_match
++	},
++};
++
++builtin_platform_driver(bcm2712_iommu_driver);
+--- /dev/null
++++ b/drivers/iommu/bcm2712-iommu.h
+@@ -0,0 +1,45 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * IOMMU driver for BCM2712
++ *
++ * Copyright (c) 2023 Raspberry Pi Ltd.
++ */
++
++#ifndef _BCM2712_IOMMU_H
++#define _BCM2712_IOMMU_H
++
++#include <linux/iommu.h>
++#include <linux/scatterlist.h>
++
++struct bcm2712_iommu_cache {
++	struct device *dev;
++	spinlock_t hw_lock; /* to protect HW registers */
++	void __iomem *reg_base;
++};
++
++void bcm2712_iommu_cache_flush(struct bcm2712_iommu_cache *cache);
++
++struct bcm2712_iommu {
++	struct device *dev;
++	struct iommu_device iommu;
++	struct iommu_group *group;
++	struct bcm2712_iommu_domain *domain;
++	char const *name;
++	struct sg_table *sgt; /* allocated memory for page tables */
++	u32 *tables;          /* kernel mapping for page tables */
++	struct bcm2712_iommu_cache *cache;
++	spinlock_t hw_lock;   /* to protect HW registers */
++	void __iomem *reg_base;
++	u64 dma_iova_offset; /* Hack for IOMMU attached to PCIe RC */
++	u32 bigpage_mask;
++	u32 superpage_mask;
++	unsigned int nmapped_pages;
++	bool dirty; /* true when tables are oriented towards CPU */
++};
++
++struct bcm2712_iommu_domain {
++	struct iommu_domain base;
++	struct bcm2712_iommu *mmu;
++};
++
++#endif
diff --git a/target/linux/bcm27xx/patches-6.1/950-0918-irqchip-irq-brcmstb-l2-Add-config-for-2711-controlle.patch b/target/linux/bcm27xx/patches-6.1/950-0918-irqchip-irq-brcmstb-l2-Add-config-for-2711-controlle.patch
new file mode 100644
index 0000000000..5ea212d4a7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0918-irqchip-irq-brcmstb-l2-Add-config-for-2711-controlle.patch
@@ -0,0 +1,73 @@
+From fa4d4ed28c92cf4470e518f1a7362dc7941632d7 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Wed, 28 Jun 2023 16:24:29 +0100
+Subject: [PATCH] irqchip/irq-brcmstb-l2: Add config for 2711 controller
+
+We currently see these regularly:
+[   25.157560] irq 31, desc: 00000000c15e6d2c, depth: 0, count: 0, unhandled: 0
+[   25.164658] ->handle_irq():  00000000b1775675, brcmstb_l2_intc_irq_handle+0x0/0x1a8
+[   25.172352] ->irq_data.chip(): 00000000fea59f1c, gic_chip_mode1+0x0/0x108
+[   25.179166] ->action(): 000000003eda6d6f
+[   25.183096] ->action->handler(): 000000002c09e646, bad_chained_irq+0x0/0x58
+[   25.190084]      IRQ_LEVEL set
+[   25.193142]    IRQ_NOPROBE set
+[   25.196198]  IRQ_NOREQUEST set
+[   25.199255]   IRQ_NOTHREAD set
+
+with:
+$ cat /proc/interrupts  | grep 31:
+ 31:          1          0          0          0     GICv2 129 Level     (null)
+
+The interrupt is described in DT with IRQ_TYPE_LEVEL_HIGH
+
+But the current compatible string uses the controller in edge triggered mode
+(as that config matches our register layout).
+
+Add a new compatible structure for level driven interrupt with our register layout.
+
+We had already been using this compatible string in device tree, so no change needed
+there.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/irqchip/irq-brcmstb-l2.c | 17 +++++++++++++++++
+ 1 file changed, 17 insertions(+)
+
+--- a/drivers/irqchip/irq-brcmstb-l2.c
++++ b/drivers/irqchip/irq-brcmstb-l2.c
+@@ -52,6 +52,16 @@ static const struct brcmstb_intc_init_pa
+ 	.cpu_mask_clear		= 0x0C
+ };
+ 
++/* Register offsets in the 2711 L2 level interrupt controller */
++static const struct brcmstb_intc_init_params l2_2711_lvl_intc_init = {
++	.handler		= handle_level_irq,
++	.cpu_status		= 0x00,
++	.cpu_clear		= 0x08,
++	.cpu_mask_status	= 0x0c,
++	.cpu_mask_set		= 0x10,
++	.cpu_mask_clear		= 0x14
++};
++
+ /* L2 intc private data structure */
+ struct brcmstb_l2_intc_data {
+ 	struct irq_domain *domain;
+@@ -286,11 +296,18 @@ static int __init brcmstb_l2_lvl_intc_of
+ 	return brcmstb_l2_intc_of_init(np, parent, &l2_lvl_intc_init);
+ }
+ 
++static int __init brcmstb_l2_2711_lvl_intc_of_init(struct device_node *np,
++	struct device_node *parent)
++{
++	return brcmstb_l2_intc_of_init(np, parent, &l2_2711_lvl_intc_init);
++}
++
+ IRQCHIP_PLATFORM_DRIVER_BEGIN(brcmstb_l2)
+ IRQCHIP_MATCH("brcm,l2-intc", brcmstb_l2_edge_intc_of_init)
+ IRQCHIP_MATCH("brcm,hif-spi-l2-intc", brcmstb_l2_edge_intc_of_init)
+ IRQCHIP_MATCH("brcm,upg-aux-aon-l2-intc", brcmstb_l2_edge_intc_of_init)
+ IRQCHIP_MATCH("brcm,bcm7271-l2-intc", brcmstb_l2_lvl_intc_of_init)
++IRQCHIP_MATCH("brcm,bcm2711-l2-intc", brcmstb_l2_2711_lvl_intc_of_init)
+ IRQCHIP_PLATFORM_DRIVER_END(brcmstb_l2)
+ MODULE_DESCRIPTION("Broadcom STB generic L2 interrupt controller");
+ MODULE_LICENSE("GPL v2");
diff --git a/target/linux/bcm27xx/patches-6.1/950-0919-rtc-rtc-rpi-Add-simple-RTC-driver-for-Raspberry-Pi.patch b/target/linux/bcm27xx/patches-6.1/950-0919-rtc-rtc-rpi-Add-simple-RTC-driver-for-Raspberry-Pi.patch
new file mode 100644
index 0000000000..e2b8c6c6a1
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0919-rtc-rtc-rpi-Add-simple-RTC-driver-for-Raspberry-Pi.patch
@@ -0,0 +1,237 @@
+From 222dedcdc09247126d39364a614ff2019789f52a Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Fri, 7 Jul 2023 20:00:45 +0100
+Subject: [PATCH] rtc: rtc-rpi: Add simple RTC driver for Raspberry Pi
+
+This supports setting and reading the real time clock
+and supports wakeup alarms.
+
+To support wake up alarms you want this bootloader config:
+ POWER_OFF_ON_HALT=1
+ WAKE_ON_GPIO=0
+
+You can test with:
+  echo +600 | sudo tee /sys/class/rtc/rtc0/wakealarm
+  sudo halt
+
+That will halt (in an almost no power state),
+then wake and restart after 10 minutes.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/rtc/Kconfig   |  11 +++
+ drivers/rtc/Makefile  |   1 +
+ drivers/rtc/rtc-rpi.c | 177 ++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 189 insertions(+)
+ create mode 100644 drivers/rtc/rtc-rpi.c
+
+--- a/drivers/rtc/Kconfig
++++ b/drivers/rtc/Kconfig
+@@ -223,6 +223,17 @@ config RTC_DRV_AC100
+ 	  This driver can also be built as a module. If so, the module
+ 	  will be called rtc-ac100.
+ 
++config RTC_DRV_RPI
++	tristate "Raspberry Pi RTC"
++	depends on ARCH_BRCMSTB || COMPILE_TEST
++	default ARCH_BRCMSTB
++	help
++	  If you say yes here you get support for the RTC found on
++	  Raspberry Pi devices.
++
++	  This driver can also be built as a module. If so, the module
++	  will be called rtc-rpi.
++
+ config RTC_DRV_BRCMSTB
+ 	tristate "Broadcom STB wake-timer"
+ 	depends on ARCH_BRCMSTB || BMIPS_GENERIC || COMPILE_TEST
+--- a/drivers/rtc/Makefile
++++ b/drivers/rtc/Makefile
+@@ -140,6 +140,7 @@ obj-$(CONFIG_RTC_DRV_RC5T583)	+= rtc-rc5
+ obj-$(CONFIG_RTC_DRV_RC5T619)	+= rtc-rc5t619.o
+ obj-$(CONFIG_RTC_DRV_RK808)	+= rtc-rk808.o
+ obj-$(CONFIG_RTC_DRV_RP5C01)	+= rtc-rp5c01.o
++obj-$(CONFIG_RTC_DRV_RPI)	+= rtc-rpi.o
+ obj-$(CONFIG_RTC_DRV_RS5C313)	+= rtc-rs5c313.o
+ obj-$(CONFIG_RTC_DRV_RS5C348)	+= rtc-rs5c348.o
+ obj-$(CONFIG_RTC_DRV_RS5C372)	+= rtc-rs5c372.o
+--- /dev/null
++++ b/drivers/rtc/rtc-rpi.c
+@@ -0,0 +1,177 @@
++// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
++/**
++ * rtc-rpi.c
++ *
++ * RTC driver using firmware mailbox
++ * Supports battery backed RTC and wake alarms
++ *
++ * Based on rtc-meson-vrtc by Neil Armstrong
++ *
++ * Copyright (c) 2023, Raspberry Pi Ltd.
++ */
++
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/rtc.h>
++#include <linux/of.h>
++#include <soc/bcm2835/raspberrypi-firmware.h>
++
++struct rpi_rtc_data {
++	struct rtc_device *rtc;
++	struct rpi_firmware *fw;
++};
++
++#define RPI_FIRMWARE_GET_RTC_REG 0x00030087
++#define RPI_FIRMWARE_SET_RTC_REG 0x00038087
++enum {RTC_TIME, RTC_ALARM, RTC_ALARM_PENDING, RTC_ALARM_ENABLE};
++
++static int rpi_rtc_read_time(struct device *dev, struct rtc_time *tm)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev);
++	u32 data[2] = {RTC_TIME};
++	int err;
++
++	err = rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_GET_RTC_REG,
++				    &data, sizeof(data));
++	rtc_time64_to_tm(data[1], tm);
++	return err;
++}
++
++static int rpi_rtc_set_time(struct device *dev, struct rtc_time *tm)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev);
++	u32 data[2] = {RTC_TIME, rtc_tm_to_time64(tm)};
++
++	return rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_SET_RTC_REG,
++				     &data, sizeof(data));
++}
++
++static int rpi_rtc_alarm_irq_is_enabled(struct device *dev, unsigned char *enabled)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev);
++	u32 data[2] = {RTC_ALARM_ENABLE};
++	s32 err = 0;
++
++	err = rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_GET_RTC_REG,
++				    &data, sizeof(data));
++	*enabled = data[1] & 0x1;
++	return err;
++}
++
++static int rpi_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev);
++	u32 data[2] = {RTC_ALARM_ENABLE, enabled};
++
++	return rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_SET_RTC_REG,
++				     &data, sizeof(data));
++}
++
++static int rpi_rtc_alarm_clear_pending(struct device *dev)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev);
++	u32 data[2] = {RTC_ALARM_PENDING, 1};
++
++	return rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_SET_RTC_REG,
++				     &data, sizeof(data));
++}
++
++static int rpi_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev);
++	u32 data[2] = {RTC_ALARM};
++	s32 err = 0;
++
++	err = rpi_rtc_alarm_irq_is_enabled(dev, &alarm->enabled);
++	if (!err)
++		err = rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_GET_RTC_REG,
++					    &data, sizeof(data));
++	rtc_time64_to_tm(data[1], &alarm->time);
++
++	return err;
++}
++
++static int rpi_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev);
++	u32 data[2] = {RTC_ALARM, rtc_tm_to_time64(&alarm->time)};
++	int err;
++
++	err = rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_SET_RTC_REG,
++				    &data, sizeof(data));
++
++	if (err == 0)
++		err = rpi_rtc_alarm_irq_enable(dev, alarm->enabled);
++
++	return err;
++}
++
++static const struct rtc_class_ops rpi_rtc_ops = {
++	.read_time = rpi_rtc_read_time,
++	.set_time = rpi_rtc_set_time,
++	.read_alarm = rpi_rtc_read_alarm,
++	.set_alarm = rpi_rtc_set_alarm,
++	.alarm_irq_enable = rpi_rtc_alarm_irq_enable,
++};
++
++static int rpi_rtc_probe(struct platform_device *pdev)
++{
++	struct rpi_rtc_data *vrtc;
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++	struct device_node *fw_node;
++	struct rpi_firmware *fw;
++	int ret;
++
++	fw_node = of_parse_phandle(np, "firmware", 0);
++	if (!fw_node) {
++		dev_err(dev, "Missing firmware node\n");
++		return -ENOENT;
++	}
++
++	fw = rpi_firmware_get(fw_node);
++	if (!fw)
++		return -EPROBE_DEFER;
++
++	vrtc = devm_kzalloc(&pdev->dev, sizeof(*vrtc), GFP_KERNEL);
++	if (!vrtc)
++		return -ENOMEM;
++
++	vrtc->fw = fw;
++
++	device_init_wakeup(&pdev->dev, 1);
++
++	platform_set_drvdata(pdev, vrtc);
++
++	vrtc->rtc = devm_rtc_allocate_device(&pdev->dev);
++	if (IS_ERR(vrtc->rtc))
++		return PTR_ERR(vrtc->rtc);
++
++	set_bit(RTC_FEATURE_ALARM_WAKEUP_ONLY, vrtc->rtc->features);
++	clear_bit(RTC_FEATURE_UPDATE_INTERRUPT, vrtc->rtc->features);
++
++	vrtc->rtc->ops = &rpi_rtc_ops;
++	ret = devm_rtc_register_device(vrtc->rtc);
++
++	rpi_rtc_alarm_clear_pending(dev);
++	return ret;
++}
++
++static const struct of_device_id rpi_rtc_dt_match[] = {
++	{ .compatible = "raspberrypi,rpi-rtc"},
++	{},
++};
++MODULE_DEVICE_TABLE(of, rpi_rtc_dt_match);
++
++static struct platform_driver rpi_rtc_driver = {
++	.probe = rpi_rtc_probe,
++	.driver = {
++		.name = "rpi-rtc",
++		.of_match_table = rpi_rtc_dt_match,
++	},
++};
++
++module_platform_driver(rpi_rtc_driver);
++
++MODULE_DESCRIPTION("Raspberry Pi RTC driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/bcm27xx/patches-6.1/950-0920-dt-bindings-rtc-new-binding-for-Raspberry-Pi-RTC-dri.patch b/target/linux/bcm27xx/patches-6.1/950-0920-dt-bindings-rtc-new-binding-for-Raspberry-Pi-RTC-dri.patch
new file mode 100644
index 0000000000..f4c630cf09
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0920-dt-bindings-rtc-new-binding-for-Raspberry-Pi-RTC-dri.patch
@@ -0,0 +1,35 @@
+From ff2c2f67689e10ad66c1e33ae6a7552d82ac983c Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Fri, 7 Jul 2023 20:16:06 +0100
+Subject: [PATCH] dt-bindings: rtc: new binding for Raspberry Pi RTC driver
+
+Add binding for the new RTC driver for Raspberry Pi.
+This platform has an RTC managed by firmware, and this RTC
+driver provides the simple mailbox interface to access it.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ .../devicetree/bindings/rtc/rtc-rpi.txt         | 17 +++++++++++++++++
+ 1 file changed, 17 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/rtc/rtc-rpi.txt
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/rtc/rtc-rpi.txt
+@@ -0,0 +1,17 @@
++* Raspberry Pi RTC
++
++This is a Linux interface to an RTC managed by firmware, hence it's
++virtual from a Linux perspective.
++
++The interface uses the firmware mailbox api to access the RTC registers.
++
++Required properties:
++compatible: should be "raspberrypi,rpi-rtc"
++firmware:   Reference to the RPi firmware device node.
++
++Example:
++
++	rpi_rtc: rpi_rtc {
++		compatible = "raspberrypi,rpi-rtc";
++		firmware = <&firmware>;
++	};
diff --git a/target/linux/bcm27xx/patches-6.1/950-0921-hwmon-pwm-fan-Add-fan-speed-register-support.patch b/target/linux/bcm27xx/patches-6.1/950-0921-hwmon-pwm-fan-Add-fan-speed-register-support.patch
new file mode 100644
index 0000000000..205806cdfd
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0921-hwmon-pwm-fan-Add-fan-speed-register-support.patch
@@ -0,0 +1,164 @@
+From 96a8a4776cb142f5d2bb7f6379df9af40e727c0b Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 11 Jul 2023 10:17:29 +0100
+Subject: [PATCH] hwmon: (pwm-fan) Add fan speed register support
+
+Some platforms include a fan-speed register that reports RPM directly
+as an alternative to counting interrupts from the fan tachometer input.
+Add support for reading a register at a given offset (rpm-offset) within
+a block declared in another node (rpm-regmap). This indirection allows
+the usual address mapping to be performed, and for address sharing with
+another driver.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/hwmon/pwm-fan.c | 59 ++++++++++++++++++++++++++++++++++++-----
+ 1 file changed, 52 insertions(+), 7 deletions(-)
+
+--- a/drivers/hwmon/pwm-fan.c
++++ b/drivers/hwmon/pwm-fan.c
+@@ -12,6 +12,7 @@
+ #include <linux/module.h>
+ #include <linux/mutex.h>
+ #include <linux/of.h>
++#include <linux/of_address.h>
+ #include <linux/platform_device.h>
+ #include <linux/pwm.h>
+ #include <linux/regulator/consumer.h>
+@@ -51,6 +52,9 @@ struct pwm_fan_ctx {
+ 	ktime_t sample_start;
+ 	struct timer_list rpm_timer;
+ 
++	void __iomem *rpm_regbase;
++	unsigned int rpm_offset;
++
+ 	unsigned int pwm_value;
+ 	unsigned int pwm_fan_state;
+ 	unsigned int pwm_fan_max_state;
+@@ -61,6 +65,10 @@ struct pwm_fan_ctx {
+ 	struct hwmon_channel_info fan_channel;
+ };
+ 
++static const u32 rpm_reg_channel_config[] = {
++	HWMON_F_INPUT, 0
++};
++
+ /* This handler assumes self resetting edge triggered interrupt. */
+ static irqreturn_t pulse_handler(int irq, void *dev_id)
+ {
+@@ -335,7 +343,10 @@ static int pwm_fan_read(struct device *d
+ 		}
+ 		return -EOPNOTSUPP;
+ 	case hwmon_fan:
+-		*val = ctx->tachs[channel].rpm;
++		if (ctx->rpm_regbase)
++			*val = (long)readl(ctx->rpm_regbase + ctx->rpm_offset);
++		else
++			*val = ctx->tachs[channel].rpm;
+ 		return 0;
+ 
+ 	default:
+@@ -470,6 +481,7 @@ static void pwm_fan_cleanup(void *__ctx)
+ 	/* Switch off everything */
+ 	ctx->enable_mode = pwm_disable_reg_disable;
+ 	pwm_fan_power_off(ctx);
++	iounmap(ctx->rpm_regbase);
+ }
+ 
+ static int pwm_fan_probe(struct platform_device *pdev)
+@@ -534,10 +546,23 @@ static int pwm_fan_probe(struct platform
+ 		return ret;
+ 
+ 	ctx->tach_count = platform_irq_count(pdev);
++	if (ctx->tach_count == 0) {
++		struct device_node *rpm_node;
++
++		rpm_node = of_parse_phandle(dev->of_node, "rpm-regmap", 0);
++		if (rpm_node)
++			ctx->rpm_regbase = of_iomap(rpm_node, 0);
++	}
++
+ 	if (ctx->tach_count < 0)
+ 		return dev_err_probe(dev, ctx->tach_count,
+ 				     "Could not get number of fan tachometer inputs\n");
+-	dev_dbg(dev, "%d fan tachometer inputs\n", ctx->tach_count);
++	if (IS_ERR(ctx->rpm_regbase))
++		return dev_err_probe(dev, PTR_ERR(ctx->rpm_regbase),
++				     "Could not get rpm reg\n");
++
++	dev_dbg(dev, "%d fan tachometer inputs, %d rpm regmap\n", ctx->tach_count,
++		!!ctx->rpm_regbase);
+ 
+ 	if (ctx->tach_count) {
+ 		channel_count++;	/* We also have a FAN channel. */
+@@ -554,12 +579,24 @@ static int pwm_fan_probe(struct platform
+ 		if (!fan_channel_config)
+ 			return -ENOMEM;
+ 		ctx->fan_channel.config = fan_channel_config;
++	} else if (ctx->rpm_regbase) {
++		channel_count++;	/* We also have a FAN channel. */
++		ctx->fan_channel.type = hwmon_fan;
++		ctx->fan_channel.config = rpm_reg_channel_config;
++
++		if (of_property_read_u32(pdev->dev.of_node, "rpm-offset", &ctx->rpm_offset)) {
++			dev_err(&pdev->dev, "unable to read 'rpm-offset'");
++			ret = -EINVAL;
++			goto error;
++		}
+ 	}
+ 
+ 	channels = devm_kcalloc(dev, channel_count + 1,
+ 				sizeof(struct hwmon_channel_info *), GFP_KERNEL);
+-	if (!channels)
+-		return -ENOMEM;
++	if (!channels) {
++		ret = -ENOMEM;
++		goto error;
++	}
+ 
+ 	channels[0] = HWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_ENABLE);
+ 
+@@ -602,6 +639,8 @@ static int pwm_fan_probe(struct platform
+ 		mod_timer(&ctx->rpm_timer, jiffies + HZ);
+ 
+ 		channels[1] = &ctx->fan_channel;
++	} else if (ctx->rpm_regbase) {
++		channels[1] = &ctx->fan_channel;
+ 	}
+ 
+ 	ctx->info.ops = &pwm_fan_hwmon_ops;
+@@ -611,12 +650,13 @@ static int pwm_fan_probe(struct platform
+ 						     ctx, &ctx->info, NULL);
+ 	if (IS_ERR(hwmon)) {
+ 		dev_err(dev, "Failed to register hwmon device\n");
+-		return PTR_ERR(hwmon);
++		ret = PTR_ERR(hwmon);
++		goto error;
+ 	}
+ 
+ 	ret = pwm_fan_of_get_cooling_data(dev, ctx);
+ 	if (ret)
+-		return ret;
++		goto error;
+ 
+ 	ctx->pwm_fan_state = ctx->pwm_fan_max_state;
+ 	if (IS_ENABLED(CONFIG_THERMAL)) {
+@@ -627,12 +667,17 @@ static int pwm_fan_probe(struct platform
+ 			dev_err(dev,
+ 				"Failed to register pwm-fan as cooling device: %d\n",
+ 				ret);
+-			return ret;
++			goto error;
+ 		}
+ 		ctx->cdev = cdev;
+ 	}
+ 
+ 	return 0;
++
++error:
++	if (ctx->rpm_regbase)
++		iounmap(ctx->rpm_regbase);
++	return ret;
+ }
+ 
+ static void pwm_fan_shutdown(struct platform_device *pdev)
diff --git a/target/linux/bcm27xx/patches-6.1/950-0922-media-i2c-imx296-Add-2ms-delay-after-releasing-stand.patch b/target/linux/bcm27xx/patches-6.1/950-0922-media-i2c-imx296-Add-2ms-delay-after-releasing-stand.patch
new file mode 100644
index 0000000000..709db039fc
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0922-media-i2c-imx296-Add-2ms-delay-after-releasing-stand.patch
@@ -0,0 +1,23 @@
+From ecbc04aa0c2e7c8879764c9d2c769ecc74fd9093 Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Fri, 28 Jul 2023 11:59:28 +0100
+Subject: [PATCH] media: i2c: imx296: Add 2ms delay after releasing standby
+
+The delay seems to be required to reliably read model ID.
+(The same delay is already used when starting the camera.)
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/media/i2c/imx296.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/media/i2c/imx296.c
++++ b/drivers/media/i2c/imx296.c
+@@ -1031,6 +1031,7 @@ static int imx296_identify_model(struct
+ 			"failed to get sensor out of standby (%d)\n", ret);
+ 		return ret;
+ 	}
++	usleep_range(2000, 5000);
+ 
+ 	usleep_range(2000, 5000);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0923-dt-bindings-input-Add-bindings-for-raspberrypi-butto.patch b/target/linux/bcm27xx/patches-6.1/950-0923-dt-bindings-input-Add-bindings-for-raspberrypi-butto.patch
new file mode 100644
index 0000000000..2972c57fd7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0923-dt-bindings-input-Add-bindings-for-raspberrypi-butto.patch
@@ -0,0 +1,63 @@
+From 07419175fdb507be2c9d3aaf4b7d18306a336348 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 2 Aug 2023 11:38:03 +0100
+Subject: [PATCH] dt-bindings: input: Add bindings for raspberrypi-button
+
+Add bindings for the firmware-based button driver.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ .../input/raspberrypi,firmware-button.yaml    | 47 +++++++++++++++++++
+ 1 file changed, 47 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/input/raspberrypi,firmware-button.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/input/raspberrypi,firmware-button.yaml
+@@ -0,0 +1,47 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/input/raspberrypi,firmware-button.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Raspberry Pi firmware buttons
++
++maintainers:
++  - Phil Elwell <phil@raspberrypi.com>
++
++description: >
++  The Raspberry Pi 5 firmware exposes the state of the power button. The
++  raspberrypi-button driver generates a keycode when it is pressed.
++
++properties:
++  compatible:
++    enum:
++      - raspberrypi,firmware-button
++
++  id:
++    description: A numeric identifier of the button
++
++  label:
++    description: Descriptive name of the button.
++
++  linux,code:
++    description: Key code to emit.
++
++required:
++  - compatible
++  - linux,code
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/input/raspberrypi-button.h>
++
++    pwr_button: pwr_button {
++        compatible = "raspberrypi,firmware-button";
++        id = <RASPBERRYPI_BUTTON_POWER>;
++        label = "pwr_button";
++        linux,code = <116>; // KEY_POWER
++    };
++
++...
diff --git a/target/linux/bcm27xx/patches-6.1/950-0924-dt-bindings-input-Add-bindings-for-raspberrypi-butto.patch b/target/linux/bcm27xx/patches-6.1/950-0924-dt-bindings-input-Add-bindings-for-raspberrypi-butto.patch
new file mode 100644
index 0000000000..e8fea23ce8
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0924-dt-bindings-input-Add-bindings-for-raspberrypi-butto.patch
@@ -0,0 +1,27 @@
+From 93c8947bc7813b49fe27a5251eef97c6df1e14c6 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 2 Aug 2023 15:01:29 +0100
+Subject: [PATCH] dt-bindings: input: Add bindings for raspberrypi-button
+
+Add bindings for the firmware-based button driver.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ include/dt-bindings/input/raspberrypi-button.h | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
+ create mode 100644 include/dt-bindings/input/raspberrypi-button.h
+
+--- /dev/null
++++ b/include/dt-bindings/input/raspberrypi-button.h
+@@ -0,0 +1,11 @@
++/* SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0 */
++/*
++ * This header provides constants the raspberrypi-button driver.
++ */
++
++#ifndef _DT_BINDINGS_RASPBERRYPI_BUTTON_H
++#define _DT_BINDINGS_RASPBERRYPI_BUTTON_H
++
++#define RASPBERRYPI_BUTTON_POWER 0
++
++#endif
diff --git a/target/linux/bcm27xx/patches-6.1/950-0925-Input-Add-raspberrypi-button-firmware-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0925-Input-Add-raspberrypi-button-firmware-driver.patch
new file mode 100644
index 0000000000..76a9261a68
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0925-Input-Add-raspberrypi-button-firmware-driver.patch
@@ -0,0 +1,197 @@
+From 7c0d40384b0648030d5202114d90239b8db7d4e0 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 2 Aug 2023 11:30:48 +0100
+Subject: [PATCH] Input: Add raspberrypi-button firmware driver
+
+Raspberry Pi 5s have a power/suspend button that is only accessible to
+the firmware. Add a driver to read it and generate key events.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/input/misc/Kconfig                 |  10 ++
+ drivers/input/misc/Makefile                |   1 +
+ drivers/input/misc/raspberrypi-button.c    | 138 +++++++++++++++++++++
+ include/soc/bcm2835/raspberrypi-firmware.h |   1 +
+ 4 files changed, 150 insertions(+)
+ create mode 100644 drivers/input/misc/raspberrypi-button.c
+
+--- a/drivers/input/misc/Kconfig
++++ b/drivers/input/misc/Kconfig
+@@ -918,6 +918,16 @@ config INPUT_RT5120_PWRKEY
+ 	  To compile this driver as a module, choose M here. the module will
+ 	  be called rt5120-pwrkey.
+ 
++config INPUT_RASPBERRYPI_BUTTON
++	tristate "Raspberry Pi button support"
++	depends on RASPBERRYPI_FIRMWARE || (COMPILE_TEST && !RASPBERRYPI_FIRMWARE)
++	help
++	  This enables support for firmware-controlled buttons on Raspberry
++	  Pi devices.
++
++	  To compile this driver as a module, choose M here. the module will
++	  be called raspberrypi-button.
++
+ config INPUT_STPMIC1_ONKEY
+ 	tristate "STPMIC1 PMIC Onkey support"
+ 	depends on MFD_STPMIC1
+--- a/drivers/input/misc/Makefile
++++ b/drivers/input/misc/Makefile
+@@ -70,6 +70,7 @@ obj-$(CONFIG_INPUT_RAVE_SP_PWRBUTTON)	+=
+ obj-$(CONFIG_INPUT_RB532_BUTTON)	+= rb532_button.o
+ obj-$(CONFIG_INPUT_REGULATOR_HAPTIC)	+= regulator-haptic.o
+ obj-$(CONFIG_INPUT_RETU_PWRBUTTON)	+= retu-pwrbutton.o
++obj-$(CONFIG_INPUT_RASPBERRYPI_BUTTON)	+= raspberrypi-button.o
+ obj-$(CONFIG_INPUT_RT5120_PWRKEY)	+= rt5120-pwrkey.o
+ obj-$(CONFIG_INPUT_AXP20X_PEK)		+= axp20x-pek.o
+ obj-$(CONFIG_INPUT_GPIO_ROTARY_ENCODER)	+= rotary_encoder.o
+--- /dev/null
++++ b/drivers/input/misc/raspberrypi-button.c
+@@ -0,0 +1,138 @@
++// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
++/*
++ * Driver for Raspberry Pi power button
++ *
++ * Copyright (C) 2023 Raspberry Pi Ltd.
++ *
++ * This driver is based on drivers/hwmon/raspberrypi-hwmon.c and
++ * input/misc/pm8941-pwrkey.c/ - see original files for copyright information
++ */
++
++#include <linux/delay.h>
++#include <linux/devm-helpers.h>
++#include <dt-bindings/input/raspberrypi-button.h>
++#include <linux/errno.h>
++#include <linux/input.h>
++#include <linux/kernel.h>
++#include <linux/ktime.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/workqueue.h>
++#include <soc/bcm2835/raspberrypi-firmware.h>
++
++struct rpi_button {
++	struct device *dev;
++	struct rpi_firmware *fw;
++	struct input_dev *input;
++	struct delayed_work poll_work;
++	unsigned long poll_rate;
++	const char *name;
++	u32 id;
++	u32 code;
++};
++
++static void button_poll(struct work_struct *work)
++{
++	struct rpi_button *button;
++	u32 value;
++	int err;
++
++	button = container_of(work, struct rpi_button,
++			      poll_work.work);
++
++	value = BIT(button->id);
++	err = rpi_firmware_property(button->fw, RPI_FIRMWARE_GET_BUTTONS_PRESSED,
++				    &value, sizeof(value));
++	if (err) {
++		dev_err_once(button->dev, "GET_BUTTON_PRESSED not implemented?\n");
++		return;
++	}
++
++	if (value & BIT(button->id)) {
++		input_event(button->input, EV_KEY, button->code, 1);
++		input_sync(button->input);
++		input_event(button->input, EV_KEY, button->code, 0);
++		input_sync(button->input);
++	}
++
++	schedule_delayed_work(&button->poll_work, button->poll_rate);
++}
++
++static int rpi_button_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct rpi_button *button;
++	int err;
++
++	button = devm_kzalloc(dev, sizeof(*button), GFP_KERNEL);
++	if (!button)
++		return -ENOMEM;
++
++	button->dev = dev;
++
++	/* Get the firmware pointer from our parent */
++	button->fw = dev_get_drvdata(dev->parent);
++
++	if (device_property_read_u32(dev, "id", &button->id))
++		button->id = RASPBERRYPI_BUTTON_POWER;
++
++	if (device_property_read_string(dev, "label", &button->name))
++		button->name = "raspberrypi-button";
++
++	if (device_property_read_u32(dev, "linux,code", &button->code)) {
++		dev_err(&pdev->dev, "no linux,code property\n");
++		return -EINVAL;
++	}
++
++	button->input = devm_input_allocate_device(dev);
++	if (!button->input) {
++		dev_dbg(&pdev->dev, "unable to allocate input device\n");
++		return -ENOMEM;
++	}
++
++	input_set_capability(button->input, EV_KEY, button->code);
++
++	button->input->name = button->name;
++	button->input->phys = "raspberrypi-button/input0";
++	button->input->dev.parent = dev;
++	button->poll_rate = HZ;
++
++	err = input_register_device(button->input);
++	if (err) {
++		dev_err(&pdev->dev, "failed to register input device: %d\n",
++			err);
++		return err;
++	}
++
++	err = devm_delayed_work_autocancel(dev, &button->poll_work,
++					   button_poll);
++	if (err)
++		return err;
++
++	platform_set_drvdata(pdev, button);
++	schedule_delayed_work(&button->poll_work, button->poll_rate);
++
++	return 0;
++}
++
++static const struct of_device_id rpi_button_match[] = {
++	{ .compatible = "raspberrypi,firmware-button", },
++	{ }
++};
++MODULE_DEVICE_TABLE(of, rpi_button_match);
++
++static struct platform_driver rpi_button_driver = {
++	.probe = rpi_button_probe,
++	.driver = {
++		.name = "raspberrypi-button",
++		.of_match_table = of_match_ptr(rpi_button_match),
++	},
++};
++module_platform_driver(rpi_button_driver);
++
++MODULE_AUTHOR("Phil Elwell <phil@raspberrypi.com>");
++MODULE_DESCRIPTION("Raspberry Pi button driver");
++MODULE_LICENSE("Dual BSD/GPL");
+--- a/include/soc/bcm2835/raspberrypi-firmware.h
++++ b/include/soc/bcm2835/raspberrypi-firmware.h
+@@ -98,6 +98,7 @@ enum rpi_firmware_property_tag {
+ 	RPI_FIRMWARE_GET_REBOOT_FLAGS =                       0x00030064,
+ 	RPI_FIRMWARE_SET_REBOOT_FLAGS =                       0x00038064,
+ 	RPI_FIRMWARE_NOTIFY_DISPLAY_DONE =                    0x00030066,
++	RPI_FIRMWARE_GET_BUTTONS_PRESSED =                    0x00030088,
+ 
+ 	/* Dispmanx TAGS */
+ 	RPI_FIRMWARE_FRAMEBUFFER_ALLOCATE =                   0x00040001,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0926-dt-bindings-update-rpi-rtc-binding.patch b/target/linux/bcm27xx/patches-6.1/950-0926-dt-bindings-update-rpi-rtc-binding.patch
new file mode 100644
index 0000000000..ffc5cc1a9d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0926-dt-bindings-update-rpi-rtc-binding.patch
@@ -0,0 +1,29 @@
+From a7a3679a148e40879f1ce77580d9edf64cb5b51c Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Mon, 18 Sep 2023 16:33:06 +0100
+Subject: [PATCH] dt: bindings: update rpi-rtc binding
+
+Add property for bcm2712 firmware RTC driver charger control
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ Documentation/devicetree/bindings/rtc/rtc-rpi.txt | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/Documentation/devicetree/bindings/rtc/rtc-rpi.txt
++++ b/Documentation/devicetree/bindings/rtc/rtc-rpi.txt
+@@ -9,9 +9,14 @@ Required properties:
+ compatible: should be "raspberrypi,rpi-rtc"
+ firmware:   Reference to the RPi firmware device node.
+ 
++Optional property:
++trickle-charge-microvolt: specify a trickle charge voltage for the backup
++                          battery in microvolts.
++
+ Example:
+ 
+ 	rpi_rtc: rpi_rtc {
+ 		compatible = "raspberrypi,rpi-rtc";
+ 		firmware = <&firmware>;
++		trickle-charge-microvolt = <3000000>;
+ 	};
diff --git a/target/linux/bcm27xx/patches-6.1/950-0927-drivers-rtc-rpi-add-battery-charge-circuit-control-a.patch b/target/linux/bcm27xx/patches-6.1/950-0927-drivers-rtc-rpi-add-battery-charge-circuit-control-a.patch
new file mode 100644
index 0000000000..dae0a1cbff
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0927-drivers-rtc-rpi-add-battery-charge-circuit-control-a.patch
@@ -0,0 +1,153 @@
+From 33b514cb16dbf13395a0becf7442d19676ae4224 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Fri, 15 Sep 2023 17:33:03 +0100
+Subject: [PATCH] drivers: rtc-rpi: add battery charge circuit control and
+ readback
+
+Parse devicetree for a charger voltage and apply it. If nonzero and a
+valid voltage, the firmware will enable charging, otherwise the charger
+circuit is disabled.
+
+Add sysfs attributes to read back the supported charge voltage range,
+the measured battery voltage, and the charger setpoint.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/rtc/rtc-rpi.c | 106 ++++++++++++++++++++++++++++++++++++++++--
+ 1 file changed, 103 insertions(+), 3 deletions(-)
+
+--- a/drivers/rtc/rtc-rpi.c
++++ b/drivers/rtc/rtc-rpi.c
+@@ -19,11 +19,22 @@
+ struct rpi_rtc_data {
+ 	struct rtc_device *rtc;
+ 	struct rpi_firmware *fw;
++	u32 bbat_vchg_microvolts;
+ };
+ 
+ #define RPI_FIRMWARE_GET_RTC_REG 0x00030087
+ #define RPI_FIRMWARE_SET_RTC_REG 0x00038087
+-enum {RTC_TIME, RTC_ALARM, RTC_ALARM_PENDING, RTC_ALARM_ENABLE};
++
++enum {
++	RTC_TIME,
++	RTC_ALARM,
++	RTC_ALARM_PENDING,
++	RTC_ALARM_ENABLE,
++	RTC_BBAT_CHG_VOLTS,
++	RTC_BBAT_CHG_VOLTS_MIN,
++	RTC_BBAT_CHG_VOLTS_MAX,
++	RTC_BBAT_VOLTS
++};
+ 
+ static int rpi_rtc_read_time(struct device *dev, struct rtc_time *tm)
+ {
+@@ -114,6 +125,83 @@ static const struct rtc_class_ops rpi_rt
+ 	.alarm_irq_enable = rpi_rtc_alarm_irq_enable,
+ };
+ 
++static int rpi_rtc_set_charge_voltage(struct device *dev)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev);
++	u32 data[2] = {RTC_BBAT_CHG_VOLTS, vrtc->bbat_vchg_microvolts};
++	int err;
++
++	err = rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_SET_RTC_REG,
++				    &data, sizeof(data));
++
++	if (err)
++		dev_err(dev, "failed to set trickle charge voltage to %uuV: %d\n",
++			vrtc->bbat_vchg_microvolts, err);
++	else if (vrtc->bbat_vchg_microvolts)
++		dev_info(dev, "trickle charging enabled at %uuV\n",
++			 vrtc->bbat_vchg_microvolts);
++
++	return err;
++}
++
++static ssize_t rpi_rtc_print_uint_reg(struct device *dev, char *buf, u32 reg)
++{
++	struct rpi_rtc_data *vrtc = dev_get_drvdata(dev->parent);
++	u32 data[2] = {reg, 0};
++	int ret = 0;
++
++	ret = rpi_firmware_property(vrtc->fw, RPI_FIRMWARE_GET_RTC_REG,
++				    &data, sizeof(data));
++	if (ret < 0)
++		return ret;
++
++	return sprintf(buf, "%u\n", data[1]);
++}
++
++static ssize_t charging_voltage_show(struct device *dev,
++				     struct device_attribute *attr,
++				     char *buf)
++{
++	return rpi_rtc_print_uint_reg(dev, buf, RTC_BBAT_CHG_VOLTS);
++}
++static DEVICE_ATTR_RO(charging_voltage);
++
++static ssize_t charging_voltage_min_show(struct device *dev,
++					 struct device_attribute *attr,
++					 char *buf)
++{
++	return rpi_rtc_print_uint_reg(dev, buf, RTC_BBAT_CHG_VOLTS_MIN);
++}
++static DEVICE_ATTR_RO(charging_voltage_min);
++
++static ssize_t charging_voltage_max_show(struct device *dev,
++					 struct device_attribute *attr,
++					 char *buf)
++{
++	return rpi_rtc_print_uint_reg(dev, buf, RTC_BBAT_CHG_VOLTS_MAX);
++}
++static DEVICE_ATTR_RO(charging_voltage_max);
++
++static ssize_t battery_voltage_show(struct device *dev,
++				    struct device_attribute *attr,
++				    char *buf)
++{
++	return rpi_rtc_print_uint_reg(dev, buf, RTC_BBAT_VOLTS);
++}
++static DEVICE_ATTR_RO(battery_voltage);
++
++static struct attribute *rpi_rtc_attrs[] = {
++	&dev_attr_charging_voltage.attr,
++	&dev_attr_charging_voltage_min.attr,
++	&dev_attr_charging_voltage_max.attr,
++	&dev_attr_battery_voltage.attr,
++	NULL
++};
++
++static const struct attribute_group rpi_rtc_sysfs_files = {
++	.attrs = rpi_rtc_attrs,
++};
++
+ static int rpi_rtc_probe(struct platform_device *pdev)
+ {
+ 	struct rpi_rtc_data *vrtc;
+@@ -151,10 +239,22 @@ static int rpi_rtc_probe(struct platform
+ 	clear_bit(RTC_FEATURE_UPDATE_INTERRUPT, vrtc->rtc->features);
+ 
+ 	vrtc->rtc->ops = &rpi_rtc_ops;
+-	ret = devm_rtc_register_device(vrtc->rtc);
++	ret = rtc_add_group(vrtc->rtc, &rpi_rtc_sysfs_files);
++	if (ret)
++		return ret;
+ 
+ 	rpi_rtc_alarm_clear_pending(dev);
+-	return ret;
++
++	/*
++	 * Optionally enable trickle charging - if the property isn't
++	 * present (or set to zero), trickle charging is disabled.
++	 */
++	of_property_read_u32(np, "trickle-charge-microvolt",
++			     &vrtc->bbat_vchg_microvolts);
++
++	rpi_rtc_set_charge_voltage(dev);
++
++	return devm_rtc_register_device(vrtc->rtc);
+ }
+ 
+ static const struct of_device_id rpi_rtc_dt_match[] = {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0928-vc4_drv-Avoid-panic-when-booted-with-no-kms.patch b/target/linux/bcm27xx/patches-6.1/950-0928-vc4_drv-Avoid-panic-when-booted-with-no-kms.patch
new file mode 100644
index 0000000000..8aae09c81a
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0928-vc4_drv-Avoid-panic-when-booted-with-no-kms.patch
@@ -0,0 +1,29 @@
+From 0f5fd4538774aa6c936bb8fc78611c3113bf19d7 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Mon, 17 Apr 2023 15:21:41 +0100
+Subject: [PATCH] vc4_drv: Avoid panic when booted with no kms
+
+If kms/fkms overlay is not present we have no matching drivers
+and so match is NULL.
+
+It is not safe to call component_master_add_with_match with a null match argument.
+
+So don't do that
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/gpu/drm/vc4/vc4_drv.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.c
++++ b/drivers/gpu/drm/vc4/vc4_drv.c
+@@ -456,6 +456,9 @@ static int vc4_platform_drm_probe(struct
+ 	vc4_match_add_drivers(dev, &match,
+ 			      component_drivers, ARRAY_SIZE(component_drivers));
+ 
++	if (!match)
++		return -ENODEV;
++
+ 	return component_master_add_with_match(dev, &vc4_drm_ops, match);
+ }
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0929-drm-vc4-Treat-zero-sized-destination-as-full-screen.patch b/target/linux/bcm27xx/patches-6.1/950-0929-drm-vc4-Treat-zero-sized-destination-as-full-screen.patch
new file mode 100644
index 0000000000..70a11df293
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0929-drm-vc4-Treat-zero-sized-destination-as-full-screen.patch
@@ -0,0 +1,28 @@
+From 2c987545a88507acdd8a572a3bd23a4ca0124d14 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Thu, 13 Apr 2023 17:41:11 +0100
+Subject: [PATCH] drm/vc4: Treat zero sized destination as full screen
+
+Kodi video planes come through with all zeros for fullscreen
+Without this check, we WARN when writing width-1, height-1
+to destination dlist
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/gpu/drm/vc4/vc4_plane.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -484,6 +484,11 @@ static int vc4_plane_setup_clipping_and_
+ 	vc4_state->crtc_w = state->dst.x2 - state->dst.x1;
+ 	vc4_state->crtc_h = state->dst.y2 - state->dst.y1;
+ 
++	if (!vc4_state->crtc_w)
++		vc4_state->crtc_w = state->crtc->mode.hdisplay;
++	if (!vc4_state->crtc_h)
++		vc4_state->crtc_h = state->crtc->mode.vdisplay;
++
+ 	ret = vc4_plane_margins_adj(state);
+ 	if (ret)
+ 		return ret;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0930-drm-vc4-Fix-FKMS-for-when-the-YUV-chroma-planes-are-.patch b/target/linux/bcm27xx/patches-6.1/950-0930-drm-vc4-Fix-FKMS-for-when-the-YUV-chroma-planes-are-.patch
new file mode 100644
index 0000000000..46bc00c548
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0930-drm-vc4-Fix-FKMS-for-when-the-YUV-chroma-planes-are-.patch
@@ -0,0 +1,50 @@
+From bb1ee75de382c7a5218750476aa2a5792309cc70 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 30 Mar 2023 17:18:36 +0100
+Subject: [PATCH] drm/vc4: Fix FKMS for when the YUV chroma planes are
+ different buffers
+
+The code was assuming that it was a single buffer with offsets,
+when kmstest uses separate buffers and 0 offsets for each plane.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_firmware_kms.c | 10 +++++++---
+ 1 file changed, 7 insertions(+), 3 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_firmware_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_firmware_kms.c
+@@ -521,7 +521,7 @@ static int vc4_plane_to_mb(struct drm_pl
+ 			   struct drm_plane_state *state)
+ {
+ 	struct drm_framebuffer *fb = state->fb;
+-	struct drm_gem_dma_object *bo = drm_fb_dma_get_gem_obj(fb, 0);
++	struct drm_gem_dma_object *bo;
+ 	const struct drm_format_info *drm_fmt = fb->format;
+ 	const struct vc_image_format *vc_fmt =
+ 					vc4_get_vc_image_fmt(drm_fmt->format);
+@@ -545,6 +545,7 @@ static int vc4_plane_to_mb(struct drm_pl
+ 					state->normalized_zpos : -127;
+ 	mb->plane.num_planes = num_planes;
+ 	mb->plane.is_vu = vc_fmt->is_vu;
++	bo = drm_fb_dma_get_gem_obj(fb, 0);
+ 	mb->plane.planes[0] = bo->dma_addr + fb->offsets[0];
+ 
+ 	rotation = drm_rotation_simplify(state->rotation,
+@@ -565,11 +566,14 @@ static int vc4_plane_to_mb(struct drm_pl
+ 		/* Makes assumptions on the stride for the chroma planes as we
+ 		 * can't easily plumb in non-standard pitches.
+ 		 */
++		bo = drm_fb_dma_get_gem_obj(fb, 1);
+ 		mb->plane.planes[1] = bo->dma_addr + fb->offsets[1];
+-		if (num_planes > 2)
++		if (num_planes > 2) {
++			bo = drm_fb_dma_get_gem_obj(fb, 2);
+ 			mb->plane.planes[2] = bo->dma_addr + fb->offsets[2];
+-		else
++		} else {
+ 			mb->plane.planes[2] = 0;
++		}
+ 
+ 		/* Special case the YUV420 with U and V as line interleaved
+ 		 * planes as we have special handling for that case.
diff --git a/target/linux/bcm27xx/patches-6.1/950-0931-drm-vc4-hdmi-Enable-the-audio-clock.patch b/target/linux/bcm27xx/patches-6.1/950-0931-drm-vc4-hdmi-Enable-the-audio-clock.patch
new file mode 100644
index 0000000000..f228dca9d5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0931-drm-vc4-hdmi-Enable-the-audio-clock.patch
@@ -0,0 +1,39 @@
+From 0da58dfbd2cc2cfa14a629787b9ba6fa10b5f666 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Wed, 29 Mar 2023 15:26:52 +0100
+Subject: [PATCH] drm/vc4: hdmi: Enable the audio clock
+
+The audio clock is used by the HDMI controller driver and we were using
+it to get its audio rate and compute the dividers needed to reach a
+given audio sample rate.
+
+However, we were never enabling it, which was resulting in lockups on
+the BCM2712.
+
+Fixes: 632ee3aa8786 ("drm/vc4: hdmi: Add audio-related callbacks")
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hdmi.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_hdmi.c
++++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
+@@ -3625,6 +3625,7 @@ static int vc4_hdmi_runtime_suspend(stru
+ {
+ 	struct vc4_hdmi *vc4_hdmi = dev_get_drvdata(dev);
+ 
++	clk_disable_unprepare(vc4_hdmi->audio_clock);
+ 	clk_disable_unprepare(vc4_hdmi->hsm_rpm_clock);
+ 
+ 	return 0;
+@@ -3666,6 +3667,10 @@ static int vc4_hdmi_runtime_resume(struc
+ 		goto err_disable_clk;
+ 	}
+ 
++	ret = clk_prepare_enable(vc4_hdmi->audio_clock);
++	if (ret)
++		goto err_disable_clk;
++
+ 	if (vc4_hdmi->variant->reset)
+ 		vc4_hdmi->variant->reset(vc4_hdmi);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0932-drm-vc4-hdmi-Warn-if-writing-to-an-unknown-HDMI-regi.patch b/target/linux/bcm27xx/patches-6.1/950-0932-drm-vc4-hdmi-Warn-if-writing-to-an-unknown-HDMI-regi.patch
new file mode 100644
index 0000000000..fa6a399dae
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0932-drm-vc4-hdmi-Warn-if-writing-to-an-unknown-HDMI-regi.patch
@@ -0,0 +1,31 @@
+From cdbebb3a92aca7327c88c6dc6ef5d4cd470d49fc Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 23 Feb 2023 19:44:32 +0100
+Subject: [PATCH] drm/vc4: hdmi: Warn if writing to an unknown HDMI register
+
+The VC4 HDMI driver has a bunch of accessors to read from a register.
+The read accessor was warning when accessing an unknown register, but
+the write one was just returning silently.
+
+Let's make sure we warn also when writing to an unknown register.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hdmi_regs.h | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hdmi_regs.h
++++ b/drivers/gpu/drm/vc4/vc4_hdmi_regs.h
+@@ -498,8 +498,11 @@ static inline void vc4_hdmi_write(struct
+ 
+ 	field = &variant->registers[reg];
+ 	base = __vc4_hdmi_get_field_base(hdmi, field->reg);
+-	if (!base)
++	if (!base) {
++		dev_warn(&hdmi->pdev->dev,
++			 "Unknown register ID %u\n", reg);
+ 		return;
++	}
+ 
+ 	writel(value, base + field->offset);
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0933-drm-vc4-hvs-More-logging-for-dlist-generation.patch b/target/linux/bcm27xx/patches-6.1/950-0933-drm-vc4-hvs-More-logging-for-dlist-generation.patch
new file mode 100644
index 0000000000..dee2fc0d66
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0933-drm-vc4-hvs-More-logging-for-dlist-generation.patch
@@ -0,0 +1,41 @@
+From 4ebd8283403daf5507e5aafb42fe3e4c7612eb14 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Wed, 22 Mar 2023 09:51:51 +0100
+Subject: [PATCH] drm/vc4: hvs: More logging for dlist generation
+
+DLIST generation can get pretty tricky and there's not a lot of debug in
+the driver to help. Let's add a few more to track the generated DLIST
+size.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 15 +++++++++++++--
+ 1 file changed, 13 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -826,11 +826,22 @@ int vc4_hvs_atomic_check(struct drm_crtc
+ 	if (hweight32(crtc_state->connector_mask) > 1)
+ 		return -EINVAL;
+ 
+-	drm_atomic_crtc_state_for_each_plane_state(plane, plane_state, crtc_state)
+-		dlist_count += vc4_plane_dlist_size(plane_state);
++	drm_atomic_crtc_state_for_each_plane_state(plane, plane_state, crtc_state) {
++		u32 plane_dlist_count = vc4_plane_dlist_size(plane_state);
++
++		drm_dbg_driver(dev, "[CRTC:%d:%s] Found [PLANE:%d:%s] with DLIST size: %u\n",
++			       crtc->base.id, crtc->name,
++			       plane->base.id, plane->name,
++			       plane_dlist_count);
++
++		dlist_count += plane_dlist_count;
++	}
+ 
+ 	dlist_count++; /* Account for SCALER_CTL0_END. */
+ 
++	drm_dbg_driver(dev, "[CRTC:%d:%s] Allocating DLIST block with size: %u\n",
++		       crtc->base.id, crtc->name, dlist_count);
++
+ 	alloc = vc4_hvs_alloc_dlist_entry(vc4->hvs, vc4_state->assigned_channel, dlist_count);
+ 	if (IS_ERR(alloc))
+ 		return PTR_ERR(alloc);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0934-drm-vc4-hvs-Print-error-if-we-fail-an-allocation.patch b/target/linux/bcm27xx/patches-6.1/950-0934-drm-vc4-hvs-Print-error-if-we-fail-an-allocation.patch
new file mode 100644
index 0000000000..7c7bbb4822
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0934-drm-vc4-hvs-Print-error-if-we-fail-an-allocation.patch
@@ -0,0 +1,66 @@
+From c0af63193bd307f281211e7fb32a02a52c2869b2 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Wed, 22 Mar 2023 09:53:17 +0100
+Subject: [PATCH] drm/vc4: hvs: Print error if we fail an allocation
+
+We need to allocate a few additional structures when checking our
+atomic_state, especially related to hardware SRAM that will hold the
+plane descriptors (DLIST) and the current line context (LBM) during
+composition.
+
+Since those allocation can fail, let's add some error message in that
+case to help debug what goes wrong.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c   | 6 +++++-
+ drivers/gpu/drm/vc4/vc4_plane.c | 7 +++++--
+ 2 files changed, 10 insertions(+), 3 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -441,6 +441,8 @@ vc4_hvs_alloc_dlist_entry(struct vc4_hvs
+ 			  unsigned int channel,
+ 			  size_t dlist_count)
+ {
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *dev = &vc4->base;
+ 	struct vc4_hvs_dlist_allocation *alloc;
+ 	unsigned long flags;
+ 	int ret;
+@@ -458,8 +460,10 @@ vc4_hvs_alloc_dlist_entry(struct vc4_hvs
+ 	ret = drm_mm_insert_node(&hvs->dlist_mm, &alloc->mm_node,
+ 				 dlist_count);
+ 	spin_unlock_irqrestore(&hvs->mm_lock, flags);
+-	if (ret)
++	if (ret) {
++		drm_err(dev, "Failed to allocate DLIST entry: %d\n", ret);
+ 		return ERR_PTR(ret);
++	}
+ 
+ 	alloc->channel = channel;
+ 
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -733,7 +733,8 @@ static void vc4_plane_calc_load(struct d
+ 
+ static int vc4_plane_allocate_lbm(struct drm_plane_state *state)
+ {
+-	struct vc4_dev *vc4 = to_vc4_dev(state->plane->dev);
++	struct drm_device *drm = state->plane->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
+ 	unsigned long irqflags;
+ 	u32 lbm_size;
+@@ -759,8 +760,10 @@ static int vc4_plane_allocate_lbm(struct
+ 						 0, 0);
+ 		spin_unlock_irqrestore(&vc4->hvs->mm_lock, irqflags);
+ 
+-		if (ret)
++		if (ret) {
++			drm_err(drm, "Failed to allocate LBM entry: %d\n", ret);
+ 			return ret;
++		}
+ 	} else {
+ 		WARN_ON_ONCE(lbm_size != vc4_state->lbm.size);
+ 	}
diff --git a/target/linux/bcm27xx/patches-6.1/950-0935-drm-vc4-plane-Add-more-debugging-for-LBM-allocation.patch b/target/linux/bcm27xx/patches-6.1/950-0935-drm-vc4-plane-Add-more-debugging-for-LBM-allocation.patch
new file mode 100644
index 0000000000..d8d68e79aa
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0935-drm-vc4-plane-Add-more-debugging-for-LBM-allocation.patch
@@ -0,0 +1,36 @@
+From 164f7e94da446984f275be1c082b93243beadfba Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Wed, 22 Mar 2023 16:17:57 +0100
+Subject: [PATCH] drm/vc4: plane: Add more debugging for LBM allocation
+
+LBM allocations need a different size depending on the line length,
+format, etc.
+
+This can get tricky, and fail. Let's add some more prints to ease the
+debugging when it does.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_plane.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -735,6 +735,7 @@ static int vc4_plane_allocate_lbm(struct
+ {
+ 	struct drm_device *drm = state->plane->dev;
+ 	struct vc4_dev *vc4 = to_vc4_dev(drm);
++	struct drm_plane *plane = state->plane;
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
+ 	unsigned long irqflags;
+ 	u32 lbm_size;
+@@ -743,6 +744,9 @@ static int vc4_plane_allocate_lbm(struct
+ 	if (!lbm_size)
+ 		return 0;
+ 
++	drm_dbg_driver(drm, "[PLANE:%d:%s] LBM Allocation Size: %u\n",
++		       plane->base.id, plane->name, lbm_size);
++
+ 	if (WARN_ON(!vc4_state->lbm_offset))
+ 		return -EINVAL;
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0936-drm-vc4-plane-Use-return-variable-in-atomic_check.patch b/target/linux/bcm27xx/patches-6.1/950-0936-drm-vc4-plane-Use-return-variable-in-atomic_check.patch
new file mode 100644
index 0000000000..220245c351
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0936-drm-vc4-plane-Use-return-variable-in-atomic_check.patch
@@ -0,0 +1,31 @@
+From 950394a39f659746e5933cbc203a8bedef8246b7 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 14:26:44 +0100
+Subject: [PATCH] drm/vc4: plane: Use return variable in atomic_check
+
+The vc4_plane_atomic_check() directly returns the result of the final
+function it calls.
+
+Using the already defined ret variable to check its content on error,
+and a separate return 0 on success, makes it easier to extend.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_plane.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -1378,7 +1378,11 @@ static int vc4_plane_atomic_check(struct
+ 	if (ret)
+ 		return ret;
+ 
+-	return vc4_plane_allocate_lbm(new_plane_state);
++	ret = vc4_plane_allocate_lbm(new_plane_state);
++	if (ret)
++		return ret;
++
++	return 0;
+ }
+ 
+ static void vc4_plane_atomic_update(struct drm_plane *plane,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0937-drm-vc4-crtc-Move-assigned_channel-to-a-variable.patch b/target/linux/bcm27xx/patches-6.1/950-0937-drm-vc4-crtc-Move-assigned_channel-to-a-variable.patch
new file mode 100644
index 0000000000..3476f548c4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0937-drm-vc4-crtc-Move-assigned_channel-to-a-variable.patch
@@ -0,0 +1,47 @@
+From f3c6acc345113c57011f2b1c8421e6cf78f0bc30 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:39:13 +0100
+Subject: [PATCH] drm/vc4: crtc: Move assigned_channel to a variable
+
+We access multiple times the vc4_crtc_state->assigned_channel variable
+in the vc4_crtc_get_scanout_position() function, so let's store it in a
+local variable.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_crtc.c | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_crtc.c
++++ b/drivers/gpu/drm/vc4/vc4_crtc.c
+@@ -104,6 +104,7 @@ static bool vc4_crtc_get_scanout_positio
+ 	struct vc4_hvs *hvs = vc4->hvs;
+ 	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
+ 	struct vc4_crtc_state *vc4_crtc_state = to_vc4_crtc_state(crtc->state);
++	unsigned int channel = vc4_crtc_state->assigned_channel;
+ 	unsigned int cob_size;
+ 	u32 val;
+ 	int fifo_lines;
+@@ -120,7 +121,7 @@ static bool vc4_crtc_get_scanout_positio
+ 	 * Read vertical scanline which is currently composed for our
+ 	 * pixelvalve by the HVS, and also the scaler status.
+ 	 */
+-	val = HVS_READ(SCALER_DISPSTATX(vc4_crtc_state->assigned_channel));
++	val = HVS_READ(SCALER_DISPSTATX(channel));
+ 
+ 	/* Get optional system timestamp after query. */
+ 	if (etime)
+@@ -136,11 +137,11 @@ static bool vc4_crtc_get_scanout_positio
+ 		*vpos /= 2;
+ 
+ 		/* Use hpos to correct for field offset in interlaced mode. */
+-		if (vc4_hvs_get_fifo_frame_count(hvs, vc4_crtc_state->assigned_channel) % 2)
++		if (vc4_hvs_get_fifo_frame_count(hvs, channel) % 2)
+ 			*hpos += mode->crtc_htotal / 2;
+ 	}
+ 
+-	cob_size = vc4_crtc_get_cob_allocation(vc4, vc4_crtc_state->assigned_channel);
++	cob_size = vc4_crtc_get_cob_allocation(vc4, channel);
+ 	/* This is the offset we need for translating hvs -> pv scanout pos. */
+ 	fifo_lines = cob_size / mode->crtc_hdisplay;
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0938-drm-vc4-Introduce-generation-number-enum.patch b/target/linux/bcm27xx/patches-6.1/950-0938-drm-vc4-Introduce-generation-number-enum.patch
new file mode 100644
index 0000000000..9314c797a0
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0938-drm-vc4-Introduce-generation-number-enum.patch
@@ -0,0 +1,1029 @@
+From fa2571d625bb53b642cd9f29a7cfc3434e1cf576 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:07:36 +0100
+Subject: [PATCH] drm/vc4: Introduce generation number enum
+
+With the introduction of the BCM2712 support, we will get yet another
+generation of display engine to support.
+
+The binary check of whether it's VC5 or not thus doesn't work anymore,
+especially since some parts of the driver will have changed with BCM2711,
+and some others with BCM2712.
+
+Let's introduce an enum to store the generation the driver is running
+on, which should provide more flexibility.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.c       | 12 +++---
+ drivers/gpu/drm/vc4/vc4_bo.c               | 28 ++++++------
+ drivers/gpu/drm/vc4/vc4_crtc.c             | 14 +++---
+ drivers/gpu/drm/vc4/vc4_drv.c              | 22 ++++++----
+ drivers/gpu/drm/vc4/vc4_drv.h              |  7 ++-
+ drivers/gpu/drm/vc4/vc4_gem.c              | 24 +++++------
+ drivers/gpu/drm/vc4/vc4_hdmi.c             |  2 +-
+ drivers/gpu/drm/vc4/vc4_hvs.c              | 50 ++++++++++++----------
+ drivers/gpu/drm/vc4/vc4_irq.c              | 10 ++---
+ drivers/gpu/drm/vc4/vc4_kms.c              | 14 +++---
+ drivers/gpu/drm/vc4/vc4_perfmon.c          | 20 ++++-----
+ drivers/gpu/drm/vc4/vc4_plane.c            | 12 +++---
+ drivers/gpu/drm/vc4/vc4_render_cl.c        |  2 +-
+ drivers/gpu/drm/vc4/vc4_v3d.c              | 10 ++---
+ drivers/gpu/drm/vc4/vc4_validate.c         |  8 ++--
+ drivers/gpu/drm/vc4/vc4_validate_shaders.c |  2 +-
+ 16 files changed, 126 insertions(+), 111 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.c
+@@ -153,11 +153,11 @@ static int __build_mock(struct kunit *te
+ 	return 0;
+ }
+ 
+-static struct vc4_dev *__mock_device(struct kunit *test, bool is_vc5)
++static struct vc4_dev *__mock_device(struct kunit *test, enum vc4_gen gen)
+ {
+ 	struct drm_device *drm;
+-	const struct drm_driver *drv = is_vc5 ? &vc5_drm_driver : &vc4_drm_driver;
+-	const struct vc4_mock_desc *desc = is_vc5 ? &vc5_mock : &vc4_mock;
++	const struct drm_driver *drv = (gen == VC4_GEN_5) ? &vc5_drm_driver : &vc4_drm_driver;
++	const struct vc4_mock_desc *desc = (gen == VC4_GEN_5) ? &vc5_mock : &vc4_mock;
+ 	struct vc4_dev *vc4;
+ 	struct device *dev;
+ 	int ret;
+@@ -171,7 +171,7 @@ static struct vc4_dev *__mock_device(str
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, vc4);
+ 
+ 	vc4->dev = dev;
+-	vc4->is_vc5 = is_vc5;
++	vc4->gen = gen;
+ 
+ 	vc4->hvs = __vc4_hvs_alloc(vc4, NULL);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, vc4->hvs);
+@@ -191,10 +191,10 @@ static struct vc4_dev *__mock_device(str
+ 
+ struct vc4_dev *vc4_mock_device(struct kunit *test)
+ {
+-	return __mock_device(test, false);
++	return __mock_device(test, VC4_GEN_4);
+ }
+ 
+ struct vc4_dev *vc5_mock_device(struct kunit *test)
+ {
+-	return __mock_device(test, true);
++	return __mock_device(test, VC4_GEN_5);
+ }
+--- a/drivers/gpu/drm/vc4/vc4_bo.c
++++ b/drivers/gpu/drm/vc4/vc4_bo.c
+@@ -251,7 +251,7 @@ void vc4_bo_add_to_purgeable_pool(struct
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(bo->base.base.dev);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	mutex_lock(&vc4->purgeable.lock);
+@@ -265,7 +265,7 @@ static void vc4_bo_remove_from_purgeable
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(bo->base.base.dev);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	/* list_del_init() is used here because the caller might release
+@@ -396,7 +396,7 @@ struct drm_gem_object *vc4_create_object
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
+@@ -427,7 +427,7 @@ struct vc4_bo *vc4_bo_create(struct drm_
+ 	struct drm_gem_dma_object *dma_obj;
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	if (size == 0)
+@@ -496,7 +496,7 @@ int vc4_bo_dumb_create(struct drm_file *
+ 	struct vc4_bo *bo = NULL;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	ret = vc4_dumb_fixup_args(args);
+@@ -622,7 +622,7 @@ int vc4_bo_inc_usecnt(struct vc4_bo *bo)
+ 	struct vc4_dev *vc4 = to_vc4_dev(bo->base.base.dev);
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	/* Fast path: if the BO is already retained by someone, no need to
+@@ -661,7 +661,7 @@ void vc4_bo_dec_usecnt(struct vc4_bo *bo
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(bo->base.base.dev);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	/* Fast path: if the BO is still retained by someone, no need to test
+@@ -783,7 +783,7 @@ int vc4_create_bo_ioctl(struct drm_devic
+ 	struct vc4_bo *bo = NULL;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	ret = vc4_grab_bin_bo(vc4, vc4file);
+@@ -813,7 +813,7 @@ int vc4_mmap_bo_ioctl(struct drm_device
+ 	struct drm_vc4_mmap_bo *args = data;
+ 	struct drm_gem_object *gem_obj;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
+@@ -839,7 +839,7 @@ vc4_create_shader_bo_ioctl(struct drm_de
+ 	struct vc4_bo *bo = NULL;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (args->size == 0)
+@@ -918,7 +918,7 @@ int vc4_set_tiling_ioctl(struct drm_devi
+ 	struct vc4_bo *bo;
+ 	bool t_format;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (args->flags != 0)
+@@ -964,7 +964,7 @@ int vc4_get_tiling_ioctl(struct drm_devi
+ 	struct drm_gem_object *gem_obj;
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (args->flags != 0 || args->modifier != 0)
+@@ -1011,7 +1011,7 @@ int vc4_bo_cache_init(struct drm_device
+ 	int ret;
+ 	int i;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	/* Create the initial set of BO labels that the kernel will
+@@ -1075,7 +1075,7 @@ int vc4_label_bo_ioctl(struct drm_device
+ 	struct drm_gem_object *gem_obj;
+ 	int ret = 0, label;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (!args->len)
+--- a/drivers/gpu/drm/vc4/vc4_crtc.c
++++ b/drivers/gpu/drm/vc4/vc4_crtc.c
+@@ -263,7 +263,7 @@ static u32 vc4_get_fifo_full_level(struc
+ 		 * Removing 1 from the FIFO full level however
+ 		 * seems to completely remove that issue.
+ 		 */
+-		if (!vc4->is_vc5)
++		if (vc4->gen == VC4_GEN_4)
+ 			return fifo_len_bytes - 3 * HVS_FIFO_LATENCY_PIX - 1;
+ 
+ 		return fifo_len_bytes - 3 * HVS_FIFO_LATENCY_PIX;
+@@ -445,7 +445,7 @@ static void vc4_crtc_config_pv(struct dr
+ 	if (is_dsi)
+ 		CRTC_WRITE(PV_HACT_ACT, mode->hdisplay * pixel_rep);
+ 
+-	if (vc4->is_vc5)
++	if (vc4->gen == VC4_GEN_5)
+ 		CRTC_WRITE(PV_MUX_CFG,
+ 			   VC4_SET_FIELD(PV_MUX_CFG_RGB_PIXEL_MUX_MODE_NO_SWAP,
+ 					 PV_MUX_CFG_RGB_PIXEL_MUX_MODE));
+@@ -936,7 +936,7 @@ static int vc4_async_set_fence_cb(struct
+ 	struct dma_fence *fence;
+ 	int ret;
+ 
+-	if (!vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_4) {
+ 		struct vc4_bo *bo = to_vc4_bo(&dma_bo->base);
+ 
+ 		return vc4_queue_seqno_cb(dev, &flip_state->cb.seqno, bo->seqno,
+@@ -1023,7 +1023,7 @@ static int vc4_async_page_flip(struct dr
+ 	struct vc4_bo *bo = to_vc4_bo(&dma_bo->base);
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	/*
+@@ -1066,7 +1066,7 @@ int vc4_page_flip(struct drm_crtc *crtc,
+ 		struct drm_device *dev = crtc->dev;
+ 		struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-		if (vc4->is_vc5)
++		if (vc4->gen == VC4_GEN_5)
+ 			return vc5_async_page_flip(crtc, fb, event, flags);
+ 		else
+ 			return vc4_async_page_flip(crtc, fb, event, flags);
+@@ -1358,13 +1358,13 @@ int __vc4_crtc_init(struct drm_device *d
+ 
+ 	drm_crtc_helper_add(crtc, crtc_helper_funcs);
+ 
+-	if (!vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_4) {
+ 		drm_mode_crtc_set_gamma_size(crtc, ARRAY_SIZE(vc4_crtc->lut_r));
+ 		drm_crtc_enable_color_mgmt(crtc, 0, false, crtc->gamma_size);
+ 	}
+ 
+ 
+-	if (!vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_4) {
+ 		/* We support CTM, but only for one CRTC at a time. It's therefore
+ 		 * implemented as private driver state in vc4_kms, not here.
+ 		 */
+--- a/drivers/gpu/drm/vc4/vc4_drv.c
++++ b/drivers/gpu/drm/vc4/vc4_drv.c
+@@ -98,7 +98,7 @@ static int vc4_get_param_ioctl(struct dr
+ 	if (args->pad != 0)
+ 		return -EINVAL;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d)
+@@ -147,7 +147,7 @@ static int vc4_open(struct drm_device *d
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_file *vc4file;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	vc4file = kzalloc(sizeof(*vc4file), GFP_KERNEL);
+@@ -165,7 +165,7 @@ static void vc4_close(struct drm_device
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_file *vc4file = file->driver_priv;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	if (vc4file->bin_bo_used)
+@@ -305,13 +305,17 @@ static int vc4_drm_bind(struct device *d
+ 	struct vc4_dev *vc4;
+ 	struct device_node *node;
+ 	struct drm_crtc *crtc;
+-	bool is_vc5;
++	enum vc4_gen gen;
+ 	int ret = 0;
+ 
+ 	dev->coherent_dma_mask = DMA_BIT_MASK(32);
+ 
+-	is_vc5 = of_device_is_compatible(dev->of_node, "brcm,bcm2711-vc5");
+-	if (is_vc5)
++	if (of_device_is_compatible(dev->of_node, "brcm,bcm2711-vc5"))
++		gen = VC4_GEN_5;
++	else
++		gen = VC4_GEN_4;
++
++	if (gen == VC4_GEN_5)
+ 		driver = &vc5_drm_driver;
+ 	else
+ 		driver = &vc4_drm_driver;
+@@ -329,14 +333,14 @@ static int vc4_drm_bind(struct device *d
+ 	vc4 = devm_drm_dev_alloc(dev, driver, struct vc4_dev, base);
+ 	if (IS_ERR(vc4))
+ 		return PTR_ERR(vc4);
+-	vc4->is_vc5 = is_vc5;
++	vc4->gen = gen;
+ 	vc4->dev = dev;
+ 
+ 	drm = &vc4->base;
+ 	platform_set_drvdata(pdev, drm);
+ 	INIT_LIST_HEAD(&vc4->debugfs_list);
+ 
+-	if (!is_vc5) {
++	if (gen == VC4_GEN_4) {
+ 		ret = drmm_mutex_init(drm, &vc4->bin_bo_lock);
+ 		if (ret)
+ 			return ret;
+@@ -350,7 +354,7 @@ static int vc4_drm_bind(struct device *d
+ 	if (ret)
+ 		return ret;
+ 
+-	if (!is_vc5) {
++	if (gen == VC4_GEN_4) {
+ 		ret = vc4_gem_init(drm);
+ 		if (ret)
+ 			return ret;
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -80,11 +80,16 @@ struct vc4_perfmon {
+ 	u64 counters[];
+ };
+ 
++enum vc4_gen {
++	VC4_GEN_4,
++	VC4_GEN_5,
++};
++
+ struct vc4_dev {
+ 	struct drm_device base;
+ 	struct device *dev;
+ 
+-	bool is_vc5;
++	enum vc4_gen gen;
+ 
+ 	unsigned int irq;
+ 
+--- a/drivers/gpu/drm/vc4/vc4_gem.c
++++ b/drivers/gpu/drm/vc4/vc4_gem.c
+@@ -76,7 +76,7 @@ vc4_get_hang_state_ioctl(struct drm_devi
+ 	u32 i;
+ 	int ret = 0;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+@@ -389,7 +389,7 @@ vc4_wait_for_seqno(struct drm_device *de
+ 	unsigned long timeout_expire;
+ 	DEFINE_WAIT(wait);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (vc4->finished_seqno >= seqno)
+@@ -474,7 +474,7 @@ vc4_submit_next_bin_job(struct drm_devic
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_exec_info *exec;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ again:
+@@ -522,7 +522,7 @@ vc4_submit_next_render_job(struct drm_de
+ 	if (!exec)
+ 		return;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	/* A previous RCL may have written to one of our textures, and
+@@ -543,7 +543,7 @@ vc4_move_job_to_render(struct drm_device
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	bool was_empty = list_empty(&vc4->render_job_list);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	list_move_tail(&exec->head, &vc4->render_job_list);
+@@ -1012,7 +1012,7 @@ vc4_job_handle_completed(struct vc4_dev
+ 	unsigned long irqflags;
+ 	struct vc4_seqno_cb *cb, *cb_temp;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	spin_lock_irqsave(&vc4->job_lock, irqflags);
+@@ -1051,7 +1051,7 @@ int vc4_queue_seqno_cb(struct drm_device
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	unsigned long irqflags;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	cb->func = func;
+@@ -1107,7 +1107,7 @@ vc4_wait_seqno_ioctl(struct drm_device *
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct drm_vc4_wait_seqno *args = data;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	return vc4_wait_for_seqno_ioctl_helper(dev, args->seqno,
+@@ -1124,7 +1124,7 @@ vc4_wait_bo_ioctl(struct drm_device *dev
+ 	struct drm_gem_object *gem_obj;
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (args->pad != 0)
+@@ -1173,7 +1173,7 @@ vc4_submit_cl_ioctl(struct drm_device *d
+ 				  args->shader_rec_size,
+ 				  args->bo_handle_count);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+@@ -1310,7 +1310,7 @@ int vc4_gem_init(struct drm_device *dev)
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	vc4->dma_fence_context = dma_fence_context_alloc(1);
+@@ -1369,7 +1369,7 @@ int vc4_gem_madvise_ioctl(struct drm_dev
+ 	struct vc4_bo *bo;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	switch (args->madv) {
+--- a/drivers/gpu/drm/vc4/vc4_hdmi.c
++++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
+@@ -2614,7 +2614,7 @@ static int vc4_hdmi_audio_prepare(struct
+ 					     VC4_HDMI_AUDIO_PACKET_CEA_MASK);
+ 
+ 	/* Set the MAI threshold */
+-	if (vc4->is_vc5)
++	if (vc4->gen >= VC4_GEN_5)
+ 		HDMI_WRITE(HDMI_MAI_THR,
+ 			VC4_SET_FIELD(0x10, VC4_HD_MAI_THR_PANICHIGH) |
+ 			VC4_SET_FIELD(0x10, VC4_HD_MAI_THR_PANICLOW) |
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -416,7 +416,7 @@ static void vc4_hvs_irq_enable_eof(const
+ 				   unsigned int channel)
+ {
+ 	struct vc4_dev *vc4 = hvs->vc4;
+-	u32 irq_mask = vc4->is_vc5 ?
++	u32 irq_mask = vc4->gen == VC4_GEN_5 ?
+ 		SCALER5_DISPCTRL_DSPEIEOF(channel) :
+ 		SCALER_DISPCTRL_DSPEIEOF(channel);
+ 
+@@ -428,7 +428,7 @@ static void vc4_hvs_irq_clear_eof(const
+ 				  unsigned int channel)
+ {
+ 	struct vc4_dev *vc4 = hvs->vc4;
+-	u32 irq_mask = vc4->is_vc5 ?
++	u32 irq_mask = vc4->gen == VC4_GEN_5 ?
+ 		SCALER5_DISPCTRL_DSPEIEOF(channel) :
+ 		SCALER_DISPCTRL_DSPEIEOF(channel);
+ 
+@@ -620,7 +620,7 @@ int vc4_hvs_get_fifo_from_output(struct
+ 	u32 reg;
+ 	int ret;
+ 
+-	if (!vc4->is_vc5)
++	if (vc4->gen == VC4_GEN_4)
+ 		return output;
+ 
+ 	/*
+@@ -701,7 +701,7 @@ static int vc4_hvs_init_channel(struct v
+ 	dispctrl = SCALER_DISPCTRLX_ENABLE;
+ 	dispbkgndx = HVS_READ(SCALER_DISPBKGNDX(chan));
+ 
+-	if (!vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_4) {
+ 		dispctrl |= VC4_SET_FIELD(mode->hdisplay,
+ 					  SCALER_DISPCTRLX_WIDTH) |
+ 			    VC4_SET_FIELD(mode->vdisplay,
+@@ -732,7 +732,7 @@ static int vc4_hvs_init_channel(struct v
+ 	/* Reload the LUT, since the SRAMs would have been disabled if
+ 	 * all CRTCs had SCALER_DISPBKGND_GAMMA unset at once.
+ 	 */
+-	if (!vc4->is_vc5)
++	if (vc4->gen == VC4_GEN_4)
+ 		vc4_hvs_lut_load(hvs, vc4_crtc);
+ 	else
+ 		vc5_hvs_lut_load(hvs, vc4_crtc);
+@@ -782,7 +782,7 @@ static int vc4_hvs_gamma_check(struct dr
+ 	struct drm_device *dev = crtc->dev;
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-	if (!vc4->is_vc5)
++	if (vc4->gen == VC4_GEN_4)
+ 		return 0;
+ 
+ 	if (!crtc_state->color_mgmt_changed)
+@@ -1036,7 +1036,7 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 		u32 dispbkgndx = HVS_READ(SCALER_DISPBKGNDX(channel));
+ 
+ 		if (crtc->state->gamma_lut) {
+-			if (!vc4->is_vc5) {
++			if (vc4->gen == VC4_GEN_4) {
+ 				vc4_hvs_update_gamma_lut(hvs, vc4_crtc);
+ 				dispbkgndx |= SCALER_DISPBKGND_GAMMA;
+ 			} else {
+@@ -1053,7 +1053,7 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 			 * should already be disabling/enabling the pipeline
+ 			 * when gamma changes.
+ 			 */
+-			if (!vc4->is_vc5)
++			if (vc4->gen == VC4_GEN_4)
+ 				dispbkgndx &= ~SCALER_DISPBKGND_GAMMA;
+ 		}
+ 		HVS_WRITE(SCALER_DISPBKGNDX(channel), dispbkgndx);
+@@ -1069,7 +1069,8 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 
+ void vc4_hvs_mask_underrun(struct vc4_hvs *hvs, int channel)
+ {
+-	struct drm_device *drm = &hvs->vc4->base;
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *drm = &vc4->base;
+ 	u32 dispctrl;
+ 	int idx;
+ 
+@@ -1077,8 +1078,9 @@ void vc4_hvs_mask_underrun(struct vc4_hv
+ 		return;
+ 
+ 	dispctrl = HVS_READ(SCALER_DISPCTRL);
+-	dispctrl &= ~(hvs->vc4->is_vc5 ? SCALER5_DISPCTRL_DSPEISLUR(channel) :
+-					 SCALER_DISPCTRL_DSPEISLUR(channel));
++	dispctrl &= ~((vc4->gen == VC4_GEN_5) ?
++		      SCALER5_DISPCTRL_DSPEISLUR(channel) :
++		      SCALER_DISPCTRL_DSPEISLUR(channel));
+ 
+ 	HVS_WRITE(SCALER_DISPCTRL, dispctrl);
+ 
+@@ -1087,7 +1089,8 @@ void vc4_hvs_mask_underrun(struct vc4_hv
+ 
+ void vc4_hvs_unmask_underrun(struct vc4_hvs *hvs, int channel)
+ {
+-	struct drm_device *drm = &hvs->vc4->base;
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *drm = &vc4->base;
+ 	u32 dispctrl;
+ 	int idx;
+ 
+@@ -1095,8 +1098,9 @@ void vc4_hvs_unmask_underrun(struct vc4_
+ 		return;
+ 
+ 	dispctrl = HVS_READ(SCALER_DISPCTRL);
+-	dispctrl |= (hvs->vc4->is_vc5 ? SCALER5_DISPCTRL_DSPEISLUR(channel) :
+-					SCALER_DISPCTRL_DSPEISLUR(channel));
++	dispctrl |= ((vc4->gen == VC4_GEN_5) ?
++		     SCALER5_DISPCTRL_DSPEISLUR(channel) :
++		     SCALER_DISPCTRL_DSPEISLUR(channel));
+ 
+ 	HVS_WRITE(SCALER_DISPSTAT,
+ 		  SCALER_DISPSTAT_EUFLOW(channel));
+@@ -1139,8 +1143,10 @@ static irqreturn_t vc4_hvs_irq_handler(i
+ 	control = HVS_READ(SCALER_DISPCTRL);
+ 
+ 	for (channel = 0; channel < SCALER_CHANNELS_COUNT; channel++) {
+-		dspeislur = vc4->is_vc5 ? SCALER5_DISPCTRL_DSPEISLUR(channel) :
+-					  SCALER_DISPCTRL_DSPEISLUR(channel);
++		dspeislur = (vc4->gen == VC4_GEN_5) ?
++			SCALER5_DISPCTRL_DSPEISLUR(channel) :
++			SCALER_DISPCTRL_DSPEISLUR(channel);
++
+ 		/* Interrupt masking is not always honored, so check it here. */
+ 		if (status & SCALER_DISPSTAT_EUFLOW(channel) &&
+ 		    control & dspeislur) {
+@@ -1177,7 +1183,7 @@ int vc4_hvs_debugfs_init(struct drm_mino
+ 	if (!vc4->hvs)
+ 		return -ENODEV;
+ 
+-	if (!vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_4) {
+ 		debugfs_create_bool("hvs_load_tracker", S_IRUGO | S_IWUSR,
+ 				    minor->debugfs_root,
+ 				    &vc4->load_tracker_enabled);
+@@ -1235,7 +1241,7 @@ struct vc4_hvs *__vc4_hvs_alloc(struct v
+ 	 * between planes when they don't overlap on the screen, but
+ 	 * for now we just allocate globally.
+ 	 */
+-	if (!vc4->is_vc5)
++	if (vc4->gen == VC4_GEN_4)
+ 		/* 48k words of 2x12-bit pixels */
+ 		drm_mm_init(&hvs->lbm_mm, 0, 48 * 1024);
+ 	else
+@@ -1269,7 +1275,7 @@ static int vc4_hvs_bind(struct device *d
+ 	hvs->regset.regs = hvs_regs;
+ 	hvs->regset.nregs = ARRAY_SIZE(hvs_regs);
+ 
+-	if (vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_5) {
+ 		struct rpi_firmware *firmware;
+ 		struct device_node *node;
+ 		unsigned int max_rate;
+@@ -1307,7 +1313,7 @@ static int vc4_hvs_bind(struct device *d
+ 		}
+ 	}
+ 
+-	if (!vc4->is_vc5)
++	if (vc4->gen == VC4_GEN_4)
+ 		hvs->dlist = hvs->regs + SCALER_DLIST_START;
+ 	else
+ 		hvs->dlist = hvs->regs + SCALER5_DLIST_START;
+@@ -1348,7 +1354,7 @@ static int vc4_hvs_bind(struct device *d
+ 		    SCALER_DISPCTRL_DISPEIRQ(1) |
+ 		    SCALER_DISPCTRL_DISPEIRQ(2);
+ 
+-	if (!vc4->is_vc5)
++	if (vc4->gen == VC4_GEN_4)
+ 		dispctrl &= ~(SCALER_DISPCTRL_DMAEIRQ |
+ 			      SCALER_DISPCTRL_SLVWREIRQ |
+ 			      SCALER_DISPCTRL_SLVRDEIRQ |
+@@ -1403,7 +1409,7 @@ static int vc4_hvs_bind(struct device *d
+ 
+ 	/* Recompute Composite Output Buffer (COB) allocations for the displays
+ 	 */
+-	if (!vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_4) {
+ 		/* The COB is 20736 pixels, or just over 10 lines at 2048 wide.
+ 		 * The bottom 2048 pixels are full 32bpp RGBA (intended for the
+ 		 * TXP composing RGBA to memory), whilst the remainder are only
+--- a/drivers/gpu/drm/vc4/vc4_irq.c
++++ b/drivers/gpu/drm/vc4/vc4_irq.c
+@@ -265,7 +265,7 @@ vc4_irq_enable(struct drm_device *dev)
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	if (!vc4->v3d)
+@@ -282,7 +282,7 @@ vc4_irq_disable(struct drm_device *dev)
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	if (!vc4->v3d)
+@@ -305,7 +305,7 @@ int vc4_irq_install(struct drm_device *d
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (irq == IRQ_NOTCONNECTED)
+@@ -326,7 +326,7 @@ void vc4_irq_uninstall(struct drm_device
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	vc4_irq_disable(dev);
+@@ -339,7 +339,7 @@ void vc4_irq_reset(struct drm_device *de
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	unsigned long irqflags;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	/* Acknowledge any stale IRQs. */
+--- a/drivers/gpu/drm/vc4/vc4_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_kms.c
+@@ -378,7 +378,7 @@ static void vc4_atomic_commit_tail(struc
+ 		old_hvs_state->fifo_state[channel].pending_commit = NULL;
+ 	}
+ 
+-	if (vc4->is_vc5 && !vc4->firmware_kms) {
++	if (vc4->gen == VC4_GEN_5 && !vc4->firmware_kms) {
+ 		unsigned long state_rate = max(old_hvs_state->core_clock_rate,
+ 					       new_hvs_state->core_clock_rate);
+ 		unsigned long core_rate = clamp_t(unsigned long, state_rate,
+@@ -398,7 +398,7 @@ static void vc4_atomic_commit_tail(struc
+ 	vc4_ctm_commit(vc4, state);
+ 
+ 	if (!vc4->firmware_kms) {
+-		if (vc4->is_vc5)
++		if (vc4->gen == VC4_GEN_5)
+ 			vc5_hvs_pv_muxing_commit(vc4, state);
+ 		else
+ 			vc4_hvs_pv_muxing_commit(vc4, state);
+@@ -417,7 +417,7 @@ static void vc4_atomic_commit_tail(struc
+ 
+ 	drm_atomic_helper_cleanup_planes(dev, state);
+ 
+-	if (vc4->is_vc5 && !vc4->firmware_kms) {
++	if (vc4->gen == VC4_GEN_5 && !vc4->firmware_kms) {
+ 		unsigned long core_rate = min_t(unsigned long,
+ 						hvs->max_core_rate,
+ 						new_hvs_state->core_clock_rate);
+@@ -482,7 +482,7 @@ static struct drm_framebuffer *vc4_fb_cr
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct drm_mode_fb_cmd2 mode_cmd_local;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	/* If the user didn't specify a modifier, use the
+@@ -1065,7 +1065,7 @@ int vc4_kms_load(struct drm_device *dev)
+ 	 * the BCM2711, but the load tracker computations are used for
+ 	 * the core clock rate calculation.
+ 	 */
+-	if (!vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_4) {
+ 		/* Start with the load tracker enabled. Can be
+ 		 * disabled through the debugfs load_tracker file.
+ 		 */
+@@ -1081,7 +1081,7 @@ int vc4_kms_load(struct drm_device *dev)
+ 		return ret;
+ 	}
+ 
+-	if (vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_5) {
+ 		dev->mode_config.max_width = 7680;
+ 		dev->mode_config.max_height = 7680;
+ 	} else {
+@@ -1089,7 +1089,7 @@ int vc4_kms_load(struct drm_device *dev)
+ 		dev->mode_config.max_height = 2048;
+ 	}
+ 
+-	dev->mode_config.funcs = vc4->is_vc5 ? &vc5_mode_funcs : &vc4_mode_funcs;
++	dev->mode_config.funcs = (vc4->gen > VC4_GEN_4) ? &vc5_mode_funcs : &vc4_mode_funcs;
+ 	dev->mode_config.helper_private = &vc4_mode_config_helpers;
+ 	dev->mode_config.preferred_depth = 24;
+ 	dev->mode_config.async_page_flip = true;
+--- a/drivers/gpu/drm/vc4/vc4_perfmon.c
++++ b/drivers/gpu/drm/vc4/vc4_perfmon.c
+@@ -23,7 +23,7 @@ void vc4_perfmon_get(struct vc4_perfmon
+ 		return;
+ 
+ 	vc4 = perfmon->dev;
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	refcount_inc(&perfmon->refcnt);
+@@ -37,7 +37,7 @@ void vc4_perfmon_put(struct vc4_perfmon
+ 		return;
+ 
+ 	vc4 = perfmon->dev;
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	if (refcount_dec_and_test(&perfmon->refcnt))
+@@ -49,7 +49,7 @@ void vc4_perfmon_start(struct vc4_dev *v
+ 	unsigned int i;
+ 	u32 mask;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	if (WARN_ON_ONCE(!perfmon || vc4->active_perfmon))
+@@ -69,7 +69,7 @@ void vc4_perfmon_stop(struct vc4_dev *vc
+ {
+ 	unsigned int i;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	if (WARN_ON_ONCE(!vc4->active_perfmon ||
+@@ -90,7 +90,7 @@ struct vc4_perfmon *vc4_perfmon_find(str
+ 	struct vc4_dev *vc4 = vc4file->dev;
+ 	struct vc4_perfmon *perfmon;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return NULL;
+ 
+ 	mutex_lock(&vc4file->perfmon.lock);
+@@ -105,7 +105,7 @@ void vc4_perfmon_open_file(struct vc4_fi
+ {
+ 	struct vc4_dev *vc4 = vc4file->dev;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	mutex_init(&vc4file->perfmon.lock);
+@@ -126,7 +126,7 @@ void vc4_perfmon_close_file(struct vc4_f
+ {
+ 	struct vc4_dev *vc4 = vc4file->dev;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	mutex_lock(&vc4file->perfmon.lock);
+@@ -146,7 +146,7 @@ int vc4_perfmon_create_ioctl(struct drm_
+ 	unsigned int i;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+@@ -200,7 +200,7 @@ int vc4_perfmon_destroy_ioctl(struct drm
+ 	struct drm_vc4_perfmon_destroy *req = data;
+ 	struct vc4_perfmon *perfmon;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+@@ -228,7 +228,7 @@ int vc4_perfmon_get_values_ioctl(struct
+ 	struct vc4_perfmon *perfmon;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -633,10 +633,10 @@ static u32 vc4_lbm_size(struct drm_plane
+ 	}
+ 
+ 	/* Align it to 64 or 128 (hvs5) bytes */
+-	lbm = roundup(lbm, vc4->is_vc5 ? 128 : 64);
++	lbm = roundup(lbm, vc4->gen == VC4_GEN_5 ? 128 : 64);
+ 
+ 	/* Each "word" of the LBM memory contains 2 or 4 (hvs5) pixels */
+-	lbm /= vc4->is_vc5 ? 4 : 2;
++	lbm /= vc4->gen == VC4_GEN_5 ? 4 : 2;
+ 
+ 	return lbm;
+ }
+@@ -760,7 +760,7 @@ static int vc4_plane_allocate_lbm(struct
+ 		ret = drm_mm_insert_node_generic(&vc4->hvs->lbm_mm,
+ 						 &vc4_state->lbm,
+ 						 lbm_size,
+-						 vc4->is_vc5 ? 64 : 32,
++						 vc4->gen == VC4_GEN_5 ? 64 : 32,
+ 						 0, 0);
+ 		spin_unlock_irqrestore(&vc4->hvs->mm_lock, irqflags);
+ 
+@@ -1141,7 +1141,7 @@ static int vc4_plane_mode_set(struct drm
+ 	mix_plane_alpha = state->alpha != DRM_BLEND_ALPHA_OPAQUE &&
+ 			  fb->format->has_alpha;
+ 
+-	if (!vc4->is_vc5) {
++	if (vc4->gen == VC4_GEN_4) {
+ 	/* Control word */
+ 		vc4_dlist_write(vc4_state,
+ 				SCALER_CTL0_VALID |
+@@ -1717,7 +1717,7 @@ struct drm_plane *vc4_plane_init(struct
+ 	};
+ 
+ 	for (i = 0; i < ARRAY_SIZE(hvs_formats); i++) {
+-		if (!hvs_formats[i].hvs5_only || vc4->is_vc5) {
++		if (!hvs_formats[i].hvs5_only || vc4->gen == VC4_GEN_5) {
+ 			formats[num_formats] = hvs_formats[i].drm;
+ 			num_formats++;
+ 		}
+@@ -1732,7 +1732,7 @@ struct drm_plane *vc4_plane_init(struct
+ 		return ERR_CAST(vc4_plane);
+ 	plane = &vc4_plane->base;
+ 
+-	if (vc4->is_vc5)
++	if (vc4->gen == VC4_GEN_5)
+ 		drm_plane_helper_add(plane, &vc5_plane_helper_funcs);
+ 	else
+ 		drm_plane_helper_add(plane, &vc4_plane_helper_funcs);
+--- a/drivers/gpu/drm/vc4/vc4_render_cl.c
++++ b/drivers/gpu/drm/vc4/vc4_render_cl.c
+@@ -599,7 +599,7 @@ int vc4_get_rcl(struct drm_device *dev,
+ 	bool has_bin = args->bin_cl_size != 0;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	if (args->min_x_tile > args->max_x_tile ||
+--- a/drivers/gpu/drm/vc4/vc4_v3d.c
++++ b/drivers/gpu/drm/vc4/vc4_v3d.c
+@@ -127,7 +127,7 @@ static int vc4_v3d_debugfs_ident(struct
+ int
+ vc4_v3d_pm_get(struct vc4_dev *vc4)
+ {
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&vc4->power_lock);
+@@ -148,7 +148,7 @@ vc4_v3d_pm_get(struct vc4_dev *vc4)
+ void
+ vc4_v3d_pm_put(struct vc4_dev *vc4)
+ {
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	mutex_lock(&vc4->power_lock);
+@@ -178,7 +178,7 @@ int vc4_v3d_get_bin_slot(struct vc4_dev
+ 	uint64_t seqno = 0;
+ 	struct vc4_exec_info *exec;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ try_again:
+@@ -325,7 +325,7 @@ int vc4_v3d_bin_bo_get(struct vc4_dev *v
+ {
+ 	int ret = 0;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&vc4->bin_bo_lock);
+@@ -360,7 +360,7 @@ static void bin_bo_release(struct kref *
+ 
+ void vc4_v3d_bin_bo_put(struct vc4_dev *vc4)
+ {
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return;
+ 
+ 	mutex_lock(&vc4->bin_bo_lock);
+--- a/drivers/gpu/drm/vc4/vc4_validate.c
++++ b/drivers/gpu/drm/vc4/vc4_validate.c
+@@ -109,7 +109,7 @@ vc4_use_bo(struct vc4_exec_info *exec, u
+ 	struct drm_gem_dma_object *obj;
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return NULL;
+ 
+ 	if (hindex >= exec->bo_count) {
+@@ -169,7 +169,7 @@ vc4_check_tex_size(struct vc4_exec_info
+ 	uint32_t utile_w = utile_width(cpp);
+ 	uint32_t utile_h = utile_height(cpp);
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return false;
+ 
+ 	/* The shaded vertex format stores signed 12.4 fixed point
+@@ -495,7 +495,7 @@ vc4_validate_bin_cl(struct drm_device *d
+ 	uint32_t dst_offset = 0;
+ 	uint32_t src_offset = 0;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	while (src_offset < len) {
+@@ -942,7 +942,7 @@ vc4_validate_shader_recs(struct drm_devi
+ 	uint32_t i;
+ 	int ret = 0;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return -ENODEV;
+ 
+ 	for (i = 0; i < exec->shader_state_count; i++) {
+--- a/drivers/gpu/drm/vc4/vc4_validate_shaders.c
++++ b/drivers/gpu/drm/vc4/vc4_validate_shaders.c
+@@ -786,7 +786,7 @@ vc4_validate_shader(struct drm_gem_dma_o
+ 	struct vc4_validated_shader_info *validated_shader = NULL;
+ 	struct vc4_shader_validation_state validation_state;
+ 
+-	if (WARN_ON_ONCE(vc4->is_vc5))
++	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
+ 		return NULL;
+ 
+ 	memset(&validation_state, 0, sizeof(validation_state));
diff --git a/target/linux/bcm27xx/patches-6.1/950-0939-drm-vc4-Make-v3d-paths-unavailable-on-any-generation.patch b/target/linux/bcm27xx/patches-6.1/950-0939-drm-vc4-Make-v3d-paths-unavailable-on-any-generation.patch
new file mode 100644
index 0000000000..699db05e0c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0939-drm-vc4-Make-v3d-paths-unavailable-on-any-generation.patch
@@ -0,0 +1,577 @@
+From c382ea6b0457027b6ad883ee4348e03df515a785 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:29:27 +0100
+Subject: [PATCH] drm/vc4: Make v3d paths unavailable on any generation newer
+ than vc4
+
+The V3D IP has been separate since BCM2711, so let's make sure we issue
+a WARN if we're running not only on BCM2711, but also anything newer.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_bo.c               | 28 +++++++++++-----------
+ drivers/gpu/drm/vc4/vc4_crtc.c             |  4 ++--
+ drivers/gpu/drm/vc4/vc4_drv.c              |  8 +++----
+ drivers/gpu/drm/vc4/vc4_gem.c              | 24 +++++++++----------
+ drivers/gpu/drm/vc4/vc4_irq.c              | 10 ++++----
+ drivers/gpu/drm/vc4/vc4_kms.c              |  2 +-
+ drivers/gpu/drm/vc4/vc4_perfmon.c          | 20 ++++++++--------
+ drivers/gpu/drm/vc4/vc4_render_cl.c        |  2 +-
+ drivers/gpu/drm/vc4/vc4_v3d.c              | 10 ++++----
+ drivers/gpu/drm/vc4/vc4_validate.c         |  8 +++----
+ drivers/gpu/drm/vc4/vc4_validate_shaders.c |  2 +-
+ 11 files changed, 59 insertions(+), 59 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_bo.c
++++ b/drivers/gpu/drm/vc4/vc4_bo.c
+@@ -251,7 +251,7 @@ void vc4_bo_add_to_purgeable_pool(struct
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(bo->base.base.dev);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	mutex_lock(&vc4->purgeable.lock);
+@@ -265,7 +265,7 @@ static void vc4_bo_remove_from_purgeable
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(bo->base.base.dev);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	/* list_del_init() is used here because the caller might release
+@@ -396,7 +396,7 @@ struct drm_gem_object *vc4_create_object
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
+@@ -427,7 +427,7 @@ struct vc4_bo *vc4_bo_create(struct drm_
+ 	struct drm_gem_dma_object *dma_obj;
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	if (size == 0)
+@@ -496,7 +496,7 @@ int vc4_bo_dumb_create(struct drm_file *
+ 	struct vc4_bo *bo = NULL;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	ret = vc4_dumb_fixup_args(args);
+@@ -622,7 +622,7 @@ int vc4_bo_inc_usecnt(struct vc4_bo *bo)
+ 	struct vc4_dev *vc4 = to_vc4_dev(bo->base.base.dev);
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	/* Fast path: if the BO is already retained by someone, no need to
+@@ -661,7 +661,7 @@ void vc4_bo_dec_usecnt(struct vc4_bo *bo
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(bo->base.base.dev);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	/* Fast path: if the BO is still retained by someone, no need to test
+@@ -783,7 +783,7 @@ int vc4_create_bo_ioctl(struct drm_devic
+ 	struct vc4_bo *bo = NULL;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	ret = vc4_grab_bin_bo(vc4, vc4file);
+@@ -813,7 +813,7 @@ int vc4_mmap_bo_ioctl(struct drm_device
+ 	struct drm_vc4_mmap_bo *args = data;
+ 	struct drm_gem_object *gem_obj;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
+@@ -839,7 +839,7 @@ vc4_create_shader_bo_ioctl(struct drm_de
+ 	struct vc4_bo *bo = NULL;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (args->size == 0)
+@@ -918,7 +918,7 @@ int vc4_set_tiling_ioctl(struct drm_devi
+ 	struct vc4_bo *bo;
+ 	bool t_format;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (args->flags != 0)
+@@ -964,7 +964,7 @@ int vc4_get_tiling_ioctl(struct drm_devi
+ 	struct drm_gem_object *gem_obj;
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (args->flags != 0 || args->modifier != 0)
+@@ -1011,7 +1011,7 @@ int vc4_bo_cache_init(struct drm_device
+ 	int ret;
+ 	int i;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	/* Create the initial set of BO labels that the kernel will
+@@ -1075,7 +1075,7 @@ int vc4_label_bo_ioctl(struct drm_device
+ 	struct drm_gem_object *gem_obj;
+ 	int ret = 0, label;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (!args->len)
+--- a/drivers/gpu/drm/vc4/vc4_crtc.c
++++ b/drivers/gpu/drm/vc4/vc4_crtc.c
+@@ -1023,7 +1023,7 @@ static int vc4_async_page_flip(struct dr
+ 	struct vc4_bo *bo = to_vc4_bo(&dma_bo->base);
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	/*
+@@ -1066,7 +1066,7 @@ int vc4_page_flip(struct drm_crtc *crtc,
+ 		struct drm_device *dev = crtc->dev;
+ 		struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-		if (vc4->gen == VC4_GEN_5)
++		if (vc4->gen > VC4_GEN_4)
+ 			return vc5_async_page_flip(crtc, fb, event, flags);
+ 		else
+ 			return vc4_async_page_flip(crtc, fb, event, flags);
+--- a/drivers/gpu/drm/vc4/vc4_drv.c
++++ b/drivers/gpu/drm/vc4/vc4_drv.c
+@@ -98,7 +98,7 @@ static int vc4_get_param_ioctl(struct dr
+ 	if (args->pad != 0)
+ 		return -EINVAL;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d)
+@@ -147,7 +147,7 @@ static int vc4_open(struct drm_device *d
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_file *vc4file;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	vc4file = kzalloc(sizeof(*vc4file), GFP_KERNEL);
+@@ -165,7 +165,7 @@ static void vc4_close(struct drm_device
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_file *vc4file = file->driver_priv;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	if (vc4file->bin_bo_used)
+@@ -315,7 +315,7 @@ static int vc4_drm_bind(struct device *d
+ 	else
+ 		gen = VC4_GEN_4;
+ 
+-	if (gen == VC4_GEN_5)
++	if (gen > VC4_GEN_4)
+ 		driver = &vc5_drm_driver;
+ 	else
+ 		driver = &vc4_drm_driver;
+--- a/drivers/gpu/drm/vc4/vc4_gem.c
++++ b/drivers/gpu/drm/vc4/vc4_gem.c
+@@ -76,7 +76,7 @@ vc4_get_hang_state_ioctl(struct drm_devi
+ 	u32 i;
+ 	int ret = 0;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+@@ -389,7 +389,7 @@ vc4_wait_for_seqno(struct drm_device *de
+ 	unsigned long timeout_expire;
+ 	DEFINE_WAIT(wait);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (vc4->finished_seqno >= seqno)
+@@ -474,7 +474,7 @@ vc4_submit_next_bin_job(struct drm_devic
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_exec_info *exec;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ again:
+@@ -522,7 +522,7 @@ vc4_submit_next_render_job(struct drm_de
+ 	if (!exec)
+ 		return;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	/* A previous RCL may have written to one of our textures, and
+@@ -543,7 +543,7 @@ vc4_move_job_to_render(struct drm_device
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	bool was_empty = list_empty(&vc4->render_job_list);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	list_move_tail(&exec->head, &vc4->render_job_list);
+@@ -1012,7 +1012,7 @@ vc4_job_handle_completed(struct vc4_dev
+ 	unsigned long irqflags;
+ 	struct vc4_seqno_cb *cb, *cb_temp;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	spin_lock_irqsave(&vc4->job_lock, irqflags);
+@@ -1051,7 +1051,7 @@ int vc4_queue_seqno_cb(struct drm_device
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	unsigned long irqflags;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	cb->func = func;
+@@ -1107,7 +1107,7 @@ vc4_wait_seqno_ioctl(struct drm_device *
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct drm_vc4_wait_seqno *args = data;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	return vc4_wait_for_seqno_ioctl_helper(dev, args->seqno,
+@@ -1124,7 +1124,7 @@ vc4_wait_bo_ioctl(struct drm_device *dev
+ 	struct drm_gem_object *gem_obj;
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (args->pad != 0)
+@@ -1173,7 +1173,7 @@ vc4_submit_cl_ioctl(struct drm_device *d
+ 				  args->shader_rec_size,
+ 				  args->bo_handle_count);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+@@ -1310,7 +1310,7 @@ int vc4_gem_init(struct drm_device *dev)
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	vc4->dma_fence_context = dma_fence_context_alloc(1);
+@@ -1369,7 +1369,7 @@ int vc4_gem_madvise_ioctl(struct drm_dev
+ 	struct vc4_bo *bo;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	switch (args->madv) {
+--- a/drivers/gpu/drm/vc4/vc4_irq.c
++++ b/drivers/gpu/drm/vc4/vc4_irq.c
+@@ -265,7 +265,7 @@ vc4_irq_enable(struct drm_device *dev)
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	if (!vc4->v3d)
+@@ -282,7 +282,7 @@ vc4_irq_disable(struct drm_device *dev)
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	if (!vc4->v3d)
+@@ -305,7 +305,7 @@ int vc4_irq_install(struct drm_device *d
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (irq == IRQ_NOTCONNECTED)
+@@ -326,7 +326,7 @@ void vc4_irq_uninstall(struct drm_device
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	vc4_irq_disable(dev);
+@@ -339,7 +339,7 @@ void vc4_irq_reset(struct drm_device *de
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	unsigned long irqflags;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	/* Acknowledge any stale IRQs. */
+--- a/drivers/gpu/drm/vc4/vc4_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_kms.c
+@@ -482,7 +482,7 @@ static struct drm_framebuffer *vc4_fb_cr
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct drm_mode_fb_cmd2 mode_cmd_local;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	/* If the user didn't specify a modifier, use the
+--- a/drivers/gpu/drm/vc4/vc4_perfmon.c
++++ b/drivers/gpu/drm/vc4/vc4_perfmon.c
+@@ -23,7 +23,7 @@ void vc4_perfmon_get(struct vc4_perfmon
+ 		return;
+ 
+ 	vc4 = perfmon->dev;
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	refcount_inc(&perfmon->refcnt);
+@@ -37,7 +37,7 @@ void vc4_perfmon_put(struct vc4_perfmon
+ 		return;
+ 
+ 	vc4 = perfmon->dev;
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	if (refcount_dec_and_test(&perfmon->refcnt))
+@@ -49,7 +49,7 @@ void vc4_perfmon_start(struct vc4_dev *v
+ 	unsigned int i;
+ 	u32 mask;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	if (WARN_ON_ONCE(!perfmon || vc4->active_perfmon))
+@@ -69,7 +69,7 @@ void vc4_perfmon_stop(struct vc4_dev *vc
+ {
+ 	unsigned int i;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	if (WARN_ON_ONCE(!vc4->active_perfmon ||
+@@ -90,7 +90,7 @@ struct vc4_perfmon *vc4_perfmon_find(str
+ 	struct vc4_dev *vc4 = vc4file->dev;
+ 	struct vc4_perfmon *perfmon;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return NULL;
+ 
+ 	mutex_lock(&vc4file->perfmon.lock);
+@@ -105,7 +105,7 @@ void vc4_perfmon_open_file(struct vc4_fi
+ {
+ 	struct vc4_dev *vc4 = vc4file->dev;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	mutex_init(&vc4file->perfmon.lock);
+@@ -126,7 +126,7 @@ void vc4_perfmon_close_file(struct vc4_f
+ {
+ 	struct vc4_dev *vc4 = vc4file->dev;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	mutex_lock(&vc4file->perfmon.lock);
+@@ -146,7 +146,7 @@ int vc4_perfmon_create_ioctl(struct drm_
+ 	unsigned int i;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+@@ -200,7 +200,7 @@ int vc4_perfmon_destroy_ioctl(struct drm
+ 	struct drm_vc4_perfmon_destroy *req = data;
+ 	struct vc4_perfmon *perfmon;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+@@ -228,7 +228,7 @@ int vc4_perfmon_get_values_ioctl(struct
+ 	struct vc4_perfmon *perfmon;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (!vc4->v3d) {
+--- a/drivers/gpu/drm/vc4/vc4_render_cl.c
++++ b/drivers/gpu/drm/vc4/vc4_render_cl.c
+@@ -599,7 +599,7 @@ int vc4_get_rcl(struct drm_device *dev,
+ 	bool has_bin = args->bin_cl_size != 0;
+ 	int ret;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	if (args->min_x_tile > args->max_x_tile ||
+--- a/drivers/gpu/drm/vc4/vc4_v3d.c
++++ b/drivers/gpu/drm/vc4/vc4_v3d.c
+@@ -127,7 +127,7 @@ static int vc4_v3d_debugfs_ident(struct
+ int
+ vc4_v3d_pm_get(struct vc4_dev *vc4)
+ {
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&vc4->power_lock);
+@@ -148,7 +148,7 @@ vc4_v3d_pm_get(struct vc4_dev *vc4)
+ void
+ vc4_v3d_pm_put(struct vc4_dev *vc4)
+ {
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	mutex_lock(&vc4->power_lock);
+@@ -178,7 +178,7 @@ int vc4_v3d_get_bin_slot(struct vc4_dev
+ 	uint64_t seqno = 0;
+ 	struct vc4_exec_info *exec;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ try_again:
+@@ -325,7 +325,7 @@ int vc4_v3d_bin_bo_get(struct vc4_dev *v
+ {
+ 	int ret = 0;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&vc4->bin_bo_lock);
+@@ -360,7 +360,7 @@ static void bin_bo_release(struct kref *
+ 
+ void vc4_v3d_bin_bo_put(struct vc4_dev *vc4)
+ {
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return;
+ 
+ 	mutex_lock(&vc4->bin_bo_lock);
+--- a/drivers/gpu/drm/vc4/vc4_validate.c
++++ b/drivers/gpu/drm/vc4/vc4_validate.c
+@@ -109,7 +109,7 @@ vc4_use_bo(struct vc4_exec_info *exec, u
+ 	struct drm_gem_dma_object *obj;
+ 	struct vc4_bo *bo;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return NULL;
+ 
+ 	if (hindex >= exec->bo_count) {
+@@ -169,7 +169,7 @@ vc4_check_tex_size(struct vc4_exec_info
+ 	uint32_t utile_w = utile_width(cpp);
+ 	uint32_t utile_h = utile_height(cpp);
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return false;
+ 
+ 	/* The shaded vertex format stores signed 12.4 fixed point
+@@ -495,7 +495,7 @@ vc4_validate_bin_cl(struct drm_device *d
+ 	uint32_t dst_offset = 0;
+ 	uint32_t src_offset = 0;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	while (src_offset < len) {
+@@ -942,7 +942,7 @@ vc4_validate_shader_recs(struct drm_devi
+ 	uint32_t i;
+ 	int ret = 0;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return -ENODEV;
+ 
+ 	for (i = 0; i < exec->shader_state_count; i++) {
+--- a/drivers/gpu/drm/vc4/vc4_validate_shaders.c
++++ b/drivers/gpu/drm/vc4/vc4_validate_shaders.c
+@@ -786,7 +786,7 @@ vc4_validate_shader(struct drm_gem_dma_o
+ 	struct vc4_validated_shader_info *validated_shader = NULL;
+ 	struct vc4_shader_validation_state validation_state;
+ 
+-	if (WARN_ON_ONCE(vc4->gen == VC4_GEN_5))
++	if (WARN_ON_ONCE(vc4->gen > VC4_GEN_4))
+ 		return NULL;
+ 
+ 	memset(&validation_state, 0, sizeof(validation_state));
diff --git a/target/linux/bcm27xx/patches-6.1/950-0940-drm-vc4-hvs-Use-switch-statement-to-simplify-vc4_hvs.patch b/target/linux/bcm27xx/patches-6.1/950-0940-drm-vc4-hvs-Use-switch-statement-to-simplify-vc4_hvs.patch
new file mode 100644
index 0000000000..048b5d3222
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0940-drm-vc4-hvs-Use-switch-statement-to-simplify-vc4_hvs.patch
@@ -0,0 +1,125 @@
+From 72e5eb3d9511af2f056911d70c4d033d4fc674b2 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 15:07:29 +0100
+Subject: [PATCH] drm/vc4: hvs: Use switch statement to simplify
+ vc4_hvs_get_fifo_from_output
+
+Since we'll support BCM2712 soon, let's move the logic behind
+vc4_hvs_get_fifo_from_output() to a switch to extend it more easily.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 80 +++++++++++++++++++----------------
+ 1 file changed, 43 insertions(+), 37 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -620,57 +620,63 @@ int vc4_hvs_get_fifo_from_output(struct
+ 	u32 reg;
+ 	int ret;
+ 
+-	if (vc4->gen == VC4_GEN_4)
++	switch (vc4->gen) {
++	case VC4_GEN_4:
+ 		return output;
+ 
+-	/*
+-	 * NOTE: We should probably use drm_dev_enter()/drm_dev_exit()
+-	 * here, but this function is only used during the DRM device
+-	 * initialization, so we should be fine.
+-	 */
+-
+-	switch (output) {
+-	case 0:
+-		return 0;
+-
+-	case 1:
+-		return 1;
+-
+-	case 2:
+-		reg = HVS_READ(SCALER_DISPECTRL);
+-		ret = FIELD_GET(SCALER_DISPECTRL_DSP2_MUX_MASK, reg);
+-		if (ret == 0)
+-			return 2;
+-
+-		return 0;
+-
+-	case 3:
+-		reg = HVS_READ(SCALER_DISPCTRL);
+-		ret = FIELD_GET(SCALER_DISPCTRL_DSP3_MUX_MASK, reg);
+-		if (ret == 3)
+-			return -EPIPE;
+-
+-		return ret;
+-
+-	case 4:
+-		reg = HVS_READ(SCALER_DISPEOLN);
+-		ret = FIELD_GET(SCALER_DISPEOLN_DSP4_MUX_MASK, reg);
+-		if (ret == 3)
+-			return -EPIPE;
++	case VC4_GEN_5:
++		/*
++		 * NOTE: We should probably use
++		 * drm_dev_enter()/drm_dev_exit() here, but this
++		 * function is only used during the DRM device
++		 * initialization, so we should be fine.
++		 */
++
++		switch (output) {
++		case 0:
++			return 0;
++
++		case 1:
++			return 1;
++
++		case 2:
++			reg = HVS_READ(SCALER_DISPECTRL);
++			ret = FIELD_GET(SCALER_DISPECTRL_DSP2_MUX_MASK, reg);
++			if (ret == 0)
++				return 2;
++
++			return 0;
++
++		case 3:
++			reg = HVS_READ(SCALER_DISPCTRL);
++			ret = FIELD_GET(SCALER_DISPCTRL_DSP3_MUX_MASK, reg);
++			if (ret == 3)
++				return -EPIPE;
++
++			return ret;
++
++		case 4:
++			reg = HVS_READ(SCALER_DISPEOLN);
++			ret = FIELD_GET(SCALER_DISPEOLN_DSP4_MUX_MASK, reg);
++			if (ret == 3)
++				return -EPIPE;
++
++			return ret;
++
++		case 5:
++			reg = HVS_READ(SCALER_DISPDITHER);
++			ret = FIELD_GET(SCALER_DISPDITHER_DSP5_MUX_MASK, reg);
++			if (ret == 3)
++				return -EPIPE;
+ 
+-		return ret;
++			return ret;
+ 
+-	case 5:
+-		reg = HVS_READ(SCALER_DISPDITHER);
+-		ret = FIELD_GET(SCALER_DISPDITHER_DSP5_MUX_MASK, reg);
+-		if (ret == 3)
++		default:
+ 			return -EPIPE;
+-
+-		return ret;
+-
+-	default:
+-		return -EPIPE;
++		}
+ 	}
++
++	return -EPIPE;
+ }
+ 
+ static int vc4_hvs_init_channel(struct vc4_hvs *hvs, struct drm_crtc *crtc,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0941-drm-vc4-hvs-Use-switch-statement-to-simplify-enablin.patch b/target/linux/bcm27xx/patches-6.1/950-0941-drm-vc4-hvs-Use-switch-statement-to-simplify-enablin.patch
new file mode 100644
index 0000000000..984b329fb4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0941-drm-vc4-hvs-Use-switch-statement-to-simplify-enablin.patch
@@ -0,0 +1,74 @@
+From 72bfb10c9393688d00e4e0b00d416e23c2753318 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 15:07:29 +0100
+Subject: [PATCH] drm/vc4: hvs: Use switch statement to simplify
+ enabling/disabling irq
+
+Since we'll support BCM2712 soon, let's move the logic to enable and
+disable the end-of-frame interrupts to a switch to extend it more
+easily.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 42 ++++++++++++++++++++++++++---------
+ 1 file changed, 32 insertions(+), 10 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -416,24 +416,46 @@ static void vc4_hvs_irq_enable_eof(const
+ 				   unsigned int channel)
+ {
+ 	struct vc4_dev *vc4 = hvs->vc4;
+-	u32 irq_mask = vc4->gen == VC4_GEN_5 ?
+-		SCALER5_DISPCTRL_DSPEIEOF(channel) :
+-		SCALER_DISPCTRL_DSPEIEOF(channel);
+ 
+-	HVS_WRITE(SCALER_DISPCTRL,
+-		  HVS_READ(SCALER_DISPCTRL) | irq_mask);
++	switch (vc4->gen) {
++	case VC4_GEN_4:
++		HVS_WRITE(SCALER_DISPCTRL,
++			  HVS_READ(SCALER_DISPCTRL) |
++			  SCALER_DISPCTRL_DSPEIEOF(channel));
++		break;
++
++	case VC4_GEN_5:
++		HVS_WRITE(SCALER_DISPCTRL,
++			  HVS_READ(SCALER_DISPCTRL) |
++			  SCALER5_DISPCTRL_DSPEIEOF(channel));
++		break;
++
++	default:
++		break;
++	}
+ }
+ 
+ static void vc4_hvs_irq_clear_eof(const struct vc4_hvs *hvs,
+ 				  unsigned int channel)
+ {
+ 	struct vc4_dev *vc4 = hvs->vc4;
+-	u32 irq_mask = vc4->gen == VC4_GEN_5 ?
+-		SCALER5_DISPCTRL_DSPEIEOF(channel) :
+-		SCALER_DISPCTRL_DSPEIEOF(channel);
+ 
+-	HVS_WRITE(SCALER_DISPCTRL,
+-		  HVS_READ(SCALER_DISPCTRL) & ~irq_mask);
++	switch (vc4->gen) {
++	case VC4_GEN_4:
++		HVS_WRITE(SCALER_DISPCTRL,
++			  HVS_READ(SCALER_DISPCTRL) &
++			  ~SCALER_DISPCTRL_DSPEIEOF(channel));
++		break;
++
++	case VC4_GEN_5:
++		HVS_WRITE(SCALER_DISPCTRL,
++			  HVS_READ(SCALER_DISPCTRL) &
++			  ~SCALER5_DISPCTRL_DSPEIEOF(channel));
++		break;
++
++	default:
++		break;
++	}
+ }
+ 
+ static struct vc4_hvs_dlist_allocation *
diff --git a/target/linux/bcm27xx/patches-6.1/950-0942-drm-vc4-hvs-Test-if-the-EOF-interrupts-are-enabled.patch b/target/linux/bcm27xx/patches-6.1/950-0942-drm-vc4-hvs-Test-if-the-EOF-interrupts-are-enabled.patch
new file mode 100644
index 0000000000..704468b90e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0942-drm-vc4-hvs-Test-if-the-EOF-interrupts-are-enabled.patch
@@ -0,0 +1,100 @@
+From bcf02f6ac0d429a425e8409f140bd875a1feed2e Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 27 Apr 2023 13:46:53 +0200
+Subject: [PATCH] drm/vc4: hvs: Test if the EOF interrupts are enabled
+
+We currently enable the EOF interrupts through the CRTC destroy_state
+implementation.
+
+However, nothing guarantees that we can't call destroy_state multiple
+times in a row, and therefore before the EOF interrupt even happens.
+
+This means we would enable the interrupt multiple times but disable it
+only once. It wasn't an issue so far since the interrupts were only
+enabled by setting a bit in a register, but with BCM2712 we will use an
+external interrupt controller, with a refcounted interrupt.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h |  8 ++++++--
+ drivers/gpu/drm/vc4/vc4_hvs.c | 14 ++++++++++++--
+ 2 files changed, 18 insertions(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -333,6 +333,8 @@ struct vc4_v3d {
+ 	struct debugfs_regset32 regset;
+ };
+ 
++#define HVS_NUM_CHANNELS 3
++
+ struct vc4_hvs {
+ 	struct vc4_dev *vc4;
+ 	struct platform_device *pdev;
+@@ -341,6 +343,10 @@ struct vc4_hvs {
+ 
+ 	struct clk *core_clk;
+ 
++	struct {
++		unsigned int enabled: 1;
++	} eof_irq[HVS_NUM_CHANNELS];
++
+ 	unsigned long max_core_rate;
+ 
+ 	/* Memory manager for CRTCs to allocate space in the display
+@@ -373,8 +379,6 @@ struct vc4_hvs {
+ 	bool vc5_hdmi_enable_4096by2160;
+ };
+ 
+-#define HVS_NUM_CHANNELS 3
+-
+ struct vc4_hvs_state {
+ 	struct drm_private_state base;
+ 	unsigned long core_clock_rate;
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -412,11 +412,14 @@ static void vc5_hvs_update_gamma_lut(str
+ 	vc5_hvs_lut_load(hvs, vc4_crtc);
+ }
+ 
+-static void vc4_hvs_irq_enable_eof(const struct vc4_hvs *hvs,
++static void vc4_hvs_irq_enable_eof(struct vc4_hvs *hvs,
+ 				   unsigned int channel)
+ {
+ 	struct vc4_dev *vc4 = hvs->vc4;
+ 
++	if (hvs->eof_irq[channel].enabled)
++		return;
++
+ 	switch (vc4->gen) {
+ 	case VC4_GEN_4:
+ 		HVS_WRITE(SCALER_DISPCTRL,
+@@ -433,13 +436,18 @@ static void vc4_hvs_irq_enable_eof(const
+ 	default:
+ 		break;
+ 	}
++
++	hvs->eof_irq[channel].enabled = true;
+ }
+ 
+-static void vc4_hvs_irq_clear_eof(const struct vc4_hvs *hvs,
++static void vc4_hvs_irq_clear_eof(struct vc4_hvs *hvs,
+ 				  unsigned int channel)
+ {
+ 	struct vc4_dev *vc4 = hvs->vc4;
+ 
++	if (!hvs->eof_irq[channel].enabled)
++		return;
++
+ 	switch (vc4->gen) {
+ 	case VC4_GEN_4:
+ 		HVS_WRITE(SCALER_DISPCTRL,
+@@ -456,6 +464,8 @@ static void vc4_hvs_irq_clear_eof(const
+ 	default:
+ 		break;
+ 	}
++
++	hvs->eof_irq[channel].enabled = false;
+ }
+ 
+ static struct vc4_hvs_dlist_allocation *
diff --git a/target/linux/bcm27xx/patches-6.1/950-0943-drm-vc4-hvs-Create-hw_init-function.patch b/target/linux/bcm27xx/patches-6.1/950-0943-drm-vc4-hvs-Create-hw_init-function.patch
new file mode 100644
index 0000000000..5b748b5e94
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0943-drm-vc4-hvs-Create-hw_init-function.patch
@@ -0,0 +1,188 @@
+From f3c84bb53107cef0009347d071c1a188ce24b8a3 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 14:36:28 +0100
+Subject: [PATCH] drm/vc4: hvs: Create hw_init function
+
+Since the BCM2712 will feature a significantly different HVS, let's move
+the hardware initialisation part of our bind function into a separate
+function.
+
+That way, it will be easier to extend in the future.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 155 ++++++++++++++++++----------------
+ 1 file changed, 83 insertions(+), 72 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -1291,79 +1291,10 @@ struct vc4_hvs *__vc4_hvs_alloc(struct v
+ 	return hvs;
+ }
+ 
+-static int vc4_hvs_bind(struct device *dev, struct device *master, void *data)
++static int vc4_hvs_hw_init(struct vc4_hvs *hvs)
+ {
+-	struct platform_device *pdev = to_platform_device(dev);
+-	struct drm_device *drm = dev_get_drvdata(master);
+-	struct vc4_dev *vc4 = to_vc4_dev(drm);
+-	struct vc4_hvs *hvs = NULL;
+-	int ret;
+-	u32 dispctrl;
+-	u32 reg, top;
+-
+-	hvs = __vc4_hvs_alloc(vc4, NULL);
+-	if (IS_ERR(hvs))
+-		return PTR_ERR(hvs);
+-
+-	hvs->regs = vc4_ioremap_regs(pdev, 0);
+-	if (IS_ERR(hvs->regs))
+-		return PTR_ERR(hvs->regs);
+-
+-	hvs->regset.base = hvs->regs;
+-	hvs->regset.regs = hvs_regs;
+-	hvs->regset.nregs = ARRAY_SIZE(hvs_regs);
+-
+-	if (vc4->gen == VC4_GEN_5) {
+-		struct rpi_firmware *firmware;
+-		struct device_node *node;
+-		unsigned int max_rate;
+-
+-		node = rpi_firmware_find_node();
+-		if (!node)
+-			return -EINVAL;
+-
+-		firmware = rpi_firmware_get(node);
+-		of_node_put(node);
+-		if (!firmware)
+-			return -EPROBE_DEFER;
+-
+-		hvs->core_clk = devm_clk_get(&pdev->dev, NULL);
+-		if (IS_ERR(hvs->core_clk)) {
+-			dev_err(&pdev->dev, "Couldn't get core clock\n");
+-			return PTR_ERR(hvs->core_clk);
+-		}
+-
+-		max_rate = rpi_firmware_clk_get_max_rate(firmware,
+-							 RPI_FIRMWARE_CORE_CLK_ID);
+-		rpi_firmware_put(firmware);
+-		if (max_rate >= 550000000)
+-			hvs->vc5_hdmi_enable_hdmi_20 = true;
+-
+-		if (max_rate >= 600000000)
+-			hvs->vc5_hdmi_enable_4096by2160 = true;
+-
+-		hvs->max_core_rate = max_rate;
+-
+-		ret = clk_prepare_enable(hvs->core_clk);
+-		if (ret) {
+-			dev_err(&pdev->dev, "Couldn't enable the core clock\n");
+-			return ret;
+-		}
+-	}
+-
+-	if (vc4->gen == VC4_GEN_4)
+-		hvs->dlist = hvs->regs + SCALER_DLIST_START;
+-	else
+-		hvs->dlist = hvs->regs + SCALER5_DLIST_START;
+-
+-	/* Upload filter kernels.  We only have the one for now, so we
+-	 * keep it around for the lifetime of the driver.
+-	 */
+-	ret = vc4_hvs_upload_linear_kernel(hvs,
+-					   &hvs->mitchell_netravali_filter,
+-					   mitchell_netravali_1_3_1_3_kernel);
+-	if (ret)
+-		return ret;
++	struct vc4_dev *vc4 = hvs->vc4;
++	u32 dispctrl, reg;
+ 
+ 	reg = HVS_READ(SCALER_DISPECTRL);
+ 	reg &= ~SCALER_DISPECTRL_DSP2_MUX_MASK;
+@@ -1445,6 +1376,86 @@ static int vc4_hvs_bind(struct device *d
+ 
+ 	HVS_WRITE(SCALER_DISPCTRL, dispctrl);
+ 
++	return 0;
++}
++
++static int vc4_hvs_bind(struct device *dev, struct device *master, void *data)
++{
++	struct platform_device *pdev = to_platform_device(dev);
++	struct drm_device *drm = dev_get_drvdata(master);
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
++	struct vc4_hvs *hvs = NULL;
++	int ret;
++	u32 reg, top;
++
++	hvs = __vc4_hvs_alloc(vc4, NULL);
++	if (IS_ERR(hvs))
++		return PTR_ERR(hvs);
++
++	hvs->regs = vc4_ioremap_regs(pdev, 0);
++	if (IS_ERR(hvs->regs))
++		return PTR_ERR(hvs->regs);
++
++	hvs->regset.base = hvs->regs;
++	hvs->regset.regs = hvs_regs;
++	hvs->regset.nregs = ARRAY_SIZE(hvs_regs);
++
++	if (vc4->gen == VC4_GEN_5) {
++		struct rpi_firmware *firmware;
++		struct device_node *node;
++		unsigned int max_rate;
++
++		node = rpi_firmware_find_node();
++		if (!node)
++			return -EINVAL;
++
++		firmware = rpi_firmware_get(node);
++		of_node_put(node);
++		if (!firmware)
++			return -EPROBE_DEFER;
++
++		hvs->core_clk = devm_clk_get(&pdev->dev, NULL);
++		if (IS_ERR(hvs->core_clk)) {
++			dev_err(&pdev->dev, "Couldn't get core clock\n");
++			return PTR_ERR(hvs->core_clk);
++		}
++
++		max_rate = rpi_firmware_clk_get_max_rate(firmware,
++							 RPI_FIRMWARE_CORE_CLK_ID);
++		rpi_firmware_put(firmware);
++		if (max_rate >= 550000000)
++			hvs->vc5_hdmi_enable_hdmi_20 = true;
++
++		if (max_rate >= 600000000)
++			hvs->vc5_hdmi_enable_4096by2160 = true;
++
++		hvs->max_core_rate = max_rate;
++
++		ret = clk_prepare_enable(hvs->core_clk);
++		if (ret) {
++			dev_err(&pdev->dev, "Couldn't enable the core clock\n");
++			return ret;
++		}
++	}
++
++	if (vc4->gen == VC4_GEN_4)
++		hvs->dlist = hvs->regs + SCALER_DLIST_START;
++	else
++		hvs->dlist = hvs->regs + SCALER5_DLIST_START;
++
++	/* Upload filter kernels.  We only have the one for now, so we
++	 * keep it around for the lifetime of the driver.
++	 */
++	ret = vc4_hvs_upload_linear_kernel(hvs,
++					   &hvs->mitchell_netravali_filter,
++					   mitchell_netravali_1_3_1_3_kernel);
++	if (ret)
++		return ret;
++
++	ret = vc4_hvs_hw_init(hvs);
++	if (ret)
++		return ret;
++
+ 	/* Recompute Composite Output Buffer (COB) allocations for the displays
+ 	 */
+ 	if (vc4->gen == VC4_GEN_4) {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0944-drm-vc4-hvs-Create-cob_init-function.patch b/target/linux/bcm27xx/patches-6.1/950-0944-drm-vc4-hvs-Create-cob_init-function.patch
new file mode 100644
index 0000000000..5b2e9745e9
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0944-drm-vc4-hvs-Create-cob_init-function.patch
@@ -0,0 +1,167 @@
+From 99a13ce3a12303dfb54815637972627a7d207086 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 15:14:55 +0100
+Subject: [PATCH] drm/vc4: hvs: Create cob_init function
+
+Just like the HVS itself, the COB parameters will be fairly different in
+the BCM2712.
+
+Let's move the COB parameters computation and its initialisation to a
+separate function that will be easier to extend in the future.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 128 ++++++++++++++++++++--------------
+ 1 file changed, 74 insertions(+), 54 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -1379,6 +1379,77 @@ static int vc4_hvs_hw_init(struct vc4_hv
+ 	return 0;
+ }
+ 
++static int vc4_hvs_cob_init(struct vc4_hvs *hvs)
++{
++	struct vc4_dev *vc4 = hvs->vc4;
++	u32 reg, top;
++
++	/*
++	 * Recompute Composite Output Buffer (COB) allocations for the
++	 * displays
++	 */
++	switch (vc4->gen) {
++	case VC4_GEN_4:
++		/* The COB is 20736 pixels, or just over 10 lines at 2048 wide.
++		 * The bottom 2048 pixels are full 32bpp RGBA (intended for the
++		 * TXP composing RGBA to memory), whilst the remainder are only
++		 * 24bpp RGB.
++		 *
++		 * Assign 3 lines to channels 1 & 2, and just over 4 lines to
++		 * channel 0.
++		 */
++		#define VC4_COB_SIZE		20736
++		#define VC4_COB_LINE_WIDTH	2048
++		#define VC4_COB_NUM_LINES	3
++		reg = 0;
++		top = VC4_COB_LINE_WIDTH * VC4_COB_NUM_LINES;
++		reg |= (top - 1) << 16;
++		HVS_WRITE(SCALER_DISPBASE2, reg);
++		reg = top;
++		top += VC4_COB_LINE_WIDTH * VC4_COB_NUM_LINES;
++		reg |= (top - 1) << 16;
++		HVS_WRITE(SCALER_DISPBASE1, reg);
++		reg = top;
++		top = VC4_COB_SIZE;
++		reg |= (top - 1) << 16;
++		HVS_WRITE(SCALER_DISPBASE0, reg);
++		break;
++
++	case VC4_GEN_5:
++		/* The COB is 44416 pixels, or 10.8 lines at 4096 wide.
++		 * The bottom 4096 pixels are full RGBA (intended for the TXP
++		 * composing RGBA to memory), whilst the remainder are only
++		 * RGB. Addressing is always pixel wide.
++		 *
++		 * Assign 3 lines of 4096 to channels 1 & 2, and just over 4
++		 * lines. to channel 0.
++		 */
++		#define VC5_COB_SIZE		44416
++		#define VC5_COB_LINE_WIDTH	4096
++		#define VC5_COB_NUM_LINES	3
++		reg = 0;
++		top = VC5_COB_LINE_WIDTH * VC5_COB_NUM_LINES;
++		reg |= top << 16;
++		HVS_WRITE(SCALER_DISPBASE2, reg);
++		top += 16;
++		reg = top;
++		top += VC5_COB_LINE_WIDTH * VC5_COB_NUM_LINES;
++		reg |= top << 16;
++		HVS_WRITE(SCALER_DISPBASE1, reg);
++		top += 16;
++		reg = top;
++		top = VC5_COB_SIZE;
++		reg |= top << 16;
++		HVS_WRITE(SCALER_DISPBASE0, reg);
++		break;
++
++	default:
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
+ static int vc4_hvs_bind(struct device *dev, struct device *master, void *data)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+@@ -1386,7 +1457,6 @@ static int vc4_hvs_bind(struct device *d
+ 	struct vc4_dev *vc4 = to_vc4_dev(drm);
+ 	struct vc4_hvs *hvs = NULL;
+ 	int ret;
+-	u32 reg, top;
+ 
+ 	hvs = __vc4_hvs_alloc(vc4, NULL);
+ 	if (IS_ERR(hvs))
+@@ -1456,59 +1526,9 @@ static int vc4_hvs_bind(struct device *d
+ 	if (ret)
+ 		return ret;
+ 
+-	/* Recompute Composite Output Buffer (COB) allocations for the displays
+-	 */
+-	if (vc4->gen == VC4_GEN_4) {
+-		/* The COB is 20736 pixels, or just over 10 lines at 2048 wide.
+-		 * The bottom 2048 pixels are full 32bpp RGBA (intended for the
+-		 * TXP composing RGBA to memory), whilst the remainder are only
+-		 * 24bpp RGB.
+-		 *
+-		 * Assign 3 lines to channels 1 & 2, and just over 4 lines to
+-		 * channel 0.
+-		 */
+-		#define VC4_COB_SIZE		20736
+-		#define VC4_COB_LINE_WIDTH	2048
+-		#define VC4_COB_NUM_LINES	3
+-		reg = 0;
+-		top = VC4_COB_LINE_WIDTH * VC4_COB_NUM_LINES;
+-		reg |= (top - 1) << 16;
+-		HVS_WRITE(SCALER_DISPBASE2, reg);
+-		reg = top;
+-		top += VC4_COB_LINE_WIDTH * VC4_COB_NUM_LINES;
+-		reg |= (top - 1) << 16;
+-		HVS_WRITE(SCALER_DISPBASE1, reg);
+-		reg = top;
+-		top = VC4_COB_SIZE;
+-		reg |= (top - 1) << 16;
+-		HVS_WRITE(SCALER_DISPBASE0, reg);
+-	} else {
+-		/* The COB is 44416 pixels, or 10.8 lines at 4096 wide.
+-		 * The bottom 4096 pixels are full RGBA (intended for the TXP
+-		 * composing RGBA to memory), whilst the remainder are only
+-		 * RGB. Addressing is always pixel wide.
+-		 *
+-		 * Assign 3 lines of 4096 to channels 1 & 2, and just over 4
+-		 * lines. to channel 0.
+-		 */
+-		#define VC5_COB_SIZE		44416
+-		#define VC5_COB_LINE_WIDTH	4096
+-		#define VC5_COB_NUM_LINES	3
+-		reg = 0;
+-		top = VC5_COB_LINE_WIDTH * VC5_COB_NUM_LINES;
+-		reg |= top << 16;
+-		HVS_WRITE(SCALER_DISPBASE2, reg);
+-		top += 16;
+-		reg = top;
+-		top += VC5_COB_LINE_WIDTH * VC5_COB_NUM_LINES;
+-		reg |= top << 16;
+-		HVS_WRITE(SCALER_DISPBASE1, reg);
+-		top += 16;
+-		reg = top;
+-		top = VC5_COB_SIZE;
+-		reg |= top << 16;
+-		HVS_WRITE(SCALER_DISPBASE0, reg);
+-	}
++	ret = vc4_hvs_cob_init(hvs);
++	if (ret)
++		return ret;
+ 
+ 	ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
+ 			       vc4_hvs_irq_handler, 0, "vc4 hvs", drm);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0945-drm-vc4-hvs-Rename-hvs_regs-list.patch b/target/linux/bcm27xx/patches-6.1/950-0945-drm-vc4-hvs-Rename-hvs_regs-list.patch
new file mode 100644
index 0000000000..4139d79f02
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0945-drm-vc4-hvs-Rename-hvs_regs-list.patch
@@ -0,0 +1,38 @@
+From 7a1c157ac856384c47df38e1de2995f55a111b85 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:41:59 +0100
+Subject: [PATCH] drm/vc4: hvs: Rename hvs_regs list
+
+The HVS register set has been heavily modified in the BCM2712, and we'll
+thus need a separate debugfs_reg32 array for it.
+
+The name hvs_regs is thus a bit too generic, so let's rename it to
+something more specific.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -33,7 +33,7 @@
+ #include "vc4_drv.h"
+ #include "vc4_regs.h"
+ 
+-static const struct debugfs_reg32 hvs_regs[] = {
++static const struct debugfs_reg32 vc4_hvs_regs[] = {
+ 	VC4_REG32(SCALER_DISPCTRL),
+ 	VC4_REG32(SCALER_DISPSTAT),
+ 	VC4_REG32(SCALER_DISPID),
+@@ -1467,8 +1467,8 @@ static int vc4_hvs_bind(struct device *d
+ 		return PTR_ERR(hvs->regs);
+ 
+ 	hvs->regset.base = hvs->regs;
+-	hvs->regset.regs = hvs_regs;
+-	hvs->regset.nregs = ARRAY_SIZE(hvs_regs);
++	hvs->regset.regs = vc4_hvs_regs;
++	hvs->regset.nregs = ARRAY_SIZE(vc4_hvs_regs);
+ 
+ 	if (vc4->gen == VC4_GEN_5) {
+ 		struct rpi_firmware *firmware;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0946-drm-vc4-plane-Change-ptr0_offset-to-an-array.patch b/target/linux/bcm27xx/patches-6.1/950-0946-drm-vc4-plane-Change-ptr0_offset-to-an-array.patch
new file mode 100644
index 0000000000..ed55f53fad
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0946-drm-vc4-plane-Change-ptr0_offset-to-an-array.patch
@@ -0,0 +1,103 @@
+From 531f66804eb95323f807d240273087fbe162aeee Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 24 Mar 2023 09:56:31 +0100
+Subject: [PATCH] drm/vc4: plane: Change ptr0_offset to an array
+
+The BCM2712 will have a fairly different dlist, that will feature one
+Pointer 0 word for each plane.
+
+Let's prepare by changing the ptr0_offset variable that holds the offset
+in a dlist of the pointer 0 word to an array.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h   |  3 ++-
+ drivers/gpu/drm/vc4/vc4_plane.c | 18 +++++++++---------
+ 2 files changed, 11 insertions(+), 10 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -14,6 +14,7 @@
+ #include <drm/drm_debugfs.h>
+ #include <drm/drm_device.h>
+ #include <drm/drm_encoder.h>
++#include <drm/drm_fourcc.h>
+ #include <drm/drm_gem_dma_helper.h>
+ #include <drm/drm_managed.h>
+ #include <drm/drm_mm.h>
+@@ -430,7 +431,7 @@ struct vc4_plane_state {
+ 	 */
+ 	u32 pos0_offset;
+ 	u32 pos2_offset;
+-	u32 ptr0_offset;
++	u32 ptr0_offset[DRM_FORMAT_MAX_PLANES];
+ 	u32 lbm_offset;
+ 
+ 	/* Offset where the plane's dlist was last stored in the
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -1242,7 +1242,7 @@ static int vc4_plane_mode_set(struct drm
+ 	 *
+ 	 * The pointers may be any byte address.
+ 	 */
+-	vc4_state->ptr0_offset = vc4_state->dlist_count;
++	vc4_state->ptr0_offset[0] = vc4_state->dlist_count;
+ 	for (i = 0; i < num_planes; i++)
+ 		vc4_dlist_write(vc4_state, vc4_state->offsets[i]);
+ 
+@@ -1447,13 +1447,13 @@ void vc4_plane_async_set_fb(struct drm_p
+ 	 * scanout will start from this address as soon as the FIFO
+ 	 * needs to refill with pixels.
+ 	 */
+-	writel(addr, &vc4_state->hw_dlist[vc4_state->ptr0_offset]);
++	writel(addr, &vc4_state->hw_dlist[vc4_state->ptr0_offset[0]]);
+ 
+ 	/* Also update the CPU-side dlist copy, so that any later
+ 	 * atomic updates that don't do a new modeset on our plane
+ 	 * also use our updated address.
+ 	 */
+-	vc4_state->dlist[vc4_state->ptr0_offset] = addr;
++	vc4_state->dlist[vc4_state->ptr0_offset[0]] = addr;
+ 
+ 	drm_dev_exit(idx);
+ }
+@@ -1517,8 +1517,8 @@ static void vc4_plane_atomic_async_updat
+ 		new_vc4_state->dlist[vc4_state->pos0_offset];
+ 	vc4_state->dlist[vc4_state->pos2_offset] =
+ 		new_vc4_state->dlist[vc4_state->pos2_offset];
+-	vc4_state->dlist[vc4_state->ptr0_offset] =
+-		new_vc4_state->dlist[vc4_state->ptr0_offset];
++	vc4_state->dlist[vc4_state->ptr0_offset[0]] =
++		new_vc4_state->dlist[vc4_state->ptr0_offset[0]];
+ 
+ 	/* Note that we can't just call vc4_plane_write_dlist()
+ 	 * because that would smash the context data that the HVS is
+@@ -1528,8 +1528,8 @@ static void vc4_plane_atomic_async_updat
+ 	       &vc4_state->hw_dlist[vc4_state->pos0_offset]);
+ 	writel(vc4_state->dlist[vc4_state->pos2_offset],
+ 	       &vc4_state->hw_dlist[vc4_state->pos2_offset]);
+-	writel(vc4_state->dlist[vc4_state->ptr0_offset],
+-	       &vc4_state->hw_dlist[vc4_state->ptr0_offset]);
++	writel(vc4_state->dlist[vc4_state->ptr0_offset[0]],
++	       &vc4_state->hw_dlist[vc4_state->ptr0_offset[0]]);
+ 
+ 	drm_dev_exit(idx);
+ }
+@@ -1556,7 +1556,7 @@ static int vc4_plane_atomic_async_check(
+ 	if (old_vc4_state->dlist_count != new_vc4_state->dlist_count ||
+ 	    old_vc4_state->pos0_offset != new_vc4_state->pos0_offset ||
+ 	    old_vc4_state->pos2_offset != new_vc4_state->pos2_offset ||
+-	    old_vc4_state->ptr0_offset != new_vc4_state->ptr0_offset ||
++	    old_vc4_state->ptr0_offset[0] != new_vc4_state->ptr0_offset[0] ||
+ 	    vc4_lbm_size(plane->state) != vc4_lbm_size(new_plane_state))
+ 		return -EINVAL;
+ 
+@@ -1566,7 +1566,7 @@ static int vc4_plane_atomic_async_check(
+ 	for (i = 0; i < new_vc4_state->dlist_count; i++) {
+ 		if (i == new_vc4_state->pos0_offset ||
+ 		    i == new_vc4_state->pos2_offset ||
+-		    i == new_vc4_state->ptr0_offset ||
++		    i == new_vc4_state->ptr0_offset[0] ||
+ 		    (new_vc4_state->lbm_offset &&
+ 		     i == new_vc4_state->lbm_offset))
+ 			continue;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0947-drm-vc4-hvs-Rework-LBM-alignment.patch b/target/linux/bcm27xx/patches-6.1/950-0947-drm-vc4-hvs-Rework-LBM-alignment.patch
new file mode 100644
index 0000000000..3a30b9ca85
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0947-drm-vc4-hvs-Rework-LBM-alignment.patch
@@ -0,0 +1,45 @@
+From 2834b58a3b58198e551d8461a0786b75d3d76823 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 13 Apr 2023 10:12:19 +0200
+Subject: [PATCH] drm/vc4: hvs: Rework LBM alignment
+
+With the introduction of the support for BCM2712, the check of whether
+we're running on vc5 or not to compute the LBM alignment requirement
+doesn't work anymore.
+
+Moreover, the LBM size will need to be computed in words for the
+BCM2712, while we've had sizes in bytes so far.
+
+Aligning on either 64 or 32 words is thus fairly harmful on BCM2712, so
+let's just explicitly align the size when needed, and then call
+drm_mm_insert_node_generic() with an alignment of 1.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_plane.c | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -744,6 +744,11 @@ static int vc4_plane_allocate_lbm(struct
+ 	if (!lbm_size)
+ 		return 0;
+ 
++	if (vc4->gen == VC4_GEN_5)
++		lbm_size = ALIGN(lbm_size, 64);
++	else if (vc4->gen == VC4_GEN_4)
++		lbm_size = ALIGN(lbm_size, 32);
++
+ 	drm_dbg_driver(drm, "[PLANE:%d:%s] LBM Allocation Size: %u\n",
+ 		       plane->base.id, plane->name, lbm_size);
+ 
+@@ -759,8 +764,7 @@ static int vc4_plane_allocate_lbm(struct
+ 		spin_lock_irqsave(&vc4->hvs->mm_lock, irqflags);
+ 		ret = drm_mm_insert_node_generic(&vc4->hvs->lbm_mm,
+ 						 &vc4_state->lbm,
+-						 lbm_size,
+-						 vc4->gen == VC4_GEN_5 ? 64 : 32,
++						 lbm_size, 1,
+ 						 0, 0);
+ 		spin_unlock_irqrestore(&vc4->hvs->mm_lock, irqflags);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0948-drm-vc4-hvs-Change-prototype-of-__vc4_hvs_alloc-to-p.patch b/target/linux/bcm27xx/patches-6.1/950-0948-drm-vc4-hvs-Change-prototype-of-__vc4_hvs_alloc-to-p.patch
new file mode 100644
index 0000000000..2927a3e04e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0948-drm-vc4-hvs-Change-prototype-of-__vc4_hvs_alloc-to-p.patch
@@ -0,0 +1,93 @@
+From 23cba2abd5ffbb7337e3f381c4724eaaf01cf5a1 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 24 Mar 2023 15:45:50 +0100
+Subject: [PATCH] drm/vc4: hvs: Change prototype of __vc4_hvs_alloc to pass
+ registers
+
+The BCM2712 HVS has registers to report the size of the various SRAM the
+driver uses, and their size actually differ depending on the stepping.
+
+The initialisation of the memory pools happen in the __vc4_hvs_alloc()
+function that also allocates the main HVS structure, that will then hold
+the pointer to the memory mapping of the registers.
+
+This creates some kind of circular dependency that we can break by
+passing the mapping pointer as an argument for __vc4_hvs_alloc() to use
+to query to get the SRAM sizes and initialise the memory pools
+accordingly.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.c |  2 +-
+ drivers/gpu/drm/vc4/vc4_drv.h        |  4 +++-
+ drivers/gpu/drm/vc4/vc4_hvs.c        | 16 ++++++++++------
+ 3 files changed, 14 insertions(+), 8 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.c
+@@ -173,7 +173,7 @@ static struct vc4_dev *__mock_device(str
+ 	vc4->dev = dev;
+ 	vc4->gen = gen;
+ 
+-	vc4->hvs = __vc4_hvs_alloc(vc4, NULL);
++	vc4->hvs = __vc4_hvs_alloc(vc4, NULL, NULL);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, vc4->hvs);
+ 
+ 	drm = &vc4->base;
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -1092,7 +1092,9 @@ void vc4_irq_reset(struct drm_device *de
+ 
+ /* vc4_hvs.c */
+ extern struct platform_driver vc4_hvs_driver;
+-struct vc4_hvs *__vc4_hvs_alloc(struct vc4_dev *vc4, struct platform_device *pdev);
++struct vc4_hvs *__vc4_hvs_alloc(struct vc4_dev *vc4,
++				void __iomem *regs,
++				struct platform_device *pdev);
+ void vc4_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int output);
+ int vc4_hvs_get_fifo_from_output(struct vc4_hvs *hvs, unsigned int output);
+ u8 vc4_hvs_get_fifo_frame_count(struct vc4_hvs *hvs, unsigned int fifo);
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -1248,7 +1248,9 @@ int vc4_hvs_debugfs_init(struct drm_mino
+ 	return 0;
+ }
+ 
+-struct vc4_hvs *__vc4_hvs_alloc(struct vc4_dev *vc4, struct platform_device *pdev)
++struct vc4_hvs *__vc4_hvs_alloc(struct vc4_dev *vc4,
++				void __iomem *regs,
++				struct platform_device *pdev)
+ {
+ 	struct drm_device *drm = &vc4->base;
+ 	struct vc4_hvs *hvs;
+@@ -1258,6 +1260,7 @@ struct vc4_hvs *__vc4_hvs_alloc(struct v
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	hvs->vc4 = vc4;
++	hvs->regs = regs;
+ 	hvs->pdev = pdev;
+ 
+ 	spin_lock_init(&hvs->mm_lock);
+@@ -1456,16 +1459,17 @@ static int vc4_hvs_bind(struct device *d
+ 	struct drm_device *drm = dev_get_drvdata(master);
+ 	struct vc4_dev *vc4 = to_vc4_dev(drm);
+ 	struct vc4_hvs *hvs = NULL;
++	void __iomem *regs;
+ 	int ret;
+ 
+-	hvs = __vc4_hvs_alloc(vc4, NULL);
++	regs = vc4_ioremap_regs(pdev, 0);
++	if (IS_ERR(regs))
++		return PTR_ERR(regs);
++
++	hvs = __vc4_hvs_alloc(vc4, regs, pdev);
+ 	if (IS_ERR(hvs))
+ 		return PTR_ERR(hvs);
+ 
+-	hvs->regs = vc4_ioremap_regs(pdev, 0);
+-	if (IS_ERR(hvs->regs))
+-		return PTR_ERR(hvs->regs);
+-
+ 	hvs->regset.base = hvs->regs;
+ 	hvs->regset.regs = vc4_hvs_regs;
+ 	hvs->regset.nregs = ARRAY_SIZE(vc4_hvs_regs);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0949-drm-vc4-UV-planes-vertical-scaling-must-always-be-en.patch b/target/linux/bcm27xx/patches-6.1/950-0949-drm-vc4-UV-planes-vertical-scaling-must-always-be-en.patch
new file mode 100644
index 0000000000..4a51862487
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0949-drm-vc4-UV-planes-vertical-scaling-must-always-be-en.patch
@@ -0,0 +1,30 @@
+From 03e0e348df7b685439f2db61ec2d8c8da25d1217 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 23 Aug 2023 17:48:23 +0100
+Subject: [PATCH] drm/vc4: UV planes vertical scaling must always be enabled
+
+It has been observed that a YUV422 unity scaled plane isn't displayed.
+Enabling vertical scaling on the UV planes solves this. There is
+already a similar clause to always enable horizontal scaling on the
+UV planes.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_plane.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -522,6 +522,12 @@ static int vc4_plane_setup_clipping_and_
+ 		 */
+ 		if (vc4_state->x_scaling[1] == VC4_SCALING_NONE)
+ 			vc4_state->x_scaling[1] = VC4_SCALING_PPF;
++
++		/* Similarly UV needs vertical scaling to be enabled.
++		 * Without this a 1:1 scaled YUV422 plane isn't rendered.
++		 */
++		if (vc4_state->y_scaling[1] == VC4_SCALING_NONE)
++			vc4_state->y_scaling[1] = VC4_SCALING_PPF;
+ 	} else {
+ 		vc4_state->is_yuv = false;
+ 		vc4_state->x_scaling[1] = VC4_SCALING_NONE;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0950-drm-vc4-hdmi-Avoid-hang-with-debug-registers-when-su.patch b/target/linux/bcm27xx/patches-6.1/950-0950-drm-vc4-hdmi-Avoid-hang-with-debug-registers-when-su.patch
new file mode 100644
index 0000000000..8e36b79794
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0950-drm-vc4-hdmi-Avoid-hang-with-debug-registers-when-su.patch
@@ -0,0 +1,39 @@
+From e5e7679d634b10e88df340c85cd8368c9f9989eb Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Tue, 5 Sep 2023 19:38:24 +0100
+Subject: [PATCH] drm/vc4: hdmi: Avoid hang with debug registers when suspended
+
+Trying to read /sys/kernel/debug/dri/1/hdmi1_regs
+when the hdmi is disconnected results in a fatal system hang.
+
+This is due to the pm suspend code disabling the dvp clock.
+That is just a gate of the 108MHz clock in DVP_HT_RPI_MISC_CONFIG,
+which results in accesses hanging AXI bus.
+
+Protect against this.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/gpu/drm/vc4/vc4_hdmi.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_hdmi.c
++++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
+@@ -193,6 +193,8 @@ static int vc4_hdmi_debugfs_regs(struct
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return -ENODEV;
+ 
++	WARN_ON(pm_runtime_resume_and_get(&vc4_hdmi->pdev->dev));
++
+ 	drm_print_regset32(&p, &vc4_hdmi->hdmi_regset);
+ 	drm_print_regset32(&p, &vc4_hdmi->hd_regset);
+ 	drm_print_regset32(&p, &vc4_hdmi->cec_regset);
+@@ -202,6 +204,8 @@ static int vc4_hdmi_debugfs_regs(struct
+ 	drm_print_regset32(&p, &vc4_hdmi->ram_regset);
+ 	drm_print_regset32(&p, &vc4_hdmi->rm_regset);
+ 
++	pm_runtime_put(&vc4_hdmi->pdev->dev);
++
+ 	drm_dev_exit(idx);
+ 
+ 	return 0;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0951-drm-vc4-Move-the-buffer-offset-out-of-the-vc4_plane_.patch b/target/linux/bcm27xx/patches-6.1/950-0951-drm-vc4-Move-the-buffer-offset-out-of-the-vc4_plane_.patch
new file mode 100644
index 0000000000..eeb2a93b5c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0951-drm-vc4-Move-the-buffer-offset-out-of-the-vc4_plane_.patch
@@ -0,0 +1,154 @@
+From 11cf37e741b439b26fe932750bde841a16a96828 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Mon, 25 Sep 2023 16:57:07 +0100
+Subject: [PATCH] drm/vc4: Move the buffer offset out of the vc4_plane_state
+
+The offset fields in vc4_plane_state are described as being
+the offset for each buffer in the bo, however it is used to
+store the complete DMA address that is then written into the
+register.
+
+The DMA address including the fb ofset  can be retrieved
+using drm_fb_dma_get_gem_addr, and the offset adjustment due to
+clipping is local to vc4_plane_mode_set.
+Drop the offset field from the state, and compute the complete
+DMA address in vc4_plane_mode_set.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h   |  5 ----
+ drivers/gpu/drm/vc4/vc4_plane.c | 51 +++++++++++++--------------------
+ 2 files changed, 20 insertions(+), 36 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -451,11 +451,6 @@ struct vc4_plane_state {
+ 	bool is_unity;
+ 	bool is_yuv;
+ 
+-	/* Offset to start scanning out from the start of the plane's
+-	 * BO.
+-	 */
+-	u32 offsets[3];
+-
+ 	/* Our allocation in LBM for temporary storage during scaling. */
+ 	struct drm_mm_node lbm;
+ 
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -450,12 +450,11 @@ static int vc4_plane_setup_clipping_and_
+ {
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
+ 	struct drm_framebuffer *fb = state->fb;
+-	struct drm_gem_dma_object *bo;
+ 	int num_planes = fb->format->num_planes;
+ 	struct drm_crtc_state *crtc_state;
+ 	u32 h_subsample = fb->format->hsub;
+ 	u32 v_subsample = fb->format->vsub;
+-	int i, ret;
++	int ret;
+ 
+ 	crtc_state = drm_atomic_get_existing_crtc_state(state->state,
+ 							state->crtc);
+@@ -469,11 +468,6 @@ static int vc4_plane_setup_clipping_and_
+ 	if (ret)
+ 		return ret;
+ 
+-	for (i = 0; i < num_planes; i++) {
+-		bo = drm_fb_dma_get_gem_obj(fb, i);
+-		vc4_state->offsets[i] = bo->dma_addr + fb->offsets[i];
+-	}
+-
+ 	vc4_state->src_x = state->src.x1;
+ 	vc4_state->src_y = state->src.y1;
+ 	vc4_state->src_w[0] = state->src.x2 - vc4_state->src_x;
+@@ -896,6 +890,7 @@ static int vc4_plane_mode_set(struct drm
+ 	u32 width, height;
+ 	u32 hvs_format = format->hvs;
+ 	unsigned int rotation;
++	u32 offsets[3] = { 0 };
+ 	int ret, i;
+ 
+ 	if (vc4_state->dlist_initialized)
+@@ -943,13 +938,8 @@ static int vc4_plane_mode_set(struct drm
+ 		 * out.
+ 		 */
+ 		for (i = 0; i < num_planes; i++) {
+-			vc4_state->offsets[i] += src_y /
+-						 (i ? v_subsample : 1) *
+-						 fb->pitches[i];
+-
+-			vc4_state->offsets[i] += src_x /
+-						 (i ? h_subsample : 1) *
+-						 fb->format->cpp[i];
++			offsets[i] += src_y / (i ? v_subsample : 1) * fb->pitches[i];
++			offsets[i] += src_x / (i ? h_subsample : 1) * fb->format->cpp[i];
+ 		}
+ 
+ 		break;
+@@ -1004,19 +994,18 @@ static int vc4_plane_mode_set(struct drm
+ 			   VC4_SET_FIELD(y_off, SCALER_PITCH0_TILE_Y_OFFSET) |
+ 			   VC4_SET_FIELD(tiles_l, SCALER_PITCH0_TILE_WIDTH_L) |
+ 			   VC4_SET_FIELD(tiles_r, SCALER_PITCH0_TILE_WIDTH_R));
+-		vc4_state->offsets[0] += tiles_t * (tiles_w << tile_size_shift);
+-		vc4_state->offsets[0] += subtile_y << 8;
+-		vc4_state->offsets[0] += utile_y << 4;
++		offsets[0] += tiles_t * (tiles_w << tile_size_shift);
++		offsets[0] += subtile_y << 8;
++		offsets[0] += utile_y << 4;
+ 
+ 		/* Rows of tiles alternate left-to-right and right-to-left. */
+ 		if (tiles_t & 1) {
+ 			pitch0 |= SCALER_PITCH0_TILE_INITIAL_LINE_DIR;
+-			vc4_state->offsets[0] += (tiles_w - tiles_l) <<
+-						 tile_size_shift;
+-			vc4_state->offsets[0] -= (1 + !tile_y) << 10;
++			offsets[0] += (tiles_w - tiles_l) << tile_size_shift;
++			offsets[0] -= (1 + !tile_y) << 10;
+ 		} else {
+-			vc4_state->offsets[0] += tiles_l << tile_size_shift;
+-			vc4_state->offsets[0] += tile_y << 10;
++			offsets[0] += tiles_l << tile_size_shift;
++			offsets[0] += tile_y << 10;
+ 		}
+ 
+ 		break;
+@@ -1105,11 +1094,9 @@ static int vc4_plane_mode_set(struct drm
+ 
+ 			tile = src_x / pix_per_tile;
+ 
+-			vc4_state->offsets[i] += param * tile_w * tile;
+-			vc4_state->offsets[i] += src_y /
+-						 (i ? v_subsample : 1) *
+-						 tile_w;
+-			vc4_state->offsets[i] += x_off & ~(i ? 1 : 0);
++			offsets[i] += param * tile_w * tile;
++			offsets[i] += src_y / (i ? v_subsample : 1) * tile_w;
++			offsets[i] += x_off & ~(i ? 1 : 0);
+ 		}
+ 
+ 		pitch0 = VC4_SET_FIELD(param, SCALER_TILE_HEIGHT);
+@@ -1253,8 +1240,12 @@ static int vc4_plane_mode_set(struct drm
+ 	 * The pointers may be any byte address.
+ 	 */
+ 	vc4_state->ptr0_offset[0] = vc4_state->dlist_count;
+-	for (i = 0; i < num_planes; i++)
+-		vc4_dlist_write(vc4_state, vc4_state->offsets[i]);
++
++	for (i = 0; i < num_planes; i++) {
++		dma_addr_t paddr = drm_fb_dma_get_gem_addr(fb, state, i);
++
++		vc4_dlist_write(vc4_state, paddr + offsets[i]);
++	}
+ 
+ 	/* Pointer Context Word 0/1/2: Written by the HVS */
+ 	for (i = 0; i < num_planes; i++)
+@@ -1518,8 +1509,6 @@ static void vc4_plane_atomic_async_updat
+ 	       sizeof(vc4_state->y_scaling));
+ 	vc4_state->is_unity = new_vc4_state->is_unity;
+ 	vc4_state->is_yuv = new_vc4_state->is_yuv;
+-	memcpy(vc4_state->offsets, new_vc4_state->offsets,
+-	       sizeof(vc4_state->offsets));
+ 	vc4_state->needs_bg_fill = new_vc4_state->needs_bg_fill;
+ 
+ 	/* Update the current vc4_state pos0, pos2 and ptr0 dlist entries. */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0952-drm-vc4-Fix-dlist-debug-not-resetting-the-next-entry.patch b/target/linux/bcm27xx/patches-6.1/950-0952-drm-vc4-Fix-dlist-debug-not-resetting-the-next-entry.patch
new file mode 100644
index 0000000000..01ad932415
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0952-drm-vc4-Fix-dlist-debug-not-resetting-the-next-entry.patch
@@ -0,0 +1,33 @@
+From 3660abb4a8523e988f1345985e89149804e50ebe Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 24 Aug 2023 15:36:21 +0100
+Subject: [PATCH] drm/vc4: Fix dlist debug not resetting the next entry pointer
+
+The debug function to display the dlists didn't reset next_entry_start
+when starting each display, so resulting in not stopping the
+list at the correct place.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -110,7 +110,7 @@ static int vc4_hvs_debugfs_dlist(struct
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_hvs *hvs = vc4->hvs;
+ 	struct drm_printer p = drm_seq_file_printer(m);
+-	unsigned int next_entry_start = 0;
++	unsigned int next_entry_start;
+ 	unsigned int i, j;
+ 	u32 dlist_word, dispstat;
+ 
+@@ -124,6 +124,7 @@ static int vc4_hvs_debugfs_dlist(struct
+ 		}
+ 
+ 		drm_printf(&p, "HVS chan %u:\n", i);
++		next_entry_start = 0;
+ 
+ 		for (j = HVS_READ(SCALER_DISPLISTX(i)); j < 256; j++) {
+ 			dlist_word = readl((u32 __iomem *)vc4->hvs->dlist + j);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0953-drm-vc4-Remove-incorrect-limit-from-hvs_dlist-debugf.patch b/target/linux/bcm27xx/patches-6.1/950-0953-drm-vc4-Remove-incorrect-limit-from-hvs_dlist-debugf.patch
new file mode 100644
index 0000000000..d41d53ecbe
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0953-drm-vc4-Remove-incorrect-limit-from-hvs_dlist-debugf.patch
@@ -0,0 +1,57 @@
+From ebf11a4cfd9f1236fb9eeb7e32e87b18f5f56f16 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 1 Sep 2023 13:45:08 +0100
+Subject: [PATCH] drm: vc4: Remove incorrect limit from hvs_dlist debugfs
+ function
+
+The debugfs function to dump dlists aborted at 256 bytes,
+when actually the dlist memory is generally significantly
+larger but varies based on SoC.
+
+We already have the correct limit in __vc4_hvs_alloc, so
+store it for use in the debugfs dlist function.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h | 1 +
+ drivers/gpu/drm/vc4/vc4_hvs.c | 5 ++++-
+ 2 files changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -341,6 +341,7 @@ struct vc4_hvs {
+ 	struct platform_device *pdev;
+ 	void __iomem *regs;
+ 	u32 __iomem *dlist;
++	unsigned int dlist_mem_size;
+ 
+ 	struct clk *core_clk;
+ 
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -110,6 +110,7 @@ static int vc4_hvs_debugfs_dlist(struct
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_hvs *hvs = vc4->hvs;
+ 	struct drm_printer p = drm_seq_file_printer(m);
++	unsigned int dlist_mem_size = hvs->dlist_mem_size;
+ 	unsigned int next_entry_start;
+ 	unsigned int i, j;
+ 	u32 dlist_word, dispstat;
+@@ -126,7 +127,7 @@ static int vc4_hvs_debugfs_dlist(struct
+ 		drm_printf(&p, "HVS chan %u:\n", i);
+ 		next_entry_start = 0;
+ 
+-		for (j = HVS_READ(SCALER_DISPLISTX(i)); j < 256; j++) {
++		for (j = HVS_READ(SCALER_DISPLISTX(i)); j < dlist_mem_size; j++) {
+ 			dlist_word = readl((u32 __iomem *)vc4->hvs->dlist + j);
+ 			drm_printf(&p, "dlist: %02d: 0x%08x\n", j,
+ 				   dlist_word);
+@@ -1278,6 +1279,8 @@ struct vc4_hvs *__vc4_hvs_alloc(struct v
+ 		    HVS_BOOTLOADER_DLIST_END,
+ 		    (SCALER_DLIST_SIZE >> 2) - HVS_BOOTLOADER_DLIST_END);
+ 
++	hvs->dlist_mem_size = dlist_size;
++
+ 	/* Set up the HVS LBM memory manager.  We could have some more
+ 	 * complicated data structure that allowed reuse of LBM areas
+ 	 * between planes when they don't overlap on the screen, but
diff --git a/target/linux/bcm27xx/patches-6.1/950-0954-drm-vc4-hvs-Remove-ABORT_ON_EMPTY-flag.patch b/target/linux/bcm27xx/patches-6.1/950-0954-drm-vc4-hvs-Remove-ABORT_ON_EMPTY-flag.patch
new file mode 100644
index 0000000000..640b0ea757
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0954-drm-vc4-hvs-Remove-ABORT_ON_EMPTY-flag.patch
@@ -0,0 +1,50 @@
+From 712bccec241e84e28ccb725fae87d3255d039f42 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Thu, 22 Jun 2023 14:06:40 +0100
+Subject: [PATCH] drm/vc4: hvs: Remove ABORT_ON_EMPTY flag
+
+ABORT_ON_EMPTY chooses whether the HVS abandons the current frame
+when it experiences an underflow, or attempts to continue.
+
+In theory the frame should be black from the point of underflow,
+compared to a shift of sebsequent pixels to the left.
+
+Unfortunately it seems to put the HVS is a bad state where it is not
+possible to recover simply. This typically requires a reboot
+following the 'flip done timed out message'.
+
+Discussion with Broadcom has suggested we don't use this flag.
+All their testing is done with it disabled.
+
+Additionally setting BLANK_INSERT_EN causes the HDMI to output
+blank pixels on an underflow which avoids it losing sync.
+
+After this change a 'flip done timed out' due to sdram bandwidth
+starvation or too low a clock is recoverable once the situation improves.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/gpu/drm/vc4/vc4_hdmi.c | 1 +
+ drivers/gpu/drm/vc4/vc4_regs.h | 1 +
+ 2 files changed, 2 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_hdmi.c
++++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
+@@ -1866,6 +1866,7 @@ static void vc4_hdmi_encoder_post_crtc_e
+ 		   VC4_HD_VID_CTL_CLRRGB |
+ 		   VC4_HD_VID_CTL_UNDERFLOW_ENABLE |
+ 		   VC4_HD_VID_CTL_FRAME_COUNTER_RESET |
++		   VC4_HD_VID_CTL_BLANK_INSERT_EN |
+ 		   (vsync_pos ? 0 : VC4_HD_VID_CTL_VSYNC_LOW) |
+ 		   (hsync_pos ? 0 : VC4_HD_VID_CTL_HSYNC_LOW));
+ 
+--- a/drivers/gpu/drm/vc4/vc4_regs.h
++++ b/drivers/gpu/drm/vc4/vc4_regs.h
+@@ -799,6 +799,7 @@ enum {
+ # define VC4_HD_VID_CTL_CLRSYNC			BIT(24)
+ # define VC4_HD_VID_CTL_CLRRGB			BIT(23)
+ # define VC4_HD_VID_CTL_BLANKPIX		BIT(18)
++# define VC4_HD_VID_CTL_BLANK_INSERT_EN		BIT(16)
+ 
+ # define VC4_HD_CSC_CTL_ORDER_MASK		VC4_MASK(7, 5)
+ # define VC4_HD_CSC_CTL_ORDER_SHIFT		5
diff --git a/target/linux/bcm27xx/patches-6.1/950-0955-drm-vc4-Enable-SCALER_CONTROL-early-in-HVS-init.patch b/target/linux/bcm27xx/patches-6.1/950-0955-drm-vc4-Enable-SCALER_CONTROL-early-in-HVS-init.patch
new file mode 100644
index 0000000000..3060c0201f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0955-drm-vc4-Enable-SCALER_CONTROL-early-in-HVS-init.patch
@@ -0,0 +1,59 @@
+From 542ba979b4fa1e07ff2ad2dabbdc12e92b80ed46 Mon Sep 17 00:00:00 2001
+From: Tim Gover <tim.gover@raspberrypi.com>
+Date: Thu, 13 Jul 2023 17:47:22 +0100
+Subject: [PATCH] drm/vc4: Enable SCALER_CONTROL early in HVS init
+
+Always enable SCALER_CONTROL before attempting other HVS
+operations. It's safe to write to some parts of the HVS but
+in general it's dangerous to do this because it can cause bus
+lockups.
+
+Signed-off-by: Tim Gover <tim.gover@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 14 ++++++++------
+ 1 file changed, 8 insertions(+), 6 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -1303,6 +1303,10 @@ static int vc4_hvs_hw_init(struct vc4_hv
+ 	struct vc4_dev *vc4 = hvs->vc4;
+ 	u32 dispctrl, reg;
+ 
++	dispctrl = HVS_READ(SCALER_DISPCTRL);
++	dispctrl |= SCALER_DISPCTRL_ENABLE;
++	HVS_WRITE(SCALER_DISPCTRL, dispctrl);
++
+ 	reg = HVS_READ(SCALER_DISPECTRL);
+ 	reg &= ~SCALER_DISPECTRL_DSP2_MUX_MASK;
+ 	HVS_WRITE(SCALER_DISPECTRL,
+@@ -1324,8 +1328,6 @@ static int vc4_hvs_hw_init(struct vc4_hv
+ 		  reg | VC4_SET_FIELD(3, SCALER_DISPDITHER_DSP5_MUX));
+ 
+ 	dispctrl = HVS_READ(SCALER_DISPCTRL);
+-
+-	dispctrl |= SCALER_DISPCTRL_ENABLE;
+ 	dispctrl |= SCALER_DISPCTRL_DISPEIRQ(0) |
+ 		    SCALER_DISPCTRL_DISPEIRQ(1) |
+ 		    SCALER_DISPCTRL_DISPEIRQ(2);
+@@ -1521,6 +1523,10 @@ static int vc4_hvs_bind(struct device *d
+ 	else
+ 		hvs->dlist = hvs->regs + SCALER5_DLIST_START;
+ 
++	ret = vc4_hvs_hw_init(hvs);
++	if (ret)
++		return ret;
++
+ 	/* Upload filter kernels.  We only have the one for now, so we
+ 	 * keep it around for the lifetime of the driver.
+ 	 */
+@@ -1530,10 +1536,6 @@ static int vc4_hvs_bind(struct device *d
+ 	if (ret)
+ 		return ret;
+ 
+-	ret = vc4_hvs_hw_init(hvs);
+-	if (ret)
+-		return ret;
+-
+ 	ret = vc4_hvs_cob_init(hvs);
+ 	if (ret)
+ 		return ret;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0956-dt-bindings-display-Add-BCM2712-HDMI-bindings.patch b/target/linux/bcm27xx/patches-6.1/950-0956-dt-bindings-display-Add-BCM2712-HDMI-bindings.patch
new file mode 100644
index 0000000000..dab1fff2e3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0956-dt-bindings-display-Add-BCM2712-HDMI-bindings.patch
@@ -0,0 +1,26 @@
+From aed3dadaa6fb4c38275b264ecc0ff5ebe0408b82 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:36:02 +0100
+Subject: [PATCH] dt-bindings: display: Add BCM2712 HDMI bindings
+
+The BCM2712 HDMI controller uses a slightly different HDMI controller
+than the BCM2711, and a completely different PHY.
+
+Let's introduce a new compatible for it.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ .../devicetree/bindings/display/brcm,bcm2711-hdmi.yaml          | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/Documentation/devicetree/bindings/display/brcm,bcm2711-hdmi.yaml
++++ b/Documentation/devicetree/bindings/display/brcm,bcm2711-hdmi.yaml
+@@ -14,6 +14,8 @@ properties:
+     enum:
+       - brcm,bcm2711-hdmi0
+       - brcm,bcm2711-hdmi1
++      - brcm,bcm2712-hdmi0
++      - brcm,bcm2712-hdmi1
+ 
+   reg:
+     items:
diff --git a/target/linux/bcm27xx/patches-6.1/950-0957-dt-bindings-display-Add-BCM2712-HVS-bindings.patch b/target/linux/bcm27xx/patches-6.1/950-0957-dt-bindings-display-Add-BCM2712-HVS-bindings.patch
new file mode 100644
index 0000000000..e28100734f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0957-dt-bindings-display-Add-BCM2712-HVS-bindings.patch
@@ -0,0 +1,34 @@
+From 2f5a75f9687553d6e91fcc09b233f5f6176b3681 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:36:14 +0100
+Subject: [PATCH] dt-bindings: display: Add BCM2712 HVS bindings
+
+The BCM2712 has a completely different HVS than the previous
+generations, so let's add a new compatible for it.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ .../devicetree/bindings/display/brcm,bcm2835-hvs.yaml        | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/Documentation/devicetree/bindings/display/brcm,bcm2835-hvs.yaml
++++ b/Documentation/devicetree/bindings/display/brcm,bcm2835-hvs.yaml
+@@ -13,6 +13,7 @@ properties:
+   compatible:
+     enum:
+       - brcm,bcm2711-hvs
++      - brcm,bcm2712-hvs
+       - brcm,bcm2835-hvs
+ 
+   reg:
+@@ -36,7 +37,9 @@ if:
+   properties:
+     compatible:
+       contains:
+-        const: brcm,bcm2711-hvs
++        enum:
++          - brcm,bcm2711-hvs
++          - brcm,bcm2712-hvs
+ 
+ then:
+   required:
diff --git a/target/linux/bcm27xx/patches-6.1/950-0958-dt-bindings-display-Add-BCM2712-PixelValve-bindings.patch b/target/linux/bcm27xx/patches-6.1/950-0958-dt-bindings-display-Add-BCM2712-PixelValve-bindings.patch
new file mode 100644
index 0000000000..b37c1274ae
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0958-dt-bindings-display-Add-BCM2712-PixelValve-bindings.patch
@@ -0,0 +1,28 @@
+From 9f26d5827745df2c59e5559fd59a5045a4ad7ce0 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:36:27 +0100
+Subject: [PATCH] dt-bindings: display: Add BCM2712 PixelValve bindings
+
+The BCM2712 has 3 different pixelvalves that are similar to the ones
+found in the previous generations but with slightly different
+capabilities.
+
+Express that using a new set of compatibles.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ .../devicetree/bindings/display/brcm,bcm2835-pixelvalve0.yaml  | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/Documentation/devicetree/bindings/display/brcm,bcm2835-pixelvalve0.yaml
++++ b/Documentation/devicetree/bindings/display/brcm,bcm2835-pixelvalve0.yaml
+@@ -20,6 +20,9 @@ properties:
+       - brcm,bcm2711-pixelvalve2
+       - brcm,bcm2711-pixelvalve3
+       - brcm,bcm2711-pixelvalve4
++      - brcm,bcm2712-pixelvalve0
++      - brcm,bcm2712-pixelvalve1
++      - brcm,bcm2712-pixelvalve2
+ 
+   reg:
+     maxItems: 1
diff --git a/target/linux/bcm27xx/patches-6.1/950-0959-dt-bindings-display-Add-BCM2712-MOP-bindings.patch b/target/linux/bcm27xx/patches-6.1/950-0959-dt-bindings-display-Add-BCM2712-MOP-bindings.patch
new file mode 100644
index 0000000000..ea537522cc
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0959-dt-bindings-display-Add-BCM2712-MOP-bindings.patch
@@ -0,0 +1,28 @@
+From 07f90ad6a81d9ed923ee0da05541718baf49fb3c Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:36:36 +0100
+Subject: [PATCH] dt-bindings: display: Add BCM2712 MOP bindings
+
+The BCM2712 has a MOP controller which is basically a new revision of
+the TXP.
+
+Express that by adding a new compatible for it.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ .../devicetree/bindings/display/brcm,bcm2835-txp.yaml         | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/Documentation/devicetree/bindings/display/brcm,bcm2835-txp.yaml
++++ b/Documentation/devicetree/bindings/display/brcm,bcm2835-txp.yaml
+@@ -11,7 +11,9 @@ maintainers:
+ 
+ properties:
+   compatible:
+-    const: brcm,bcm2835-txp
++    enum:
++      - brcm,bcm2712-mop
++      - brcm,bcm2835-txp
+ 
+   reg:
+     maxItems: 1
diff --git a/target/linux/bcm27xx/patches-6.1/950-0960-dt-bindings-display-Add-BCM2712-MOPLET-bindings.patch b/target/linux/bcm27xx/patches-6.1/950-0960-dt-bindings-display-Add-BCM2712-MOPLET-bindings.patch
new file mode 100644
index 0000000000..97aaf5bb7a
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0960-dt-bindings-display-Add-BCM2712-MOPLET-bindings.patch
@@ -0,0 +1,25 @@
+From e4a3722d08c723f1212bfbdcb52710de8340720a Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:36:36 +0100
+Subject: [PATCH] dt-bindings: display: Add BCM2712 MOPLET bindings
+
+The BCM2712 has a MOPLET controller which is basically a TXP without the
+transpose feature.
+
+Express that by adding a new compatible for it.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ Documentation/devicetree/bindings/display/brcm,bcm2835-txp.yaml | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/Documentation/devicetree/bindings/display/brcm,bcm2835-txp.yaml
++++ b/Documentation/devicetree/bindings/display/brcm,bcm2835-txp.yaml
+@@ -13,6 +13,7 @@ properties:
+   compatible:
+     enum:
+       - brcm,bcm2712-mop
++      - brcm,bcm2712-moplet
+       - brcm,bcm2835-txp
+ 
+   reg:
diff --git a/target/linux/bcm27xx/patches-6.1/950-0961-dt-bindings-display-Add-BCM2712-KMS-driver-bindings.patch b/target/linux/bcm27xx/patches-6.1/950-0961-dt-bindings-display-Add-BCM2712-KMS-driver-bindings.patch
new file mode 100644
index 0000000000..420c66ce66
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0961-dt-bindings-display-Add-BCM2712-KMS-driver-bindings.patch
@@ -0,0 +1,23 @@
+From e66d4b49a027257c347fa57ce6972f08747c0917 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:36:51 +0100
+Subject: [PATCH] dt-bindings: display: Add BCM2712 KMS driver bindings
+
+The BCM2712 SoC comes with a new variation of the videocore display
+pipeline. Let's create a new compatible for it.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ Documentation/devicetree/bindings/display/brcm,bcm2835-vc4.yaml | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/Documentation/devicetree/bindings/display/brcm,bcm2835-vc4.yaml
++++ b/Documentation/devicetree/bindings/display/brcm,bcm2835-vc4.yaml
+@@ -18,6 +18,7 @@ properties:
+   compatible:
+     enum:
+       - brcm,bcm2711-vc5
++      - brcm,bcm2712-vc6
+       - brcm,bcm2835-vc4
+       - brcm,cygnus-vc4
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0962-drm-vc4-drv-Support-BCM2712.patch b/target/linux/bcm27xx/patches-6.1/950-0962-drm-vc4-drv-Support-BCM2712.patch
new file mode 100644
index 0000000000..57a797ce18
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0962-drm-vc4-drv-Support-BCM2712.patch
@@ -0,0 +1,47 @@
+From 847ec495822ad512dd9f1a58a85dabea01534855 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 15:29:52 +0100
+Subject: [PATCH] drm/vc4: drv: Support BCM2712
+
+The BCM2712 has an improved display pipeline, most notably with a
+different HVS and only HDMI and writeback outputs.
+
+Let's introduce it as a new VideoCore generation and compatible.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_drv.c | 5 ++++-
+ drivers/gpu/drm/vc4/vc4_drv.h | 1 +
+ 2 files changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.c
++++ b/drivers/gpu/drm/vc4/vc4_drv.c
+@@ -310,7 +310,9 @@ static int vc4_drm_bind(struct device *d
+ 
+ 	dev->coherent_dma_mask = DMA_BIT_MASK(32);
+ 
+-	if (of_device_is_compatible(dev->of_node, "brcm,bcm2711-vc5"))
++	if (of_device_is_compatible(dev->of_node, "brcm,bcm2712-vc6"))
++		gen = VC4_GEN_6;
++	else if (of_device_is_compatible(dev->of_node, "brcm,bcm2711-vc5"))
+ 		gen = VC4_GEN_5;
+ 	else
+ 		gen = VC4_GEN_4;
+@@ -475,6 +477,7 @@ static int vc4_platform_drm_remove(struc
+ 
+ static const struct of_device_id vc4_of_match[] = {
+ 	{ .compatible = "brcm,bcm2711-vc5", },
++	{ .compatible = "brcm,bcm2712-vc6", },
+ 	{ .compatible = "brcm,bcm2835-vc4", },
+ 	{ .compatible = "brcm,cygnus-vc4", },
+ 	{},
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -84,6 +84,7 @@ struct vc4_perfmon {
+ enum vc4_gen {
+ 	VC4_GEN_4,
+ 	VC4_GEN_5,
++	VC4_GEN_6,
+ };
+ 
+ struct vc4_dev {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0963-drm-vc4-hvs-Support-BCM2712-HVS.patch b/target/linux/bcm27xx/patches-6.1/950-0963-drm-vc4-hvs-Support-BCM2712-HVS.patch
new file mode 100644
index 0000000000..9659432294
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0963-drm-vc4-hvs-Support-BCM2712-HVS.patch
@@ -0,0 +1,2139 @@
+From e84da235223d0209165183c430692dde5c69854c Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 15:25:16 +0100
+Subject: [PATCH] drm/vc4: hvs: Support BCM2712 HVS
+
+The HVS found in the BCM2712, while having a similar role, is very
+different from the one found in the previous SoCs. Indeed, the register
+layout is fairly different, and the DLIST format is new as well.
+
+Let's introduce the needed functions to support the new HVS.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_crtc.c  |  47 ++-
+ drivers/gpu/drm/vc4/vc4_drv.c   |   8 +-
+ drivers/gpu/drm/vc4/vc4_drv.h   |  18 +
+ drivers/gpu/drm/vc4/vc4_hvs.c   | 626 ++++++++++++++++++++++++++++---
+ drivers/gpu/drm/vc4/vc4_kms.c   | 102 ++++-
+ drivers/gpu/drm/vc4/vc4_plane.c | 641 +++++++++++++++++++++++++++++++-
+ drivers/gpu/drm/vc4/vc4_regs.h  | 181 +++++++++
+ 7 files changed, 1540 insertions(+), 83 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_crtc.c
++++ b/drivers/gpu/drm/vc4/vc4_crtc.c
+@@ -82,13 +82,22 @@ static unsigned int
+ vc4_crtc_get_cob_allocation(struct vc4_dev *vc4, unsigned int channel)
+ {
+ 	struct vc4_hvs *hvs = vc4->hvs;
+-	u32 dispbase = HVS_READ(SCALER_DISPBASEX(channel));
++	u32 dispbase, top, base;
++
+ 	/* Top/base are supposed to be 4-pixel aligned, but the
+ 	 * Raspberry Pi firmware fills the low bits (which are
+ 	 * presumably ignored).
+ 	 */
+-	u32 top = VC4_GET_FIELD(dispbase, SCALER_DISPBASEX_TOP) & ~3;
+-	u32 base = VC4_GET_FIELD(dispbase, SCALER_DISPBASEX_BASE) & ~3;
++
++	if (vc4->gen >= VC4_GEN_6) {
++		dispbase = HVS_READ(SCALER6_DISPX_COB(channel));
++		top = VC4_GET_FIELD(dispbase, SCALER6_DISPX_COB_TOP) & ~3;
++		base = VC4_GET_FIELD(dispbase, SCALER6_DISPX_COB_BASE) & ~3;
++	} else {
++		dispbase = HVS_READ(SCALER_DISPBASEX(channel));
++		top = VC4_GET_FIELD(dispbase, SCALER_DISPBASEX_TOP) & ~3;
++		base = VC4_GET_FIELD(dispbase, SCALER_DISPBASEX_BASE) & ~3;
++	}
+ 
+ 	return top - base + 4;
+ }
+@@ -121,7 +130,10 @@ static bool vc4_crtc_get_scanout_positio
+ 	 * Read vertical scanline which is currently composed for our
+ 	 * pixelvalve by the HVS, and also the scaler status.
+ 	 */
+-	val = HVS_READ(SCALER_DISPSTATX(channel));
++	if (vc4->gen >= VC4_GEN_6)
++		val = HVS_READ(SCALER6_DISPX_STATUS(channel));
++	else
++		val = HVS_READ(SCALER_DISPSTATX(channel));
+ 
+ 	/* Get optional system timestamp after query. */
+ 	if (etime)
+@@ -130,7 +142,12 @@ static bool vc4_crtc_get_scanout_positio
+ 	/* preempt_enable_rt() should go right here in PREEMPT_RT patchset. */
+ 
+ 	/* Vertical position of hvs composed scanline. */
+-	*vpos = VC4_GET_FIELD(val, SCALER_DISPSTATX_LINE);
++
++	if (vc4->gen >= VC4_GEN_6)
++		*vpos = VC4_GET_FIELD(val, SCALER6_DISPX_STATUS_YLINE);
++	else
++		*vpos = VC4_GET_FIELD(val, SCALER_DISPSTATX_LINE);
++
+ 	*hpos = 0;
+ 
+ 	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+@@ -475,8 +492,10 @@ static void require_hvs_enabled(struct d
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_hvs *hvs = vc4->hvs;
+ 
+-	WARN_ON_ONCE((HVS_READ(SCALER_DISPCTRL) & SCALER_DISPCTRL_ENABLE) !=
+-		     SCALER_DISPCTRL_ENABLE);
++	if (vc4->gen >= VC4_GEN_6)
++		WARN_ON_ONCE(!(HVS_READ(SCALER6_CONTROL) & SCALER6_CONTROL_HVS_EN));
++	else
++		WARN_ON_ONCE(!(HVS_READ(SCALER_DISPCTRL) & SCALER_DISPCTRL_ENABLE));
+ }
+ 
+ static int vc4_crtc_disable(struct drm_crtc *crtc,
+@@ -804,14 +823,21 @@ static void vc4_crtc_handle_page_flip(st
+ 	struct drm_device *dev = crtc->dev;
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_hvs *hvs = vc4->hvs;
++	unsigned int current_dlist;
+ 	u32 chan = vc4_crtc->current_hvs_channel;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&dev->event_lock, flags);
+ 	spin_lock(&vc4_crtc->irq_lock);
++
++	if (vc4->gen >= VC4_GEN_6)
++		current_dlist = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_DL(chan)),
++					      SCALER6_DISPX_DL_LACT);
++	else
++		current_dlist = HVS_READ(SCALER_DISPLACTX(chan));
++
+ 	if (vc4_crtc->event &&
+-	    (vc4_crtc->current_dlist == HVS_READ(SCALER_DISPLACTX(chan)) ||
+-	     vc4_crtc->feeds_txp)) {
++	    (vc4_crtc->current_dlist == current_dlist || vc4_crtc->feeds_txp)) {
+ 		drm_crtc_send_vblank_event(crtc, vc4_crtc->event);
+ 		vc4_crtc->event = NULL;
+ 		drm_crtc_vblank_put(crtc);
+@@ -822,7 +848,8 @@ static void vc4_crtc_handle_page_flip(st
+ 		 * the CRTC and encoder already reconfigured, leading to
+ 		 * underruns. This can be seen when reconfiguring the CRTC.
+ 		 */
+-		vc4_hvs_unmask_underrun(hvs, chan);
++		if (vc4->gen < VC4_GEN_6)
++			vc4_hvs_unmask_underrun(hvs, chan);
+ 	}
+ 	spin_unlock(&vc4_crtc->irq_lock);
+ 	spin_unlock_irqrestore(&dev->event_lock, flags);
+--- a/drivers/gpu/drm/vc4/vc4_drv.c
++++ b/drivers/gpu/drm/vc4/vc4_drv.c
+@@ -277,6 +277,7 @@ static const struct of_device_id vc4_dma
+ 	{ .compatible = "brcm,bcm2711-hvs" },
+ 	{ .compatible = "brcm,bcm2835-hvs" },
+ 	{ .compatible = "brcm,bcm2711-hvs" },
++	{ .compatible = "brcm,bcm2712-hvs" },
+ 	{ .compatible = "raspberrypi,rpi-firmware-kms" },
+ 	{ .compatible = "brcm,bcm2835-v3d" },
+ 	{ .compatible = "brcm,cygnus-v3d" },
+@@ -308,8 +309,6 @@ static int vc4_drm_bind(struct device *d
+ 	enum vc4_gen gen;
+ 	int ret = 0;
+ 
+-	dev->coherent_dma_mask = DMA_BIT_MASK(32);
+-
+ 	if (of_device_is_compatible(dev->of_node, "brcm,bcm2712-vc6"))
+ 		gen = VC4_GEN_6;
+ 	else if (of_device_is_compatible(dev->of_node, "brcm,bcm2711-vc5"))
+@@ -322,6 +321,11 @@ static int vc4_drm_bind(struct device *d
+ 	else
+ 		driver = &vc4_drm_driver;
+ 
++	if (gen >= VC4_GEN_6)
++		dma_set_mask_and_coherent(dev, DMA_BIT_MASK(36));
++	else
++		dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));
++
+ 	node = of_find_matching_node_and_match(NULL, vc4_dma_range_matches,
+ 					       NULL);
+ 	if (node) {
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -345,8 +345,10 @@ struct vc4_hvs {
+ 	unsigned int dlist_mem_size;
+ 
+ 	struct clk *core_clk;
++	struct clk *disp_clk;
+ 
+ 	struct {
++		unsigned int desc;
+ 		unsigned int enabled: 1;
+ 	} eof_irq[HVS_NUM_CHANNELS];
+ 
+@@ -358,6 +360,11 @@ struct vc4_hvs {
+ 	struct drm_mm dlist_mm;
+ 	/* Memory manager for the LBM memory used by HVS scaling. */
+ 	struct drm_mm lbm_mm;
++
++	/* Memory manager for the UPM memory used for prefetching. */
++	struct drm_mm upm_mm;
++	struct ida upm_handles;
++
+ 	spinlock_t mm_lock;
+ 
+ 	struct list_head stale_dlist_entries;
+@@ -382,6 +389,8 @@ struct vc4_hvs {
+ 	bool vc5_hdmi_enable_4096by2160;
+ };
+ 
++#define HVS_UBM_WORD_SIZE 256
++
+ struct vc4_hvs_state {
+ 	struct drm_private_state base;
+ 	unsigned long core_clock_rate;
+@@ -456,6 +465,15 @@ struct vc4_plane_state {
+ 	/* Our allocation in LBM for temporary storage during scaling. */
+ 	struct drm_mm_node lbm;
+ 
++	/* Our allocation in UPM for prefetching. */
++	struct drm_mm_node upm[DRM_FORMAT_MAX_PLANES];
++
++	/* The Unified Pre-Fetcher Handle */
++	unsigned int upm_handle[DRM_FORMAT_MAX_PLANES];
++
++	/* Number of lines to pre-fetch */
++	unsigned int upm_buffer_lines;
++
+ 	/* Set when the plane has per-pixel alpha content or does not cover
+ 	 * the entire screen. This is a hint to the CRTC that it might need
+ 	 * to enable background color fill.
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -67,6 +67,80 @@ static const struct debugfs_reg32 vc4_hv
+ 	VC4_REG32(SCALER_OLEDCOEF2),
+ };
+ 
++static const struct debugfs_reg32 vc6_hvs_regs[] = {
++	VC4_REG32(SCALER6_VERSION),
++	VC4_REG32(SCALER6_CXM_SIZE),
++	VC4_REG32(SCALER6_LBM_SIZE),
++	VC4_REG32(SCALER6_UBM_SIZE),
++	VC4_REG32(SCALER6_COBA_SIZE),
++	VC4_REG32(SCALER6_COB_SIZE),
++	VC4_REG32(SCALER6_CONTROL),
++	VC4_REG32(SCALER6_FETCHER_STATUS),
++	VC4_REG32(SCALER6_FETCH_STATUS),
++	VC4_REG32(SCALER6_HANDLE_ERROR),
++	VC4_REG32(SCALER6_DISP0_CTRL0),
++	VC4_REG32(SCALER6_DISP0_CTRL1),
++	VC4_REG32(SCALER6_DISP0_BGND),
++	VC4_REG32(SCALER6_DISP0_LPTRS),
++	VC4_REG32(SCALER6_DISP0_COB),
++	VC4_REG32(SCALER6_DISP0_STATUS),
++	VC4_REG32(SCALER6_DISP0_DL),
++	VC4_REG32(SCALER6_DISP0_RUN),
++	VC4_REG32(SCALER6_DISP1_CTRL0),
++	VC4_REG32(SCALER6_DISP1_CTRL1),
++	VC4_REG32(SCALER6_DISP1_BGND),
++	VC4_REG32(SCALER6_DISP1_LPTRS),
++	VC4_REG32(SCALER6_DISP1_COB),
++	VC4_REG32(SCALER6_DISP1_STATUS),
++	VC4_REG32(SCALER6_DISP1_DL),
++	VC4_REG32(SCALER6_DISP1_RUN),
++	VC4_REG32(SCALER6_DISP2_CTRL0),
++	VC4_REG32(SCALER6_DISP2_CTRL1),
++	VC4_REG32(SCALER6_DISP2_BGND),
++	VC4_REG32(SCALER6_DISP2_LPTRS),
++	VC4_REG32(SCALER6_DISP2_COB),
++	VC4_REG32(SCALER6_DISP2_STATUS),
++	VC4_REG32(SCALER6_DISP2_DL),
++	VC4_REG32(SCALER6_DISP2_RUN),
++	VC4_REG32(SCALER6_EOLN),
++	VC4_REG32(SCALER6_DL_STATUS),
++	VC4_REG32(SCALER6_BFG_MISC),
++	VC4_REG32(SCALER6_QOS0),
++	VC4_REG32(SCALER6_PROF0),
++	VC4_REG32(SCALER6_QOS1),
++	VC4_REG32(SCALER6_PROF1),
++	VC4_REG32(SCALER6_QOS2),
++	VC4_REG32(SCALER6_PROF2),
++	VC4_REG32(SCALER6_PRI_MAP0),
++	VC4_REG32(SCALER6_PRI_MAP1),
++	VC4_REG32(SCALER6_HISTCTRL),
++	VC4_REG32(SCALER6_HISTBIN0),
++	VC4_REG32(SCALER6_HISTBIN1),
++	VC4_REG32(SCALER6_HISTBIN2),
++	VC4_REG32(SCALER6_HISTBIN3),
++	VC4_REG32(SCALER6_HISTBIN4),
++	VC4_REG32(SCALER6_HISTBIN5),
++	VC4_REG32(SCALER6_HISTBIN6),
++	VC4_REG32(SCALER6_HISTBIN7),
++	VC4_REG32(SCALER6_HDR_CFG_REMAP),
++	VC4_REG32(SCALER6_COL_SPACE),
++	VC4_REG32(SCALER6_HVS_ID),
++	VC4_REG32(SCALER6_CFC1),
++	VC4_REG32(SCALER6_DISP_UPM_ISO0),
++	VC4_REG32(SCALER6_DISP_UPM_ISO1),
++	VC4_REG32(SCALER6_DISP_UPM_ISO2),
++	VC4_REG32(SCALER6_DISP_LBM_ISO0),
++	VC4_REG32(SCALER6_DISP_LBM_ISO1),
++	VC4_REG32(SCALER6_DISP_LBM_ISO2),
++	VC4_REG32(SCALER6_DISP_COB_ISO0),
++	VC4_REG32(SCALER6_DISP_COB_ISO1),
++	VC4_REG32(SCALER6_DISP_COB_ISO2),
++	VC4_REG32(SCALER6_BAD_COB),
++	VC4_REG32(SCALER6_BAD_LBM),
++	VC4_REG32(SCALER6_BAD_UPM),
++	VC4_REG32(SCALER6_BAD_AXI),
++};
++
+ void vc4_hvs_dump_state(struct vc4_hvs *hvs)
+ {
+ 	struct drm_device *drm = &hvs->vc4->base;
+@@ -145,6 +219,55 @@ static int vc4_hvs_debugfs_dlist(struct
+ 	return 0;
+ }
+ 
++static int vc6_hvs_debugfs_dlist(struct seq_file *m, void *data)
++{
++	struct drm_info_node *node = m->private;
++	struct drm_device *dev = node->minor->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct vc4_hvs *hvs = vc4->hvs;
++	struct drm_printer p = drm_seq_file_printer(m);
++	unsigned int dlist_mem_size = hvs->dlist_mem_size;
++	unsigned int next_entry_start;
++	unsigned int i;
++
++	for (i = 0; i < SCALER_CHANNELS_COUNT; i++) {
++		unsigned int active_dlist, dispstat;
++		unsigned int j;
++
++		dispstat = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_STATUS(i)),
++					 SCALER6_DISPX_STATUS_MODE);
++		if (dispstat == SCALER6_DISPX_STATUS_MODE_DISABLED ||
++		    dispstat == SCALER6_DISPX_STATUS_MODE_EOF) {
++			drm_printf(&p, "HVS chan %u disabled\n", i);
++			continue;
++		}
++
++		drm_printf(&p, "HVS chan %u:\n", i);
++
++		active_dlist = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_DL(i)),
++					     SCALER6_DISPX_DL_LACT);
++		next_entry_start = 0;
++
++		for (j = active_dlist; j < dlist_mem_size; j++) {
++			u32 dlist_word;
++
++			dlist_word = readl((u32 __iomem *)vc4->hvs->dlist + j);
++			drm_printf(&p, "dlist: %02d: 0x%08x\n", j,
++				   dlist_word);
++			if (!next_entry_start ||
++			    next_entry_start == j) {
++				if (dlist_word & SCALER_CTL0_END)
++					break;
++				next_entry_start = j +
++					VC4_GET_FIELD(dlist_word,
++						      SCALER_CTL0_SIZE);
++			}
++		}
++	}
++
++	return 0;
++}
++
+ static int vc5_hvs_debugfs_gamma(struct seq_file *m, void *data)
+ {
+ 	struct drm_info_node *node = m->private;
+@@ -435,6 +558,10 @@ static void vc4_hvs_irq_enable_eof(struc
+ 			  SCALER5_DISPCTRL_DSPEIEOF(channel));
+ 		break;
+ 
++	case VC4_GEN_6:
++		enable_irq(hvs->eof_irq[channel].desc);
++		break;
++
+ 	default:
+ 		break;
+ 	}
+@@ -463,6 +590,10 @@ static void vc4_hvs_irq_clear_eof(struct
+ 			  ~SCALER5_DISPCTRL_DSPEIEOF(channel));
+ 		break;
+ 
++	case VC4_GEN_6:
++		disable_irq_nosync(hvs->eof_irq[channel].desc);
++		break;
++
+ 	default:
+ 		break;
+ 	}
+@@ -622,26 +753,32 @@ static void vc4_hvs_dlist_free_work(stru
+ 
+ u8 vc4_hvs_get_fifo_frame_count(struct vc4_hvs *hvs, unsigned int fifo)
+ {
+-	struct drm_device *drm = &hvs->vc4->base;
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *drm = &vc4->base;
+ 	u8 field = 0;
+ 	int idx;
+ 
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return 0;
+ 
+-	switch (fifo) {
+-	case 0:
+-		field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),
+-				      SCALER_DISPSTAT1_FRCNT0);
+-		break;
+-	case 1:
+-		field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),
+-				      SCALER_DISPSTAT1_FRCNT1);
+-		break;
+-	case 2:
+-		field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT2),
+-				      SCALER_DISPSTAT2_FRCNT2);
+-		break;
++	if (vc4->gen >= VC4_GEN_6) {
++		field = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_STATUS(fifo)),
++				      SCALER6_DISPX_STATUS_FRCNT);
++	} else {
++		switch (fifo) {
++		case 0:
++			field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),
++					      SCALER_DISPSTAT1_FRCNT0);
++			break;
++		case 1:
++			field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),
++					      SCALER_DISPSTAT1_FRCNT1);
++			break;
++		case 2:
++			field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT2),
++					      SCALER_DISPSTAT2_FRCNT2);
++			break;
++		}
+ 	}
+ 
+ 	drm_dev_exit(idx);
+@@ -708,6 +845,23 @@ int vc4_hvs_get_fifo_from_output(struct
+ 		default:
+ 			return -EPIPE;
+ 		}
++
++	case VC4_GEN_6:
++		switch (output) {
++		case 0:
++			return 0;
++
++		case 2:
++			return 2;
++
++		case 1:
++		case 3:
++		case 4:
++			return 1;
++
++		default:
++			return -EPIPE;
++		}
+ 	}
+ 
+ 	return -EPIPE;
+@@ -782,7 +936,41 @@ static int vc4_hvs_init_channel(struct v
+ 	return 0;
+ }
+ 
+-void vc4_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int chan)
++static int vc6_hvs_init_channel(struct vc4_hvs *hvs, struct drm_crtc *crtc,
++				struct drm_display_mode *mode, bool oneshot)
++{
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *drm = &vc4->base;
++	struct vc4_crtc_state *vc4_crtc_state = to_vc4_crtc_state(crtc->state);
++	unsigned int chan = vc4_crtc_state->assigned_channel;
++	bool interlace = mode->flags & DRM_MODE_FLAG_INTERLACE;
++	u32 disp_ctrl1;
++	int idx;
++
++	if (!drm_dev_enter(drm, &idx))
++		return -ENODEV;
++
++	HVS_WRITE(SCALER6_DISPX_CTRL0(chan), SCALER6_DISPX_CTRL0_RESET);
++
++	disp_ctrl1 = HVS_READ(SCALER6_DISPX_CTRL1(chan));
++	disp_ctrl1 &= ~SCALER6_DISPX_CTRL1_INTLACE;
++	HVS_WRITE(SCALER6_DISPX_CTRL1(chan),
++		  disp_ctrl1 | (interlace ? SCALER6_DISPX_CTRL1_INTLACE : 0));
++
++	HVS_WRITE(SCALER6_DISPX_CTRL0(chan),
++		  SCALER6_DISPX_CTRL0_ENB |
++		  VC4_SET_FIELD(mode->hdisplay - 1,
++				SCALER6_DISPX_CTRL0_FWIDTH) |
++		  (oneshot ? SCALER6_DISPX_CTRL0_ONESHOT : 0) |
++		  VC4_SET_FIELD(mode->vdisplay - 1,
++				SCALER6_DISPX_CTRL0_LINES));
++
++	drm_dev_exit(idx);
++
++	return 0;
++}
++
++static void __vc4_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int chan)
+ {
+ 	struct drm_device *drm = &hvs->vc4->base;
+ 	int idx;
+@@ -813,6 +1001,42 @@ out:
+ 	drm_dev_exit(idx);
+ }
+ 
++static void __vc6_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int chan)
++{
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *drm = &vc4->base;
++	int idx;
++
++	if (!drm_dev_enter(drm, &idx))
++		return;
++
++	if (HVS_READ(SCALER6_DISPX_CTRL0(chan)) & SCALER6_DISPX_CTRL0_ENB)
++		goto out;
++
++	HVS_WRITE(SCALER6_DISPX_CTRL0(chan),
++		  HVS_READ(SCALER6_DISPX_CTRL0(chan)) | SCALER6_DISPX_CTRL0_RESET);
++
++	HVS_WRITE(SCALER6_DISPX_CTRL0(chan),
++		  HVS_READ(SCALER6_DISPX_CTRL0(chan)) & ~SCALER6_DISPX_CTRL0_ENB);
++
++	WARN_ON_ONCE(VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_STATUS(chan)),
++				   SCALER6_DISPX_STATUS_MODE) !=
++		     SCALER6_DISPX_STATUS_MODE_DISABLED);
++
++out:
++	drm_dev_exit(idx);
++}
++
++void vc4_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int chan)
++{
++	struct vc4_dev *vc4 = hvs->vc4;
++
++	if (vc4->gen >= VC4_GEN_6)
++		__vc6_hvs_stop_channel(hvs, chan);
++	else
++		__vc4_hvs_stop_channel(hvs, chan);
++}
++
+ static int vc4_hvs_gamma_check(struct drm_crtc *crtc,
+ 			       struct drm_atomic_state *state)
+ {
+@@ -907,8 +1131,14 @@ static void vc4_hvs_install_dlist(struct
+ 		return;
+ 
+ 	WARN_ON(!vc4_state->mm);
+-	HVS_WRITE(SCALER_DISPLISTX(vc4_state->assigned_channel),
+-		  vc4_state->mm->mm_node.start);
++
++	if (vc4->gen >= VC4_GEN_6)
++		HVS_WRITE(SCALER6_DISPX_LPTRS(vc4_state->assigned_channel),
++			  VC4_SET_FIELD(vc4_state->mm->mm_node.start,
++					SCALER6_DISPX_LPTRS_HEADE));
++	else
++		HVS_WRITE(SCALER_DISPLISTX(vc4_state->assigned_channel),
++			  vc4_state->mm->mm_node.start);
+ 
+ 	drm_dev_exit(idx);
+ }
+@@ -965,7 +1195,11 @@ void vc4_hvs_atomic_enable(struct drm_cr
+ 
+ 	vc4_hvs_install_dlist(crtc);
+ 	vc4_hvs_update_dlist(crtc);
+-	vc4_hvs_init_channel(vc4->hvs, crtc, mode, oneshot);
++
++	if (vc4->gen >= VC4_GEN_6)
++		vc6_hvs_init_channel(vc4->hvs, crtc, mode, oneshot);
++	else
++		vc4_hvs_init_channel(vc4->hvs, crtc, mode, oneshot);
+ }
+ 
+ void vc4_hvs_atomic_disable(struct drm_crtc *crtc,
+@@ -1052,13 +1286,28 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 	WARN_ON(!vc4_state->mm);
+ 	WARN_ON_ONCE(dlist_next - dlist_start != vc4_state->mm->mm_node.size);
+ 
+-	if (enable_bg_fill)
++	if (enable_bg_fill) {
+ 		/* This sets a black background color fill, as is the case
+ 		 * with other DRM drivers.
+ 		 */
+-		HVS_WRITE(SCALER_DISPBKGNDX(channel),
+-			  HVS_READ(SCALER_DISPBKGNDX(channel)) |
+-			  SCALER_DISPBKGND_FILL);
++		if (vc4->gen >= VC4_GEN_6)
++			HVS_WRITE(SCALER6_DISPX_CTRL1(channel),
++				  HVS_READ(SCALER6_DISPX_CTRL1(channel)) |
++				  SCALER6_DISPX_CTRL1_BGENB);
++		else
++			HVS_WRITE(SCALER_DISPBKGNDX(channel),
++				  HVS_READ(SCALER_DISPBKGNDX(channel)) |
++				  SCALER_DISPBKGND_FILL);
++	} else {
++		if (vc4->gen >= VC4_GEN_6)
++			HVS_WRITE(SCALER6_DISPX_CTRL1(channel),
++				  HVS_READ(SCALER6_DISPX_CTRL1(channel)) &
++				  ~SCALER6_DISPX_CTRL1_BGENB);
++		else
++			HVS_WRITE(SCALER_DISPBKGNDX(channel),
++				  HVS_READ(SCALER_DISPBKGNDX(channel)) &
++				  ~SCALER_DISPBKGND_FILL);
++	}
+ 
+ 	/* Only update DISPLIST if the CRTC was already running and is not
+ 	 * being disabled.
+@@ -1210,6 +1459,27 @@ static irqreturn_t vc4_hvs_irq_handler(i
+ 	return irqret;
+ }
+ 
++static irqreturn_t vc6_hvs_eof_irq_handler(int irq, void *data)
++{
++	struct drm_device *dev = data;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct vc4_hvs *hvs = vc4->hvs;
++	unsigned int i;
++
++	for (i = 0; i < HVS_NUM_CHANNELS; i++) {
++		if (!hvs->eof_irq[i].enabled)
++			continue;
++
++		if (hvs->eof_irq[i].desc != irq)
++			continue;
++
++		vc4_hvs_schedule_dlist_sweep(hvs, i);
++		return IRQ_HANDLED;
++	}
++
++	return IRQ_NONE;
++}
++
+ int vc4_hvs_debugfs_init(struct drm_minor *minor)
+ {
+ 	struct drm_device *drm = minor->dev;
+@@ -1232,8 +1502,10 @@ int vc4_hvs_debugfs_init(struct drm_mino
+ 				     NULL);
+ 	}
+ 
+-	ret = vc4_debugfs_add_file(minor, "hvs_dlists",
+-				   vc4_hvs_debugfs_dlist, NULL);
++	if (vc4->gen >= VC4_GEN_6)
++		ret = vc4_debugfs_add_file(minor, "hvs_dlists", vc6_hvs_debugfs_dlist, NULL);
++	else
++		ret = vc4_debugfs_add_file(minor, "hvs_dlists", vc4_hvs_debugfs_dlist, NULL);
+ 	if (ret)
+ 		return ret;
+ 
+@@ -1256,6 +1528,9 @@ struct vc4_hvs *__vc4_hvs_alloc(struct v
+ {
+ 	struct drm_device *drm = &vc4->base;
+ 	struct vc4_hvs *hvs;
++	unsigned int dlist_start;
++	size_t dlist_size;
++	size_t lbm_size;
+ 
+ 	hvs = drmm_kzalloc(drm, sizeof(*hvs), GFP_KERNEL);
+ 	if (!hvs)
+@@ -1270,14 +1545,39 @@ struct vc4_hvs *__vc4_hvs_alloc(struct v
+ 	INIT_LIST_HEAD(&hvs->stale_dlist_entries);
+ 	INIT_WORK(&hvs->free_dlist_work, vc4_hvs_dlist_free_work);
+ 
+-	/* Set up the HVS display list memory manager.  We never
+-	 * overwrite the setup from the bootloader (just 128b out of
+-	 * our 16K), since we don't want to scramble the screen when
+-	 * transitioning from the firmware's boot setup to runtime.
+-	 */
+-	drm_mm_init(&hvs->dlist_mm,
+-		    HVS_BOOTLOADER_DLIST_END,
+-		    (SCALER_DLIST_SIZE >> 2) - HVS_BOOTLOADER_DLIST_END);
++	switch (vc4->gen) {
++	case VC4_GEN_4:
++	case VC4_GEN_5:
++		/* Set up the HVS display list memory manager. We never
++		 * overwrite the setup from the bootloader (just 128b
++		 * out of our 16K), since we don't want to scramble the
++		 * screen when transitioning from the firmware's boot
++		 * setup to runtime.
++		 */
++		dlist_start = HVS_BOOTLOADER_DLIST_END;
++		dlist_size = (SCALER_DLIST_SIZE >> 2) - HVS_BOOTLOADER_DLIST_END;
++		break;
++
++	case VC4_GEN_6:
++		dlist_start = HVS_BOOTLOADER_DLIST_END;
++
++		/*
++		 * If we are running a test, it means that we can't
++		 * access a register. Use a plausible size then.
++		 */
++		if (!kunit_get_current_test())
++			dlist_size = HVS_READ(SCALER6_CXM_SIZE);
++		else
++			dlist_size = 4096;
++
++		break;
++
++	default:
++		drm_err(drm, "Unknown VC4 generation: %d", vc4->gen);
++		return ERR_PTR(-ENODEV);
++	}
++
++	drm_mm_init(&hvs->dlist_mm, dlist_start, dlist_size);
+ 
+ 	hvs->dlist_mem_size = dlist_size;
+ 
+@@ -1286,12 +1586,46 @@ struct vc4_hvs *__vc4_hvs_alloc(struct v
+ 	 * between planes when they don't overlap on the screen, but
+ 	 * for now we just allocate globally.
+ 	 */
+-	if (vc4->gen == VC4_GEN_4)
++
++	switch (vc4->gen) {
++	case VC4_GEN_4:
+ 		/* 48k words of 2x12-bit pixels */
+-		drm_mm_init(&hvs->lbm_mm, 0, 48 * 1024);
+-	else
++		lbm_size = 48 * SZ_1K;
++		break;
++
++	case VC4_GEN_5:
+ 		/* 60k words of 4x12-bit pixels */
+-		drm_mm_init(&hvs->lbm_mm, 0, 60 * 1024);
++		lbm_size = 60 * SZ_1K;
++		break;
++
++	case VC4_GEN_6:
++		/*
++		 * If we are running a test, it means that we can't
++		 * access a register. Use a plausible size then.
++		 */
++		lbm_size = 1024;
++		break;
++
++	default:
++		drm_err(drm, "Unknown VC4 generation: %d", vc4->gen);
++		return ERR_PTR(-ENODEV);
++	}
++
++	drm_mm_init(&hvs->lbm_mm, 0, lbm_size);
++
++	if (vc4->gen >= VC4_GEN_6) {
++		ida_init(&hvs->upm_handles);
++
++		/*
++		 * NOTE: On BCM2712, the size can also be read through
++		 * the SCALER_UBM_SIZE register. We would need to do a
++		 * register access though, which we can't do with kunit
++		 * that also uses this function to create its mock
++		 * device.
++		 */
++		drm_mm_init(&hvs->upm_mm, 0, 1024 * HVS_UBM_WORD_SIZE);
++	}
++
+ 
+ 	vc4->hvs = hvs;
+ 
+@@ -1388,10 +1722,124 @@ static int vc4_hvs_hw_init(struct vc4_hv
+ 	return 0;
+ }
+ 
++#define CFC1_N_NL_CSC_CTRL(x)		(0xa000 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C00(x)	(0xa008 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C01(x)	(0xa00c + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C02(x)	(0xa010 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C03(x)	(0xa014 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C04(x)	(0xa018 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C10(x)	(0xa01c + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C11(x)	(0xa020 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C12(x)	(0xa024 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C13(x)	(0xa028 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C14(x)	(0xa02c + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C20(x)	(0xa030 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C21(x)	(0xa034 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C22(x)	(0xa038 + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C23(x)	(0xa03c + ((x) * 0x3000))
++#define CFC1_N_MA_CSC_COEFF_C24(x)	(0xa040 + ((x) * 0x3000))
++
++/* 4 S2.22 multiplication factors, and 1 S9.15 addititive element for each of 3
++ * output components
++ */
++struct vc6_csc_coeff_entry {
++	u32 csc[3][5];
++};
++
++static const struct vc6_csc_coeff_entry csc_coeffs[2][3] = {
++	[DRM_COLOR_YCBCR_LIMITED_RANGE] = {
++		[DRM_COLOR_YCBCR_BT601] = {
++			.csc = {
++				{ 0x004A8542, 0x0, 0x0066254A, 0x0, 0xFF908A0D },
++				{ 0x004A8542, 0xFFE6ED5D, 0xFFCBF856, 0x0, 0x0043C9A3 },
++				{ 0x004A8542, 0x00811A54, 0x0, 0x0, 0xFF759502 }
++			}
++		},
++		[DRM_COLOR_YCBCR_BT709] = {
++			.csc = {
++				{ 0x004A8542, 0x0, 0x0072BC44, 0x0, 0xFF83F312 },
++				{ 0x004A8542, 0xFFF25A22, 0xFFDDE4D0, 0x0, 0x00267064 },
++				{ 0x004A8542, 0x00873197, 0x0, 0x0, 0xFF6F7DC0 }
++			}
++		},
++		[DRM_COLOR_YCBCR_BT2020] = {
++			.csc = {
++				{ 0x004A8542, 0x0, 0x006B4A17, 0x0, 0xFF8B653F },
++				{ 0x004A8542, 0xFFF402D9, 0xFFDDE4D0, 0x0, 0x0024C7AE },
++				{ 0x004A8542, 0x008912CC, 0x0, 0x0, 0xFF6D9C8B }
++			}
++		}
++	},
++	[DRM_COLOR_YCBCR_FULL_RANGE] = {
++		[DRM_COLOR_YCBCR_BT601] = {
++			.csc = {
++				{ 0x00400000, 0x0, 0x0059BA5E, 0x0, 0xFFA645A1 },
++				{ 0x00400000, 0xFFE9F9AC, 0xFFD24B97, 0x0, 0x0043BABB },
++				{ 0x00400000, 0x00716872, 0x0, 0x0, 0xFF8E978D }
++			}
++		},
++		[DRM_COLOR_YCBCR_BT709] = {
++			.csc = {
++				{ 0x00400000, 0x0, 0x0064C985, 0x0, 0xFF9B367A },
++				{ 0x00400000, 0xFFF402E1, 0xFFE20A40, 0x0, 0x0029F2DE },
++				{ 0x00400000, 0x0076C226, 0x0, 0x0, 0xFF893DD9 }
++			}
++		},
++		[DRM_COLOR_YCBCR_BT2020] = {
++			.csc = {
++				{ 0x00400000, 0x0, 0x005E3F14, 0x0, 0xFFA1C0EB },
++				{ 0x00400000, 0xFFF577F6, 0xFFDB580F, 0x0, 0x002F2FFA },
++				{ 0x00400000, 0x007868DB, 0x0, 0x0, 0xFF879724 }
++			}
++		}
++	}
++};
++
++static int vc6_hvs_hw_init(struct vc4_hvs *hvs)
++{
++	const struct vc6_csc_coeff_entry *coeffs;
++	unsigned int i;
++
++	HVS_WRITE(SCALER6_CONTROL,
++		  SCALER6_CONTROL_HVS_EN |
++		  VC4_SET_FIELD(8, SCALER6_CONTROL_PF_LINES) |
++		  VC4_SET_FIELD(15, SCALER6_CONTROL_MAX_REQS));
++
++	/* Set HVS arbiter priority to max */
++	HVS_WRITE(SCALER6_PRI_MAP0, 0xffffffff);
++	HVS_WRITE(SCALER6_PRI_MAP1, 0xffffffff);
++
++	for (i = 0; i < 6; i++) {
++		coeffs = &csc_coeffs[i / 3][i % 3];
++
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C00(i), coeffs->csc[0][0]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C01(i), coeffs->csc[0][1]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C02(i), coeffs->csc[0][2]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C03(i), coeffs->csc[0][3]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C04(i), coeffs->csc[0][4]);
++
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C10(i), coeffs->csc[1][0]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C11(i), coeffs->csc[1][1]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C12(i), coeffs->csc[1][2]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C13(i), coeffs->csc[1][3]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C14(i), coeffs->csc[1][4]);
++
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C20(i), coeffs->csc[2][0]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C21(i), coeffs->csc[2][1]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C22(i), coeffs->csc[2][2]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C23(i), coeffs->csc[2][3]);
++		HVS_WRITE(CFC1_N_MA_CSC_COEFF_C24(i), coeffs->csc[2][4]);
++
++		HVS_WRITE(CFC1_N_NL_CSC_CTRL(i), BIT(15));
++	}
++
++	return 0;
++}
++
+ static int vc4_hvs_cob_init(struct vc4_hvs *hvs)
+ {
+ 	struct vc4_dev *vc4 = hvs->vc4;
+-	u32 reg, top;
++	u32 reg, top, base;
+ 
+ 	/*
+ 	 * Recompute Composite Output Buffer (COB) allocations for the
+@@ -1452,6 +1900,31 @@ static int vc4_hvs_cob_init(struct vc4_h
+ 		HVS_WRITE(SCALER_DISPBASE0, reg);
+ 		break;
+ 
++	case VC4_GEN_6:
++		#define VC6_COB_LINE_WIDTH	3840
++		#define VC6_COB_NUM_LINES	4
++		reg = 0;
++		top = 3840;
++
++		HVS_WRITE(SCALER6_DISP2_COB,
++			  VC4_SET_FIELD(top, SCALER6_DISPX_COB_TOP) |
++			  VC4_SET_FIELD(base, SCALER6_DISPX_COB_BASE));
++
++		base = top + 16;
++		top += VC6_COB_LINE_WIDTH * VC6_COB_NUM_LINES;
++
++		HVS_WRITE(SCALER6_DISP1_COB,
++			  VC4_SET_FIELD(top, SCALER6_DISPX_COB_TOP) |
++			  VC4_SET_FIELD(base, SCALER6_DISPX_COB_BASE));
++
++		base = top + 16;
++		top += VC6_COB_LINE_WIDTH * VC6_COB_NUM_LINES;
++
++		HVS_WRITE(SCALER6_DISP0_COB,
++			  VC4_SET_FIELD(top, SCALER6_DISPX_COB_TOP) |
++			  VC4_SET_FIELD(base, SCALER6_DISPX_COB_BASE));
++		break;
++
+ 	default:
+ 		return -EINVAL;
+ 	}
+@@ -1477,10 +1950,16 @@ static int vc4_hvs_bind(struct device *d
+ 		return PTR_ERR(hvs);
+ 
+ 	hvs->regset.base = hvs->regs;
+-	hvs->regset.regs = vc4_hvs_regs;
+-	hvs->regset.nregs = ARRAY_SIZE(vc4_hvs_regs);
+ 
+-	if (vc4->gen == VC4_GEN_5) {
++	if (vc4->gen >= VC4_GEN_6) {
++		hvs->regset.regs = vc6_hvs_regs;
++		hvs->regset.nregs = ARRAY_SIZE(vc6_hvs_regs);
++	} else {
++		hvs->regset.regs = vc4_hvs_regs;
++		hvs->regset.nregs = ARRAY_SIZE(vc4_hvs_regs);
++	}
++
++	if (vc4->gen >= VC4_GEN_5) {
+ 		struct rpi_firmware *firmware;
+ 		struct device_node *node;
+ 		unsigned int max_rate;
+@@ -1494,12 +1973,20 @@ static int vc4_hvs_bind(struct device *d
+ 		if (!firmware)
+ 			return -EPROBE_DEFER;
+ 
+-		hvs->core_clk = devm_clk_get(&pdev->dev, NULL);
++		hvs->core_clk = devm_clk_get(&pdev->dev,
++					     (vc4->gen >= VC4_GEN_6) ? "core" : NULL);
+ 		if (IS_ERR(hvs->core_clk)) {
+ 			dev_err(&pdev->dev, "Couldn't get core clock\n");
+ 			return PTR_ERR(hvs->core_clk);
+ 		}
+ 
++		hvs->disp_clk = devm_clk_get(&pdev->dev,
++					     (vc4->gen >= VC4_GEN_6) ? "disp" : NULL);
++		if (IS_ERR(hvs->disp_clk)) {
++			dev_err(&pdev->dev, "Couldn't get disp clock\n");
++			return PTR_ERR(hvs->disp_clk);
++		}
++
+ 		max_rate = rpi_firmware_clk_get_max_rate(firmware,
+ 							 RPI_FIRMWARE_CORE_CLK_ID);
+ 		rpi_firmware_put(firmware);
+@@ -1516,14 +2003,51 @@ static int vc4_hvs_bind(struct device *d
+ 			dev_err(&pdev->dev, "Couldn't enable the core clock\n");
+ 			return ret;
+ 		}
++
++		ret = clk_prepare_enable(hvs->disp_clk);
++		if (ret) {
++			dev_err(&pdev->dev, "Couldn't enable the disp clock\n");
++			return ret;
++		}
+ 	}
+ 
+-	if (vc4->gen == VC4_GEN_4)
+-		hvs->dlist = hvs->regs + SCALER_DLIST_START;
+-	else
++	if (vc4->gen >= VC4_GEN_6) {
++		unsigned int i;
++
++		for (i = 0; i < HVS_NUM_CHANNELS; i++) {
++			char irq_name[16];
++			int irq;
++
++			snprintf(irq_name, sizeof(irq_name), "ch%u-eof", i);
++
++			irq = platform_get_irq_byname(pdev, irq_name);
++			if (irq < 0) {
++				dev_err(&pdev->dev,
++					"Couldn't get %s interrupt: %d\n",
++					irq_name, irq);
++				return irq;
++			}
++
++			ret = devm_request_irq(&pdev->dev,
++					       irq,
++					       vc6_hvs_eof_irq_handler,
++					       IRQF_NO_AUTOEN,
++					       dev_name(&pdev->dev),
++					       drm);
++
++			hvs->eof_irq[i].desc = irq;
++		}
++	}
++
++	if (vc4->gen >= VC4_GEN_5)
+ 		hvs->dlist = hvs->regs + SCALER5_DLIST_START;
++	else
++		hvs->dlist = hvs->regs + SCALER_DLIST_START;
+ 
+-	ret = vc4_hvs_hw_init(hvs);
++	if (vc4->gen >= VC4_GEN_6)
++		ret = vc6_hvs_hw_init(hvs);
++	else
++		ret = vc4_hvs_hw_init(hvs);
+ 	if (ret)
+ 		return ret;
+ 
+@@ -1540,10 +2064,12 @@ static int vc4_hvs_bind(struct device *d
+ 	if (ret)
+ 		return ret;
+ 
+-	ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
+-			       vc4_hvs_irq_handler, 0, "vc4 hvs", drm);
+-	if (ret)
+-		return ret;
++	if (vc4->gen < VC4_GEN_6) {
++		ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
++				       vc4_hvs_irq_handler, 0, "vc4 hvs", drm);
++		if (ret)
++			return ret;
++	}
+ 
+ 	return 0;
+ }
+@@ -1568,6 +2094,7 @@ static void vc4_hvs_unbind(struct device
+ 		drm_mm_remove_node(node);
+ 	drm_mm_takedown(&vc4->hvs->lbm_mm);
+ 
++	clk_disable_unprepare(hvs->disp_clk);
+ 	clk_disable_unprepare(hvs->core_clk);
+ 
+ 	vc4->hvs = NULL;
+@@ -1591,6 +2118,7 @@ static int vc4_hvs_dev_remove(struct pla
+ 
+ static const struct of_device_id vc4_hvs_dt_match[] = {
+ 	{ .compatible = "brcm,bcm2711-hvs" },
++	{ .compatible = "brcm,bcm2712-hvs" },
+ 	{ .compatible = "brcm,bcm2835-hvs" },
+ 	{}
+ };
+--- a/drivers/gpu/drm/vc4/vc4_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_kms.c
+@@ -329,17 +329,59 @@ static void vc5_hvs_pv_muxing_commit(str
+ 	}
+ }
+ 
++static void vc6_hvs_pv_muxing_commit(struct vc4_dev *vc4,
++				     struct drm_atomic_state *state)
++{
++	struct vc4_hvs *hvs = vc4->hvs;
++	struct drm_crtc_state *crtc_state;
++	struct drm_crtc *crtc;
++	unsigned int i;
++
++	WARN_ON_ONCE(vc4->gen != VC4_GEN_6);
++
++	for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
++		struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);
++		struct vc4_encoder *vc4_encoder;
++		struct drm_encoder *encoder;
++		unsigned char mux;
++		u32 reg;
++
++		if (!vc4_state->update_muxing)
++			continue;
++
++		if (vc4_state->assigned_channel != 1)
++			continue;
++
++		encoder = vc4_get_crtc_encoder(crtc, crtc_state);
++		vc4_encoder = to_vc4_encoder(encoder);
++		switch (vc4_encoder->type) {
++		case VC4_ENCODER_TYPE_HDMI1:
++			mux = 0;
++			break;
++
++		case VC4_ENCODER_TYPE_TXP:
++			mux = 2;
++			break;
++
++		default:
++			break;
++		}
++
++		reg = HVS_READ(SCALER6_CONTROL);
++		HVS_WRITE(SCALER6_CONTROL,
++			  (reg & ~SCALER6_CONTROL_DSP1_TARGET_MASK) |
++			  VC4_SET_FIELD(mux, SCALER6_CONTROL_DSP1_TARGET));
++	}
++}
++
+ static void vc4_atomic_commit_tail(struct drm_atomic_state *state)
+ {
+ 	struct drm_device *dev = state->dev;
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_hvs *hvs = vc4->hvs;
+-	struct drm_crtc_state *new_crtc_state;
+ 	struct vc4_hvs_state *new_hvs_state;
+-	struct drm_crtc *crtc;
+ 	struct vc4_hvs_state *old_hvs_state;
+ 	unsigned int channel;
+-	int i;
+ 
+ 	old_hvs_state = vc4_hvs_get_old_global_state(state);
+ 	if (WARN_ON(IS_ERR(old_hvs_state)))
+@@ -349,14 +391,23 @@ static void vc4_atomic_commit_tail(struc
+ 	if (WARN_ON(IS_ERR(new_hvs_state)))
+ 		return;
+ 
+-	for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
+-		struct vc4_crtc_state *vc4_crtc_state;
++	if (vc4->gen < VC4_GEN_6) {
++		struct drm_crtc_state *new_crtc_state;
++		struct drm_crtc *crtc;
++		int i;
++
++		for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
++			struct vc4_crtc_state *vc4_crtc_state;
+ 
+-		if (!new_crtc_state->commit || vc4->firmware_kms)
+-			continue;
++			if (vc4->firmware_kms)
++				continue;
+ 
+-		vc4_crtc_state = to_vc4_crtc_state(new_crtc_state);
+-		vc4_hvs_mask_underrun(hvs, vc4_crtc_state->assigned_channel);
++			if (!new_crtc_state->commit)
++				continue;
++
++			vc4_crtc_state = to_vc4_crtc_state(new_crtc_state);
++			vc4_hvs_mask_underrun(hvs, vc4_crtc_state->assigned_channel);
++		}
+ 	}
+ 
+ 	for (channel = 0; channel < HVS_NUM_CHANNELS; channel++) {
+@@ -378,7 +429,7 @@ static void vc4_atomic_commit_tail(struc
+ 		old_hvs_state->fifo_state[channel].pending_commit = NULL;
+ 	}
+ 
+-	if (vc4->gen == VC4_GEN_5 && !vc4->firmware_kms) {
++	if (vc4->gen >= VC4_GEN_5 && !vc4->firmware_kms) {
+ 		unsigned long state_rate = max(old_hvs_state->core_clock_rate,
+ 					       new_hvs_state->core_clock_rate);
+ 		unsigned long core_rate = clamp_t(unsigned long, state_rate,
+@@ -391,17 +442,32 @@ static void vc4_atomic_commit_tail(struc
+ 		 * modeset.
+ 		 */
+ 		WARN_ON(clk_set_min_rate(hvs->core_clk, core_rate));
++		WARN_ON(clk_set_min_rate(hvs->disp_clk, core_rate));
+ 	}
+ 
+ 	drm_atomic_helper_commit_modeset_disables(dev, state);
+ 
+-	vc4_ctm_commit(vc4, state);
++	if (vc4->gen <= VC4_GEN_5)
++		vc4_ctm_commit(vc4, state);
+ 
+ 	if (!vc4->firmware_kms) {
+-		if (vc4->gen == VC4_GEN_5)
+-			vc5_hvs_pv_muxing_commit(vc4, state);
+-		else
++		switch (vc4->gen) {
++		case VC4_GEN_4:
+ 			vc4_hvs_pv_muxing_commit(vc4, state);
++			break;
++
++		case VC4_GEN_5:
++			vc5_hvs_pv_muxing_commit(vc4, state);
++			break;
++
++		case VC4_GEN_6:
++			vc6_hvs_pv_muxing_commit(vc4, state);
++			break;
++
++		default:
++			drm_err(dev, "Unknown VC4 generation: %d", vc4->gen);
++			break;
++		}
+ 	}
+ 
+ 	drm_atomic_helper_commit_planes(dev, state,
+@@ -417,7 +483,7 @@ static void vc4_atomic_commit_tail(struc
+ 
+ 	drm_atomic_helper_cleanup_planes(dev, state);
+ 
+-	if (vc4->gen == VC4_GEN_5 && !vc4->firmware_kms) {
++	if (vc4->gen >= VC4_GEN_5 && !vc4->firmware_kms) {
+ 		unsigned long core_rate = min_t(unsigned long,
+ 						hvs->max_core_rate,
+ 						new_hvs_state->core_clock_rate);
+@@ -429,6 +495,7 @@ static void vc4_atomic_commit_tail(struc
+ 		 * requirements.
+ 		 */
+ 		WARN_ON(clk_set_min_rate(hvs->core_clk, core_rate));
++		WARN_ON(clk_set_min_rate(hvs->disp_clk, core_rate));
+ 
+ 		drm_dbg(dev, "Core clock actual rate: %lu Hz\n",
+ 			clk_get_rate(hvs->core_clk));
+@@ -1081,7 +1148,10 @@ int vc4_kms_load(struct drm_device *dev)
+ 		return ret;
+ 	}
+ 
+-	if (vc4->gen == VC4_GEN_5) {
++	if (vc4->gen >= VC4_GEN_6) {
++		dev->mode_config.max_width = 8192;
++		dev->mode_config.max_height = 8192;
++	} else if (vc4->gen >= VC4_GEN_5) {
+ 		dev->mode_config.max_width = 7680;
+ 		dev->mode_config.max_height = 7680;
+ 	} else {
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -279,6 +279,7 @@ static bool plane_enabled(struct drm_pla
+ static struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane)
+ {
+ 	struct vc4_plane_state *vc4_state;
++	unsigned int i;
+ 
+ 	if (WARN_ON(!plane->state))
+ 		return NULL;
+@@ -288,6 +289,11 @@ static struct drm_plane_state *vc4_plane
+ 		return NULL;
+ 
+ 	memset(&vc4_state->lbm, 0, sizeof(vc4_state->lbm));
++	memset(&vc4_state->upm, 0, sizeof(vc4_state->upm));
++
++	for (i = 0; i < DRM_FORMAT_MAX_PLANES; i++)
++		vc4_state->upm_handle[i] = 0;
++
+ 	vc4_state->dlist_initialized = 0;
+ 
+ 	__drm_atomic_helper_plane_duplicate_state(plane, &vc4_state->base);
+@@ -310,14 +316,30 @@ static void vc4_plane_destroy_state(stru
+ 				    struct drm_plane_state *state)
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
++	struct vc4_hvs *hvs = vc4->hvs;
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
++	unsigned int i;
+ 
+ 	if (drm_mm_node_allocated(&vc4_state->lbm)) {
+ 		unsigned long irqflags;
+ 
+-		spin_lock_irqsave(&vc4->hvs->mm_lock, irqflags);
++		spin_lock_irqsave(&hvs->mm_lock, irqflags);
+ 		drm_mm_remove_node(&vc4_state->lbm);
+-		spin_unlock_irqrestore(&vc4->hvs->mm_lock, irqflags);
++		spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
++	}
++
++	for (i = 0; i < DRM_FORMAT_MAX_PLANES; i++) {
++		unsigned long irqflags;
++
++		if (!drm_mm_node_allocated(&vc4_state->upm[i]))
++			continue;
++
++		spin_lock_irqsave(&hvs->mm_lock, irqflags);
++		drm_mm_remove_node(&vc4_state->upm[i]);
++		spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
++
++		if (vc4_state->upm_handle[i] > 0)
++			ida_free(&hvs->upm_handles, vc4_state->upm_handle[i]);
+ 	}
+ 
+ 	kfree(vc4_state->dlist);
+@@ -543,6 +565,11 @@ static void vc4_write_tpz(struct vc4_pla
+ 	recip = ~0 / scale;
+ 
+ 	vc4_dlist_write(vc4_state,
++			/*
++			 * The BCM2712 is lacking BIT(31) compared to
++			 * the previous generations, but we don't use
++			 * it.
++			 */
+ 			VC4_SET_FIELD(scale, SCALER_TPZ0_SCALE) |
+ 			VC4_SET_FIELD(0, SCALER_TPZ0_IPHASE));
+ 	vc4_dlist_write(vc4_state,
+@@ -590,10 +617,15 @@ static void vc4_write_ppf(struct vc4_pla
+ 	vc4_dlist_write(vc4_state,
+ 			SCALER_PPF_AGC |
+ 			VC4_SET_FIELD(scale, SCALER_PPF_SCALE) |
++			/*
++			 * The register layout documentation is slightly
++			 * different to setup the phase in the BCM2712,
++			 * but they seem equivalent.
++			 */
+ 			VC4_SET_FIELD(phase, SCALER_PPF_IPHASE));
+ }
+ 
+-static u32 vc4_lbm_size(struct drm_plane_state *state)
++static u32 __vc4_lbm_size(struct drm_plane_state *state)
+ {
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
+ 	struct vc4_dev *vc4 = to_vc4_dev(state->plane->dev);
+@@ -641,6 +673,131 @@ static u32 vc4_lbm_size(struct drm_plane
+ 	return lbm;
+ }
+ 
++static unsigned int vc4_lbm_words_per_component(const struct drm_plane_state *state,
++						unsigned int channel)
++{
++	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
++
++	switch (vc4_state->y_scaling[channel]) {
++	case VC4_SCALING_PPF:
++		return 4;
++
++	case VC4_SCALING_TPZ:
++		return 2;
++
++	default:
++		return 0;
++	}
++}
++
++static unsigned int vc4_lbm_components(const struct drm_plane_state *state,
++				       unsigned int channel)
++{
++	const struct drm_format_info *info = state->fb->format;
++	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
++
++	if (vc4_state->y_scaling[channel] == VC4_SCALING_NONE)
++		return 0;
++
++	if (info->is_yuv)
++		return channel ? 2 : 1;
++
++	if (info->has_alpha)
++		return 4;
++
++	return 3;
++}
++
++static unsigned int vc4_lbm_channel_size(const struct drm_plane_state *state,
++					 unsigned int channel)
++{
++	const struct drm_format_info *info = state->fb->format;
++	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
++	unsigned int channels_scaled = 0;
++	unsigned int components, words, wpc;
++	unsigned int width, lines;
++	unsigned int i;
++
++	/* LBM is meant to use the smaller of source or dest width, but there
++	 * is a issue with UV scaling that the size required for the second
++	 * channel is based on the source width only.
++	 */
++	if (info->hsub > 1 && channel == 1)
++		width = state->src_w >> 16;
++	else
++		width = min(state->src_w >> 16, state->crtc_w);
++	width = round_up(width / info->hsub, 4);
++
++	wpc = vc4_lbm_words_per_component(state, channel);
++	if (!wpc)
++		return 0;
++
++	components = vc4_lbm_components(state, channel);
++	if (!components)
++		return 0;
++
++	if (state->alpha != DRM_BLEND_ALPHA_OPAQUE)
++		components -= 1;
++
++	words = width * wpc * components;
++
++	lines = DIV_ROUND_UP(words, 128 / info->hsub);
++
++	for (i = 0; i < 2; i++)
++		if (vc4_state->y_scaling[channel] != VC4_SCALING_NONE)
++			channels_scaled++;
++
++	if (channels_scaled == 1)
++		lines = lines / 2;
++
++	return lines;
++}
++
++static unsigned int __vc6_lbm_size(const struct drm_plane_state *state)
++{
++	const struct drm_format_info *info = state->fb->format;
++
++	if (info->hsub > 1)
++		return max(vc4_lbm_channel_size(state, 0),
++			   vc4_lbm_channel_size(state, 1));
++	else
++		return vc4_lbm_channel_size(state, 0);
++}
++
++u32 vc4_lbm_size(struct drm_plane_state *state)
++{
++	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
++	struct vc4_dev *vc4 = to_vc4_dev(state->plane->dev);
++
++	/* LBM is not needed when there's no vertical scaling. */
++	if (vc4_state->y_scaling[0] == VC4_SCALING_NONE &&
++	    vc4_state->y_scaling[1] == VC4_SCALING_NONE)
++		return 0;
++
++	if (vc4->gen >= VC4_GEN_6)
++		return __vc6_lbm_size(state);
++	else
++		return __vc4_lbm_size(state);
++}
++
++static size_t vc6_upm_size(const struct drm_plane_state *state,
++			   unsigned int plane)
++{
++	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
++	unsigned int stride = state->fb->pitches[plane];
++
++	/*
++	 * TODO: This only works for raster formats, and is sub-optimal
++	 * for buffers with a stride aligned on 32 bytes.
++	 */
++	unsigned int words_per_line = (stride + 62) / 32;
++	unsigned int fetch_region_size = words_per_line * 32;
++	unsigned int buffer_lines = 2 << vc4_state->upm_buffer_lines;
++	unsigned int buffer_size = fetch_region_size * buffer_lines;
++
++	return ALIGN(buffer_size, HVS_UBM_WORD_SIZE);
++}
++
+ static void vc4_write_scaling_parameters(struct drm_plane_state *state,
+ 					 int channel)
+ {
+@@ -744,6 +901,10 @@ static int vc4_plane_allocate_lbm(struct
+ 	if (!lbm_size)
+ 		return 0;
+ 
++	/*
++	 * NOTE: BCM2712 doesn't need to be aligned, since the size
++	 * returned by vc4_lbm_size() is in words already.
++	 */
+ 	if (vc4->gen == VC4_GEN_5)
+ 		lbm_size = ALIGN(lbm_size, 64);
+ 	else if (vc4->gen == VC4_GEN_4)
+@@ -781,6 +942,57 @@ static int vc4_plane_allocate_lbm(struct
+ 	return 0;
+ }
+ 
++static int vc6_plane_allocate_upm(struct drm_plane_state *state)
++{
++	const struct drm_format_info *info = state->fb->format;
++	struct drm_device *drm = state->plane->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
++	struct vc4_hvs *hvs = vc4->hvs;
++	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
++	unsigned int i;
++	int ret;
++
++	WARN_ON_ONCE(vc4->gen < VC4_GEN_6);
++
++	vc4_state->upm_buffer_lines = SCALER6_PTR0_UPM_BUFF_SIZE_2_LINES;
++
++	for (i = 0; i < info->num_planes; i++) {
++		unsigned long irqflags;
++		size_t upm_size;
++
++		upm_size = vc6_upm_size(state, i);
++		if (!upm_size)
++			return -EINVAL;
++
++		spin_lock_irqsave(&hvs->mm_lock, irqflags);
++		ret = drm_mm_insert_node_generic(&hvs->upm_mm,
++						 &vc4_state->upm[i],
++						 upm_size, HVS_UBM_WORD_SIZE,
++						 0, 0);
++		spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
++		if (ret) {
++			drm_err(drm, "Failed to allocate UPM entry: %d\n", ret);
++			return ret;
++		}
++
++		ret = ida_alloc_range(&hvs->upm_handles, 1, 32, GFP_KERNEL);
++		if (ret < 0)
++			return ret;
++
++		vc4_state->upm_handle[i] = ret;
++
++		vc4_state->dlist[vc4_state->ptr0_offset[i]] |=
++			VC4_SET_FIELD(vc4_state->upm[i].start / HVS_UBM_WORD_SIZE,
++				      SCALER6_PTR0_UPM_BASE) |
++			VC4_SET_FIELD(vc4_state->upm_handle[i] - 1,
++				      SCALER6_PTR0_UPM_HANDLE) |
++			VC4_SET_FIELD(vc4_state->upm_buffer_lines,
++				      SCALER6_PTR0_UPM_BUFF_SIZE);
++	}
++
++	return 0;
++}
++
+ /*
+  * The colorspace conversion matrices are held in 3 entries in the dlist.
+  * Create an array of them, with entries for each full and limited mode, and
+@@ -1355,6 +1567,413 @@ static int vc4_plane_mode_set(struct drm
+ 	return 0;
+ }
+ 
++static u32 vc6_plane_get_csc_mode(struct vc4_plane_state *vc4_state)
++{
++	struct drm_plane_state *state = &vc4_state->base;
++	u32 ret = 0;
++
++	if (vc4_state->is_yuv) {
++		enum drm_color_encoding color_encoding = state->color_encoding;
++		enum drm_color_range color_range = state->color_range;
++
++		ret |= SCALER6_CTL2_CSC_ENABLE;
++
++		/* CSC pre-loaded with:
++		 * 0 = BT601 limited range
++		 * 1 = BT709 limited range
++		 * 2 = BT2020 limited range
++		 * 3 = BT601 full range
++		 * 4 = BT709 full range
++		 * 5 = BT2020 full range
++		 */
++		if (color_encoding > DRM_COLOR_YCBCR_BT2020)
++			color_encoding = DRM_COLOR_YCBCR_BT601;
++		if (color_range > DRM_COLOR_YCBCR_FULL_RANGE)
++			color_range = DRM_COLOR_YCBCR_LIMITED_RANGE;
++
++		ret |= VC4_SET_FIELD(color_encoding + (color_range * 3),
++				     SCALER6_CTL2_BRCM_CFC_CONTROL);
++	}
++
++	return ret;
++}
++
++static int vc6_plane_mode_set(struct drm_plane *plane,
++			      struct drm_plane_state *state)
++{
++	struct drm_device *drm = plane->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
++	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
++	struct drm_framebuffer *fb = state->fb;
++	const struct hvs_format *format = vc4_get_hvs_format(fb->format->format);
++	u64 base_format_mod = fourcc_mod_broadcom_mod(fb->modifier);
++	int num_planes = fb->format->num_planes;
++	u32 h_subsample = fb->format->hsub;
++	u32 v_subsample = fb->format->vsub;
++	bool mix_plane_alpha;
++	bool covers_screen;
++	u32 scl0, scl1, pitch0;
++	u32 tiling, src_x, src_y;
++	u32 width, height;
++	u32 hvs_format = format->hvs;
++	u32 offsets[3] = { 0 };
++	unsigned int rotation;
++	int ret, i;
++
++	if (vc4_state->dlist_initialized)
++		return 0;
++
++	ret = vc4_plane_setup_clipping_and_scaling(state);
++	if (ret)
++		return ret;
++
++	width = vc4_state->src_w[0] >> 16;
++	height = vc4_state->src_h[0] >> 16;
++
++	/* SCL1 is used for Cb/Cr scaling of planar formats.  For RGB
++	 * and 4:4:4, scl1 should be set to scl0 so both channels of
++	 * the scaler do the same thing.  For YUV, the Y plane needs
++	 * to be put in channel 1 and Cb/Cr in channel 0, so we swap
++	 * the scl fields here.
++	 */
++	if (num_planes == 1) {
++		scl0 = vc4_get_scl_field(state, 0);
++		scl1 = scl0;
++	} else {
++		scl0 = vc4_get_scl_field(state, 1);
++		scl1 = vc4_get_scl_field(state, 0);
++	}
++
++	rotation = drm_rotation_simplify(state->rotation,
++					 DRM_MODE_ROTATE_0 |
++					 DRM_MODE_REFLECT_X |
++					 DRM_MODE_REFLECT_Y);
++
++	/* We must point to the last line when Y reflection is enabled. */
++	src_y = vc4_state->src_y >> 16;
++	if (rotation & DRM_MODE_REFLECT_Y)
++		src_y += height - 1;
++
++	src_x = vc4_state->src_x >> 16;
++
++	switch (base_format_mod) {
++	case DRM_FORMAT_MOD_LINEAR:
++		tiling = SCALER6_CTL0_ADDR_MODE_LINEAR;
++
++		/* Adjust the base pointer to the first pixel to be scanned
++		 * out.
++		 */
++		for (i = 0; i < num_planes; i++) {
++			offsets[i] += src_y / (i ? v_subsample : 1) * fb->pitches[i];
++			offsets[i] += src_x / (i ? h_subsample : 1) * fb->format->cpp[i];
++		}
++
++		break;
++
++	case DRM_FORMAT_MOD_BROADCOM_SAND128:
++	case DRM_FORMAT_MOD_BROADCOM_SAND256: {
++		uint32_t param = fourcc_mod_broadcom_param(fb->modifier);
++		u32 components_per_word;
++		u32 starting_offset;
++		u32 fetch_count;
++
++		if (param > SCALER_TILE_HEIGHT_MASK) {
++			DRM_DEBUG_KMS("SAND height too large (%d)\n",
++				      param);
++			return -EINVAL;
++		}
++
++		if (fb->format->format == DRM_FORMAT_P030) {
++			hvs_format = HVS_PIXEL_FORMAT_YCBCR_10BIT;
++			tiling = SCALER6_CTL0_ADDR_MODE_128B;
++		} else {
++			hvs_format = HVS_PIXEL_FORMAT_YCBCR_YUV420_2PLANE;
++
++			switch (base_format_mod) {
++			case DRM_FORMAT_MOD_BROADCOM_SAND128:
++				tiling = SCALER6_CTL0_ADDR_MODE_128B;
++				break;
++			case DRM_FORMAT_MOD_BROADCOM_SAND256:
++				tiling = SCALER6_CTL0_ADDR_MODE_256B;
++				break;
++			default:
++				return -EINVAL;
++			}
++		}
++
++		/* Adjust the base pointer to the first pixel to be scanned
++		 * out.
++		 *
++		 * For P030, y_ptr [31:4] is the 128bit word for the start pixel
++		 * y_ptr [3:0] is the pixel (0-11) contained within that 128bit
++		 * word that should be taken as the first pixel.
++		 * Ditto uv_ptr [31:4] vs [3:0], however [3:0] contains the
++		 * element within the 128bit word, eg for pixel 3 the value
++		 * should be 6.
++		 */
++		for (i = 0; i < num_planes; i++) {
++			u32 tile_w, tile, x_off, pix_per_tile;
++
++			if (fb->format->format == DRM_FORMAT_P030) {
++				/*
++				 * Spec says: bits [31:4] of the given address
++				 * should point to the 128-bit word containing
++				 * the desired starting pixel, and bits[3:0]
++				 * should be between 0 and 11, indicating which
++				 * of the 12-pixels in that 128-bit word is the
++				 * first pixel to be used
++				 */
++				u32 remaining_pixels = src_x % 96;
++				u32 aligned = remaining_pixels / 12;
++				u32 last_bits = remaining_pixels % 12;
++
++				x_off = aligned * 16 + last_bits;
++				tile_w = 128;
++				pix_per_tile = 96;
++			} else {
++				switch (base_format_mod) {
++				case DRM_FORMAT_MOD_BROADCOM_SAND128:
++					tile_w = 128;
++					break;
++				case DRM_FORMAT_MOD_BROADCOM_SAND256:
++					tile_w = 256;
++					break;
++				default:
++					return -EINVAL;
++				}
++				pix_per_tile = tile_w / fb->format->cpp[0];
++				x_off = (src_x % pix_per_tile) /
++					(i ? h_subsample : 1) *
++					fb->format->cpp[i];
++			}
++
++			tile = src_x / pix_per_tile;
++
++			offsets[i] += param * tile_w * tile;
++			offsets[i] += src_y / (i ? v_subsample : 1) * tile_w;
++			offsets[i] += x_off & ~(i ? 1 : 0);
++		}
++
++		components_per_word = fb->format->format == DRM_FORMAT_P030 ? 24 : 32;
++		starting_offset = src_x % components_per_word;
++		fetch_count = (width + starting_offset + components_per_word - 1) /
++			components_per_word;
++
++		pitch0 = VC4_SET_FIELD(param, SCALER6_PTR2_PITCH) |
++			 VC4_SET_FIELD(fetch_count - 1, SCALER6_PTR2_FETCH_COUNT);
++		break;
++	}
++
++	default:
++		DRM_DEBUG_KMS("Unsupported FB tiling flag 0x%16llx",
++			      (long long)fb->modifier);
++		return -EINVAL;
++	}
++
++	/* fetch an extra pixel if we don't actually line up with the left edge. */
++	if ((vc4_state->src_x & 0xffff) && vc4_state->src_x < (state->fb->width << 16))
++		width++;
++
++	/* same for the right side */
++	if (((vc4_state->src_x + vc4_state->src_w[0]) & 0xffff) &&
++	    vc4_state->src_x + vc4_state->src_w[0] < (state->fb->width << 16))
++		width++;
++
++	/* now for the top */
++	if ((vc4_state->src_y & 0xffff) && vc4_state->src_y < (state->fb->height << 16))
++		height++;
++
++	/* and the bottom */
++	if (((vc4_state->src_y + vc4_state->src_h[0]) & 0xffff) &&
++	    vc4_state->src_y + vc4_state->src_h[0] < (state->fb->height << 16))
++		height++;
++
++	/* for YUV444 hardware wants double the width, otherwise it doesn't
++	 * fetch full width of chroma
++	 */
++	if (format->drm == DRM_FORMAT_YUV444 || format->drm == DRM_FORMAT_YVU444)
++		width <<= 1;
++
++	/* Don't waste cycles mixing with plane alpha if the set alpha
++	 * is opaque or there is no per-pixel alpha information.
++	 * In any case we use the alpha property value as the fixed alpha.
++	 */
++	mix_plane_alpha = state->alpha != DRM_BLEND_ALPHA_OPAQUE &&
++			  fb->format->has_alpha;
++
++	/* Control Word 0: Scaling Configuration & Element Validity*/
++	vc4_dlist_write(vc4_state,
++			SCALER6_CTL0_VALID |
++			VC4_SET_FIELD(tiling, SCALER6_CTL0_ADDR_MODE) |
++			VC4_SET_FIELD(0, SCALER6_CTL0_ALPHA_MASK) |
++			(vc4_state->is_unity ? SCALER6_CTL0_UNITY : 0) |
++			VC4_SET_FIELD(format->pixel_order_hvs5, SCALER6_CTL0_ORDERRGBA) |
++			VC4_SET_FIELD(scl1, SCALER6_CTL0_SCL1_MODE) |
++			VC4_SET_FIELD(scl0, SCALER6_CTL0_SCL0_MODE) |
++			VC4_SET_FIELD(hvs_format, SCALER6_CTL0_PIXEL_FORMAT));
++
++	/* Position Word 0: Image Position */
++	vc4_state->pos0_offset = vc4_state->dlist_count;
++	vc4_dlist_write(vc4_state,
++			VC4_SET_FIELD(vc4_state->crtc_y, SCALER6_POS0_START_Y) |
++			(rotation & DRM_MODE_REFLECT_X ? SCALER6_POS0_HFLIP : 0) |
++			VC4_SET_FIELD(vc4_state->crtc_x, SCALER6_POS0_START_X));
++
++	/* Control Word 2: Alpha Value & CSC */
++	vc4_dlist_write(vc4_state,
++			vc6_plane_get_csc_mode(vc4_state) |
++			vc4_hvs5_get_alpha_blend_mode(state) |
++			(mix_plane_alpha ? SCALER6_CTL2_ALPHA_MIX : 0) |
++			VC4_SET_FIELD(state->alpha >> 4, SCALER5_CTL2_ALPHA));
++
++	/* Position Word 1: Scaled Image Dimensions */
++	if (!vc4_state->is_unity)
++		vc4_dlist_write(vc4_state,
++				VC4_SET_FIELD(vc4_state->crtc_h - 1,
++					      SCALER6_POS1_SCL_LINES) |
++				VC4_SET_FIELD(vc4_state->crtc_w - 1,
++					      SCALER6_POS1_SCL_WIDTH));
++
++	/* Position Word 2: Source Image Size */
++	vc4_state->pos2_offset = vc4_state->dlist_count;
++	vc4_dlist_write(vc4_state,
++			VC4_SET_FIELD(height - 1,
++				      SCALER6_POS2_SRC_LINES) |
++			VC4_SET_FIELD(width - 1,
++				      SCALER6_POS2_SRC_WIDTH));
++
++	/* Position Word 3: Context */
++	vc4_dlist_write(vc4_state, 0xc0c0c0c0);
++
++	/*
++	 * TODO: This only covers Raster Scan Order planes
++	 */
++	for (i = 0; i < num_planes; i++) {
++		dma_addr_t paddr = drm_fb_dma_get_gem_addr(fb, state, i);
++
++		paddr += offsets[i];
++
++		/* Pointer Word 0 */
++		vc4_state->ptr0_offset[i] = vc4_state->dlist_count;
++		vc4_dlist_write(vc4_state,
++				(rotation & DRM_MODE_REFLECT_Y ? SCALER6_PTR0_VFLIP : 0) |
++				/*
++				 * The UPM buffer will be allocated in
++				 * vc6_plane_allocate_upm().
++				 */
++				VC4_SET_FIELD(upper_32_bits(paddr) & 0xf,
++					      SCALER6_PTR0_UPPER_ADDR));
++
++		/* Pointer Word 1 */
++		vc4_dlist_write(vc4_state, lower_32_bits(paddr));
++
++		/* Pointer Word 2 */
++		if (base_format_mod != DRM_FORMAT_MOD_BROADCOM_SAND128 &&
++		    base_format_mod != DRM_FORMAT_MOD_BROADCOM_SAND256) {
++			vc4_dlist_write(vc4_state,
++					VC4_SET_FIELD(fb->pitches[i],
++						      SCALER6_PTR2_PITCH));
++		} else {
++			vc4_dlist_write(vc4_state, pitch0);
++		}
++	}
++
++	/*
++	 * Palette Word 0
++	 * TODO: We're not using the palette mode
++	 */
++
++	/*
++	 * Trans Word 0
++	 * TODO: It's only relevant if we set the trans_rgb bit in the
++	 * control word 0, and we don't at the moment.
++	 */
++
++	vc4_state->lbm_offset = 0;
++
++	if (!vc4_state->is_unity || fb->format->is_yuv) {
++		/*
++		 * Reserve a slot for the LBM Base Address. The real value will
++		 * be set when calling vc4_plane_allocate_lbm().
++		 */
++		if (vc4_state->y_scaling[0] != VC4_SCALING_NONE ||
++		    vc4_state->y_scaling[1] != VC4_SCALING_NONE) {
++			vc4_state->lbm_offset = vc4_state->dlist_count;
++			vc4_dlist_counter_increment(vc4_state);
++		}
++
++		if (vc4_state->x_scaling[0] != VC4_SCALING_NONE ||
++		    vc4_state->x_scaling[1] != VC4_SCALING_NONE ||
++		    vc4_state->y_scaling[0] != VC4_SCALING_NONE ||
++		    vc4_state->y_scaling[1] != VC4_SCALING_NONE) {
++			if (num_planes > 1)
++				/*
++				 * Emit Cb/Cr as channel 0 and Y as channel
++				 * 1. This matches how we set up scl0/scl1
++				 * above.
++				 */
++				vc4_write_scaling_parameters(state, 1);
++
++			vc4_write_scaling_parameters(state, 0);
++		}
++
++		/*
++		 * If any PPF setup was done, then all the kernel
++		 * pointers get uploaded.
++		 */
++		if (vc4_state->x_scaling[0] == VC4_SCALING_PPF ||
++		    vc4_state->y_scaling[0] == VC4_SCALING_PPF ||
++		    vc4_state->x_scaling[1] == VC4_SCALING_PPF ||
++		    vc4_state->y_scaling[1] == VC4_SCALING_PPF) {
++			u32 kernel =
++				VC4_SET_FIELD(vc4->hvs->mitchell_netravali_filter.start,
++					      SCALER_PPF_KERNEL_OFFSET);
++
++			/* HPPF plane 0 */
++			vc4_dlist_write(vc4_state, kernel);
++			/* VPPF plane 0 */
++			vc4_dlist_write(vc4_state, kernel);
++			/* HPPF plane 1 */
++			vc4_dlist_write(vc4_state, kernel);
++			/* VPPF plane 1 */
++				vc4_dlist_write(vc4_state, kernel);
++		}
++	}
++
++	vc4_dlist_write(vc4_state, SCALER6_CTL0_END);
++
++	vc4_state->dlist[0] |=
++		VC4_SET_FIELD(vc4_state->dlist_count, SCALER6_CTL0_NEXT);
++
++	/* crtc_* are already clipped coordinates. */
++	covers_screen = vc4_state->crtc_x == 0 && vc4_state->crtc_y == 0 &&
++			vc4_state->crtc_w == state->crtc->mode.hdisplay &&
++			vc4_state->crtc_h == state->crtc->mode.vdisplay;
++
++	/*
++	 * Background fill might be necessary when the plane has per-pixel
++	 * alpha content or a non-opaque plane alpha and could blend from the
++	 * background or does not cover the entire screen.
++	 */
++	vc4_state->needs_bg_fill = fb->format->has_alpha || !covers_screen ||
++				   state->alpha != DRM_BLEND_ALPHA_OPAQUE;
++
++	/*
++	 * Flag the dlist as initialized to avoid checking it twice in case
++	 * the async update check already called vc4_plane_mode_set() and
++	 * decided to fallback to sync update because async update was not
++	 * possible.
++	 */
++	vc4_state->dlist_initialized = 1;
++
++	vc4_plane_calc_load(state);
++
++	drm_dbg_driver(drm, "[PLANE:%d:%s] Computed DLIST size: %u\n",
++		       plane->base.id, plane->name, vc4_state->dlist_count);
++
++	return 0;
++}
++
+ /* If a modeset involves changing the setup of a plane, the atomic
+  * infrastructure will call this to validate a proposed plane setup.
+  * However, if a plane isn't getting updated, this (and the
+@@ -1365,6 +1984,7 @@ static int vc4_plane_mode_set(struct drm
+ static int vc4_plane_atomic_check(struct drm_plane *plane,
+ 				  struct drm_atomic_state *state)
+ {
++	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
+ 	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
+ 										 plane);
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(new_plane_state);
+@@ -1375,7 +1995,10 @@ static int vc4_plane_atomic_check(struct
+ 	if (!plane_enabled(new_plane_state))
+ 		return 0;
+ 
+-	ret = vc4_plane_mode_set(plane, new_plane_state);
++	if (vc4->gen >= VC4_GEN_6)
++		ret = vc6_plane_mode_set(plane, new_plane_state);
++	else
++		ret = vc4_plane_mode_set(plane, new_plane_state);
+ 	if (ret)
+ 		return ret;
+ 
+@@ -1383,6 +2006,12 @@ static int vc4_plane_atomic_check(struct
+ 	if (ret)
+ 		return ret;
+ 
++	if (vc4->gen >= VC4_GEN_6) {
++		ret = vc6_plane_allocate_upm(new_plane_state);
++		if (ret)
++			return ret;
++	}
++
+ 	return 0;
+ }
+ 
+@@ -1716,7 +2345,7 @@ struct drm_plane *vc4_plane_init(struct
+ 	};
+ 
+ 	for (i = 0; i < ARRAY_SIZE(hvs_formats); i++) {
+-		if (!hvs_formats[i].hvs5_only || vc4->gen == VC4_GEN_5) {
++		if (!hvs_formats[i].hvs5_only || vc4->gen >= VC4_GEN_5) {
+ 			formats[num_formats] = hvs_formats[i].drm;
+ 			num_formats++;
+ 		}
+@@ -1731,7 +2360,7 @@ struct drm_plane *vc4_plane_init(struct
+ 		return ERR_CAST(vc4_plane);
+ 	plane = &vc4_plane->base;
+ 
+-	if (vc4->gen == VC4_GEN_5)
++	if (vc4->gen >= VC4_GEN_5)
+ 		drm_plane_helper_add(plane, &vc5_plane_helper_funcs);
+ 	else
+ 		drm_plane_helper_add(plane, &vc4_plane_helper_funcs);
+--- a/drivers/gpu/drm/vc4/vc4_regs.h
++++ b/drivers/gpu/drm/vc4/vc4_regs.h
+@@ -536,6 +536,130 @@
+ 
+ #define SCALER5_DLIST_START			0x00004000
+ 
++#define SCALER6_VERSION				0x00000000
++#define SCALER6_CXM_SIZE			0x00000004
++#define SCALER6_LBM_SIZE			0x00000008
++#define SCALER6_UBM_SIZE			0x0000000c
++#define SCALER6_COBA_SIZE			0x00000010
++#define SCALER6_COB_SIZE			0x00000014
++
++#define SCALER6_CONTROL				0x00000020
++# define SCALER6_CONTROL_HVS_EN			BIT(31)
++# define SCALER6_CONTROL_PF_LINES_MASK		VC4_MASK(22, 18)
++# define SCALER6_CONTROL_ABORT_ON_EMPTY		BIT(16)
++# define SCALER6_CONTROL_DSP1_TARGET_MASK	VC4_MASK(13, 12)
++# define SCALER6_CONTROL_MAX_REQS_MASK		VC4_MASK(7, 4)
++
++#define SCALER6_FETCHER_STATUS			0x00000024
++#define SCALER6_FETCH_STATUS			0x00000028
++#define SCALER6_HANDLE_ERROR			0x0000002c
++
++#define SCALER6_DISP0_CTRL0			0x00000030
++#define SCALER6_DISPX_CTRL0(x)						\
++	(SCALER6_DISP0_CTRL0 + ((x) * (SCALER6_DISP1_CTRL0 - SCALER6_DISP0_CTRL0)))
++# define SCALER6_DISPX_CTRL0_ENB		BIT(31)
++# define SCALER6_DISPX_CTRL0_RESET		BIT(30)
++# define SCALER6_DISPX_CTRL0_FWIDTH_MASK	VC4_MASK(28, 16)
++# define SCALER6_DISPX_CTRL0_ONESHOT		BIT(15)
++# define SCALER6_DISPX_CTRL0_ONECTX_MASK	VC4_MASK(14, 13)
++# define SCALER6_DISPX_CTRL0_LINES_MASK		VC4_MASK(12, 0)
++
++#define SCALER6_DISP0_CTRL1			0x00000034
++#define SCALER6_DISPX_CTRL1(x)						\
++	(SCALER6_DISP0_CTRL1 + ((x) * (SCALER6_DISP1_CTRL1 - SCALER6_DISP0_CTRL1)))
++# define SCALER6_DISPX_CTRL1_BGENB		BIT(8)
++# define SCALER6_DISPX_CTRL1_INTLACE		BIT(0)
++
++#define SCALER6_DISP0_BGND			0x00000038
++#define SCALER6_DISPX_BGND(x)						\
++	(SCALER6_DISP0_BGND + ((x) * (SCALER6_DISP1_BGND - SCALER6_DISP0_BGND)))
++
++#define SCALER6_DISP0_LPTRS			0x0000003c
++#define SCALER6_DISPX_LPTRS(x)						\
++	(SCALER6_DISP0_LPTRS + ((x) * (SCALER6_DISP1_LPTRS - SCALER6_DISP0_LPTRS)))
++# define SCALER6_DISPX_LPTRS_HEADE_MASK		VC4_MASK(11, 0)
++
++#define SCALER6_DISP0_COB			0x00000040
++#define SCALER6_DISPX_COB(x)						\
++	(SCALER6_DISP0_COB + ((x) * (SCALER6_DISP1_COB - SCALER6_DISP0_COB)))
++# define SCALER6_DISPX_COB_TOP_MASK		VC4_MASK(31, 16)
++# define SCALER6_DISPX_COB_BASE_MASK		VC4_MASK(15, 0)
++
++#define SCALER6_DISP0_STATUS			0x00000044
++
++#define SCALER6_DISPX_STATUS(x)						\
++	(SCALER6_DISP0_STATUS + ((x) * (SCALER6_DISP1_STATUS - SCALER6_DISP0_STATUS)))
++# define SCALER6_DISPX_STATUS_EMPTY		BIT(22)
++# define SCALER6_DISPX_STATUS_FRCNT_MASK	VC4_MASK(21, 16)
++# define SCALER6_DISPX_STATUS_OFIELD		BIT(15)
++# define SCALER6_DISPX_STATUS_MODE_MASK		VC4_MASK(14, 13)
++# define SCALER6_DISPX_STATUS_MODE_DISABLED	0
++# define SCALER6_DISPX_STATUS_MODE_INIT		1
++# define SCALER6_DISPX_STATUS_MODE_RUN		2
++# define SCALER6_DISPX_STATUS_MODE_EOF		3
++# define SCALER6_DISPX_STATUS_YLINE_MASK	VC4_MASK(12, 0)
++
++#define SCALER6_DISP0_DL			0x00000048
++
++#define SCALER6_DISPX_DL(x)						\
++	(SCALER6_DISP0_DL + ((x) * (SCALER6_DISP1_DL - SCALER6_DISP0_DL)))
++# define SCALER6_DISPX_DL_LACT_MASK		VC4_MASK(11, 0)
++
++#define SCALER6_DISP0_RUN			0x0000004c
++#define SCALER6_DISP1_CTRL0			0x00000050
++#define SCALER6_DISP1_CTRL1			0x00000054
++#define SCALER6_DISP1_BGND			0x00000058
++#define SCALER6_DISP1_LPTRS			0x0000005c
++#define SCALER6_DISP1_COB			0x00000060
++#define SCALER6_DISP1_STATUS			0x00000064
++#define SCALER6_DISP1_DL			0x00000068
++#define SCALER6_DISP1_RUN			0x0000006c
++#define SCALER6_DISP2_CTRL0			0x00000070
++#define SCALER6_DISP2_CTRL1			0x00000074
++#define SCALER6_DISP2_BGND			0x00000078
++#define SCALER6_DISP2_LPTRS			0x0000007c
++#define SCALER6_DISP2_COB			0x00000080
++#define SCALER6_DISP2_STATUS			0x00000084
++#define SCALER6_DISP2_DL			0x00000088
++#define SCALER6_DISP2_RUN			0x0000008c
++#define SCALER6_EOLN				0x00000090
++#define SCALER6_DL_STATUS			0x00000094
++#define SCALER6_BFG_MISC			0x0000009c
++#define SCALER6_QOS0				0x000000a0
++#define SCALER6_PROF0				0x000000a4
++#define SCALER6_QOS1				0x000000a8
++#define SCALER6_PROF1				0x000000ac
++#define SCALER6_QOS2				0x000000b0
++#define SCALER6_PROF2				0x000000b4
++#define SCALER6_PRI_MAP0			0x000000b8
++#define SCALER6_PRI_MAP1			0x000000bc
++#define SCALER6_HISTCTRL			0x000000c0
++#define SCALER6_HISTBIN0			0x000000c4
++#define SCALER6_HISTBIN1			0x000000c8
++#define SCALER6_HISTBIN2			0x000000cc
++#define SCALER6_HISTBIN3			0x000000d0
++#define SCALER6_HISTBIN4			0x000000d4
++#define SCALER6_HISTBIN5			0x000000d8
++#define SCALER6_HISTBIN6			0x000000dc
++#define SCALER6_HISTBIN7			0x000000e0
++#define SCALER6_HDR_CFG_REMAP			0x000000f4
++#define SCALER6_COL_SPACE			0x000000f8
++#define SCALER6_HVS_ID				0x000000fc
++#define SCALER6_CFC1				0x00000100
++#define SCALER6_DISP_UPM_ISO0			0x00000200
++#define SCALER6_DISP_UPM_ISO1			0x00000204
++#define SCALER6_DISP_UPM_ISO2			0x00000208
++#define SCALER6_DISP_LBM_ISO0			0x0000020c
++#define SCALER6_DISP_LBM_ISO1			0x00000210
++#define SCALER6_DISP_LBM_ISO2			0x00000214
++#define SCALER6_DISP_COB_ISO0			0x00000218
++#define SCALER6_DISP_COB_ISO1			0x0000021c
++#define SCALER6_DISP_COB_ISO2			0x00000220
++#define SCALER6_BAD_COB				0x00000224
++#define SCALER6_BAD_LBM				0x00000228
++#define SCALER6_BAD_UPM				0x0000022c
++#define SCALER6_BAD_AXI				0x00000230
++
+ # define VC4_HDMI_SW_RESET_FORMAT_DETECT	BIT(1)
+ # define VC4_HDMI_SW_RESET_HDMI			BIT(0)
+ 
+@@ -1131,4 +1255,61 @@ enum hvs_pixel_format {
+ #define SCALER_PITCH0_TILE_WIDTH_R_MASK		VC4_MASK(6, 0)
+ #define SCALER_PITCH0_TILE_WIDTH_R_SHIFT	0
+ 
++#define SCALER6_CTL0_END			BIT(31)
++#define SCALER6_CTL0_VALID			BIT(30)
++#define SCALER6_CTL0_NEXT_MASK			VC4_MASK(29, 24)
++#define SCALER6_CTL0_RGB_TRANS			BIT(23)
++#define SCALER6_CTL0_ADDR_MODE_MASK		VC4_MASK(22, 20)
++#define SCALER6_CTL0_ADDR_MODE_LINEAR		0
++#define SCALER6_CTL0_ADDR_MODE_128B		1
++#define SCALER6_CTL0_ADDR_MODE_256B		2
++#define SCALER6_CTL0_ADDR_MODE_MAP8		3
++#define SCALER6_CTL0_ADDR_MODE_UIF		4
++
++#define SCALER6_CTL0_ALPHA_MASK_MASK		VC4_MASK(19, 18)
++#define SCALER6_CTL0_UNITY			BIT(15)
++#define SCALER6_CTL0_ORDERRGBA_MASK		VC4_MASK(14, 13)
++#define SCALER6_CTL0_SCL1_MODE_MASK		VC4_MASK(10, 8)
++#define SCALER6_CTL0_SCL0_MODE_MASK		VC4_MASK(7, 5)
++#define SCALER6_CTL0_PIXEL_FORMAT_MASK		VC4_MASK(4, 0)
++
++#define SCALER6_POS0_START_Y_MASK		VC4_MASK(28, 16)
++#define SCALER6_POS0_HFLIP			BIT(15)
++#define SCALER6_POS0_START_X_MASK		VC4_MASK(12, 0)
++
++#define SCALER6_CTL2_ALPHA_MODE_MASK		VC4_MASK(31, 30)
++#define SCALER6_CTL2_ALPHA_PREMULT		BIT(29)
++#define SCALER6_CTL2_ALPHA_MIX			BIT(28)
++#define SCALER6_CTL2_BFG			BIT(26)
++#define SCALER6_CTL2_CSC_ENABLE			BIT(25)
++#define SCALER6_CTL2_BRCM_CFC_CONTROL_MASK	VC4_MASK(18, 16)
++#define SCALER6_CTL2_ALPHA_MASK			VC4_MASK(15, 4)
++
++#define SCALER6_POS1_SCL_LINES_MASK		VC4_MASK(28, 16)
++#define SCALER6_POS1_SCL_WIDTH_MASK		VC4_MASK(12, 0)
++
++#define SCALER6_POS2_SRC_LINES_MASK		VC4_MASK(28, 16)
++#define SCALER6_POS2_SRC_WIDTH_MASK		VC4_MASK(12, 0)
++
++#define SCALER6_PTR0_VFLIP			BIT(31)
++#define SCALER6_PTR0_UPM_BASE_MASK		VC4_MASK(28, 16)
++#define SCALER6_PTR0_UPM_HANDLE_MASK		VC4_MASK(14, 10)
++#define SCALER6_PTR0_UPM_BUFF_SIZE_MASK		VC4_MASK(9, 8)
++#define SCALER6_PTR0_UPM_BUFF_SIZE_16_LINES	3
++#define SCALER6_PTR0_UPM_BUFF_SIZE_8_LINES	2
++#define SCALER6_PTR0_UPM_BUFF_SIZE_4_LINES	1
++#define SCALER6_PTR0_UPM_BUFF_SIZE_2_LINES	0
++#define SCALER6_PTR0_UPPER_ADDR_MASK		VC4_MASK(7, 0)
++
++#define SCALER6_PTR2_ALPHA_BPP_MASK		VC4_MASK(31, 31)
++#define SCALER6_PTR2_ALPHA_BPP_1BPP		1
++#define SCALER6_PTR2_ALPHA_BPP_8BPP		0
++#define SCALER6_PTR2_ALPHA_ORDER_MASK		VC4_MASK(30, 30)
++#define SCALER6_PTR2_ALPHA_ORDER_MSB_TO_LSB	1
++#define SCALER6_PTR2_ALPHA_ORDER_LSB_TO_MSB	0
++#define SCALER6_PTR2_ALPHA_OFFS_MASK		VC4_MASK(29, 27)
++#define SCALER6_PTR2_LSKIP_MASK			VC4_MASK(26, 24)
++#define SCALER6_PTR2_PITCH_MASK			VC4_MASK(16, 0)
++#define SCALER6_PTR2_FETCH_COUNT_MASK		VC4_MASK(26, 16)
++
+ #endif /* VC4_REGS_H */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0964-drm-vc4-crtc-Add-support-for-BCM2712-PixelValves.patch b/target/linux/bcm27xx/patches-6.1/950-0964-drm-vc4-crtc-Add-support-for-BCM2712-PixelValves.patch
new file mode 100644
index 0000000000..1870158e06
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0964-drm-vc4-crtc-Add-support-for-BCM2712-PixelValves.patch
@@ -0,0 +1,144 @@
+From 000f1b7d4dc5b515c755ee25db301e26bded00e1 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 15:33:23 +0100
+Subject: [PATCH] drm/vc4: crtc: Add support for BCM2712 PixelValves
+
+The PixelValves found on the BCM2712 are similar to the ones found in
+the previous generation.
+
+Compared to BCM2711, the pixelvalves only drive one HDMI controller each
+and HDMI1 PixelValve has a FIFO long enough to support 4k at 60Hz.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_crtc.c | 53 ++++++++++++++++++++++++++++++++--
+ drivers/gpu/drm/vc4/vc4_drv.h  |  2 ++
+ drivers/gpu/drm/vc4/vc4_regs.h |  5 ++++
+ 3 files changed, 58 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_crtc.c
++++ b/drivers/gpu/drm/vc4/vc4_crtc.c
+@@ -239,6 +239,11 @@ static u32 vc4_get_fifo_full_level(struc
+ 	const struct vc4_crtc_data *crtc_data = vc4_crtc_to_vc4_crtc_data(vc4_crtc);
+ 	const struct vc4_pv_data *pv_data = vc4_crtc_to_vc4_pv_data(vc4_crtc);
+ 	struct vc4_dev *vc4 = to_vc4_dev(vc4_crtc->base.dev);
++
++	/*
++	 * NOTE: Could we use register 0x68 (PV_HW_CFG1) to get the FIFO
++	 * size?
++	 */
+ 	u32 fifo_len_bytes = pv_data->fifo_depth;
+ 
+ 	/*
+@@ -393,6 +398,12 @@ static void vc4_crtc_config_pv(struct dr
+ 
+ 	vc4_crtc_pixelvalve_reset(crtc);
+ 
++	/*
++	 * NOTE: The BCM2712 has a H_OTE (Horizontal Odd Timing Enable)
++	 * bit that, when set, will allow to specify the timings in
++	 * pixels instead of cycles, thus allowing to specify odd
++	 * timings.
++	 */
+ 	CRTC_WRITE(PV_HORZA,
+ 		   VC4_SET_FIELD((mode->htotal - mode->hsync_end) * pixel_rep / ppc,
+ 				 PV_HORZA_HBP) |
+@@ -462,11 +473,17 @@ static void vc4_crtc_config_pv(struct dr
+ 	if (is_dsi)
+ 		CRTC_WRITE(PV_HACT_ACT, mode->hdisplay * pixel_rep);
+ 
+-	if (vc4->gen == VC4_GEN_5)
++	if (vc4->gen >= VC4_GEN_5)
+ 		CRTC_WRITE(PV_MUX_CFG,
+ 			   VC4_SET_FIELD(PV_MUX_CFG_RGB_PIXEL_MUX_MODE_NO_SWAP,
+ 					 PV_MUX_CFG_RGB_PIXEL_MUX_MODE));
+ 
++	if (vc4->gen >= VC4_GEN_6)
++		CRTC_WRITE(PV_PIPE_INIT_CTRL,
++			   VC4_SET_FIELD(1, PV_PIPE_INIT_CTRL_PV_INIT_WIDTH) |
++			   VC4_SET_FIELD(1, PV_PIPE_INIT_CTRL_PV_INIT_IDLE) |
++			   PV_PIPE_INIT_CTRL_PV_INIT_EN);
++
+ 	CRTC_WRITE(PV_CONTROL, PV_CONTROL_FIFO_CLR |
+ 		   vc4_crtc_get_fifo_full_level_bits(vc4_crtc, format) |
+ 		   VC4_SET_FIELD(format, PV_CONTROL_FORMAT) |
+@@ -565,7 +582,11 @@ int vc4_crtc_disable_at_boot(struct drm_
+ 	if (!(of_device_is_compatible(vc4_crtc->pdev->dev.of_node,
+ 				      "brcm,bcm2711-pixelvalve2") ||
+ 	      of_device_is_compatible(vc4_crtc->pdev->dev.of_node,
+-				      "brcm,bcm2711-pixelvalve4")))
++				      "brcm,bcm2711-pixelvalve4") ||
++	      of_device_is_compatible(vc4_crtc->pdev->dev.of_node,
++				      "brcm,bcm2712-pixelvalve0") ||
++	      of_device_is_compatible(vc4_crtc->pdev->dev.of_node,
++				      "brcm,bcm2712-pixelvalve1")))
+ 		return 0;
+ 
+ 	if (!(CRTC_READ(PV_CONTROL) & PV_CONTROL_EN))
+@@ -1304,6 +1325,32 @@ const struct vc4_pv_data bcm2711_pv4_dat
+ 	},
+ };
+ 
++const struct vc4_pv_data bcm2712_pv0_data = {
++	.base = {
++		.debugfs_name = "crtc0_regs",
++		.hvs_available_channels = BIT(0),
++		.hvs_output = 0,
++	},
++	.fifo_depth = 64,
++	.pixels_per_clock = 2,
++	.encoder_types = {
++		[0] = VC4_ENCODER_TYPE_HDMI0,
++	},
++};
++
++const struct vc4_pv_data bcm2712_pv1_data = {
++	.base = {
++		.debugfs_name = "crtc1_regs",
++		.hvs_available_channels = BIT(1),
++		.hvs_output = 1,
++	},
++	.fifo_depth = 64,
++	.pixels_per_clock = 2,
++	.encoder_types = {
++		[0] = VC4_ENCODER_TYPE_HDMI1,
++	},
++};
++
+ static const struct of_device_id vc4_crtc_dt_match[] = {
+ 	{ .compatible = "brcm,bcm2835-pixelvalve0", .data = &bcm2835_pv0_data },
+ 	{ .compatible = "brcm,bcm2835-pixelvalve1", .data = &bcm2835_pv1_data },
+@@ -1313,6 +1360,8 @@ static const struct of_device_id vc4_crt
+ 	{ .compatible = "brcm,bcm2711-pixelvalve2", .data = &bcm2711_pv2_data },
+ 	{ .compatible = "brcm,bcm2711-pixelvalve3", .data = &bcm2711_pv3_data },
+ 	{ .compatible = "brcm,bcm2711-pixelvalve4", .data = &bcm2711_pv4_data },
++	{ .compatible = "brcm,bcm2712-pixelvalve0", .data = &bcm2712_pv0_data },
++	{ .compatible = "brcm,bcm2712-pixelvalve1", .data = &bcm2712_pv1_data },
+ 	{}
+ };
+ 
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -583,6 +583,8 @@ extern const struct vc4_pv_data bcm2711_
+ extern const struct vc4_pv_data bcm2711_pv2_data;
+ extern const struct vc4_pv_data bcm2711_pv3_data;
+ extern const struct vc4_pv_data bcm2711_pv4_data;
++extern const struct vc4_pv_data bcm2712_pv0_data;
++extern const struct vc4_pv_data bcm2712_pv1_data;
+ 
+ struct vc5_gamma_entry {
+ 	u32 x_c_terms;
+--- a/drivers/gpu/drm/vc4/vc4_regs.h
++++ b/drivers/gpu/drm/vc4/vc4_regs.h
+@@ -215,6 +215,11 @@
+ # define PV_MUX_CFG_RGB_PIXEL_MUX_MODE_SHIFT	2
+ # define PV_MUX_CFG_RGB_PIXEL_MUX_MODE_NO_SWAP	8
+ 
++#define PV_PIPE_INIT_CTRL			0x94
++# define PV_PIPE_INIT_CTRL_PV_INIT_WIDTH_MASK	VC4_MASK(11, 8)
++# define PV_PIPE_INIT_CTRL_PV_INIT_IDLE_MASK	VC4_MASK(7, 4)
++# define PV_PIPE_INIT_CTRL_PV_INIT_EN		BIT(0)
++
+ #define SCALER_CHANNELS_COUNT			3
+ 
+ #define SCALER_DISPCTRL                         0x00000000
diff --git a/target/linux/bcm27xx/patches-6.1/950-0965-drm-vc4-hdmi-Add-support-for-BCM2712-HDMI-controller.patch b/target/linux/bcm27xx/patches-6.1/950-0965-drm-vc4-hdmi-Add-support-for-BCM2712-HDMI-controller.patch
new file mode 100644
index 0000000000..7cb4e5661d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0965-drm-vc4-hdmi-Add-support-for-BCM2712-HDMI-controller.patch
@@ -0,0 +1,1057 @@
+From 1bb54596ae2a9a36f4aa9f8f2ba941320f463811 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 15:34:30 +0100
+Subject: [PATCH] drm/vc4: hdmi: Add support for BCM2712 HDMI controllers
+
+The HDMI controllers found in the BCM2712 are largely the ones found in
+the BCM2711 with a different PHY.
+
+There's some difference with how timings are split between registers,
+and HDMI1 is now able to run at 4k/60Hz.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hdmi.c      |  82 +++-
+ drivers/gpu/drm/vc4/vc4_hdmi.h      |   4 +
+ drivers/gpu/drm/vc4/vc4_hdmi_phy.c  | 640 ++++++++++++++++++++++++++++
+ drivers/gpu/drm/vc4/vc4_hdmi_regs.h | 217 ++++++++++
+ 4 files changed, 937 insertions(+), 6 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hdmi.c
++++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
+@@ -1127,6 +1127,7 @@ static void vc4_hdmi_encoder_post_crtc_d
+ {
+ 	struct vc4_hdmi *vc4_hdmi = encoder_to_vc4_hdmi(encoder);
+ 	struct drm_device *drm = vc4_hdmi->connector.dev;
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
+ 	unsigned long flags;
+ 	int idx;
+ 
+@@ -1143,14 +1144,25 @@ static void vc4_hdmi_encoder_post_crtc_d
+ 
+ 	HDMI_WRITE(HDMI_VID_CTL, HDMI_READ(HDMI_VID_CTL) | VC4_HD_VID_CTL_CLRRGB);
+ 
++	if (vc4->gen >= VC4_GEN_6)
++		HDMI_WRITE(HDMI_VID_CTL, HDMI_READ(HDMI_VID_CTL) |
++			   VC4_HD_VID_CTL_BLANKPIX);
++
+ 	spin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);
+ 
+ 	mdelay(1);
+ 
+-	spin_lock_irqsave(&vc4_hdmi->hw_lock, flags);
+-	HDMI_WRITE(HDMI_VID_CTL,
+-		   HDMI_READ(HDMI_VID_CTL) & ~VC4_HD_VID_CTL_ENABLE);
+-	spin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);
++	/*
++	 * TODO: This should work on BCM2712, but doesn't for some
++	 * reason and result in a system lockup.
++	 */
++	if (vc4->gen < VC4_GEN_6) {
++		spin_lock_irqsave(&vc4_hdmi->hw_lock, flags);
++		HDMI_WRITE(HDMI_VID_CTL,
++			   HDMI_READ(HDMI_VID_CTL) &
++			   ~VC4_HD_VID_CTL_ENABLE);
++		spin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);
++	}
+ 
+ 	vc4_hdmi_disable_scrambling(encoder);
+ 
+@@ -1757,7 +1769,6 @@ static void vc4_hdmi_encoder_pre_crtc_co
+ 		goto err_put_runtime_pm;
+ 	}
+ 
+-
+ 	vc4_hdmi_cec_update_clk_div(vc4_hdmi);
+ 
+ 	if (tmds_char_rate > 297000000)
+@@ -1862,6 +1873,7 @@ static void vc4_hdmi_encoder_post_crtc_e
+ 	spin_lock_irqsave(&vc4_hdmi->hw_lock, flags);
+ 
+ 	HDMI_WRITE(HDMI_VID_CTL,
++		   HDMI_READ(HDMI_VID_CTL) |
+ 		   VC4_HD_VID_CTL_ENABLE |
+ 		   VC4_HD_VID_CTL_CLRRGB |
+ 		   VC4_HD_VID_CTL_UNDERFLOW_ENABLE |
+@@ -3796,7 +3808,9 @@ static int vc4_hdmi_bind(struct device *
+ 		return ret;
+ 
+ 	if ((of_device_is_compatible(dev->of_node, "brcm,bcm2711-hdmi0") ||
+-	     of_device_is_compatible(dev->of_node, "brcm,bcm2711-hdmi1")) &&
++	     of_device_is_compatible(dev->of_node, "brcm,bcm2711-hdmi1") ||
++	     of_device_is_compatible(dev->of_node, "brcm,bcm2712-hdmi0") ||
++	     of_device_is_compatible(dev->of_node, "brcm,bcm2712-hdmi1")) &&
+ 	    HDMI_READ(HDMI_VID_CTL) & VC4_HD_VID_CTL_ENABLE) {
+ 		clk_prepare_enable(vc4_hdmi->pixel_clock);
+ 		clk_prepare_enable(vc4_hdmi->hsm_clock);
+@@ -3931,10 +3945,66 @@ static const struct vc4_hdmi_variant bcm
+ 	.hp_detect		= vc5_hdmi_hp_detect,
+ };
+ 
++static const struct vc4_hdmi_variant bcm2712_hdmi0_variant = {
++	.encoder_type		= VC4_ENCODER_TYPE_HDMI0,
++	.debugfs_name		= "hdmi0_regs",
++	.card_name		= "vc4-hdmi-0",
++	.max_pixel_clock	= 600000000,
++	.registers		= vc6_hdmi_hdmi0_fields,
++	.num_registers		= ARRAY_SIZE(vc6_hdmi_hdmi0_fields),
++	.phy_lane_mapping	= {
++		PHY_LANE_0,
++		PHY_LANE_1,
++		PHY_LANE_2,
++		PHY_LANE_CK,
++	},
++	.unsupported_odd_h_timings	= true,
++	.external_irq_controller	= true,
++
++	.init_resources		= vc5_hdmi_init_resources,
++	.csc_setup		= vc5_hdmi_csc_setup,
++	.reset			= vc5_hdmi_reset,
++	.set_timings		= vc5_hdmi_set_timings,
++	.phy_init		= vc6_hdmi_phy_init,
++	.phy_disable		= vc6_hdmi_phy_disable,
++	.channel_map		= vc5_hdmi_channel_map,
++	.supports_hdr		= true,
++	.hp_detect		= vc5_hdmi_hp_detect,
++};
++
++static const struct vc4_hdmi_variant bcm2712_hdmi1_variant = {
++	.encoder_type		= VC4_ENCODER_TYPE_HDMI1,
++	.debugfs_name		= "hdmi1_regs",
++	.card_name		= "vc4-hdmi-1",
++	.max_pixel_clock	= 600000000,
++	.registers		= vc6_hdmi_hdmi1_fields,
++	.num_registers		= ARRAY_SIZE(vc6_hdmi_hdmi1_fields),
++	.phy_lane_mapping	= {
++		PHY_LANE_0,
++		PHY_LANE_1,
++		PHY_LANE_2,
++		PHY_LANE_CK,
++	},
++	.unsupported_odd_h_timings	= true,
++	.external_irq_controller	= true,
++
++	.init_resources		= vc5_hdmi_init_resources,
++	.csc_setup		= vc5_hdmi_csc_setup,
++	.reset			= vc5_hdmi_reset,
++	.set_timings		= vc5_hdmi_set_timings,
++	.phy_init		= vc6_hdmi_phy_init,
++	.phy_disable		= vc6_hdmi_phy_disable,
++	.channel_map		= vc5_hdmi_channel_map,
++	.supports_hdr		= true,
++	.hp_detect		= vc5_hdmi_hp_detect,
++};
++
+ static const struct of_device_id vc4_hdmi_dt_match[] = {
+ 	{ .compatible = "brcm,bcm2835-hdmi", .data = &bcm2835_variant },
+ 	{ .compatible = "brcm,bcm2711-hdmi0", .data = &bcm2711_hdmi0_variant },
+ 	{ .compatible = "brcm,bcm2711-hdmi1", .data = &bcm2711_hdmi1_variant },
++	{ .compatible = "brcm,bcm2712-hdmi0", .data = &bcm2712_hdmi0_variant },
++	{ .compatible = "brcm,bcm2712-hdmi1", .data = &bcm2712_hdmi1_variant },
+ 	{}
+ };
+ 
+--- a/drivers/gpu/drm/vc4/vc4_hdmi.h
++++ b/drivers/gpu/drm/vc4/vc4_hdmi.h
+@@ -284,4 +284,8 @@ void vc5_hdmi_phy_disable(struct vc4_hdm
+ void vc5_hdmi_phy_rng_enable(struct vc4_hdmi *vc4_hdmi);
+ void vc5_hdmi_phy_rng_disable(struct vc4_hdmi *vc4_hdmi);
+ 
++void vc6_hdmi_phy_init(struct vc4_hdmi *vc4_hdmi,
++		       struct vc4_hdmi_connector_state *vc4_conn_state);
++void vc6_hdmi_phy_disable(struct vc4_hdmi *vc4_hdmi);
++
+ #endif /* _VC4_HDMI_H_ */
+--- a/drivers/gpu/drm/vc4/vc4_hdmi_phy.c
++++ b/drivers/gpu/drm/vc4/vc4_hdmi_phy.c
+@@ -125,6 +125,48 @@
+ #define VC4_HDMI_RM_FORMAT_SHIFT_SHIFT			24
+ #define VC4_HDMI_RM_FORMAT_SHIFT_MASK			VC4_MASK(25, 24)
+ 
++#define VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_BG_PWRUP	BIT(8)
++#define VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_LDO_PWRUP	BIT(7)
++#define VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_BIAS_PWRUP	BIT(6)
++#define VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_RNDGEN_PWRUP	BIT(4)
++#define VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_TX_CK_PWRUP	BIT(3)
++#define VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_TX_2_PWRUP	BIT(2)
++#define VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_TX_1_PWRUP	BIT(1)
++#define VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_TX_0_PWRUP	BIT(0)
++
++#define VC6_HDMI_TX_PHY_PLL_REFCLK_REFCLK_SEL_CMOS	BIT(13)
++#define VC6_HDMI_TX_PHY_PLL_REFCLK_REFFRQ_MASK		VC4_MASK(9, 0)
++
++#define VC6_HDMI_TX_PHY_PLL_POST_KDIV_CLK0_SEL_MASK	VC4_MASK(3, 2)
++#define VC6_HDMI_TX_PHY_PLL_POST_KDIV_KDIV_MASK		VC4_MASK(1, 0)
++
++#define VC6_HDMI_TX_PHY_PLL_VCOCLK_DIV_VCODIV_EN	BIT(10)
++#define VC6_HDMI_TX_PHY_PLL_VCOCLK_DIV_VCODIV_MASK	VC4_MASK(9, 0)
++
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_CTL_MASK	VC4_MASK(31, 28)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_ENABLE_MASK		VC4_MASK(27, 27)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_RATE_CTL_MASK	VC4_MASK(26, 26)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_POST_TAP_EN_MASK	VC4_MASK(25, 25)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_LDMOS_BIAS_CTL_MASK	VC4_MASK(24, 23)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_COM_MODE_LDMOS_EN_MASK	VC4_MASK(22, 22)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EDGE_SEL_MASK		VC4_MASK(21, 21)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_HS_EN_MASK	VC4_MASK(20, 20)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_TERM_CTL_MASK		VC4_MASK(19, 18)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_EN_MASK	VC4_MASK(17, 17)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_EN_MASK	VC4_MASK(16, 16)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_CTL_MASK	VC4_MASK(15, 12)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_HS_EN_MASK	VC4_MASK(11, 11)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_MAIN_TAP_CURRENT_SELECT_MASK	VC4_MASK(10, 8)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_POST_TAP_CURRENT_SELECT_MASK	VC4_MASK(7, 5)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_LOADING_MASK	VC4_MASK(4, 3)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_DRIVING_MASK	VC4_MASK(2, 1)
++#define VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_PRE_TAP_EN_MASK	VC4_MASK(0, 0)
++
++#define VC6_HDMI_TX_PHY_PLL_RESET_CTL_PLL_PLLPOST_RESETB	BIT(1)
++#define VC6_HDMI_TX_PHY_PLL_RESET_CTL_PLL_RESETB	BIT(0)
++
++#define VC6_HDMI_TX_PHY_PLL_POWERUP_CTL_PLL_PWRUP	BIT(0)
++
+ #define OSCILLATOR_FREQUENCY	54000000
+ 
+ void vc4_hdmi_phy_init(struct vc4_hdmi *vc4_hdmi,
+@@ -558,3 +600,601 @@ void vc5_hdmi_phy_rng_disable(struct vc4
+ 		   VC4_HDMI_TX_PHY_POWERDOWN_CTL_RNDGEN_PWRDN);
+ 	spin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);
+ }
++
++#define VC6_VCO_MIN_FREQ	(8ULL * 1000 * 1000 * 1000)
++#define VC6_VCO_MAX_FREQ	(12ULL * 1000 * 1000 * 1000)
++
++static unsigned long long
++vc6_phy_get_vco_freq(unsigned long long tmds_rate, unsigned int *vco_div)
++{
++	unsigned int min_div;
++	unsigned int max_div;
++	unsigned int div;
++
++	div = 0;
++	while (tmds_rate * div * 10 < VC6_VCO_MIN_FREQ)
++		div++;
++	min_div = div;
++
++	while (tmds_rate * (div + 1) * 10 < VC6_VCO_MAX_FREQ)
++		div++;
++	max_div = div;
++
++	div = min_div + (max_div - min_div) / 2;
++
++	*vco_div = div;
++	return tmds_rate * div * 10;
++}
++
++struct vc6_phy_lane_settings {
++	unsigned int ext_current_ctl:4;
++	unsigned int ffe_enable:1;
++	unsigned int slew_rate_ctl:1;
++	unsigned int ffe_post_tap_en:1;
++	unsigned int ldmos_bias_ctl:2;
++	unsigned int com_mode_ldmos_en:1;
++	unsigned int edge_sel:1;
++	unsigned int ext_current_src_hs_en:1;
++	unsigned int term_ctl:2;
++	unsigned int ext_current_src_en:1;
++	unsigned int int_current_src_en:1;
++	unsigned int int_current_ctl:4;
++	unsigned int int_current_src_hs_en:1;
++	unsigned int main_tap_current_select:3;
++	unsigned int post_tap_current_select:3;
++	unsigned int slew_ctl_slow_loading:2;
++	unsigned int slew_ctl_slow_driving:2;
++	unsigned int ffe_pre_tap_en:1;
++};
++
++struct vc6_phy_settings {
++	unsigned long long min_rate;
++	unsigned long long max_rate;
++	struct vc6_phy_lane_settings channel[3];
++	struct vc6_phy_lane_settings clock;
++};
++
++static const struct vc6_phy_settings vc6_hdmi_phy_settings[] = {
++	{
++		0, 222000000,
++		{
++			{
++				/* 200mA */
++				.ext_current_ctl = 8,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* 200mA */
++				.int_current_ctl = 8,
++
++				/* 17.6 mA */
++				.main_tap_current_select = 7,
++			},
++			{
++				/* 200mA */
++				.ext_current_ctl = 8,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* 200mA */
++				.int_current_ctl = 8,
++
++				/* 17.6 mA */
++				.main_tap_current_select = 7,
++			},
++			{
++				/* 200mA */
++				.ext_current_ctl = 8,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* 200mA */
++				.int_current_ctl = 8,
++
++				/* 17.6 mA */
++				.main_tap_current_select = 7,
++			},
++		},
++		{
++			/* 200mA */
++			.ext_current_ctl = 8,
++
++			/* 0.85V */
++			.ldmos_bias_ctl = 1,
++
++			/* Enable External Current Source */
++			.ext_current_src_en = 1,
++
++			/* 200mA */
++			.int_current_ctl = 8,
++
++			/* 17.6 mA */
++			.main_tap_current_select = 7,
++		},
++	},
++	{
++		222000001, 297000000,
++		{
++			{
++				/* 200mA and 180mA ?! */
++				.ext_current_ctl = 12,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* 100 Ohm */
++				.term_ctl = 1,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* Enable Internal Current Source */
++				.int_current_src_en = 1,
++			},
++			{
++				/* 200mA and 180mA ?! */
++				.ext_current_ctl = 12,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* 100 Ohm */
++				.term_ctl = 1,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* Enable Internal Current Source */
++				.int_current_src_en = 1,
++			},
++			{
++				/* 200mA and 180mA ?! */
++				.ext_current_ctl = 12,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* 100 Ohm */
++				.term_ctl = 1,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* Enable Internal Current Source */
++				.int_current_src_en = 1,
++			},
++		},
++		{
++			/* 200mA and 180mA ?! */
++			.ext_current_ctl = 12,
++
++			/* 0.85V */
++			.ldmos_bias_ctl = 1,
++
++			/* 100 Ohm */
++			.term_ctl = 1,
++
++			/* Enable External Current Source */
++			.ext_current_src_en = 1,
++
++			/* Enable Internal Current Source */
++			.int_current_src_en = 1,
++
++			/* Internal Current Source Half Swing Enable*/
++			.int_current_src_hs_en = 1,
++		},
++	},
++	{
++		297000001, 597000044,
++		{
++			{
++				/* 200mA */
++				.ext_current_ctl = 8,
++
++				/* Normal Slew Rate Control */
++				.slew_rate_ctl = 1,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* 50 Ohms */
++				.term_ctl = 3,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* Enable Internal Current Source */
++				.int_current_src_en = 1,
++
++				/* 200mA */
++				.int_current_ctl = 8,
++
++				/* 17.6 mA */
++				.main_tap_current_select = 7,
++			},
++			{
++				/* 200mA */
++				.ext_current_ctl = 8,
++
++				/* Normal Slew Rate Control */
++				.slew_rate_ctl = 1,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* 50 Ohms */
++				.term_ctl = 3,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* Enable Internal Current Source */
++				.int_current_src_en = 1,
++
++				/* 200mA */
++				.int_current_ctl = 8,
++
++				/* 17.6 mA */
++				.main_tap_current_select = 7,
++			},
++			{
++				/* 200mA */
++				.ext_current_ctl = 8,
++
++				/* Normal Slew Rate Control */
++				.slew_rate_ctl = 1,
++
++				/* 0.85V */
++				.ldmos_bias_ctl = 1,
++
++				/* 50 Ohms */
++				.term_ctl = 3,
++
++				/* Enable External Current Source */
++				.ext_current_src_en = 1,
++
++				/* Enable Internal Current Source */
++				.int_current_src_en = 1,
++
++				/* 200mA */
++				.int_current_ctl = 8,
++
++				/* 17.6 mA */
++				.main_tap_current_select = 7,
++			},
++		},
++		{
++			/* 200mA */
++			.ext_current_ctl = 8,
++
++			/* Normal Slew Rate Control */
++			.slew_rate_ctl = 1,
++
++			/* 0.85V */
++			.ldmos_bias_ctl = 1,
++
++			/* External Current Source Half Swing Enable*/
++			.ext_current_src_hs_en = 1,
++
++			/* 50 Ohms */
++			.term_ctl = 3,
++
++			/* Enable External Current Source */
++			.ext_current_src_en = 1,
++
++			/* Enable Internal Current Source */
++			.int_current_src_en = 1,
++
++			/* 200mA */
++			.int_current_ctl = 8,
++
++			/* Internal Current Source Half Swing Enable*/
++			.int_current_src_hs_en = 1,
++
++			/* 17.6 mA */
++			.main_tap_current_select = 7,
++		},
++	},
++};
++
++static const struct vc6_phy_settings *
++vc6_phy_get_settings(unsigned long long tmds_rate)
++{
++	unsigned int count = ARRAY_SIZE(vc6_hdmi_phy_settings);
++	unsigned int i;
++
++	for (i = 0; i < count; i++) {
++		const struct vc6_phy_settings *s = &vc6_hdmi_phy_settings[i];
++
++		if (tmds_rate >= s->min_rate && tmds_rate <= s->max_rate)
++			return s;
++	}
++
++	/*
++	 * If the pixel clock exceeds our max setting, try the max
++	 * setting anyway.
++	 */
++	return &vc6_hdmi_phy_settings[count - 1];
++}
++
++static const struct vc6_phy_lane_settings *
++vc6_phy_get_channel_settings(enum vc4_hdmi_phy_channel chan,
++			     unsigned long long tmds_rate)
++{
++	const struct vc6_phy_settings *settings = vc6_phy_get_settings(tmds_rate);
++
++	if (chan == PHY_LANE_CK)
++		return &settings->clock;
++
++	return &settings->channel[chan];
++}
++
++static void vc6_hdmi_reset_phy(struct vc4_hdmi *vc4_hdmi)
++{
++	lockdep_assert_held(&vc4_hdmi->hw_lock);
++
++	HDMI_WRITE(HDMI_TX_PHY_RESET_CTL, 0);
++	HDMI_WRITE(HDMI_TX_PHY_POWERUP_CTL, 0);
++}
++
++void vc6_hdmi_phy_init(struct vc4_hdmi *vc4_hdmi,
++		       struct vc4_hdmi_connector_state *conn_state)
++{
++	const struct vc6_phy_lane_settings *chan0_settings;
++	const struct vc6_phy_lane_settings *chan1_settings;
++	const struct vc6_phy_lane_settings *chan2_settings;
++	const struct vc6_phy_lane_settings *clock_settings;
++	const struct vc4_hdmi_variant *variant = vc4_hdmi->variant;
++	unsigned long long pixel_freq = conn_state->tmds_char_rate;
++	unsigned long long vco_freq;
++	unsigned char word_sel;
++	unsigned long flags;
++	unsigned int vco_div;
++
++	vco_freq = vc6_phy_get_vco_freq(pixel_freq, &vco_div);
++
++	spin_lock_irqsave(&vc4_hdmi->hw_lock, flags);
++
++	vc6_hdmi_reset_phy(vc4_hdmi);
++
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_0, 0x810c6000);
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_1, 0x00b8c451);
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_2, 0x46402e31);
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_3, 0x00b8c005);
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_4, 0x42410261);
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_5, 0xcc021001);
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_6, 0xc8301c80);
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_7, 0xb0804444);
++	HDMI_WRITE(HDMI_TX_PHY_PLL_MISC_8, 0xf80f8000);
++
++	HDMI_WRITE(HDMI_TX_PHY_PLL_REFCLK,
++		   VC6_HDMI_TX_PHY_PLL_REFCLK_REFCLK_SEL_CMOS |
++		   VC4_SET_FIELD(54, VC6_HDMI_TX_PHY_PLL_REFCLK_REFFRQ));
++
++	HDMI_WRITE(HDMI_TX_PHY_RESET_CTL, 0x7f);
++
++	HDMI_WRITE(HDMI_RM_OFFSET,
++		   VC4_HDMI_RM_OFFSET_ONLY |
++		   VC4_SET_FIELD(phy_get_rm_offset(vco_freq),
++				 VC4_HDMI_RM_OFFSET_OFFSET));
++
++	HDMI_WRITE(HDMI_TX_PHY_PLL_VCOCLK_DIV,
++		   VC6_HDMI_TX_PHY_PLL_VCOCLK_DIV_VCODIV_EN |
++		   VC4_SET_FIELD(vco_div,
++				 VC6_HDMI_TX_PHY_PLL_VCOCLK_DIV_VCODIV));
++
++	HDMI_WRITE(HDMI_TX_PHY_PLL_CFG,
++		   VC4_SET_FIELD(0, VC4_HDMI_TX_PHY_PLL_CFG_PDIV));
++
++	HDMI_WRITE(HDMI_TX_PHY_PLL_POST_KDIV,
++		   VC4_SET_FIELD(2, VC6_HDMI_TX_PHY_PLL_POST_KDIV_CLK0_SEL) |
++		   VC4_SET_FIELD(1, VC6_HDMI_TX_PHY_PLL_POST_KDIV_KDIV));
++
++	chan0_settings =
++		vc6_phy_get_channel_settings(variant->phy_lane_mapping[PHY_LANE_0],
++					     pixel_freq);
++	HDMI_WRITE(HDMI_TX_PHY_CTL_0,
++		   VC4_SET_FIELD(chan0_settings->ext_current_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_CTL) |
++		   VC4_SET_FIELD(chan0_settings->ffe_enable,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_ENABLE) |
++		   VC4_SET_FIELD(chan0_settings->slew_rate_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_RATE_CTL) |
++		   VC4_SET_FIELD(chan0_settings->ffe_post_tap_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_POST_TAP_EN) |
++		   VC4_SET_FIELD(chan0_settings->ldmos_bias_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_LDMOS_BIAS_CTL) |
++		   VC4_SET_FIELD(chan0_settings->com_mode_ldmos_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_COM_MODE_LDMOS_EN) |
++		   VC4_SET_FIELD(chan0_settings->edge_sel,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EDGE_SEL) |
++		   VC4_SET_FIELD(chan0_settings->ext_current_src_hs_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_HS_EN) |
++		   VC4_SET_FIELD(chan0_settings->term_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_TERM_CTL) |
++		   VC4_SET_FIELD(chan0_settings->ext_current_src_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_EN) |
++		   VC4_SET_FIELD(chan0_settings->int_current_src_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_EN) |
++		   VC4_SET_FIELD(chan0_settings->int_current_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_CTL) |
++		   VC4_SET_FIELD(chan0_settings->int_current_src_hs_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_HS_EN) |
++		   VC4_SET_FIELD(chan0_settings->main_tap_current_select,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_MAIN_TAP_CURRENT_SELECT) |
++		   VC4_SET_FIELD(chan0_settings->post_tap_current_select,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_POST_TAP_CURRENT_SELECT) |
++		   VC4_SET_FIELD(chan0_settings->slew_ctl_slow_loading,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_LOADING) |
++		   VC4_SET_FIELD(chan0_settings->slew_ctl_slow_driving,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_DRIVING) |
++		   VC4_SET_FIELD(chan0_settings->ffe_pre_tap_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_PRE_TAP_EN));
++
++	chan1_settings =
++		vc6_phy_get_channel_settings(variant->phy_lane_mapping[PHY_LANE_1],
++					     pixel_freq);
++	HDMI_WRITE(HDMI_TX_PHY_CTL_1,
++		   VC4_SET_FIELD(chan1_settings->ext_current_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_CTL) |
++		   VC4_SET_FIELD(chan1_settings->ffe_enable,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_ENABLE) |
++		   VC4_SET_FIELD(chan1_settings->slew_rate_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_RATE_CTL) |
++		   VC4_SET_FIELD(chan1_settings->ffe_post_tap_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_POST_TAP_EN) |
++		   VC4_SET_FIELD(chan1_settings->ldmos_bias_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_LDMOS_BIAS_CTL) |
++		   VC4_SET_FIELD(chan1_settings->com_mode_ldmos_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_COM_MODE_LDMOS_EN) |
++		   VC4_SET_FIELD(chan1_settings->edge_sel,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EDGE_SEL) |
++		   VC4_SET_FIELD(chan1_settings->ext_current_src_hs_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_HS_EN) |
++		   VC4_SET_FIELD(chan1_settings->term_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_TERM_CTL) |
++		   VC4_SET_FIELD(chan1_settings->ext_current_src_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_EN) |
++		   VC4_SET_FIELD(chan1_settings->int_current_src_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_EN) |
++		   VC4_SET_FIELD(chan1_settings->int_current_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_CTL) |
++		   VC4_SET_FIELD(chan1_settings->int_current_src_hs_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_HS_EN) |
++		   VC4_SET_FIELD(chan1_settings->main_tap_current_select,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_MAIN_TAP_CURRENT_SELECT) |
++		   VC4_SET_FIELD(chan1_settings->post_tap_current_select,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_POST_TAP_CURRENT_SELECT) |
++		   VC4_SET_FIELD(chan1_settings->slew_ctl_slow_loading,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_LOADING) |
++		   VC4_SET_FIELD(chan1_settings->slew_ctl_slow_driving,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_DRIVING) |
++		   VC4_SET_FIELD(chan1_settings->ffe_pre_tap_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_PRE_TAP_EN));
++
++	chan2_settings =
++		vc6_phy_get_channel_settings(variant->phy_lane_mapping[PHY_LANE_2],
++					     pixel_freq);
++	HDMI_WRITE(HDMI_TX_PHY_CTL_2,
++		   VC4_SET_FIELD(chan2_settings->ext_current_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_CTL) |
++		   VC4_SET_FIELD(chan2_settings->ffe_enable,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_ENABLE) |
++		   VC4_SET_FIELD(chan2_settings->slew_rate_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_RATE_CTL) |
++		   VC4_SET_FIELD(chan2_settings->ffe_post_tap_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_POST_TAP_EN) |
++		   VC4_SET_FIELD(chan2_settings->ldmos_bias_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_LDMOS_BIAS_CTL) |
++		   VC4_SET_FIELD(chan2_settings->com_mode_ldmos_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_COM_MODE_LDMOS_EN) |
++		   VC4_SET_FIELD(chan2_settings->edge_sel,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EDGE_SEL) |
++		   VC4_SET_FIELD(chan2_settings->ext_current_src_hs_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_HS_EN) |
++		   VC4_SET_FIELD(chan2_settings->term_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_TERM_CTL) |
++		   VC4_SET_FIELD(chan2_settings->ext_current_src_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_EN) |
++		   VC4_SET_FIELD(chan2_settings->int_current_src_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_EN) |
++		   VC4_SET_FIELD(chan2_settings->int_current_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_CTL) |
++		   VC4_SET_FIELD(chan2_settings->int_current_src_hs_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_HS_EN) |
++		   VC4_SET_FIELD(chan2_settings->main_tap_current_select,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_MAIN_TAP_CURRENT_SELECT) |
++		   VC4_SET_FIELD(chan2_settings->post_tap_current_select,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_POST_TAP_CURRENT_SELECT) |
++		   VC4_SET_FIELD(chan2_settings->slew_ctl_slow_loading,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_LOADING) |
++		   VC4_SET_FIELD(chan2_settings->slew_ctl_slow_driving,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_DRIVING) |
++		   VC4_SET_FIELD(chan2_settings->ffe_pre_tap_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_PRE_TAP_EN));
++
++	clock_settings =
++		vc6_phy_get_channel_settings(variant->phy_lane_mapping[PHY_LANE_CK],
++					     pixel_freq);
++	HDMI_WRITE(HDMI_TX_PHY_CTL_CK,
++		   VC4_SET_FIELD(clock_settings->ext_current_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_CTL) |
++		   VC4_SET_FIELD(clock_settings->ffe_enable,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_ENABLE) |
++		   VC4_SET_FIELD(clock_settings->slew_rate_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_RATE_CTL) |
++		   VC4_SET_FIELD(clock_settings->ffe_post_tap_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_POST_TAP_EN) |
++		   VC4_SET_FIELD(clock_settings->ldmos_bias_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_LDMOS_BIAS_CTL) |
++		   VC4_SET_FIELD(clock_settings->com_mode_ldmos_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_COM_MODE_LDMOS_EN) |
++		   VC4_SET_FIELD(clock_settings->edge_sel,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EDGE_SEL) |
++		   VC4_SET_FIELD(clock_settings->ext_current_src_hs_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_HS_EN) |
++		   VC4_SET_FIELD(clock_settings->term_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_TERM_CTL) |
++		   VC4_SET_FIELD(clock_settings->ext_current_src_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_EXT_CURRENT_SRC_EN) |
++		   VC4_SET_FIELD(clock_settings->int_current_src_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_EN) |
++		   VC4_SET_FIELD(clock_settings->int_current_ctl,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_CTL) |
++		   VC4_SET_FIELD(clock_settings->int_current_src_hs_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_INT_CURRENT_SRC_HS_EN) |
++		   VC4_SET_FIELD(clock_settings->main_tap_current_select,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_MAIN_TAP_CURRENT_SELECT) |
++		   VC4_SET_FIELD(clock_settings->post_tap_current_select,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_POST_TAP_CURRENT_SELECT) |
++		   VC4_SET_FIELD(clock_settings->slew_ctl_slow_loading,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_LOADING) |
++		   VC4_SET_FIELD(clock_settings->slew_ctl_slow_driving,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_SLEW_CTL_SLOW_DRIVING) |
++		   VC4_SET_FIELD(clock_settings->ffe_pre_tap_en,
++				 VC6_HDMI_TX_PHY_HDMI_CTRL_CHX_FFE_PRE_TAP_EN));
++
++	if (pixel_freq >= 340000000)
++		word_sel = 3;
++	else
++		word_sel = 0;
++	HDMI_WRITE(HDMI_TX_PHY_TMDS_CLK_WORD_SEL, word_sel);
++
++	HDMI_WRITE(HDMI_TX_PHY_POWERUP_CTL,
++		   VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_BG_PWRUP |
++		   VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_LDO_PWRUP |
++		   VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_BIAS_PWRUP |
++		   VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_TX_CK_PWRUP |
++		   VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_TX_2_PWRUP |
++		   VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_TX_1_PWRUP |
++		   VC6_HDMI_TX_PHY_HDMI_POWERUP_CTL_TX_0_PWRUP);
++
++	HDMI_WRITE(HDMI_TX_PHY_PLL_POWERUP_CTL,
++		   VC6_HDMI_TX_PHY_PLL_POWERUP_CTL_PLL_PWRUP);
++
++	HDMI_WRITE(HDMI_TX_PHY_PLL_RESET_CTL,
++		   HDMI_READ(HDMI_TX_PHY_PLL_RESET_CTL) &
++		   ~VC6_HDMI_TX_PHY_PLL_RESET_CTL_PLL_RESETB);
++
++	HDMI_WRITE(HDMI_TX_PHY_PLL_RESET_CTL,
++		   HDMI_READ(HDMI_TX_PHY_PLL_RESET_CTL) |
++		   VC6_HDMI_TX_PHY_PLL_RESET_CTL_PLL_RESETB);
++
++	spin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);
++}
++
++void vc6_hdmi_phy_disable(struct vc4_hdmi *vc4_hdmi)
++{
++}
+--- a/drivers/gpu/drm/vc4/vc4_hdmi_regs.h
++++ b/drivers/gpu/drm/vc4/vc4_hdmi_regs.h
+@@ -111,13 +111,30 @@ enum vc4_hdmi_field {
+ 	HDMI_TX_PHY_CTL_1,
+ 	HDMI_TX_PHY_CTL_2,
+ 	HDMI_TX_PHY_CTL_3,
++	HDMI_TX_PHY_CTL_CK,
+ 	HDMI_TX_PHY_PLL_CALIBRATION_CONFIG_1,
+ 	HDMI_TX_PHY_PLL_CALIBRATION_CONFIG_2,
+ 	HDMI_TX_PHY_PLL_CALIBRATION_CONFIG_4,
+ 	HDMI_TX_PHY_PLL_CFG,
++	HDMI_TX_PHY_PLL_CFG_PDIV,
+ 	HDMI_TX_PHY_PLL_CTL_0,
+ 	HDMI_TX_PHY_PLL_CTL_1,
++	HDMI_TX_PHY_PLL_MISC_0,
++	HDMI_TX_PHY_PLL_MISC_1,
++	HDMI_TX_PHY_PLL_MISC_2,
++	HDMI_TX_PHY_PLL_MISC_3,
++	HDMI_TX_PHY_PLL_MISC_4,
++	HDMI_TX_PHY_PLL_MISC_5,
++	HDMI_TX_PHY_PLL_MISC_6,
++	HDMI_TX_PHY_PLL_MISC_7,
++	HDMI_TX_PHY_PLL_MISC_8,
++	HDMI_TX_PHY_PLL_POST_KDIV,
++	HDMI_TX_PHY_PLL_POWERUP_CTL,
++	HDMI_TX_PHY_PLL_REFCLK,
++	HDMI_TX_PHY_PLL_RESET_CTL,
++	HDMI_TX_PHY_PLL_VCOCLK_DIV,
+ 	HDMI_TX_PHY_POWERDOWN_CTL,
++	HDMI_TX_PHY_POWERUP_CTL,
+ 	HDMI_TX_PHY_RESET_CTL,
+ 	HDMI_TX_PHY_TMDS_CLK_WORD_SEL,
+ 	HDMI_VEC_INTERFACE_CFG,
+@@ -383,6 +400,206 @@ static const struct vc4_hdmi_register __
+ 
+ 	VC5_RM_REG(HDMI_RM_CONTROL, 0x000),
+ 	VC5_RM_REG(HDMI_RM_OFFSET, 0x018),
++	VC5_RM_REG(HDMI_RM_FORMAT, 0x01c),
++
++	VC5_RAM_REG(HDMI_RAM_PACKET_START, 0x000),
++
++	VC5_CEC_REG(HDMI_CEC_CNTRL_1, 0x010),
++	VC5_CEC_REG(HDMI_CEC_CNTRL_2, 0x014),
++	VC5_CEC_REG(HDMI_CEC_CNTRL_3, 0x018),
++	VC5_CEC_REG(HDMI_CEC_CNTRL_4, 0x01c),
++	VC5_CEC_REG(HDMI_CEC_CNTRL_5, 0x020),
++	VC5_CEC_REG(HDMI_CEC_TX_DATA_1, 0x028),
++	VC5_CEC_REG(HDMI_CEC_TX_DATA_2, 0x02c),
++	VC5_CEC_REG(HDMI_CEC_TX_DATA_3, 0x030),
++	VC5_CEC_REG(HDMI_CEC_TX_DATA_4, 0x034),
++	VC5_CEC_REG(HDMI_CEC_RX_DATA_1, 0x038),
++	VC5_CEC_REG(HDMI_CEC_RX_DATA_2, 0x03c),
++	VC5_CEC_REG(HDMI_CEC_RX_DATA_3, 0x040),
++	VC5_CEC_REG(HDMI_CEC_RX_DATA_4, 0x044),
++
++	VC5_CSC_REG(HDMI_CSC_CTL, 0x000),
++	VC5_CSC_REG(HDMI_CSC_12_11, 0x004),
++	VC5_CSC_REG(HDMI_CSC_14_13, 0x008),
++	VC5_CSC_REG(HDMI_CSC_22_21, 0x00c),
++	VC5_CSC_REG(HDMI_CSC_24_23, 0x010),
++	VC5_CSC_REG(HDMI_CSC_32_31, 0x014),
++	VC5_CSC_REG(HDMI_CSC_34_33, 0x018),
++	VC5_CSC_REG(HDMI_CSC_CHANNEL_CTL, 0x02c),
++};
++
++static const struct vc4_hdmi_register __maybe_unused vc6_hdmi_hdmi0_fields[] = {
++	VC4_HD_REG(HDMI_DVP_CTL, 0x0000),
++	VC4_HD_REG(HDMI_MAI_CTL, 0x0010),
++	VC4_HD_REG(HDMI_MAI_THR, 0x0014),
++	VC4_HD_REG(HDMI_MAI_FMT, 0x0018),
++	VC4_HD_REG(HDMI_MAI_DATA, 0x001c),
++	VC4_HD_REG(HDMI_MAI_SMP, 0x0020),
++	VC4_HD_REG(HDMI_VID_CTL, 0x0044),
++	VC4_HD_REG(HDMI_FRAME_COUNT, 0x0060),
++
++	VC4_HDMI_REG(HDMI_FIFO_CTL, 0x07c),
++	VC4_HDMI_REG(HDMI_AUDIO_PACKET_CONFIG, 0x0c0),
++	VC4_HDMI_REG(HDMI_RAM_PACKET_CONFIG, 0x0c4),
++	VC4_HDMI_REG(HDMI_RAM_PACKET_STATUS, 0x0cc),
++	VC4_HDMI_REG(HDMI_CRP_CFG, 0x0d0),
++	VC4_HDMI_REG(HDMI_CTS_0, 0x0d4),
++	VC4_HDMI_REG(HDMI_CTS_1, 0x0d8),
++	VC4_HDMI_REG(HDMI_SCHEDULER_CONTROL, 0x0e8),
++	VC4_HDMI_REG(HDMI_HORZA, 0x0ec),
++	VC4_HDMI_REG(HDMI_HORZB, 0x0f0),
++	VC4_HDMI_REG(HDMI_VERTA0, 0x0f4),
++	VC4_HDMI_REG(HDMI_VERTB0, 0x0f8),
++	VC4_HDMI_REG(HDMI_VERTA1, 0x100),
++	VC4_HDMI_REG(HDMI_VERTB1, 0x104),
++	VC4_HDMI_REG(HDMI_MISC_CONTROL, 0x114),
++	VC4_HDMI_REG(HDMI_MAI_CHANNEL_MAP, 0x0a4),
++	VC4_HDMI_REG(HDMI_MAI_CONFIG, 0x0a8),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_1, 0x148),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_2, 0x14c),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_3, 0x150),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_4, 0x158),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_5, 0x15c),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_6, 0x160),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_7, 0x164),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_8, 0x168),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_9, 0x16c),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_10, 0x170),
++	VC4_HDMI_REG(HDMI_DEEP_COLOR_CONFIG_1, 0x18c),
++	VC4_HDMI_REG(HDMI_GCP_CONFIG, 0x194),
++	VC4_HDMI_REG(HDMI_GCP_WORD_1, 0x198),
++	VC4_HDMI_REG(HDMI_HOTPLUG, 0x1c8),
++	VC4_HDMI_REG(HDMI_SCRAMBLER_CTL, 0x1e4),
++
++	VC5_DVP_REG(HDMI_CLOCK_STOP, 0x0bc),
++	VC5_DVP_REG(HDMI_VEC_INTERFACE_CFG, 0x0f0),
++	VC5_DVP_REG(HDMI_VEC_INTERFACE_XBAR, 0x0f4),
++
++	VC5_PHY_REG(HDMI_TX_PHY_RESET_CTL, 0x000),
++	VC5_PHY_REG(HDMI_TX_PHY_POWERUP_CTL, 0x004),
++	VC5_PHY_REG(HDMI_TX_PHY_CTL_0, 0x008),
++	VC5_PHY_REG(HDMI_TX_PHY_CTL_1, 0x00c),
++	VC5_PHY_REG(HDMI_TX_PHY_CTL_2, 0x010),
++	VC5_PHY_REG(HDMI_TX_PHY_CTL_CK, 0x014),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_REFCLK, 0x01c),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_POST_KDIV, 0x028),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_VCOCLK_DIV, 0x02c),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_CFG, 0x044),
++	VC5_PHY_REG(HDMI_TX_PHY_TMDS_CLK_WORD_SEL, 0x054),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_0, 0x060),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_1, 0x064),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_2, 0x068),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_3, 0x06c),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_4, 0x070),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_5, 0x074),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_6, 0x078),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_7, 0x07c),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_8, 0x080),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_RESET_CTL, 0x190),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_POWERUP_CTL, 0x194),
++
++	VC5_RM_REG(HDMI_RM_CONTROL, 0x000),
++	VC5_RM_REG(HDMI_RM_OFFSET, 0x018),
++	VC5_RM_REG(HDMI_RM_FORMAT, 0x01c),
++
++	VC5_RAM_REG(HDMI_RAM_PACKET_START, 0x000),
++
++	VC5_CEC_REG(HDMI_CEC_CNTRL_1, 0x010),
++	VC5_CEC_REG(HDMI_CEC_CNTRL_2, 0x014),
++	VC5_CEC_REG(HDMI_CEC_CNTRL_3, 0x018),
++	VC5_CEC_REG(HDMI_CEC_CNTRL_4, 0x01c),
++	VC5_CEC_REG(HDMI_CEC_CNTRL_5, 0x020),
++	VC5_CEC_REG(HDMI_CEC_TX_DATA_1, 0x028),
++	VC5_CEC_REG(HDMI_CEC_TX_DATA_2, 0x02c),
++	VC5_CEC_REG(HDMI_CEC_TX_DATA_3, 0x030),
++	VC5_CEC_REG(HDMI_CEC_TX_DATA_4, 0x034),
++	VC5_CEC_REG(HDMI_CEC_RX_DATA_1, 0x038),
++	VC5_CEC_REG(HDMI_CEC_RX_DATA_2, 0x03c),
++	VC5_CEC_REG(HDMI_CEC_RX_DATA_3, 0x040),
++	VC5_CEC_REG(HDMI_CEC_RX_DATA_4, 0x044),
++
++	VC5_CSC_REG(HDMI_CSC_CTL, 0x000),
++	VC5_CSC_REG(HDMI_CSC_12_11, 0x004),
++	VC5_CSC_REG(HDMI_CSC_14_13, 0x008),
++	VC5_CSC_REG(HDMI_CSC_22_21, 0x00c),
++	VC5_CSC_REG(HDMI_CSC_24_23, 0x010),
++	VC5_CSC_REG(HDMI_CSC_32_31, 0x014),
++	VC5_CSC_REG(HDMI_CSC_34_33, 0x018),
++	VC5_CSC_REG(HDMI_CSC_CHANNEL_CTL, 0x02c),
++};
++
++static const struct vc4_hdmi_register __maybe_unused vc6_hdmi_hdmi1_fields[] = {
++	VC4_HD_REG(HDMI_DVP_CTL, 0x0000),
++	VC4_HD_REG(HDMI_MAI_CTL, 0x0030),
++	VC4_HD_REG(HDMI_MAI_THR, 0x0034),
++	VC4_HD_REG(HDMI_MAI_FMT, 0x0038),
++	VC4_HD_REG(HDMI_MAI_DATA, 0x003c),
++	VC4_HD_REG(HDMI_MAI_SMP, 0x0040),
++	VC4_HD_REG(HDMI_VID_CTL, 0x0048),
++	VC4_HD_REG(HDMI_FRAME_COUNT, 0x0064),
++
++	VC4_HDMI_REG(HDMI_FIFO_CTL, 0x07c),
++	VC4_HDMI_REG(HDMI_AUDIO_PACKET_CONFIG, 0x0c0),
++	VC4_HDMI_REG(HDMI_RAM_PACKET_CONFIG, 0x0c4),
++	VC4_HDMI_REG(HDMI_RAM_PACKET_STATUS, 0x0cc),
++	VC4_HDMI_REG(HDMI_CRP_CFG, 0x0d0),
++	VC4_HDMI_REG(HDMI_CTS_0, 0x0d4),
++	VC4_HDMI_REG(HDMI_CTS_1, 0x0d8),
++	VC4_HDMI_REG(HDMI_SCHEDULER_CONTROL, 0x0e8),
++	VC4_HDMI_REG(HDMI_HORZA, 0x0ec),
++	VC4_HDMI_REG(HDMI_HORZB, 0x0f0),
++	VC4_HDMI_REG(HDMI_VERTA0, 0x0f4),
++	VC4_HDMI_REG(HDMI_VERTB0, 0x0f8),
++	VC4_HDMI_REG(HDMI_VERTA1, 0x100),
++	VC4_HDMI_REG(HDMI_VERTB1, 0x104),
++	VC4_HDMI_REG(HDMI_MISC_CONTROL, 0x114),
++	VC4_HDMI_REG(HDMI_MAI_CHANNEL_MAP, 0x0a4),
++	VC4_HDMI_REG(HDMI_MAI_CONFIG, 0x0a8),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_1, 0x148),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_2, 0x14c),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_3, 0x150),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_4, 0x158),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_5, 0x15c),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_6, 0x160),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_7, 0x164),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_8, 0x168),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_9, 0x16c),
++	VC4_HDMI_REG(HDMI_FORMAT_DET_10, 0x170),
++	VC4_HDMI_REG(HDMI_DEEP_COLOR_CONFIG_1, 0x18c),
++	VC4_HDMI_REG(HDMI_GCP_CONFIG, 0x194),
++	VC4_HDMI_REG(HDMI_GCP_WORD_1, 0x198),
++	VC4_HDMI_REG(HDMI_HOTPLUG, 0x1c8),
++	VC4_HDMI_REG(HDMI_SCRAMBLER_CTL, 0x1e4),
++
++	VC5_DVP_REG(HDMI_CLOCK_STOP, 0x0bc),
++	VC5_DVP_REG(HDMI_VEC_INTERFACE_CFG, 0x0f0),
++	VC5_DVP_REG(HDMI_VEC_INTERFACE_XBAR, 0x0f4),
++
++	VC5_PHY_REG(HDMI_TX_PHY_RESET_CTL, 0x000),
++	VC5_PHY_REG(HDMI_TX_PHY_POWERUP_CTL, 0x004),
++	VC5_PHY_REG(HDMI_TX_PHY_CTL_0, 0x008),
++	VC5_PHY_REG(HDMI_TX_PHY_CTL_1, 0x00c),
++	VC5_PHY_REG(HDMI_TX_PHY_CTL_2, 0x010),
++	VC5_PHY_REG(HDMI_TX_PHY_CTL_CK, 0x014),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_REFCLK, 0x01c),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_POST_KDIV, 0x028),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_VCOCLK_DIV, 0x02c),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_CFG, 0x044),
++	VC5_PHY_REG(HDMI_TX_PHY_TMDS_CLK_WORD_SEL, 0x054),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_0, 0x060),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_1, 0x064),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_2, 0x068),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_3, 0x06c),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_4, 0x070),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_5, 0x074),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_6, 0x078),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_7, 0x07c),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_MISC_8, 0x080),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_RESET_CTL, 0x190),
++	VC5_PHY_REG(HDMI_TX_PHY_PLL_POWERUP_CTL, 0x194),
++
++	VC5_RM_REG(HDMI_RM_CONTROL, 0x000),
++	VC5_RM_REG(HDMI_RM_OFFSET, 0x018),
+ 	VC5_RM_REG(HDMI_RM_FORMAT, 0x01c),
+ 
+ 	VC5_RAM_REG(HDMI_RAM_PACKET_START, 0x000),
diff --git a/target/linux/bcm27xx/patches-6.1/950-0966-drm-vc4-txp-Introduce-structure-to-deal-with-revisio.patch b/target/linux/bcm27xx/patches-6.1/950-0966-drm-vc4-txp-Introduce-structure-to-deal-with-revisio.patch
new file mode 100644
index 0000000000..c54ab0d360
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0966-drm-vc4-txp-Introduce-structure-to-deal-with-revisio.patch
@@ -0,0 +1,117 @@
+From a68e8ffc3314612b0d00d491c8cdd61ae1d9af4e Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Tue, 25 Apr 2023 10:12:32 +0200
+Subject: [PATCH] drm/vc4: txp: Introduce structure to deal with revision
+ differences
+
+The BCM2712 will have several TXP with small differences. Let's add a
+structure tied to the compatible to deal with those differences.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.c |  4 ++--
+ drivers/gpu/drm/vc4/vc4_drv.h        |  6 +++++-
+ drivers/gpu/drm/vc4/vc4_txp.c        | 23 ++++++++++++++++-------
+ 3 files changed, 23 insertions(+), 10 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.c
+@@ -51,7 +51,7 @@ struct vc4_mock_desc {
+ 
+ static const struct vc4_mock_desc vc4_mock =
+ 	VC4_MOCK_DESC(
+-		VC4_MOCK_CRTC_DESC(&vc4_txp_crtc_data,
++		VC4_MOCK_CRTC_DESC(&vc4_txp_data.base,
+ 				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP,
+ 							DRM_MODE_ENCODER_VIRTUAL,
+ 							DRM_MODE_CONNECTOR_WRITEBACK)),
+@@ -77,7 +77,7 @@ static const struct vc4_mock_desc vc4_mo
+ 
+ static const struct vc4_mock_desc vc5_mock =
+ 	VC4_MOCK_DESC(
+-		VC4_MOCK_CRTC_DESC(&vc4_txp_crtc_data,
++		VC4_MOCK_CRTC_DESC(&vc4_txp_data.base,
+ 				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP,
+ 							DRM_MODE_ENCODER_VIRTUAL,
+ 							DRM_MODE_CONNECTOR_WRITEBACK)),
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -561,7 +561,11 @@ struct vc4_crtc_data {
+ 	int hvs_output;
+ };
+ 
+-extern const struct vc4_crtc_data vc4_txp_crtc_data;
++struct vc4_txp_data {
++	struct vc4_crtc_data	base;
++};
++
++extern const struct vc4_txp_data vc4_txp_data;
+ 
+ struct vc4_pv_data {
+ 	struct vc4_crtc_data	base;
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -159,6 +159,7 @@
+ 
+ struct vc4_txp {
+ 	struct vc4_crtc	base;
++	const struct vc4_txp_data *data;
+ 
+ 	struct platform_device *pdev;
+ 
+@@ -488,17 +489,20 @@ static irqreturn_t vc4_txp_interrupt(int
+ 	return IRQ_HANDLED;
+ }
+ 
+-const struct vc4_crtc_data vc4_txp_crtc_data = {
+-	.name = "txp",
+-	.debugfs_name = "txp_regs",
+-	.hvs_available_channels = BIT(2),
+-	.hvs_output = 2,
++const struct vc4_txp_data vc4_txp_data = {
++	.base = {
++		.name = "txp",
++		.debugfs_name = "txp_regs",
++		.hvs_available_channels = BIT(2),
++		.hvs_output = 2,
++	},
+ };
+ 
+ static int vc4_txp_bind(struct device *dev, struct device *master, void *data)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct drm_device *drm = dev_get_drvdata(master);
++	const struct vc4_txp_data *txp_data;
+ 	struct vc4_encoder *vc4_encoder;
+ 	struct drm_encoder *encoder;
+ 	struct vc4_crtc *vc4_crtc;
+@@ -513,6 +517,11 @@ static int vc4_txp_bind(struct device *d
+ 	if (!txp)
+ 		return -ENOMEM;
+ 
++	txp_data = of_device_get_match_data(dev);
++	if (!txp_data)
++		return -ENODEV;
++
++	txp->data = txp_data;
+ 	txp->pdev = pdev;
+ 	txp->regs = vc4_ioremap_regs(pdev, 0);
+ 	if (IS_ERR(txp->regs))
+@@ -523,7 +532,7 @@ static int vc4_txp_bind(struct device *d
+ 	vc4_crtc->regset.regs = txp_regs;
+ 	vc4_crtc->regset.nregs = ARRAY_SIZE(txp_regs);
+ 
+-	ret = vc4_crtc_init(drm, pdev, vc4_crtc, &vc4_txp_crtc_data,
++	ret = vc4_crtc_init(drm, pdev, vc4_crtc, &txp_data->base,
+ 			    &vc4_txp_crtc_funcs, &vc4_txp_crtc_helper_funcs, true);
+ 	if (ret)
+ 		return ret;
+@@ -584,7 +593,7 @@ static int vc4_txp_remove(struct platfor
+ }
+ 
+ static const struct of_device_id vc4_txp_dt_match[] = {
+-	{ .compatible = "brcm,bcm2835-txp" },
++	{ .compatible = "brcm,bcm2835-txp", .data = &vc4_txp_data },
+ 	{ /* sentinel */ },
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0967-drm-vc4-txp-Rename-TXP-data-structure.patch b/target/linux/bcm27xx/patches-6.1/950-0967-drm-vc4-txp-Rename-TXP-data-structure.patch
new file mode 100644
index 0000000000..9303f86734
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0967-drm-vc4-txp-Rename-TXP-data-structure.patch
@@ -0,0 +1,66 @@
+From 7d345345b70f00bf4c673a68da7d1cf0faf5cc47 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Tue, 25 Apr 2023 10:21:53 +0200
+Subject: [PATCH] drm/vc4: txp: Rename TXP data structure
+
+The TXP data structure has a name too generic for the multiple variants
+we'll have to support. Let's rename it to mention the SoC it applies to.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.c | 4 ++--
+ drivers/gpu/drm/vc4/vc4_drv.h        | 2 +-
+ drivers/gpu/drm/vc4/vc4_txp.c        | 4 ++--
+ 3 files changed, 5 insertions(+), 5 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.c
+@@ -51,7 +51,7 @@ struct vc4_mock_desc {
+ 
+ static const struct vc4_mock_desc vc4_mock =
+ 	VC4_MOCK_DESC(
+-		VC4_MOCK_CRTC_DESC(&vc4_txp_data.base,
++		VC4_MOCK_CRTC_DESC(&bcm2835_txp_data.base,
+ 				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP,
+ 							DRM_MODE_ENCODER_VIRTUAL,
+ 							DRM_MODE_CONNECTOR_WRITEBACK)),
+@@ -77,7 +77,7 @@ static const struct vc4_mock_desc vc4_mo
+ 
+ static const struct vc4_mock_desc vc5_mock =
+ 	VC4_MOCK_DESC(
+-		VC4_MOCK_CRTC_DESC(&vc4_txp_data.base,
++		VC4_MOCK_CRTC_DESC(&bcm2835_txp_data.base,
+ 				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP,
+ 							DRM_MODE_ENCODER_VIRTUAL,
+ 							DRM_MODE_CONNECTOR_WRITEBACK)),
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -565,7 +565,7 @@ struct vc4_txp_data {
+ 	struct vc4_crtc_data	base;
+ };
+ 
+-extern const struct vc4_txp_data vc4_txp_data;
++extern const struct vc4_txp_data bcm2835_txp_data;
+ 
+ struct vc4_pv_data {
+ 	struct vc4_crtc_data	base;
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -489,7 +489,7 @@ static irqreturn_t vc4_txp_interrupt(int
+ 	return IRQ_HANDLED;
+ }
+ 
+-const struct vc4_txp_data vc4_txp_data = {
++const struct vc4_txp_data bcm2835_txp_data = {
+ 	.base = {
+ 		.name = "txp",
+ 		.debugfs_name = "txp_regs",
+@@ -593,7 +593,7 @@ static int vc4_txp_remove(struct platfor
+ }
+ 
+ static const struct of_device_id vc4_txp_dt_match[] = {
+-	{ .compatible = "brcm,bcm2835-txp", .data = &vc4_txp_data },
++	{ .compatible = "brcm,bcm2835-txp", .data = &bcm2835_txp_data },
+ 	{ /* sentinel */ },
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0968-drm-vc4-txp-Add-byte-enable-toggle-bit.patch b/target/linux/bcm27xx/patches-6.1/950-0968-drm-vc4-txp-Add-byte-enable-toggle-bit.patch
new file mode 100644
index 0000000000..cea9062b19
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0968-drm-vc4-txp-Add-byte-enable-toggle-bit.patch
@@ -0,0 +1,56 @@
+From e8dbad6d506b6fac992fdf74a7e3a66a38e554c3 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 27 Apr 2023 09:30:33 +0200
+Subject: [PATCH] drm/vc4: txp: Add byte enable toggle bit
+
+The MOPLET doesn't have the BYTE_ENABLE field to set, but the TXP and
+MOP do, so let's add a boolean to control whether or not we need to set
+it.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h | 1 +
+ drivers/gpu/drm/vc4/vc4_txp.c | 6 +++++-
+ 2 files changed, 6 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -563,6 +563,7 @@ struct vc4_crtc_data {
+ 
+ struct vc4_txp_data {
+ 	struct vc4_crtc_data	base;
++	unsigned int has_byte_enable:1;
+ };
+ 
+ extern const struct vc4_txp_data bcm2835_txp_data;
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -291,6 +291,7 @@ static void vc4_txp_connector_atomic_com
+ 	struct drm_connector_state *conn_state = drm_atomic_get_new_connector_state(state,
+ 										    conn);
+ 	struct vc4_txp *txp = connector_to_vc4_txp(conn);
++	const struct vc4_txp_data *txp_data = txp->data;
+ 	struct drm_gem_dma_object *gem;
+ 	struct drm_display_mode *mode;
+ 	struct drm_framebuffer *fb;
+@@ -313,9 +314,11 @@ static void vc4_txp_connector_atomic_com
+ 		return;
+ 
+ 	ctrl = TXP_GO | TXP_EI |
+-	       VC4_SET_FIELD(0xf, TXP_BYTE_ENABLE) |
+ 	       VC4_SET_FIELD(txp_fmts[i], TXP_FORMAT);
+ 
++	if (txp_data->has_byte_enable)
++		ctrl |= VC4_SET_FIELD(0xf, TXP_BYTE_ENABLE);
++
+ 	if (fb->format->has_alpha)
+ 		ctrl |= TXP_ALPHA_ENABLE;
+ 	else
+@@ -496,6 +499,7 @@ const struct vc4_txp_data bcm2835_txp_da
+ 		.hvs_available_channels = BIT(2),
+ 		.hvs_output = 2,
+ 	},
++	.has_byte_enable = true,
+ };
+ 
+ static int vc4_txp_bind(struct device *dev, struct device *master, void *data)
diff --git a/target/linux/bcm27xx/patches-6.1/950-0969-drm-vc4-txp-Add-horizontal-and-vertical-size-offset-.patch b/target/linux/bcm27xx/patches-6.1/950-0969-drm-vc4-txp-Add-horizontal-and-vertical-size-offset-.patch
new file mode 100644
index 0000000000..290473e834
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0969-drm-vc4-txp-Add-horizontal-and-vertical-size-offset-.patch
@@ -0,0 +1,59 @@
+From a51e4acdab01540e1006e43f38e5befb40002de0 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 27 Apr 2023 09:47:54 +0200
+Subject: [PATCH] drm/vc4: txp: Add horizontal and vertical size offset toggle
+ bit
+
+The new writeback controllers that can be found on the BCM2712 require
+to have their horizontal and vertical size reduced by one.
+
+Let's tie that behaviour to the compatible so we can support both the
+new and old controllers.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h |  1 +
+ drivers/gpu/drm/vc4/vc4_txp.c | 14 ++++++++++++--
+ 2 files changed, 13 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -564,6 +564,7 @@ struct vc4_crtc_data {
+ struct vc4_txp_data {
+ 	struct vc4_crtc_data	base;
+ 	unsigned int has_byte_enable:1;
++	unsigned int size_minus_one:1;
+ };
+ 
+ extern const struct vc4_txp_data bcm2835_txp_data;
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -295,6 +295,8 @@ static void vc4_txp_connector_atomic_com
+ 	struct drm_gem_dma_object *gem;
+ 	struct drm_display_mode *mode;
+ 	struct drm_framebuffer *fb;
++	unsigned int hdisplay;
++	unsigned int vdisplay;
+ 	u32 ctrl;
+ 	int idx;
+ 	int i;
+@@ -334,9 +336,17 @@ static void vc4_txp_connector_atomic_com
+ 	gem = drm_fb_dma_get_gem_obj(fb, 0);
+ 	TXP_WRITE(TXP_DST_PTR, gem->dma_addr + fb->offsets[0]);
+ 	TXP_WRITE(TXP_DST_PITCH, fb->pitches[0]);
++
++	hdisplay = mode->hdisplay ?: 1;
++	vdisplay = mode->vdisplay ?: 1;
++	if (txp_data->size_minus_one) {
++		hdisplay -= 1;
++		vdisplay -= 1;
++	}
++
+ 	TXP_WRITE(TXP_DIM,
+-		  VC4_SET_FIELD(mode->hdisplay, TXP_WIDTH) |
+-		  VC4_SET_FIELD(mode->vdisplay, TXP_HEIGHT));
++		  VC4_SET_FIELD(hdisplay, TXP_WIDTH) |
++		  VC4_SET_FIELD(vdisplay, TXP_HEIGHT));
+ 
+ 	TXP_WRITE(TXP_DST_CTRL, ctrl);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0970-drm-vc4-txp-Handle-40-bits-DMA-Addresses.patch b/target/linux/bcm27xx/patches-6.1/950-0970-drm-vc4-txp-Handle-40-bits-DMA-Addresses.patch
new file mode 100644
index 0000000000..5d1fbcb119
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0970-drm-vc4-txp-Handle-40-bits-DMA-Addresses.patch
@@ -0,0 +1,59 @@
+From ddb9aa80692ed5d35e4ee4688c36789620f78c5c Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 14 Apr 2023 17:47:11 +0200
+Subject: [PATCH] drm/vc4: txp: Handle 40-bits DMA Addresses
+
+The BCM2712 MOP and MOPLET can handle addresses larger than 32bits
+through an extra register. We can easily support it and make it
+conditional based on the compatible through a boolean in our variant
+structure.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h |  1 +
+ drivers/gpu/drm/vc4/vc4_txp.c | 10 +++++++++-
+ 2 files changed, 10 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -565,6 +565,7 @@ struct vc4_txp_data {
+ 	struct vc4_crtc_data	base;
+ 	unsigned int has_byte_enable:1;
+ 	unsigned int size_minus_one:1;
++	unsigned int supports_40bit_addresses:1;
+ };
+ 
+ extern const struct vc4_txp_data bcm2835_txp_data;
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -145,6 +145,8 @@
+ /* Number of lines received and committed to memory. */
+ #define TXP_PROGRESS		0x10
+ 
++#define TXP_DST_PTR_HIGH	0x1c
++
+ #define TXP_READ(offset)								\
+ 	({										\
+ 		kunit_fail_current_test("Accessing a register in a unit test!\n");	\
+@@ -297,6 +299,7 @@ static void vc4_txp_connector_atomic_com
+ 	struct drm_framebuffer *fb;
+ 	unsigned int hdisplay;
+ 	unsigned int vdisplay;
++	dma_addr_t addr;
+ 	u32 ctrl;
+ 	int idx;
+ 	int i;
+@@ -334,7 +337,12 @@ static void vc4_txp_connector_atomic_com
+ 		return;
+ 
+ 	gem = drm_fb_dma_get_gem_obj(fb, 0);
+-	TXP_WRITE(TXP_DST_PTR, gem->dma_addr + fb->offsets[0]);
++	addr = gem->dma_addr + fb->offsets[0];
++	TXP_WRITE(TXP_DST_PTR, lower_32_bits(addr));
++
++	if (txp_data->supports_40bit_addresses)
++		TXP_WRITE(TXP_DST_PTR_HIGH, upper_32_bits(addr) & 0xff);
++
+ 	TXP_WRITE(TXP_DST_PITCH, fb->pitches[0]);
+ 
+ 	hdisplay = mode->hdisplay ?: 1;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0971-drm-vc4-txp-Move-the-encoder-type-in-the-variant-str.patch b/target/linux/bcm27xx/patches-6.1/950-0971-drm-vc4-txp-Move-the-encoder-type-in-the-variant-str.patch
new file mode 100644
index 0000000000..0445c4f509
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0971-drm-vc4-txp-Move-the-encoder-type-in-the-variant-str.patch
@@ -0,0 +1,44 @@
+From 2e8f4fa23af4bb794e9b2284a53aa40bbfdd3cbb Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 27 Apr 2023 11:26:10 +0200
+Subject: [PATCH] drm/vc4: txp: Move the encoder type in the variant structure
+
+We'll have multiple TXP instances in the BCM2712, so we can't use a
+single encoder type anymore. Let's tie the encoder type to the
+compatible.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h | 1 +
+ drivers/gpu/drm/vc4/vc4_txp.c | 3 ++-
+ 2 files changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -563,6 +563,7 @@ struct vc4_crtc_data {
+ 
+ struct vc4_txp_data {
+ 	struct vc4_crtc_data	base;
++	enum vc4_encoder_type encoder_type;
+ 	unsigned int has_byte_enable:1;
+ 	unsigned int size_minus_one:1;
+ 	unsigned int supports_40bit_addresses:1;
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -517,6 +517,7 @@ const struct vc4_txp_data bcm2835_txp_da
+ 		.hvs_available_channels = BIT(2),
+ 		.hvs_output = 2,
+ 	},
++	.encoder_type = VC4_ENCODER_TYPE_TXP,
+ 	.has_byte_enable = true,
+ };
+ 
+@@ -560,7 +561,7 @@ static int vc4_txp_bind(struct device *d
+ 		return ret;
+ 
+ 	vc4_encoder = &txp->encoder;
+-	txp->encoder.type = VC4_ENCODER_TYPE_TXP;
++	txp->encoder.type = txp_data->encoder_type;
+ 
+ 	encoder = &vc4_encoder->base;
+ 	encoder->possible_crtcs = drm_crtc_mask(&vc4_crtc->base);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0972-drm-vc4-txp-Add-a-new-TXP-encoder-type.patch b/target/linux/bcm27xx/patches-6.1/950-0972-drm-vc4-txp-Add-a-new-TXP-encoder-type.patch
new file mode 100644
index 0000000000..f832fc1ed5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0972-drm-vc4-txp-Add-a-new-TXP-encoder-type.patch
@@ -0,0 +1,475 @@
+From 68a00ca7b1d7809ac7be736c02238c142e629127 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 27 Apr 2023 11:49:28 +0200
+Subject: [PATCH] drm/vc4: txp: Add a new TXP encoder type
+
+Starting with BCM2712, we'll have a two TXP. Let's follow the HDMI
+example and add two encoder types for TXP: TXP0 and TXP1.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.c          |   4 +-
+ .../gpu/drm/vc4/tests/vc4_test_pv_muxing.c    | 106 +++++++++---------
+ drivers/gpu/drm/vc4/vc4_drv.h                 |   3 +-
+ drivers/gpu/drm/vc4/vc4_kms.c                 |   2 +-
+ drivers/gpu/drm/vc4/vc4_txp.c                 |   2 +-
+ 5 files changed, 59 insertions(+), 58 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.c
+@@ -52,7 +52,7 @@ struct vc4_mock_desc {
+ static const struct vc4_mock_desc vc4_mock =
+ 	VC4_MOCK_DESC(
+ 		VC4_MOCK_CRTC_DESC(&bcm2835_txp_data.base,
+-				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP,
++				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP0,
+ 							DRM_MODE_ENCODER_VIRTUAL,
+ 							DRM_MODE_CONNECTOR_WRITEBACK)),
+ 		VC4_MOCK_PIXELVALVE_DESC(&bcm2835_pv0_data,
+@@ -78,7 +78,7 @@ static const struct vc4_mock_desc vc4_mo
+ static const struct vc4_mock_desc vc5_mock =
+ 	VC4_MOCK_DESC(
+ 		VC4_MOCK_CRTC_DESC(&bcm2835_txp_data.base,
+-				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP,
++				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP0,
+ 							DRM_MODE_ENCODER_VIRTUAL,
+ 							DRM_MODE_CONNECTOR_WRITEBACK)),
+ 		VC4_MOCK_PIXELVALVE_DESC(&bcm2711_pv0_data,
+--- a/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
+@@ -91,7 +91,7 @@ static const struct encoder_constraint v
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_DSI0, 0),
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI0, 1),
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_VEC, 1),
+-	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP, 2),
++	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP0, 2),
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_DSI1, 2),
+ };
+ 
+@@ -99,7 +99,7 @@ static const struct encoder_constraint v
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_DPI, 0),
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_DSI0, 0),
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_VEC, 1),
+-	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP, 0, 2),
++	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP0, 0, 2),
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_DSI1, 0, 1, 2),
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI0, 0, 1, 2),
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI1, 0, 1, 2),
+@@ -208,7 +208,7 @@ static const struct pv_muxing_param vc4_
+ 	VC4_PV_MUXING_TEST("1 output: DSI1",
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC4_PV_MUXING_TEST("1 output: TXP",
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("2 outputs: DSI0, HDMI0",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+@@ -220,7 +220,7 @@ static const struct pv_muxing_param vc4_
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC4_PV_MUXING_TEST("2 outputs: DSI0, TXP",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("2 outputs: DPI, HDMI0",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+@@ -232,19 +232,19 @@ static const struct pv_muxing_param vc4_
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC4_PV_MUXING_TEST("2 outputs: DPI, TXP",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("2 outputs: HDMI0, DSI1",
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC4_PV_MUXING_TEST("2 outputs: HDMI0, TXP",
+ 			   VC4_ENCODER_TYPE_HDMI0,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("2 outputs: VEC, DSI1",
+ 			   VC4_ENCODER_TYPE_VEC,
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC4_PV_MUXING_TEST("2 outputs: VEC, TXP",
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("3 outputs: DSI0, HDMI0, DSI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+@@ -252,7 +252,7 @@ static const struct pv_muxing_param vc4_
+ 	VC4_PV_MUXING_TEST("3 outputs: DSI0, HDMI0, TXP",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("3 outputs: DSI0, VEC, DSI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+@@ -260,7 +260,7 @@ static const struct pv_muxing_param vc4_
+ 	VC4_PV_MUXING_TEST("3 outputs: DSI0, VEC, TXP",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("3 outputs: DPI, HDMI0, DSI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+@@ -268,7 +268,7 @@ static const struct pv_muxing_param vc4_
+ 	VC4_PV_MUXING_TEST("3 outputs: DPI, HDMI0, TXP",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("3 outputs: DPI, VEC, DSI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+@@ -276,7 +276,7 @@ static const struct pv_muxing_param vc4_
+ 	VC4_PV_MUXING_TEST("3 outputs: DPI, VEC, TXP",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ };
+ 
+ KUNIT_ARRAY_PARAM(vc4_test_pv_muxing,
+@@ -288,7 +288,7 @@ static const struct pv_muxing_param vc4_
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_DSI0),
+ 	VC4_PV_MUXING_TEST("TXP/DSI1 Conflict",
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC4_PV_MUXING_TEST("HDMI0/VEC Conflict",
+ 			   VC4_ENCODER_TYPE_HDMI0,
+@@ -297,22 +297,22 @@ static const struct pv_muxing_param vc4_
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, DSI1, TXP",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+ 			   VC4_ENCODER_TYPE_DSI1,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("More than 3 outputs: DPI, HDMI0, DSI1, TXP",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC4_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, DSI1, TXP",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+ 			   VC4_ENCODER_TYPE_DSI1,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ };
+ 
+ KUNIT_ARRAY_PARAM(vc4_test_pv_muxing_invalid,
+@@ -343,7 +343,7 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("2 outputs: DPI, TXP",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC5_PV_MUXING_TEST("2 outputs: DPI, VEC",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC),
+@@ -361,7 +361,7 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("2 outputs: DSI0, TXP",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC5_PV_MUXING_TEST("2 outputs: DSI0, VEC",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC),
+@@ -373,7 +373,7 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_VEC),
+ 	VC5_PV_MUXING_TEST("2 outputs: DSI1, TXP",
+ 			   VC4_ENCODER_TYPE_DSI1,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC5_PV_MUXING_TEST("2 outputs: DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+@@ -385,7 +385,7 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_VEC),
+ 	VC5_PV_MUXING_TEST("2 outputs: HDMI0, TXP",
+ 			   VC4_ENCODER_TYPE_HDMI0,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC5_PV_MUXING_TEST("2 outputs: HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+@@ -394,14 +394,14 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_VEC),
+ 	VC5_PV_MUXING_TEST("2 outputs: HDMI1, TXP",
+ 			   VC4_ENCODER_TYPE_HDMI1,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC5_PV_MUXING_TEST("2 outputs: TXP, VEC",
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_VEC),
+ 	VC5_PV_MUXING_TEST("3 outputs: DPI, VEC, TXP",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC5_PV_MUXING_TEST("3 outputs: DPI, VEC, DSI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+@@ -416,15 +416,15 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("3 outputs: DPI, TXP, DSI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC5_PV_MUXING_TEST("3 outputs: DPI, TXP, HDMI0",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+ 	VC5_PV_MUXING_TEST("3 outputs: DPI, TXP, HDMI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("3 outputs: DPI, DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DPI,
+@@ -441,7 +441,7 @@ static const struct pv_muxing_param vc5_
+ 	VC5_PV_MUXING_TEST("3 outputs: DSI0, VEC, TXP",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP),
++			   VC4_ENCODER_TYPE_TXP0),
+ 	VC5_PV_MUXING_TEST("3 outputs: DSI0, VEC, DSI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+@@ -456,15 +456,15 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("3 outputs: DSI0, TXP, DSI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC5_PV_MUXING_TEST("3 outputs: DSI0, TXP, HDMI0",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+ 	VC5_PV_MUXING_TEST("3 outputs: DSI0, TXP, HDMI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("3 outputs: DSI0, DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DSI0,
+@@ -491,17 +491,17 @@ static const struct pv_muxing_param vc5_
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, TXP, DSI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, TXP, HDMI0",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, TXP, HDMI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DPI,
+@@ -520,17 +520,17 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, TXP, DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, TXP, DSI1, HDMI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, TXP, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, DSI1, HDMI0, HDMI1",
+@@ -541,19 +541,19 @@ static const struct pv_muxing_param vc5_
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, TXP, DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, TXP, DSI1, HDMI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, TXP, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, DSI1, HDMI0, HDMI1",
+@@ -564,24 +564,24 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, TXP, DSI1, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, TXP, DSI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, TXP, HDMI0",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, TXP, HDMI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DSI0,
+@@ -600,17 +600,17 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, TXP, DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, TXP, DSI1, HDMI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, TXP, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, DSI1, HDMI0, HDMI1",
+@@ -621,19 +621,19 @@ static const struct pv_muxing_param vc5_
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, TXP, DSI1, HDMI0",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, TXP, DSI1, HDMI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, TXP, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, DSI1, HDMI0, HDMI1",
+@@ -644,27 +644,27 @@ static const struct pv_muxing_param vc5_
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, TXP, DSI1, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: VEC, TXP, DSI1, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DPI, VEC, TXP, DSI1, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_DPI,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+ 	VC5_PV_MUXING_TEST("More than 3 outputs: DSI0, VEC, TXP, DSI1, HDMI0, HDMI1",
+ 			   VC4_ENCODER_TYPE_DSI0,
+ 			   VC4_ENCODER_TYPE_VEC,
+-			   VC4_ENCODER_TYPE_TXP,
++			   VC4_ENCODER_TYPE_TXP0,
+ 			   VC4_ENCODER_TYPE_DSI1,
+ 			   VC4_ENCODER_TYPE_HDMI0,
+ 			   VC4_ENCODER_TYPE_HDMI1),
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -511,7 +511,8 @@ enum vc4_encoder_type {
+ 	VC4_ENCODER_TYPE_DSI1,
+ 	VC4_ENCODER_TYPE_SMI,
+ 	VC4_ENCODER_TYPE_DPI,
+-	VC4_ENCODER_TYPE_TXP,
++	VC4_ENCODER_TYPE_TXP0,
++	VC4_ENCODER_TYPE_TXP1,
+ };
+ 
+ struct vc4_encoder {
+--- a/drivers/gpu/drm/vc4/vc4_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_kms.c
+@@ -359,7 +359,7 @@ static void vc6_hvs_pv_muxing_commit(str
+ 			mux = 0;
+ 			break;
+ 
+-		case VC4_ENCODER_TYPE_TXP:
++		case VC4_ENCODER_TYPE_TXP0:
+ 			mux = 2;
+ 			break;
+ 
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -517,7 +517,7 @@ const struct vc4_txp_data bcm2835_txp_da
+ 		.hvs_available_channels = BIT(2),
+ 		.hvs_output = 2,
+ 	},
+-	.encoder_type = VC4_ENCODER_TYPE_TXP,
++	.encoder_type = VC4_ENCODER_TYPE_TXP0,
+ 	.has_byte_enable = true,
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0973-drm-vc4-txp-Add-support-for-BCM2712-MOP.patch b/target/linux/bcm27xx/patches-6.1/950-0973-drm-vc4-txp-Add-support-for-BCM2712-MOP.patch
new file mode 100644
index 0000000000..aec0753408
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0973-drm-vc4-txp-Add-support-for-BCM2712-MOP.patch
@@ -0,0 +1,64 @@
+From 831c6e8c68a66678e8329a382823dc83c483dcc8 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Thu, 27 Apr 2023 09:30:49 +0200
+Subject: [PATCH] drm/vc4: txp: Add support for BCM2712 MOP
+
+The BCM2712 has an evolution of what used to be called TXP in the
+earlier SoCs, but is now called MOP.
+
+There's a few differences still, so we can add a new compatible to deal
+with them easily.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_txp.c | 18 +++++++++++++++++-
+ 1 file changed, 17 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -388,6 +388,7 @@ static const struct drm_connector_funcs
+ static void vc4_txp_encoder_disable(struct drm_encoder *encoder)
+ {
+ 	struct drm_device *drm = encoder->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
+ 	struct vc4_txp *txp = encoder_to_vc4_txp(encoder);
+ 	int idx;
+ 
+@@ -406,7 +407,8 @@ static void vc4_txp_encoder_disable(stru
+ 		WARN_ON(TXP_READ(TXP_DST_CTRL) & TXP_BUSY);
+ 	}
+ 
+-	TXP_WRITE(TXP_DST_CTRL, TXP_POWERDOWN);
++	if (vc4->gen < VC4_GEN_6)
++		TXP_WRITE(TXP_DST_CTRL, TXP_POWERDOWN);
+ 
+ 	drm_dev_exit(idx);
+ }
+@@ -510,6 +512,19 @@ static irqreturn_t vc4_txp_interrupt(int
+ 	return IRQ_HANDLED;
+ }
+ 
++const struct vc4_txp_data bcm2712_mop_data = {
++	.base = {
++		.name = "mop",
++		.debugfs_name = "mop_regs",
++		.hvs_available_channels = BIT(2),
++		.hvs_output = 2,
++	},
++	.encoder_type = VC4_ENCODER_TYPE_TXP0,
++	.has_byte_enable = true,
++	.size_minus_one = true,
++	.supports_40bit_addresses = true,
++};
++
+ const struct vc4_txp_data bcm2835_txp_data = {
+ 	.base = {
+ 		.name = "txp",
+@@ -616,6 +631,7 @@ static int vc4_txp_remove(struct platfor
+ }
+ 
+ static const struct of_device_id vc4_txp_dt_match[] = {
++	{ .compatible = "brcm,bcm2712-mop", .data = &bcm2712_mop_data },
+ 	{ .compatible = "brcm,bcm2835-txp", .data = &bcm2835_txp_data },
+ 	{ /* sentinel */ },
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-0974-drm-vc4-txp-Add-BCM2712-MOPLET-support.patch b/target/linux/bcm27xx/patches-6.1/950-0974-drm-vc4-txp-Add-BCM2712-MOPLET-support.patch
new file mode 100644
index 0000000000..b2a28bd144
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0974-drm-vc4-txp-Add-BCM2712-MOPLET-support.patch
@@ -0,0 +1,42 @@
+From b239fc6a68fea2b073c4cb48884fbb697014ac2b Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Mon, 20 Feb 2023 17:16:01 +0100
+Subject: [PATCH] drm/vc4: txp: Add BCM2712 MOPLET support
+
+The BCM2712 features a simpler TXP called MOPLET. Let's add support for
+it.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_txp.c | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -525,6 +525,18 @@ const struct vc4_txp_data bcm2712_mop_da
+ 	.supports_40bit_addresses = true,
+ };
+ 
++const struct vc4_txp_data bcm2712_moplet_data = {
++	.base = {
++		.name = "moplet",
++		.debugfs_name = "moplet_regs",
++		.hvs_available_channels = BIT(1),
++		.hvs_output = 4,
++	},
++	.encoder_type = VC4_ENCODER_TYPE_TXP1,
++	.size_minus_one = true,
++	.supports_40bit_addresses = true,
++};
++
+ const struct vc4_txp_data bcm2835_txp_data = {
+ 	.base = {
+ 		.name = "txp",
+@@ -632,6 +644,7 @@ static int vc4_txp_remove(struct platfor
+ 
+ static const struct of_device_id vc4_txp_dt_match[] = {
+ 	{ .compatible = "brcm,bcm2712-mop", .data = &bcm2712_mop_data },
++	{ .compatible = "brcm,bcm2712-moplet", .data = &bcm2712_moplet_data },
+ 	{ .compatible = "brcm,bcm2835-txp", .data = &bcm2835_txp_data },
+ 	{ /* sentinel */ },
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-0975-drm-vc4-Add-additional-warn_on.patch b/target/linux/bcm27xx/patches-6.1/950-0975-drm-vc4-Add-additional-warn_on.patch
new file mode 100644
index 0000000000..0fc95e5f6b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0975-drm-vc4-Add-additional-warn_on.patch
@@ -0,0 +1,240 @@
+From bb05ccd66342643b1cd9a0a48cec3ebdc3eed511 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Tue, 21 Feb 2023 14:38:32 +0100
+Subject: [PATCH] drm/vc4: Add additional warn_on
+
+Some code path in vc4 are conditional to a generation and cannot be
+executed on others. Let's put a WARN_ON if that ever happens.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c   | 32 ++++++++++++++++++++++++++++++--
+ drivers/gpu/drm/vc4/vc4_kms.c   |  6 ++++++
+ drivers/gpu/drm/vc4/vc4_plane.c | 19 +++++++++++++++++++
+ 3 files changed, 55 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -417,12 +417,15 @@ static int vc4_hvs_upload_linear_kernel(
+ static void vc4_hvs_lut_load(struct vc4_hvs *hvs,
+ 			     struct vc4_crtc *vc4_crtc)
+ {
+-	struct drm_device *drm = &hvs->vc4->base;
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *drm = &vc4->base;
+ 	struct drm_crtc *crtc = &vc4_crtc->base;
+ 	struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc->state);
+ 	int idx;
+ 	u32 i;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_5);
++
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return;
+ 
+@@ -758,6 +761,8 @@ u8 vc4_hvs_get_fifo_frame_count(struct v
+ 	u8 field = 0;
+ 	int idx;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
++
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return 0;
+ 
+@@ -791,6 +796,8 @@ int vc4_hvs_get_fifo_from_output(struct
+ 	u32 reg;
+ 	int ret;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
++
+ 	switch (vc4->gen) {
+ 	case VC4_GEN_4:
+ 		return output;
+@@ -880,6 +887,8 @@ static int vc4_hvs_init_channel(struct v
+ 	u32 dispctrl;
+ 	int idx;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_5);
++
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return -ENODEV;
+ 
+@@ -947,6 +956,8 @@ static int vc6_hvs_init_channel(struct v
+ 	u32 disp_ctrl1;
+ 	int idx;
+ 
++	WARN_ON_ONCE(vc4->gen != VC4_GEN_6);
++
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return -ENODEV;
+ 
+@@ -972,9 +983,12 @@ static int vc6_hvs_init_channel(struct v
+ 
+ static void __vc4_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int chan)
+ {
+-	struct drm_device *drm = &hvs->vc4->base;
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *drm = &vc4->base;
+ 	int idx;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_5);
++
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return;
+ 
+@@ -1007,6 +1021,8 @@ static void __vc6_hvs_stop_channel(struc
+ 	struct drm_device *drm = &vc4->base;
+ 	int idx;
+ 
++	WARN_ON_ONCE(vc4->gen != VC4_GEN_6);
++
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return;
+ 
+@@ -1234,6 +1250,8 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 	bool found = false;
+ 	int idx;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
++
+ 	if (!drm_dev_enter(dev, &idx)) {
+ 		vc4_crtc_send_vblank(crtc);
+ 		return;
+@@ -1324,6 +1342,8 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 	if (crtc->state->color_mgmt_changed) {
+ 		u32 dispbkgndx = HVS_READ(SCALER_DISPBKGNDX(channel));
+ 
++		WARN_ON_ONCE(vc4->gen > VC4_GEN_5);
++
+ 		if (crtc->state->gamma_lut) {
+ 			if (vc4->gen == VC4_GEN_4) {
+ 				vc4_hvs_update_gamma_lut(hvs, vc4_crtc);
+@@ -1363,6 +1383,8 @@ void vc4_hvs_mask_underrun(struct vc4_hv
+ 	u32 dispctrl;
+ 	int idx;
+ 
++	WARN_ON(vc4->gen > VC4_GEN_5);
++
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return;
+ 
+@@ -1383,6 +1405,8 @@ void vc4_hvs_unmask_underrun(struct vc4_
+ 	u32 dispctrl;
+ 	int idx;
+ 
++	WARN_ON(vc4->gen > VC4_GEN_5);
++
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return;
+ 
+@@ -1417,6 +1441,8 @@ static irqreturn_t vc4_hvs_irq_handler(i
+ 	u32 status;
+ 	u32 dspeislur;
+ 
++	WARN_ON(vc4->gen > VC4_GEN_5);
++
+ 	/*
+ 	 * NOTE: We don't need to protect the register access using
+ 	 * drm_dev_enter() there because the interrupt handler lifetime
+@@ -1466,6 +1492,8 @@ static irqreturn_t vc6_hvs_eof_irq_handl
+ 	struct vc4_hvs *hvs = vc4->hvs;
+ 	unsigned int i;
+ 
++	WARN_ON(vc4->gen < VC4_GEN_6);
++
+ 	for (i = 0; i < HVS_NUM_CHANNELS; i++) {
+ 		if (!hvs->eof_irq[i].enabled)
+ 			continue;
+--- a/drivers/gpu/drm/vc4/vc4_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_kms.c
+@@ -147,6 +147,8 @@ vc4_ctm_commit(struct vc4_dev *vc4, stru
+ 	if (vc4->firmware_kms)
+ 		return;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_5);
++
+ 	if (ctm_state->fifo) {
+ 		HVS_WRITE(SCALER_OLEDCOEF2,
+ 			  VC4_SET_FIELD(vc4_ctm_s31_32_to_s0_9(ctm->matrix[0]),
+@@ -222,6 +224,8 @@ static void vc4_hvs_pv_muxing_commit(str
+ 	struct drm_crtc *crtc;
+ 	unsigned int i;
+ 
++	WARN_ON_ONCE(vc4->gen != VC4_GEN_4);
++
+ 	for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
+ 		struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
+ 		struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);
+@@ -265,6 +269,8 @@ static void vc5_hvs_pv_muxing_commit(str
+ 	unsigned int i;
+ 	u32 reg;
+ 
++	WARN_ON_ONCE(vc4->gen != VC4_GEN_5);
++
+ 	for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
+ 		struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);
+ 		struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -555,8 +555,11 @@ static int vc4_plane_setup_clipping_and_
+ 
+ static void vc4_write_tpz(struct vc4_plane_state *vc4_state, u32 src, u32 dst)
+ {
++	struct vc4_dev *vc4 = to_vc4_dev(vc4_state->base.plane->dev);
+ 	u32 scale, recip;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
++
+ 	scale = src / dst;
+ 
+ 	/* The specs note that while the reciprocal would be defined
+@@ -581,10 +584,13 @@ static void vc4_write_tpz(struct vc4_pla
+ 
+ static void vc4_write_ppf(struct vc4_plane_state *vc4_state, u32 src, u32 dst, u32 xy, int channel, int chroma_offset)
+ {
++	struct vc4_dev *vc4 = to_vc4_dev(vc4_state->base.plane->dev);
+ 	u32 scale = src / dst;
+ 	s32 offset, offset2;
+ 	s32 phase;
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
++
+ 	/* Start the phase at 1/2 pixel from the 1st pixel at src_x.
+ 	   1/4 pixel for YUV, plus the offset for chroma siting */
+ 	if (channel) {
+@@ -801,8 +807,11 @@ static size_t vc6_upm_size(const struct
+ static void vc4_write_scaling_parameters(struct drm_plane_state *state,
+ 					 int channel)
+ {
++	struct vc4_dev *vc4 = to_vc4_dev(state->plane->dev);
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
+ 
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
++
+ 	/* Ch0 H-PPF Word 0: Scaling Parameters */
+ 	if (vc4_state->x_scaling[channel] == VC4_SCALING_PPF) {
+ 		vc4_write_ppf(vc4_state,
+@@ -1040,6 +1049,11 @@ static const u32 colorspace_coeffs[2][DR
+ 
+ static u32 vc4_hvs4_get_alpha_blend_mode(struct drm_plane_state *state)
+ {
++	struct drm_device *dev = state->state->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++
++	WARN_ON_ONCE(vc4->gen != VC4_GEN_4);
++
+ 	if (!state->fb->format->has_alpha)
+ 		return VC4_SET_FIELD(SCALER_POS2_ALPHA_MODE_FIXED,
+ 				     SCALER_POS2_ALPHA_MODE);
+@@ -1061,6 +1075,11 @@ static u32 vc4_hvs4_get_alpha_blend_mode
+ 
+ static u32 vc4_hvs5_get_alpha_blend_mode(struct drm_plane_state *state)
+ {
++	struct drm_device *dev = state->state->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++
++	WARN_ON_ONCE(vc4->gen != VC4_GEN_5 && vc4->gen != VC4_GEN_6);
++
+ 	if (!state->fb->format->has_alpha)
+ 		return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_FIXED,
+ 				     SCALER5_CTL2_ALPHA_MODE);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0976-drm-vc4-tests-Switch-generation-mockup-to-a-switch.patch b/target/linux/bcm27xx/patches-6.1/950-0976-drm-vc4-tests-Switch-generation-mockup-to-a-switch.patch
new file mode 100644
index 0000000000..0751d46536
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0976-drm-vc4-tests-Switch-generation-mockup-to-a-switch.patch
@@ -0,0 +1,47 @@
+From 336917ca87807b8a4bb08855b4dcb0477289c765 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:35:16 +0100
+Subject: [PATCH] drm/vc4: tests: Switch generation mockup to a switch
+
+Testing whether the VideoCore generation we want to mock is vc5 or vc4
+worked so far, but will be difficult to extend to support BCM2712 (VC6).
+
+Convert to a switch.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.c | 18 ++++++++++++++++--
+ 1 file changed, 16 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.c
+@@ -155,13 +155,27 @@ static int __build_mock(struct kunit *te
+ 
+ static struct vc4_dev *__mock_device(struct kunit *test, enum vc4_gen gen)
+ {
++	const struct vc4_mock_desc *desc;
++	const struct drm_driver *drv;
+ 	struct drm_device *drm;
+-	const struct drm_driver *drv = (gen == VC4_GEN_5) ? &vc5_drm_driver : &vc4_drm_driver;
+-	const struct vc4_mock_desc *desc = (gen == VC4_GEN_5) ? &vc5_mock : &vc4_mock;
+ 	struct vc4_dev *vc4;
+ 	struct device *dev;
+ 	int ret;
+ 
++	switch (gen) {
++	case VC4_GEN_4:
++		drv = &vc4_drm_driver;
++		desc = &vc4_mock;
++		break;
++	case VC4_GEN_5:
++		drv = &vc5_drm_driver;
++		desc = &vc5_mock;
++		break;
++
++	default:
++		return NULL;
++	}
++
+ 	dev = drm_kunit_helper_alloc_device(test);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, dev);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0977-drm-vc4-tests-Drop-drm-parameter-for-vc4_find_crtc_f.patch b/target/linux/bcm27xx/patches-6.1/950-0977-drm-vc4-tests-Drop-drm-parameter-for-vc4_find_crtc_f.patch
new file mode 100644
index 0000000000..42c4be9b8b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0977-drm-vc4-tests-Drop-drm-parameter-for-vc4_find_crtc_f.patch
@@ -0,0 +1,63 @@
+From 70e906d3c688491e181446afa27bea32ce241d6a Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 24 Mar 2023 09:58:15 +0100
+Subject: [PATCH] drm/vc4: tests: Drop drm parameter for
+ vc4_find_crtc_for_encoder
+
+The DRM device pointer and the DRM encoder pointer are redundant, since
+the latter is attached to the former and we can just follow the
+drm_encoder->dev pointer.
+
+Let's remove the drm_device pointer argument.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.h           | 2 +-
+ drivers/gpu/drm/vc4/tests/vc4_mock_output.c    | 4 ++--
+ drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c | 2 +-
+ 3 files changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.h
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.h
+@@ -7,9 +7,9 @@
+ 
+ static inline
+ struct drm_crtc *vc4_find_crtc_for_encoder(struct kunit *test,
+-					   struct drm_device *drm,
+ 					   struct drm_encoder *encoder)
+ {
++	struct drm_device *drm = encoder->dev;
+ 	struct drm_crtc *crtc;
+ 
+ 	KUNIT_ASSERT_EQ(test, hweight32(encoder->possible_crtcs), 1);
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock_output.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock_output.c
+@@ -77,7 +77,7 @@ int vc4_mock_atomic_add_output(struct ku
+ 	encoder = vc4_find_encoder_by_type(drm, type);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, encoder);
+ 
+-	crtc = vc4_find_crtc_for_encoder(test, drm, encoder);
++	crtc = vc4_find_crtc_for_encoder(test, encoder);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, crtc);
+ 
+ 	output = container_of(encoder, struct vc4_dummy_output, encoder.base);
+@@ -115,7 +115,7 @@ int vc4_mock_atomic_del_output(struct ku
+ 	encoder = vc4_find_encoder_by_type(drm, type);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, encoder);
+ 
+-	crtc = vc4_find_crtc_for_encoder(test, drm, encoder);
++	crtc = vc4_find_crtc_for_encoder(test, encoder);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, crtc);
+ 
+ 	crtc_state = drm_atomic_get_crtc_state(state, crtc);
+--- a/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
+@@ -132,7 +132,7 @@ get_vc4_crtc_state_for_encoder(struct ku
+ 	encoder = vc4_find_encoder_by_type(drm, type);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, encoder);
+ 
+-	crtc = vc4_find_crtc_for_encoder(test, drm, encoder);
++	crtc = vc4_find_crtc_for_encoder(test, encoder);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, crtc);
+ 
+ 	new_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0978-drm-vc4-tests-Return-the-allocated-output.patch b/target/linux/bcm27xx/patches-6.1/950-0978-drm-vc4-tests-Return-the-allocated-output.patch
new file mode 100644
index 0000000000..6f49d52f32
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0978-drm-vc4-tests-Return-the-allocated-output.patch
@@ -0,0 +1,174 @@
+From 14e97c5765579eaab3c8372701750ffa30e4c7da Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 24 Mar 2023 10:02:59 +0100
+Subject: [PATCH] drm/vc4: tests: Return the allocated output
+
+Some tests will need to retrieve the output that was just allocated by
+vc4_mock_atomic_add_output().
+
+Instead of making them look them up in the DRM device, we can simply
+make vc4_mock_atomic_add_output() return an error pointer that holds the
+allocated output instead of the error code.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.h          |  7 ++--
+ drivers/gpu/drm/vc4/tests/vc4_mock_output.c   |  9 +++--
+ .../gpu/drm/vc4/tests/vc4_test_pv_muxing.c    | 37 +++++++++++--------
+ 3 files changed, 30 insertions(+), 23 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.h
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.h
+@@ -53,9 +53,10 @@ struct vc4_dummy_output *vc4_dummy_outpu
+ struct vc4_dev *vc4_mock_device(struct kunit *test);
+ struct vc4_dev *vc5_mock_device(struct kunit *test);
+ 
+-int vc4_mock_atomic_add_output(struct kunit *test,
+-			       struct drm_atomic_state *state,
+-			       enum vc4_encoder_type type);
++struct vc4_dummy_output *
++vc4_mock_atomic_add_output(struct kunit *test,
++			   struct drm_atomic_state *state,
++			   enum vc4_encoder_type type);
+ int vc4_mock_atomic_del_output(struct kunit *test,
+ 			       struct drm_atomic_state *state,
+ 			       enum vc4_encoder_type type);
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock_output.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock_output.c
+@@ -61,9 +61,10 @@ static const struct drm_display_mode def
+ 	DRM_SIMPLE_MODE(640, 480, 64, 48)
+ };
+ 
+-int vc4_mock_atomic_add_output(struct kunit *test,
+-			       struct drm_atomic_state *state,
+-			       enum vc4_encoder_type type)
++struct vc4_dummy_output *
++vc4_mock_atomic_add_output(struct kunit *test,
++			   struct drm_atomic_state *state,
++			   enum vc4_encoder_type type)
+ {
+ 	struct drm_device *drm = state->dev;
+ 	struct drm_connector_state *conn_state;
+@@ -96,7 +97,7 @@ int vc4_mock_atomic_add_output(struct ku
+ 
+ 	crtc_state->active = true;
+ 
+-	return 0;
++	return output;
+ }
+ 
+ int vc4_mock_atomic_del_output(struct kunit *test,
+--- a/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
+@@ -683,10 +683,11 @@ static void drm_vc4_test_pv_muxing(struc
+ 	int ret;
+ 
+ 	for (i = 0; i < params->nencoders; i++) {
++		struct vc4_dummy_output *output;
+ 		enum vc4_encoder_type enc_type = params->encoders[i];
+ 
+-		ret = vc4_mock_atomic_add_output(test, state, enc_type);
+-		KUNIT_ASSERT_EQ(test, ret, 0);
++		output = vc4_mock_atomic_add_output(test, state, enc_type);
++		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+ 	}
+ 
+ 	ret = drm_atomic_check_only(state);
+@@ -712,10 +713,11 @@ static void drm_vc4_test_pv_muxing_inval
+ 	int ret;
+ 
+ 	for (i = 0; i < params->nencoders; i++) {
++		struct vc4_dummy_output *output;
+ 		enum vc4_encoder_type enc_type = params->encoders[i];
+ 
+-		ret = vc4_mock_atomic_add_output(test, state, enc_type);
+-		KUNIT_ASSERT_EQ(test, ret, 0);
++		output = vc4_mock_atomic_add_output(test, state, enc_type);
++		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+ 	}
+ 
+ 	ret = drm_atomic_check_only(state);
+@@ -804,6 +806,7 @@ static void drm_test_vc5_pv_muxing_bugs_
+ {
+ 	struct drm_modeset_acquire_ctx ctx;
+ 	struct drm_atomic_state *state;
++	struct vc4_dummy_output *output;
+ 	struct vc4_crtc_state *new_vc4_crtc_state;
+ 	struct vc4_hvs_state *new_hvs_state;
+ 	unsigned int hdmi0_channel;
+@@ -823,8 +826,8 @@ static void drm_test_vc5_pv_muxing_bugs_
+ 
+ 	state->acquire_ctx = &ctx;
+ 
+-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
+-	KUNIT_ASSERT_EQ(test, ret, 0);
++	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+ 
+ 	ret = drm_atomic_check_only(state);
+ 	KUNIT_ASSERT_EQ(test, ret, 0);
+@@ -850,8 +853,8 @@ static void drm_test_vc5_pv_muxing_bugs_
+ 
+ 	state->acquire_ctx = &ctx;
+ 
+-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
+-	KUNIT_ASSERT_EQ(test, ret, 0);
++	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+ 
+ 	ret = drm_atomic_check_only(state);
+ 	KUNIT_ASSERT_EQ(test, ret, 0);
+@@ -880,6 +883,7 @@ static void drm_test_vc5_pv_muxing_bugs_
+ {
+ 	struct drm_modeset_acquire_ctx ctx;
+ 	struct drm_atomic_state *state;
++	struct vc4_dummy_output *output;
+ 	struct vc4_crtc_state *new_vc4_crtc_state;
+ 	struct vc4_hvs_state *new_hvs_state;
+ 	unsigned int old_hdmi0_channel;
+@@ -899,11 +903,11 @@ static void drm_test_vc5_pv_muxing_bugs_
+ 
+ 	state->acquire_ctx = &ctx;
+ 
+-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
+-	KUNIT_ASSERT_EQ(test, ret, 0);
++	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+ 
+-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
+-	KUNIT_ASSERT_EQ(test, ret, 0);
++	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+ 
+ 	ret = drm_atomic_check_only(state);
+ 	KUNIT_ASSERT_EQ(test, ret, 0);
+@@ -971,6 +975,7 @@ drm_test_vc5_pv_muxing_bugs_subsequent_c
+ {
+ 	struct drm_modeset_acquire_ctx ctx;
+ 	struct drm_atomic_state *state;
++	struct vc4_dummy_output *output;
+ 	struct vc4_crtc_state *new_vc4_crtc_state;
+ 	struct drm_device *drm;
+ 	struct vc4_dev *vc4;
+@@ -987,8 +992,8 @@ drm_test_vc5_pv_muxing_bugs_subsequent_c
+ 
+ 	state->acquire_ctx = &ctx;
+ 
+-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
+-	KUNIT_ASSERT_EQ(test, ret, 0);
++	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+ 
+ 	ret = drm_atomic_check_only(state);
+ 	KUNIT_ASSERT_EQ(test, ret, 0);
+@@ -1003,8 +1008,8 @@ drm_test_vc5_pv_muxing_bugs_subsequent_c
+ 
+ 	state->acquire_ctx = &ctx;
+ 
+-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
+-	KUNIT_ASSERT_EQ(test, ret, 0);
++	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+ 
+ 	ret = drm_atomic_check_only(state);
+ 	KUNIT_ASSERT_EQ(test, ret, 0);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0979-drm-vc4-tests-Add-BCM2712-mock-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0979-drm-vc4-tests-Add-BCM2712-mock-driver.patch
new file mode 100644
index 0000000000..8c12375284
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0979-drm-vc4-tests-Add-BCM2712-mock-driver.patch
@@ -0,0 +1,87 @@
+From 04bec005b049604f862765b35ebd71c2a69b9e7c Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 17 Feb 2023 13:38:10 +0100
+Subject: [PATCH] drm/vc4: tests: Add BCM2712 mock driver
+
+The BCM2712 has a simpler pipeline that can only output to a writeback
+connector and two HDMI controllers.
+
+Let's allow our kunit tests to create a mock of that pipeline.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.c | 29 ++++++++++++++++++++++++++++
+ drivers/gpu/drm/vc4/tests/vc4_mock.h |  1 +
+ drivers/gpu/drm/vc4/vc4_drv.h        |  2 ++
+ 3 files changed, 32 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.c
+@@ -106,6 +106,26 @@ static const struct vc4_mock_desc vc5_mo
+ 							      DRM_MODE_CONNECTOR_HDMIA)),
+ );
+ 
++static const struct vc4_mock_desc vc6_mock =
++	VC4_MOCK_DESC(
++		VC4_MOCK_CRTC_DESC(&bcm2712_mop_data.base,
++				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP0,
++							DRM_MODE_ENCODER_VIRTUAL,
++							DRM_MODE_CONNECTOR_WRITEBACK)),
++		VC4_MOCK_CRTC_DESC(&bcm2712_moplet_data.base,
++				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP1,
++							DRM_MODE_ENCODER_VIRTUAL,
++							DRM_MODE_CONNECTOR_WRITEBACK)),
++		VC4_MOCK_PIXELVALVE_DESC(&bcm2712_pv0_data,
++					 VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_HDMI0,
++							      DRM_MODE_ENCODER_TMDS,
++							      DRM_MODE_CONNECTOR_HDMIA)),
++		VC4_MOCK_PIXELVALVE_DESC(&bcm2712_pv1_data,
++					 VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_HDMI1,
++							      DRM_MODE_ENCODER_TMDS,
++							      DRM_MODE_CONNECTOR_HDMIA)),
++);
++
+ static int __build_one_pipe(struct kunit *test, struct drm_device *drm,
+ 			    const struct vc4_mock_pipe_desc *pipe)
+ {
+@@ -171,6 +191,10 @@ static struct vc4_dev *__mock_device(str
+ 		drv = &vc5_drm_driver;
+ 		desc = &vc5_mock;
+ 		break;
++	case VC4_GEN_6:
++		drv = &vc5_drm_driver;
++		desc = &vc6_mock;
++		break;
+ 
+ 	default:
+ 		return NULL;
+@@ -212,3 +236,8 @@ struct vc4_dev *vc5_mock_device(struct k
+ {
+ 	return __mock_device(test, VC4_GEN_5);
+ }
++
++struct vc4_dev *vc6_mock_device(struct kunit *test)
++{
++	return __mock_device(test, VC4_GEN_6);
++}
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.h
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.h
+@@ -52,6 +52,7 @@ struct vc4_dummy_output *vc4_dummy_outpu
+ 
+ struct vc4_dev *vc4_mock_device(struct kunit *test);
+ struct vc4_dev *vc5_mock_device(struct kunit *test);
++struct vc4_dev *vc6_mock_device(struct kunit *test);
+ 
+ struct vc4_dummy_output *
+ vc4_mock_atomic_add_output(struct kunit *test,
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -570,6 +570,8 @@ struct vc4_txp_data {
+ 	unsigned int supports_40bit_addresses:1;
+ };
+ 
++extern const struct vc4_txp_data bcm2712_mop_data;
++extern const struct vc4_txp_data bcm2712_moplet_data;
+ extern const struct vc4_txp_data bcm2835_txp_data;
+ 
+ struct vc4_pv_data {
diff --git a/target/linux/bcm27xx/patches-6.1/950-0980-drm-vc4-tests-Add-tests-for-BCM2712-PixelValve-Muxin.patch b/target/linux/bcm27xx/patches-6.1/950-0980-drm-vc4-tests-Add-tests-for-BCM2712-PixelValve-Muxin.patch
new file mode 100644
index 0000000000..6c0db592c9
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0980-drm-vc4-tests-Add-tests-for-BCM2712-PixelValve-Muxin.patch
@@ -0,0 +1,138 @@
+From 77c14764ae164b7969e65437a87aca25b30d8b80 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 14 Apr 2023 11:14:22 +0200
+Subject: [PATCH] drm/vc4: tests: Add tests for BCM2712 PixelValve Muxing
+
+The BCM2712 has a simpler pipeline than the BCM2711, and thus the muxing
+requirements are different. Create some tests to make sure we get proper
+muxing decisions.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ .../gpu/drm/vc4/tests/vc4_test_pv_muxing.c    | 81 +++++++++++++++++++
+ 1 file changed, 81 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
+@@ -105,6 +105,13 @@ static const struct encoder_constraint v
+ 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI1, 0, 1, 2),
+ };
+ 
++static const struct encoder_constraint vc6_encoder_constraints[] = {
++	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI0, 0),
++	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI1, 1),
++	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP1, 1),
++	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP0, 2),
++};
++
+ static bool check_vc4_encoder_constraints(enum vc4_encoder_type type, unsigned int channel)
+ {
+ 	return __check_encoder_constraints(vc4_encoder_constraints,
+@@ -119,6 +126,13 @@ static bool check_vc5_encoder_constraint
+ 					   type, channel);
+ }
+ 
++static bool check_vc6_encoder_constraints(enum vc4_encoder_type type, unsigned int channel)
++{
++	return __check_encoder_constraints(vc6_encoder_constraints,
++					   ARRAY_SIZE(vc6_encoder_constraints),
++					   type, channel);
++}
++
+ static struct vc4_crtc_state *
+ get_vc4_crtc_state_for_encoder(struct kunit *test,
+ 			       const struct drm_atomic_state *state,
+@@ -196,6 +210,9 @@ static void vc4_test_pv_muxing_desc(cons
+ #define VC5_PV_MUXING_TEST(_name, ...)		\
+ 	PV_MUXING_TEST(_name, vc5_mock_device, check_vc5_encoder_constraints, __VA_ARGS__)
+ 
++#define VC6_PV_MUXING_TEST(_name, ...)		\
++	PV_MUXING_TEST(_name, vc6_mock_device, check_vc6_encoder_constraints, __VA_ARGS__)
++
+ static const struct pv_muxing_param vc4_test_pv_muxing_params[] = {
+ 	VC4_PV_MUXING_TEST("1 output: DSI0",
+ 			   VC4_ENCODER_TYPE_DSI0),
+@@ -674,6 +691,54 @@ KUNIT_ARRAY_PARAM(vc5_test_pv_muxing_inv
+ 		  vc5_test_pv_muxing_invalid_params,
+ 		  vc4_test_pv_muxing_desc);
+ 
++static const struct pv_muxing_param vc6_test_pv_muxing_params[] = {
++	VC6_PV_MUXING_TEST("1 output: HDMI0",
++			   VC4_ENCODER_TYPE_HDMI0),
++	VC6_PV_MUXING_TEST("1 output: HDMI1",
++			   VC4_ENCODER_TYPE_HDMI1),
++	VC6_PV_MUXING_TEST("1 output: MOPLET",
++			   VC4_ENCODER_TYPE_TXP1),
++	VC6_PV_MUXING_TEST("1 output: MOP",
++			   VC4_ENCODER_TYPE_TXP0),
++	VC6_PV_MUXING_TEST("2 outputs: HDMI0, HDMI1",
++			   VC4_ENCODER_TYPE_HDMI0,
++			   VC4_ENCODER_TYPE_HDMI1),
++	VC6_PV_MUXING_TEST("2 outputs: HDMI0, MOPLET",
++			   VC4_ENCODER_TYPE_HDMI0,
++			   VC4_ENCODER_TYPE_TXP1),
++	VC6_PV_MUXING_TEST("2 outputs: HDMI0, MOP",
++			   VC4_ENCODER_TYPE_HDMI0,
++			   VC4_ENCODER_TYPE_TXP0),
++	VC6_PV_MUXING_TEST("2 outputs: HDMI1, MOP",
++			   VC4_ENCODER_TYPE_HDMI1,
++			   VC4_ENCODER_TYPE_TXP0),
++	VC6_PV_MUXING_TEST("2 outputs: MOPLET, MOP",
++			   VC4_ENCODER_TYPE_TXP1,
++			   VC4_ENCODER_TYPE_TXP0),
++	VC6_PV_MUXING_TEST("3 outputs: HDMI0, HDMI1, MOP",
++			   VC4_ENCODER_TYPE_HDMI0,
++			   VC4_ENCODER_TYPE_HDMI1,
++			   VC4_ENCODER_TYPE_TXP0),
++	VC6_PV_MUXING_TEST("3 outputs: HDMI0, MOPLET, MOP",
++			   VC4_ENCODER_TYPE_HDMI0,
++			   VC4_ENCODER_TYPE_TXP1,
++			   VC4_ENCODER_TYPE_TXP0),
++};
++
++KUNIT_ARRAY_PARAM(vc6_test_pv_muxing,
++		  vc6_test_pv_muxing_params,
++		  vc4_test_pv_muxing_desc);
++
++static const struct pv_muxing_param vc6_test_pv_muxing_invalid_params[] = {
++	VC6_PV_MUXING_TEST("HDMI1/MOPLET Conflict",
++			   VC4_ENCODER_TYPE_HDMI1,
++			   VC4_ENCODER_TYPE_TXP1),
++};
++
++KUNIT_ARRAY_PARAM(vc6_test_pv_muxing_invalid,
++		  vc6_test_pv_muxing_invalid_params,
++		  vc4_test_pv_muxing_desc);
++
+ static void drm_vc4_test_pv_muxing(struct kunit *test)
+ {
+ 	const struct pv_muxing_param *params = test->param_value;
+@@ -797,6 +862,21 @@ static struct kunit_suite vc5_pv_muxing_
+ 	.test_cases = vc5_pv_muxing_tests,
+ };
+ 
++static struct kunit_case vc6_pv_muxing_tests[] = {
++	KUNIT_CASE_PARAM(drm_vc4_test_pv_muxing,
++			 vc6_test_pv_muxing_gen_params),
++	KUNIT_CASE_PARAM(drm_vc4_test_pv_muxing_invalid,
++			 vc6_test_pv_muxing_invalid_gen_params),
++	{}
++};
++
++static struct kunit_suite vc6_pv_muxing_test_suite = {
++	.name = "vc6-pv-muxing-combinations",
++	.init = vc4_pv_muxing_test_init,
++	.exit = vc4_pv_muxing_test_exit,
++	.test_cases = vc6_pv_muxing_tests,
++};
++
+ /* See
+  * https://lore.kernel.org/all/3e113525-aa89-b1e2-56b7-ca55bd41d057@samsung.com/
+  * and
+@@ -1040,5 +1120,6 @@ static struct kunit_suite vc5_pv_muxing_
+ kunit_test_suites(
+ 	&vc4_pv_muxing_test_suite,
+ 	&vc5_pv_muxing_test_suite,
++	&vc6_pv_muxing_test_suite,
+ 	&vc5_pv_muxing_bugs_test_suite
+ );
diff --git a/target/linux/bcm27xx/patches-6.1/950-0981-drm-vc4-fkms-Rename-plane-related-functions.patch b/target/linux/bcm27xx/patches-6.1/950-0981-drm-vc4-fkms-Rename-plane-related-functions.patch
new file mode 100644
index 0000000000..b61d7ffba8
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0981-drm-vc4-fkms-Rename-plane-related-functions.patch
@@ -0,0 +1,64 @@
+From 3d849ab48cecab55862a4f2742f11937d66ba54b Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 14 Apr 2023 11:21:34 +0200
+Subject: [PATCH] drm/vc4: fkms: Rename plane related functions
+
+The name collide with the Full KMS functions that are going to be made
+public.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/vc4_firmware_kms.c | 14 +++++++-------
+ 1 file changed, 7 insertions(+), 7 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_firmware_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_firmware_kms.c
+@@ -663,8 +663,8 @@ static int vc4_plane_to_mb(struct drm_pl
+ 	return 0;
+ }
+ 
+-static int vc4_plane_atomic_check(struct drm_plane *plane,
+-				  struct drm_atomic_state *state)
++static int vc4_fkms_plane_atomic_check(struct drm_plane *plane,
++				       struct drm_atomic_state *state)
+ {
+ 	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
+ 										 plane);
+@@ -721,7 +721,7 @@ static int vc4_plane_atomic_async_check(
+ }
+ 
+ /* Called during init to allocate the plane's atomic state. */
+-static void vc4_plane_reset(struct drm_plane *plane)
++static void vc4_fkms_plane_reset(struct drm_plane *plane)
+ {
+ 	struct vc4_plane_state *vc4_state;
+ 
+@@ -781,7 +781,7 @@ static bool vc4_fkms_format_mod_supporte
+ 	}
+ }
+ 
+-static struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane)
++static struct drm_plane_state *vc4_fkms_plane_duplicate_state(struct drm_plane *plane)
+ {
+ 	struct vc4_plane_state *vc4_state;
+ 
+@@ -802,8 +802,8 @@ static const struct drm_plane_funcs vc4_
+ 	.disable_plane = drm_atomic_helper_disable_plane,
+ 	.destroy = vc4_plane_destroy,
+ 	.set_property = NULL,
+-	.reset = vc4_plane_reset,
+-	.atomic_duplicate_state = vc4_plane_duplicate_state,
++	.reset = vc4_fkms_plane_reset,
++	.atomic_duplicate_state = vc4_fkms_plane_duplicate_state,
+ 	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+ 	.format_mod_supported = vc4_fkms_format_mod_supported,
+ };
+@@ -811,7 +811,7 @@ static const struct drm_plane_funcs vc4_
+ static const struct drm_plane_helper_funcs vc4_plane_helper_funcs = {
+ 	.prepare_fb = drm_gem_plane_helper_prepare_fb,
+ 	.cleanup_fb = NULL,
+-	.atomic_check = vc4_plane_atomic_check,
++	.atomic_check = vc4_fkms_plane_atomic_check,
+ 	.atomic_update = vc4_plane_atomic_update,
+ 	.atomic_disable = vc4_plane_atomic_disable,
+ 	.atomic_async_check = vc4_plane_atomic_async_check,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0982-drm-vc4-tests-Use-custom-plane-state-for-mock.patch b/target/linux/bcm27xx/patches-6.1/950-0982-drm-vc4-tests-Use-custom-plane-state-for-mock.patch
new file mode 100644
index 0000000000..0105753a91
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0982-drm-vc4-tests-Use-custom-plane-state-for-mock.patch
@@ -0,0 +1,95 @@
+From 14fe42ff341741d60ba338c401855dee7fb68754 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 14 Apr 2023 11:24:37 +0200
+Subject: [PATCH] drm/vc4: tests: Use custom plane state for mock
+
+The current mock planes were just using the regular drm_plane_state,
+while the driver expect struct vc4_plane_state that subclasses
+drm_plane_state.
+
+Hook the proper implementations of reset, duplicate_state, destroy and
+atomic_check to create vc4_plane_state.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock_plane.c |  7 ++++---
+ drivers/gpu/drm/vc4/vc4_drv.h              |  6 ++++++
+ drivers/gpu/drm/vc4/vc4_plane.c            | 12 ++++++------
+ 3 files changed, 16 insertions(+), 9 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c
+@@ -10,12 +10,13 @@
+ #include "vc4_mock.h"
+ 
+ static const struct drm_plane_helper_funcs vc4_dummy_plane_helper_funcs = {
++	.atomic_check = vc4_plane_atomic_check,
+ };
+ 
+ static const struct drm_plane_funcs vc4_dummy_plane_funcs = {
+-	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,
+-	.atomic_duplicate_state	= drm_atomic_helper_plane_duplicate_state,
+-	.reset			= drm_atomic_helper_plane_reset,
++	.atomic_destroy_state	= vc4_plane_destroy_state,
++	.atomic_duplicate_state	= vc4_plane_duplicate_state,
++	.reset			= vc4_plane_reset,
+ };
+ 
+ static const uint32_t vc4_dummy_plane_formats[] = {
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -1145,6 +1145,12 @@ int vc4_kms_load(struct drm_device *dev)
+ struct drm_plane *vc4_plane_init(struct drm_device *dev,
+ 				 enum drm_plane_type type,
+ 				 uint32_t possible_crtcs);
++void vc4_plane_reset(struct drm_plane *plane);
++void vc4_plane_destroy_state(struct drm_plane *plane,
++			     struct drm_plane_state *state);
++struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane);
++int vc4_plane_atomic_check(struct drm_plane *plane,
++			   struct drm_atomic_state *state);
+ int vc4_plane_create_additional_planes(struct drm_device *dev);
+ u32 vc4_plane_write_dlist(struct drm_plane *plane, u32 __iomem *dlist);
+ u32 vc4_plane_dlist_size(const struct drm_plane_state *state);
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -276,7 +276,7 @@ static bool plane_enabled(struct drm_pla
+ 	return state->fb && !WARN_ON(!state->crtc);
+ }
+ 
+-static struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane)
++struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane)
+ {
+ 	struct vc4_plane_state *vc4_state;
+ 	unsigned int i;
+@@ -312,8 +312,8 @@ static struct drm_plane_state *vc4_plane
+ 	return &vc4_state->base;
+ }
+ 
+-static void vc4_plane_destroy_state(struct drm_plane *plane,
+-				    struct drm_plane_state *state)
++void vc4_plane_destroy_state(struct drm_plane *plane,
++			     struct drm_plane_state *state)
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
+ 	struct vc4_hvs *hvs = vc4->hvs;
+@@ -348,7 +348,7 @@ static void vc4_plane_destroy_state(stru
+ }
+ 
+ /* Called during init to allocate the plane's atomic state. */
+-static void vc4_plane_reset(struct drm_plane *plane)
++void vc4_plane_reset(struct drm_plane *plane)
+ {
+ 	struct vc4_plane_state *vc4_state;
+ 
+@@ -2000,8 +2000,8 @@ static int vc6_plane_mode_set(struct drm
+  * compute the dlist here and have all active plane dlists get updated
+  * in the CRTC's flush.
+  */
+-static int vc4_plane_atomic_check(struct drm_plane *plane,
+-				  struct drm_atomic_state *state)
++int vc4_plane_atomic_check(struct drm_plane *plane,
++			   struct drm_atomic_state *state)
+ {
+ 	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
+ 	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0983-drm-vc4-tests-Add-function-to-lookup-a-plane-for-a-C.patch b/target/linux/bcm27xx/patches-6.1/950-0983-drm-vc4-tests-Add-function-to-lookup-a-plane-for-a-C.patch
new file mode 100644
index 0000000000..ebab218cf3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0983-drm-vc4-tests-Add-function-to-lookup-a-plane-for-a-C.patch
@@ -0,0 +1,36 @@
+From 3320e449e40eeb49b601dcbbd4bd72b8cb8f3054 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 14 Apr 2023 11:26:58 +0200
+Subject: [PATCH] drm/vc4: tests: Add function to lookup a plane for a CRTC
+
+Some tests will need to find a plane to run a test on for a given CRTC.
+Let's create a small helper to do that.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.h | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.h
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.h
+@@ -21,6 +21,20 @@ struct drm_crtc *vc4_find_crtc_for_encod
+ 	return NULL;
+ }
+ 
++static inline
++struct drm_plane *vc4_mock_find_plane_for_crtc(struct kunit *test,
++					       struct drm_crtc *crtc)
++{
++	struct drm_device *drm = crtc->dev;
++	struct drm_plane *plane;
++
++	drm_for_each_plane(plane, drm)
++		if (plane->possible_crtcs & drm_crtc_mask(crtc))
++			return plane;
++
++	return NULL;
++}
++
+ struct vc4_dummy_plane {
+ 	struct vc4_plane plane;
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-0984-drm-vc4-tests-Add-helper-to-add-a-new-plane-to-a-sta.patch b/target/linux/bcm27xx/patches-6.1/950-0984-drm-vc4-tests-Add-helper-to-add-a-new-plane-to-a-sta.patch
new file mode 100644
index 0000000000..7d230294fc
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0984-drm-vc4-tests-Add-helper-to-add-a-new-plane-to-a-sta.patch
@@ -0,0 +1,62 @@
+From a2f912c44b98acb6c10c977db105e199011c09b5 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 14 Apr 2023 12:57:53 +0200
+Subject: [PATCH] drm/vc4: tests: Add helper to add a new plane to a state
+
+We'll start to add some tests for the plane state logic, so let's create
+a helper to add a plane to an existing atomic state.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock.h       |  4 ++++
+ drivers/gpu/drm/vc4/tests/vc4_mock_plane.c | 22 ++++++++++++++++++++++
+ 2 files changed, 26 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock.h
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock.h
+@@ -42,6 +42,10 @@ struct vc4_dummy_plane {
+ struct vc4_dummy_plane *vc4_dummy_plane(struct kunit *test,
+ 					struct drm_device *drm,
+ 					enum drm_plane_type type);
++struct drm_plane *
++vc4_mock_atomic_add_plane(struct kunit *test,
++			  struct drm_atomic_state *state,
++			  struct drm_crtc *crtc);
+ 
+ struct vc4_dummy_crtc {
+ 	struct vc4_crtc crtc;
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c
+@@ -1,6 +1,7 @@
+ // SPDX-License-Identifier: GPL-2.0
+ 
+ #include <drm/drm_atomic_state_helper.h>
++#include <drm/drm_atomic_uapi.h>
+ #include <drm/drm_fourcc.h>
+ #include <drm/drm_modeset_helper_vtables.h>
+ #include <drm/drm_plane.h>
+@@ -46,3 +47,24 @@ struct vc4_dummy_plane *vc4_dummy_plane(
+ 
+ 	return dummy_plane;
+ }
++
++struct drm_plane *
++vc4_mock_atomic_add_plane(struct kunit *test,
++			  struct drm_atomic_state *state,
++			  struct drm_crtc *crtc)
++{
++	struct drm_plane_state *plane_state;
++	struct drm_plane *plane;
++	int ret;
++
++	plane = vc4_mock_find_plane_for_crtc(test, crtc);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane);
++
++	plane_state = drm_atomic_get_plane_state(state, plane);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane_state);
++
++	ret = drm_atomic_set_crtc_for_plane(plane_state, crtc);
++	KUNIT_EXPECT_EQ(test, ret, 0);
++
++	return plane;
++}
diff --git a/target/linux/bcm27xx/patches-6.1/950-0985-drm-vc4-tests-Support-a-few-more-plane-formats.patch b/target/linux/bcm27xx/patches-6.1/950-0985-drm-vc4-tests-Support-a-few-more-plane-formats.patch
new file mode 100644
index 0000000000..191181dbb6
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0985-drm-vc4-tests-Support-a-few-more-plane-formats.patch
@@ -0,0 +1,26 @@
+From 418d2e0e652c3870c29dd2e462f052a88fa027da Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 14 Apr 2023 12:59:05 +0200
+Subject: [PATCH] drm/vc4: tests: Support a few more plane formats
+
+We'll start testing our planes code in situations where we will use more
+than XRGB8888, so let's add a few common pixel formats.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/tests/vc4_mock_plane.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c
+@@ -21,7 +21,10 @@ static const struct drm_plane_funcs vc4_
+ };
+ 
+ static const uint32_t vc4_dummy_plane_formats[] = {
++	DRM_FORMAT_ARGB8888,
+ 	DRM_FORMAT_XRGB8888,
++	DRM_FORMAT_YUV420,
++	DRM_FORMAT_YUV422,
+ };
+ 
+ struct vc4_dummy_plane *vc4_dummy_plane(struct kunit *test,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0986-drm-vc4-tests-Introduce-a-test-for-LBM-buffer-size.patch b/target/linux/bcm27xx/patches-6.1/950-0986-drm-vc4-tests-Introduce-a-test-for-LBM-buffer-size.patch
new file mode 100644
index 0000000000..5902d141ef
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0986-drm-vc4-tests-Introduce-a-test-for-LBM-buffer-size.patch
@@ -0,0 +1,358 @@
+From 39ae36d19bf6e59e3091f8f0ec6f4eac59aaf6f2 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime@cerno.tech>
+Date: Fri, 14 Apr 2023 13:43:32 +0200
+Subject: [PATCH] drm/vc4: tests: Introduce a test for LBM buffer size
+
+The BCM2712 comes with a different LBM size computation than the
+previous generations, so let's add the few examples provided as kunit
+tests to make sure we always satisfy those requirements.
+
+Signed-off-by: Maxime Ripard <maxime@cerno.tech>
+---
+ drivers/gpu/drm/vc4/Makefile                  |   3 +-
+ drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c | 327 ++++++++++++++++++
+ 2 files changed, 329 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c
+
+--- a/drivers/gpu/drm/vc4/Makefile
++++ b/drivers/gpu/drm/vc4/Makefile
+@@ -31,7 +31,8 @@ vc4-$(CONFIG_DRM_VC4_KUNIT_TEST) += \
+ 	tests/vc4_mock_crtc.o \
+ 	tests/vc4_mock_output.o \
+ 	tests/vc4_mock_plane.o \
+-	tests/vc4_test_pv_muxing.o
++	tests/vc4_test_pv_muxing.o \
++	tests/vc4_test_lbm_size.o
+ 
+ vc4-$(CONFIG_DEBUG_FS) += vc4_debugfs.o
+ 
+--- /dev/null
++++ b/drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c
+@@ -0,0 +1,327 @@
++// SPDX-License-Identifier: GPL-2.0
++
++#include <drm/drm_atomic_helper.h>
++#include <drm/drm_atomic_uapi.h>
++#include <drm/drm_drv.h>
++#include <drm/drm_fourcc.h>
++#include <drm/drm_framebuffer.h>
++#include <drm/drm_plane.h>
++#include <drm/drm_kunit_helpers.h>
++
++#include "../../drm_crtc_internal.h"
++#include "../../drm_internal.h"
++
++#include <kunit/test.h>
++
++#include "../vc4_drv.h"
++
++#include "vc4_mock.h"
++
++u32 vc4_lbm_size(struct drm_plane_state *state);
++
++struct vc4_lbm_size_priv {
++	struct vc4_dev *vc4;
++	struct drm_file *file;
++	struct drm_modeset_acquire_ctx ctx;
++	struct drm_atomic_state *state;
++};
++
++struct vc4_lbm_size_param {
++	unsigned int src_w, src_h;
++	unsigned int crtc_w, crtc_h;
++	bool forced_alpha;
++	u32 fourcc;
++	enum vc4_scaling_mode expected_x_scaling[2];
++	enum vc4_scaling_mode expected_y_scaling[2];
++	unsigned int expected_lbm_size;
++};
++
++static const struct vc4_lbm_size_param vc4_test_lbm_size_params[] = {
++	{
++		.src_w = 256,
++		.crtc_w = 256,
++		.src_h = 256,
++		.crtc_h = 512,
++		.fourcc = DRM_FORMAT_ARGB8888,
++		.expected_x_scaling = { VC4_SCALING_NONE, },
++		.expected_y_scaling = { VC4_SCALING_PPF, },
++		.expected_lbm_size = 32,
++	},
++	{
++		.src_w = 256,
++		.crtc_w = 179,
++		.src_h = 256,
++		.crtc_h = 512,
++		.fourcc = DRM_FORMAT_ARGB8888,
++		.expected_x_scaling = { VC4_SCALING_PPF, },
++		.expected_y_scaling = { VC4_SCALING_PPF, },
++		.expected_lbm_size = 23,
++	},
++	{
++		.src_w = 256,
++		.crtc_w = 256,
++		.src_h = 256,
++		.crtc_h = 512,
++		.fourcc = DRM_FORMAT_XRGB8888,
++		.expected_x_scaling = { VC4_SCALING_NONE, },
++		.expected_y_scaling = { VC4_SCALING_PPF, },
++		.expected_lbm_size = 24,
++	},
++	{
++		.src_w = 100,
++		.crtc_w = 73,
++		.src_h = 100,
++		.crtc_h = 73,
++		.fourcc = DRM_FORMAT_XRGB8888,
++		.expected_x_scaling = { VC4_SCALING_PPF, },
++		.expected_y_scaling = { VC4_SCALING_PPF, },
++		.expected_lbm_size = 8,
++	},
++	{
++		.src_w = 256,
++		.crtc_w = 256,
++		.src_h = 256,
++		.crtc_h = 512,
++		.forced_alpha = true,
++		.fourcc = DRM_FORMAT_ARGB8888,
++		.expected_x_scaling = { VC4_SCALING_NONE, },
++		.expected_y_scaling = { VC4_SCALING_PPF, },
++		.expected_lbm_size = 24,
++	},
++	{
++		.src_w = 100,
++		.crtc_w = 73,
++		.src_h = 100,
++		.crtc_h = 73,
++		.forced_alpha = true,
++		.fourcc = DRM_FORMAT_ARGB8888,
++		.expected_x_scaling = { VC4_SCALING_PPF, },
++		.expected_y_scaling = { VC4_SCALING_PPF, },
++		.expected_lbm_size = 8,
++	},
++	{
++		.src_w = 256,
++		.crtc_w = 94,
++		.src_h = 256,
++		.crtc_h = 94,
++		.fourcc = DRM_FORMAT_ARGB8888,
++		.expected_x_scaling = { VC4_SCALING_TPZ, },
++		.expected_y_scaling = { VC4_SCALING_TPZ, },
++		.expected_lbm_size = 6,
++	},
++
++/*
++ * TODO: Those tests reflect the LBM size calculation examples, but the
++ * driver ends up taking different scaler filters decisions, and thus
++ * doesn't end up with the same sizes. It would be valuable to have
++ * those tests, but the driver doesn't take a bad decision either, so
++ * it's not clear what we should do at this point.
++ */
++#if 0
++	{
++		.src_w = 320,
++		.crtc_w = 320,
++		.src_h = 320,
++		.crtc_h = 320,
++		.fourcc = DRM_FORMAT_YUV420,
++		.expected_x_scaling = { VC4_SCALING_NONE, VC4_SCALING_NONE, },
++		.expected_y_scaling = { VC4_SCALING_NONE, VC4_SCALING_PPF, },
++		.expected_lbm_size = 10,
++	},
++	{
++		.src_w = 512,
++		.crtc_w = 512,
++		.src_h = 512,
++		.crtc_h = 256,
++		.fourcc = DRM_FORMAT_YUV420,
++		.expected_x_scaling = { VC4_SCALING_NONE, VC4_SCALING_NONE, },
++		.expected_y_scaling = { VC4_SCALING_TPZ, VC4_SCALING_NONE, },
++		.expected_lbm_size = 5,
++	},
++	{
++		.src_w = 486,
++		.crtc_w = 157,
++		.src_h = 404,
++		.crtc_h = 929,
++		.fourcc = DRM_FORMAT_YUV422,
++		.expected_x_scaling = { VC4_SCALING_PPF, VC4_SCALING_PPF, },
++		.expected_y_scaling = { VC4_SCALING_PPF, VC4_SCALING_PPF, },
++		.expected_lbm_size = 20,
++	},
++	{
++		.src_w = 320,
++		.crtc_w = 128,
++		.src_h = 176,
++		.crtc_h = 70,
++		.fourcc = DRM_FORMAT_YUV420,
++		.expected_x_scaling = { VC4_SCALING_TPZ, VC4_SCALING_TPZ, },
++		.expected_y_scaling = { VC4_SCALING_TPZ, VC4_SCALING_TPZ, },
++		.expected_lbm_size = 8,
++	},
++#endif
++};
++
++static void vc4_test_lbm_size_desc(const struct vc4_lbm_size_param *t, char *desc)
++{
++	snprintf(desc, KUNIT_PARAM_DESC_SIZE,
++		 "%ux%u to %ux%u %s(%p4cc)",
++		 t->src_w, t->src_h,
++		 t->crtc_w, t->crtc_h,
++		 t->forced_alpha ? "with forced alpha " : "",
++		 &t->fourcc);
++}
++
++KUNIT_ARRAY_PARAM(vc4_test_lbm_size,
++		  vc4_test_lbm_size_params,
++		  vc4_test_lbm_size_desc);
++
++static void drm_vc4_test_vc4_lbm_size(struct kunit *test)
++{
++	const struct vc4_lbm_size_param *params = test->param_value;
++	const struct vc4_lbm_size_priv *priv = test->priv;
++	const struct drm_format_info *info;
++	struct drm_mode_fb_cmd2 fb_req = { };
++	struct drm_atomic_state *state = priv->state;
++	struct vc4_plane_state *vc4_plane_state;
++	struct drm_plane_state *plane_state;
++	struct vc4_dummy_output *output;
++	struct drm_framebuffer *fb;
++	struct drm_plane *plane;
++	struct drm_crtc *crtc;
++	unsigned int i;
++	int ret;
++
++	info = drm_format_info(params->fourcc);
++	KUNIT_ASSERT_NOT_NULL(test, info);
++
++	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
++
++	crtc = vc4_find_crtc_for_encoder(test, &output->encoder.base);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, crtc);
++
++	plane = vc4_mock_atomic_add_plane(test, state, crtc);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane);
++
++	plane_state = drm_atomic_get_plane_state(state, plane);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane_state);
++
++	vc4_plane_state = to_vc4_plane_state(plane_state);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, vc4_plane_state);
++
++	fb_req.pixel_format = params->fourcc;
++	fb_req.width = params->src_w;
++	fb_req.height = params->src_h;
++
++	for (i = 0; i < info->num_planes; i++) {
++		struct drm_mode_create_dumb dumb_args = { };
++
++		dumb_args.width = params->src_w;
++		dumb_args.height = params->src_h;
++		dumb_args.bpp = drm_format_info_bpp(info, i);
++
++		ret = drm_mode_create_dumb(state->dev, &dumb_args, priv->file);
++		KUNIT_ASSERT_EQ(test, ret, 0);
++
++		fb_req.handles[i] = dumb_args.handle;
++		fb_req.pitches[i] = dumb_args.pitch;
++	}
++
++	fb = drm_internal_framebuffer_create(state->dev, &fb_req, priv->file);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, fb);
++
++	drm_atomic_set_fb_for_plane(plane_state, fb);
++
++	plane_state->src_x = 0;
++	plane_state->src_y = 0;
++	plane_state->src_h = params->src_h << 16;
++	plane_state->src_w = params->src_w << 16;
++
++	plane_state->crtc_x = 0;
++	plane_state->crtc_y = 0;
++	plane_state->crtc_h = params->crtc_h;
++	plane_state->crtc_w = params->crtc_w;
++
++	if (params->forced_alpha)
++		plane_state->alpha = 128;
++
++	ret = drm_atomic_check_only(state);
++	KUNIT_ASSERT_EQ(test, ret, 0);
++
++	KUNIT_EXPECT_EQ(test, vc4_plane_state->lbm.size, params->expected_lbm_size);
++
++	for (i = 0; i < 2; i++) {
++		KUNIT_EXPECT_EQ(test,
++				vc4_plane_state->x_scaling[i],
++				params->expected_x_scaling[i]);
++		KUNIT_EXPECT_EQ(test,
++				vc4_plane_state->y_scaling[i],
++				params->expected_y_scaling[i]);
++	}
++
++	drm_framebuffer_put(fb);
++
++	for (i = 0; i < info->num_planes; i++)
++		drm_mode_destroy_dumb(state->dev, fb_req.handles[i], priv->file);
++}
++
++static struct kunit_case vc4_lbm_size_tests[] = {
++	KUNIT_CASE_PARAM(drm_vc4_test_vc4_lbm_size,
++			 vc4_test_lbm_size_gen_params),
++	{}
++};
++
++static int vc4_lbm_size_test_init(struct kunit *test)
++{
++	struct drm_atomic_state *state;
++	struct vc4_lbm_size_priv *priv;
++	struct drm_device *drm;
++	struct vc4_dev *vc4;
++
++	priv = kunit_kzalloc(test, sizeof(*priv), GFP_KERNEL);
++	KUNIT_ASSERT_NOT_NULL(test, priv);
++	test->priv = priv;
++
++	vc4 = vc6_mock_device(test);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, vc4);
++	priv->vc4 = vc4;
++
++	priv->file = drm_file_alloc(priv->vc4->base.primary);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, priv->file);
++
++	drm_modeset_acquire_init(&priv->ctx, 0);
++
++	drm = &vc4->base;
++	state = drm_atomic_state_alloc(drm);
++	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, state);
++
++	state->acquire_ctx = &priv->ctx;
++
++	priv->state = state;
++
++	return 0;
++}
++
++static void vc4_lbm_size_test_exit(struct kunit *test)
++{
++	struct vc4_lbm_size_priv *priv = test->priv;
++	struct vc4_dev *vc4 = priv->vc4;
++	struct drm_device *drm = &vc4->base;
++	struct drm_atomic_state *state = priv->state;
++
++	drm_atomic_state_put(state);
++	drm_modeset_drop_locks(&priv->ctx);
++	drm_modeset_acquire_fini(&priv->ctx);
++	drm_file_free(priv->file);
++	drm_dev_unregister(drm);
++	drm_kunit_helper_free_device(test, vc4->dev);
++}
++
++static struct kunit_suite vc4_lbm_size_test_suite = {
++	.name = "vc4-lbm-size",
++	.init = vc4_lbm_size_test_init,
++	.exit = vc4_lbm_size_test_exit,
++	.test_cases = vc4_lbm_size_tests,
++};
++
++kunit_test_suite(vc4_lbm_size_test_suite);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0987-drm-vc4-kms-Avoid-setting-core-and-disp-clocks-for-h.patch b/target/linux/bcm27xx/patches-6.1/950-0987-drm-vc4-kms-Avoid-setting-core-and-disp-clocks-for-h.patch
new file mode 100644
index 0000000000..f20b0cf3f8
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0987-drm-vc4-kms-Avoid-setting-core-and-disp-clocks-for-h.patch
@@ -0,0 +1,40 @@
+From 352d96c9e50012f2b5e5dde9933af8d570e7dc81 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Mon, 17 Jul 2023 17:45:32 +0100
+Subject: [PATCH] drm/vc4: kms: Avoid setting core and disp clocks for hdmi
+ modes
+
+On 2712, the firmware always runs these clock at a speed sufficient
+for dual 4kp60.
+
+The requests here prevent the gpu from going into its lowest voltage
+mode, so just skip the clock requests.
+
+With this applied the idle voltage on my pi 5 reduces from 0.7424V
+to 0.72V.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/gpu/drm/vc4/vc4_kms.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_kms.c
+@@ -435,7 +435,7 @@ static void vc4_atomic_commit_tail(struc
+ 		old_hvs_state->fifo_state[channel].pending_commit = NULL;
+ 	}
+ 
+-	if (vc4->gen >= VC4_GEN_5 && !vc4->firmware_kms) {
++	if (vc4->gen == VC4_GEN_5 && !vc4->firmware_kms) {
+ 		unsigned long state_rate = max(old_hvs_state->core_clock_rate,
+ 					       new_hvs_state->core_clock_rate);
+ 		unsigned long core_rate = clamp_t(unsigned long, state_rate,
+@@ -489,7 +489,7 @@ static void vc4_atomic_commit_tail(struc
+ 
+ 	drm_atomic_helper_cleanup_planes(dev, state);
+ 
+-	if (vc4->gen >= VC4_GEN_5 && !vc4->firmware_kms) {
++	if (vc4->gen == VC4_GEN_5 && !vc4->firmware_kms) {
+ 		unsigned long core_rate = min_t(unsigned long,
+ 						hvs->max_core_rate,
+ 						new_hvs_state->core_clock_rate);
diff --git a/target/linux/bcm27xx/patches-6.1/950-0988-drm-vc4-Assign-LBM-memory-during-atomic_flush.patch b/target/linux/bcm27xx/patches-6.1/950-0988-drm-vc4-Assign-LBM-memory-during-atomic_flush.patch
new file mode 100644
index 0000000000..b489bbc7f7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0988-drm-vc4-Assign-LBM-memory-during-atomic_flush.patch
@@ -0,0 +1,240 @@
+From bb0839405b61da6e6ae7141f7433f6a121725e6f Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 31 Aug 2023 11:45:38 +0100
+Subject: [PATCH] drm/vc4: Assign LBM memory during atomic_flush.
+
+Avoid double buffering LBM allocations by making the
+allocation a single alloc per crtc at atomic_flush.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c |  2 +-
+ drivers/gpu/drm/vc4/vc4_drv.h                 |  8 ++--
+ drivers/gpu/drm/vc4/vc4_hvs.c                 | 47 ++++++++++++++++++-
+ drivers/gpu/drm/vc4/vc4_plane.c               | 38 +++------------
+ 4 files changed, 58 insertions(+), 37 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c
++++ b/drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c
+@@ -248,7 +248,7 @@ static void drm_vc4_test_vc4_lbm_size(st
+ 	ret = drm_atomic_check_only(state);
+ 	KUNIT_ASSERT_EQ(test, ret, 0);
+ 
+-	KUNIT_EXPECT_EQ(test, vc4_plane_state->lbm.size, params->expected_lbm_size);
++	KUNIT_EXPECT_EQ(test, vc4_plane_state->lbm_size, params->expected_lbm_size);
+ 
+ 	for (i = 0; i < 2; i++) {
+ 		KUNIT_EXPECT_EQ(test,
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -437,6 +437,8 @@ struct vc4_plane_state {
+ 	u32 dlist_size; /* Number of dwords allocated for the display list */
+ 	u32 dlist_count; /* Number of used dwords in the display list. */
+ 
++	u32 lbm_size; /* LBM requirements for this plane */
++
+ 	/* Offset in the dlist to various words, for pageflip or
+ 	 * cursor updates.
+ 	 */
+@@ -462,9 +464,6 @@ struct vc4_plane_state {
+ 	bool is_unity;
+ 	bool is_yuv;
+ 
+-	/* Our allocation in LBM for temporary storage during scaling. */
+-	struct drm_mm_node lbm;
+-
+ 	/* Our allocation in UPM for prefetching. */
+ 	struct drm_mm_node upm[DRM_FORMAT_MAX_PLANES];
+ 
+@@ -661,6 +660,9 @@ struct vc4_crtc {
+ 	 * access to that value.
+ 	 */
+ 	unsigned int current_hvs_channel;
++
++	/* @lbm: Our allocation in LBM for temporary storage during scaling. */
++	struct drm_mm_node lbm;
+ };
+ 
+ static inline struct vc4_crtc *
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -1103,6 +1103,7 @@ int vc4_hvs_atomic_check(struct drm_crtc
+ 	struct drm_plane *plane;
+ 	const struct drm_plane_state *plane_state;
+ 	u32 dlist_count = 0;
++	u32 lbm_count = 0;
+ 
+ 	/* The pixelvalve can only feed one encoder (and encoders are
+ 	 * 1:1 with connectors.)
+@@ -1111,6 +1112,8 @@ int vc4_hvs_atomic_check(struct drm_crtc
+ 		return -EINVAL;
+ 
+ 	drm_atomic_crtc_state_for_each_plane_state(plane, plane_state, crtc_state) {
++		const struct vc4_plane_state *vc4_plane_state =
++						to_vc4_plane_state(plane_state);
+ 		u32 plane_dlist_count = vc4_plane_dlist_size(plane_state);
+ 
+ 		drm_dbg_driver(dev, "[CRTC:%d:%s] Found [PLANE:%d:%s] with DLIST size: %u\n",
+@@ -1119,6 +1122,7 @@ int vc4_hvs_atomic_check(struct drm_crtc
+ 			       plane_dlist_count);
+ 
+ 		dlist_count += plane_dlist_count;
++		lbm_count += vc4_plane_state->lbm_size;
+ 	}
+ 
+ 	dlist_count++; /* Account for SCALER_CTL0_END. */
+@@ -1132,6 +1136,8 @@ int vc4_hvs_atomic_check(struct drm_crtc
+ 
+ 	vc4_state->mm = alloc;
+ 
++	/* FIXME: Check total lbm allocation here */
++
+ 	return vc4_hvs_gamma_check(crtc, state);
+ }
+ 
+@@ -1246,7 +1252,10 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 	bool debug_dump_regs = false;
+ 	bool enable_bg_fill = false;
+ 	u32 __iomem *dlist_start, *dlist_next;
++	unsigned long irqflags;
+ 	unsigned int zpos = 0;
++	u32 lbm_offset = 0;
++	u32 lbm_size = 0;
+ 	bool found = false;
+ 	int idx;
+ 
+@@ -1265,6 +1274,35 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 		vc4_hvs_dump_state(hvs);
+ 	}
+ 
++	drm_atomic_crtc_for_each_plane(plane, crtc) {
++		vc4_plane_state = to_vc4_plane_state(plane->state);
++		lbm_size += vc4_plane_state->lbm_size;
++	}
++
++	if (drm_mm_node_allocated(&vc4_crtc->lbm)) {
++		spin_lock_irqsave(&vc4_crtc->irq_lock, irqflags);
++		drm_mm_remove_node(&vc4_crtc->lbm);
++		spin_unlock_irqrestore(&vc4_crtc->irq_lock, irqflags);
++	}
++
++	if (lbm_size) {
++		int ret;
++
++		spin_lock_irqsave(&vc4_crtc->irq_lock, irqflags);
++		ret = drm_mm_insert_node_generic(&vc4->hvs->lbm_mm,
++						 &vc4_crtc->lbm,
++						 lbm_size, 1,
++						 0, 0);
++		spin_unlock_irqrestore(&vc4_crtc->irq_lock, irqflags);
++
++		if (ret) {
++			pr_err("Failed to allocate LBM ret %d\n", ret);
++			return;
++		}
++	}
++
++	lbm_offset = vc4_crtc->lbm.start;
++
+ 	dlist_start = vc4->hvs->dlist + vc4_state->mm->mm_node.start;
+ 	dlist_next = dlist_start;
+ 
+@@ -1276,6 +1314,8 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 			if (plane->state->normalized_zpos != zpos)
+ 				continue;
+ 
++			vc4_plane_state = to_vc4_plane_state(plane->state);
++
+ 			/* Is this the first active plane? */
+ 			if (dlist_next == dlist_start) {
+ 				/* We need to enable background fill when a plane
+@@ -1286,10 +1326,15 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 				 * already needs it or all planes on top blend from
+ 				 * the first or a lower plane.
+ 				 */
+-				vc4_plane_state = to_vc4_plane_state(plane->state);
+ 				enable_bg_fill = vc4_plane_state->needs_bg_fill;
+ 			}
+ 
++			if (vc4_plane_state->lbm_size) {
++				vc4_plane_state->dlist[vc4_plane_state->lbm_offset] =
++								lbm_offset;
++				lbm_offset += vc4_plane_state->lbm_size;
++			}
++
+ 			dlist_next += vc4_plane_write_dlist(plane, dlist_next);
+ 
+ 			found = true;
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -288,7 +288,6 @@ struct drm_plane_state *vc4_plane_duplic
+ 	if (!vc4_state)
+ 		return NULL;
+ 
+-	memset(&vc4_state->lbm, 0, sizeof(vc4_state->lbm));
+ 	memset(&vc4_state->upm, 0, sizeof(vc4_state->upm));
+ 
+ 	for (i = 0; i < DRM_FORMAT_MAX_PLANES; i++)
+@@ -320,14 +319,6 @@ void vc4_plane_destroy_state(struct drm_
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
+ 	unsigned int i;
+ 
+-	if (drm_mm_node_allocated(&vc4_state->lbm)) {
+-		unsigned long irqflags;
+-
+-		spin_lock_irqsave(&hvs->mm_lock, irqflags);
+-		drm_mm_remove_node(&vc4_state->lbm);
+-		spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
+-	}
+-
+ 	for (i = 0; i < DRM_FORMAT_MAX_PLANES; i++) {
+ 		unsigned long irqflags;
+ 
+@@ -903,12 +894,13 @@ static int vc4_plane_allocate_lbm(struct
+ 	struct vc4_dev *vc4 = to_vc4_dev(drm);
+ 	struct drm_plane *plane = state->plane;
+ 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
+-	unsigned long irqflags;
+ 	u32 lbm_size;
+ 
+ 	lbm_size = vc4_lbm_size(state);
+-	if (!lbm_size)
++	if (!lbm_size) {
++		vc4_state->lbm_size = 0;
+ 		return 0;
++	}
+ 
+ 	/*
+ 	 * NOTE: BCM2712 doesn't need to be aligned, since the size
+@@ -925,28 +917,10 @@ static int vc4_plane_allocate_lbm(struct
+ 	if (WARN_ON(!vc4_state->lbm_offset))
+ 		return -EINVAL;
+ 
+-	/* Allocate the LBM memory that the HVS will use for temporary
+-	 * storage due to our scaling/format conversion.
++	/* FIXME: Add loop here that ensures that the total LBM assigned in this
++	 *  state is less than the total lbm size
+ 	 */
+-	if (!drm_mm_node_allocated(&vc4_state->lbm)) {
+-		int ret;
+-
+-		spin_lock_irqsave(&vc4->hvs->mm_lock, irqflags);
+-		ret = drm_mm_insert_node_generic(&vc4->hvs->lbm_mm,
+-						 &vc4_state->lbm,
+-						 lbm_size, 1,
+-						 0, 0);
+-		spin_unlock_irqrestore(&vc4->hvs->mm_lock, irqflags);
+-
+-		if (ret) {
+-			drm_err(drm, "Failed to allocate LBM entry: %d\n", ret);
+-			return ret;
+-		}
+-	} else {
+-		WARN_ON_ONCE(lbm_size != vc4_state->lbm.size);
+-	}
+-
+-	vc4_state->dlist[vc4_state->lbm_offset] = vc4_state->lbm.start;
++	vc4_state->lbm_size = lbm_size;
+ 
+ 	return 0;
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0989-drm-panel-simple-Alter-the-timing-for-the-Pi-7-DSI-d.patch b/target/linux/bcm27xx/patches-6.1/950-0989-drm-panel-simple-Alter-the-timing-for-the-Pi-7-DSI-d.patch
new file mode 100644
index 0000000000..ef70de7ee4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0989-drm-panel-simple-Alter-the-timing-for-the-Pi-7-DSI-d.patch
@@ -0,0 +1,33 @@
+From b1bd2f406eab321be642decd6aee6b6222aec62b Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 28 Jul 2023 17:40:27 +0100
+Subject: [PATCH] drm/panel: simple: Alter the timing for the Pi 7" DSI display
+
+vc4 has always fixed up the timing, so the values defined have
+never actually appeared on the wire.
+The display appears to want a slightly longer HFP, so extend
+the timings and recompute the clock to give the same frame rate.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/panel/panel-simple.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/panel/panel-simple.c
++++ b/drivers/gpu/drm/panel/panel-simple.c
+@@ -3241,11 +3241,11 @@ static const struct panel_desc qishenglo
+ };
+ 
+ static const struct drm_display_mode raspberrypi_7inch_mode = {
+-	.clock = 25979400 / 1000,
++	.clock = 27777,
+ 	.hdisplay = 800,
+-	.hsync_start = 800 + 2,
+-	.hsync_end = 800 + 2 + 2,
+-	.htotal = 800 + 2 + 2 + 46,
++	.hsync_start = 800 + 59,
++	.hsync_end = 800 + 59 + 2,
++	.htotal = 800 + 59 + 2 + 46,
+ 	.vdisplay = 480,
+ 	.vsync_start = 480 + 7,
+ 	.vsync_end = 480 + 7 + 2,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0990-drm-panel-waveshare-Fix-up-timings-for-10.1-panel.patch b/target/linux/bcm27xx/patches-6.1/950-0990-drm-panel-waveshare-Fix-up-timings-for-10.1-panel.patch
new file mode 100644
index 0000000000..0a4203fbc5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0990-drm-panel-waveshare-Fix-up-timings-for-10.1-panel.patch
@@ -0,0 +1,33 @@
+From c7cf33911d477fe55a91a9e4d84dad857b244ae3 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 28 Jul 2023 18:10:53 +0100
+Subject: [PATCH] drm/panel: waveshare: Fix up timings for 10.1" panel
+
+The 10.1" panel doesn't work with the timings defined. vc4
+will always have been fixing up the timing due to the limited
+integer divider, so compute the fixed up mode and use it
+directly.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/panel/panel-waveshare-dsi.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/panel/panel-waveshare-dsi.c
++++ b/drivers/gpu/drm/panel/panel-waveshare-dsi.c
+@@ -112,11 +112,11 @@ static const struct drm_display_mode ws_
+  * https://www.waveshare.com/product/raspberry-pi/displays/10.1inch-dsi-lcd-c.htm
+  */
+ static const struct drm_display_mode ws_panel_10_1_mode = {
+-	.clock = 76800,
++	.clock = 83333,
+ 	.hdisplay = 1280,
+-	.hsync_start = 1280 + 40,
+-	.hsync_end = 1280 + 40 + 20,
+-	.htotal = 1280 + 40 + 20 + 40,
++	.hsync_start = 1280 + 156,
++	.hsync_end = 1280 + 156 + 20,
++	.htotal = 1280 + 156 + 20 + 40,
+ 	.vdisplay = 800,
+ 	.vsync_start = 800 + 40,
+ 	.vsync_end = 800 + 40 + 48,
diff --git a/target/linux/bcm27xx/patches-6.1/950-0991-media-i2c-imx477-Fix-locking-in-imx477_init_controls.patch b/target/linux/bcm27xx/patches-6.1/950-0991-media-i2c-imx477-Fix-locking-in-imx477_init_controls.patch
new file mode 100644
index 0000000000..9d7869af9c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0991-media-i2c-imx477-Fix-locking-in-imx477_init_controls.patch
@@ -0,0 +1,34 @@
+From 72c25bbb761de2b2acd9f8b652d63e2a2f1caeed Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Mon, 11 Sep 2023 12:17:25 +0300
+Subject: [PATCH] media: i2c: imx477: Fix locking in imx477_init_controls()
+
+The driver does not lock the imx477 mutex when calling
+imx477_set_framing_limits(), leading to:
+
+WARNING: CPU: 3 PID: 426 at drivers/media/v4l2-core/v4l2-ctrls-api.c:934 __v4l2_ctrl_modify_range+0x1a0/0x210 [
+videodev]
+
+Fix this by taking the lock.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/i2c/imx477.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/media/i2c/imx477.c
++++ b/drivers/media/i2c/imx477.c
+@@ -2069,9 +2069,13 @@ static int imx477_init_controls(struct i
+ 
+ 	imx477->sd.ctrl_handler = ctrl_hdlr;
+ 
++	mutex_lock(&imx477->mutex);
++
+ 	/* Setup exposure and frame/line length limits. */
+ 	imx477_set_framing_limits(imx477);
+ 
++	mutex_unlock(&imx477->mutex);
++
+ 	return 0;
+ 
+ error:
diff --git a/target/linux/bcm27xx/patches-6.1/950-0994-overlays-Fix-vc4-kms-dsi-7inch.patch b/target/linux/bcm27xx/patches-6.1/950-0994-overlays-Fix-vc4-kms-dsi-7inch.patch
new file mode 100644
index 0000000000..10339e2774
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0994-overlays-Fix-vc4-kms-dsi-7inch.patch
@@ -0,0 +1,57 @@
+From 2ff65ffbdeb0c8764985af19df2a687a126136f4 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 29 Sep 2023 16:55:28 +0100
+Subject: [PATCH] overlays: Fix vc4-kms-dsi-7inch
+
+Fix the touchscreen.
+
+See: https://github.com/raspberrypi/linux/issues/5619
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/edt-ft5406.dtsi          | 13 ++++---------
+ .../boot/dts/overlays/vc4-kms-dsi-7inch-overlay.dts |  2 +-
+ 2 files changed, 5 insertions(+), 10 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/edt-ft5406.dtsi
++++ b/arch/arm/boot/dts/overlays/edt-ft5406.dtsi
+@@ -22,11 +22,13 @@
+ 		};
+ 	};
+ 
+-	fragment@12 {
+-		target = <&i2cbus>;
++	ts_i2c_frag: fragment@12 {
++		target = <&i2c_csi_dsi>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
++			status = "okay";
++
+ 			ft5406: ts@38 {
+ 				compatible = "edt,edt-ft5506";
+ 				reg = <0x38>;
+@@ -37,13 +39,6 @@
+ 		};
+ 	};
+ 
+-	ts_i2c_frag: fragment@13 {
+-		target = <&i2c_csi_dsi>;
+-		i2cbus: __overlay__ {
+-			status = "okay";
+-		};
+-	};
+-
+ 	__overrides__ {
+ 		sizex = <&ft5406>,"touchscreen-size-x:0";
+ 		sizey = <&ft5406>,"touchscreen-size-y:0";
+--- a/arch/arm/boot/dts/overlays/vc4-kms-dsi-7inch-overlay.dts
++++ b/arch/arm/boot/dts/overlays/vc4-kms-dsi-7inch-overlay.dts
+@@ -119,6 +119,6 @@
+ 		       <&panel_disp>, "reg:0=0",
+ 		       <&reg_bridge>, "reg:0=0",
+ 		       <&reg_bridge>, "regulator-name=bridge_reg_0";
+-		disable_touch = <0>, "-10-11-12";
++		disable_touch = <&ft5406>, "status=disabled";
+ 	};
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-0995-Revert-ASoC-hdmi-codec-Fix-broken-channel-map-report.patch b/target/linux/bcm27xx/patches-6.1/950-0995-Revert-ASoC-hdmi-codec-Fix-broken-channel-map-report.patch
new file mode 100644
index 0000000000..6c08344f02
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0995-Revert-ASoC-hdmi-codec-Fix-broken-channel-map-report.patch
@@ -0,0 +1,21 @@
+From 3256af79fffeea5b6e506da5524c1482c4746d9a Mon Sep 17 00:00:00 2001
+From: Matthias Reichl <hias@horus.com>
+Date: Mon, 2 Oct 2023 17:30:47 +0200
+Subject: [PATCH] Revert "ASoC: hdmi-codec: Fix broken channel map reporting"
+
+This reverts commit a319c6c1a5661af2014b98cd0a02526e7f2f515a.
+---
+ sound/soc/codecs/hdmi-codec.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/sound/soc/codecs/hdmi-codec.c
++++ b/sound/soc/codecs/hdmi-codec.c
+@@ -520,7 +520,7 @@ static int hdmi_codec_fill_codec_params(
+ 	hp->sample_rate = sample_rate;
+ 	hp->channels = channels;
+ 
+-	hcp->chmap_idx = ca_id;
++	hcp->chmap_idx = idx;
+ 
+ 	return 0;
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0996-ASoC-hdmi-codec-Fix-broken-channel-map-reporting.patch b/target/linux/bcm27xx/patches-6.1/950-0996-ASoC-hdmi-codec-Fix-broken-channel-map-reporting.patch
new file mode 100644
index 0000000000..c8fd2a2f90
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0996-ASoC-hdmi-codec-Fix-broken-channel-map-reporting.patch
@@ -0,0 +1,56 @@
+From a1caea3c996f6bfa8c9568f521257f4e473285fb Mon Sep 17 00:00:00 2001
+From: Matthias Reichl <hias@horus.com>
+Date: Fri, 29 Sep 2023 21:50:28 +0200
+Subject: [PATCH] ASoC: hdmi-codec: Fix broken channel map reporting
+
+Commit b84b53149476b22cc3b8677b771fb4cf06d1d455 upstream.
+
+Commit 4e0871333661 ("ASoC: hdmi-codec: fix channel info for
+compressed formats") accidentally changed hcp->chmap_idx from
+ca_id, the CEA channel allocation ID, to idx, the index to
+the table of channel mappings ordered by preference.
+
+This resulted in wrong channel maps being reported to userspace,
+eg for 5.1 "FL,FR,LFE,FC" was reported instead of the expected
+"FL,FR,LFE,FC,RL,RR":
+
+~ # speaker-test -c 6 -t sine
+...
+ 0 - Front Left
+ 3 - Front Center
+ 1 - Front Right
+ 2 - LFE
+ 4 - Unknown
+ 5 - Unknown
+
+~ # amixer cget iface=PCM,name='Playback Channel Map' | grep ': values'
+  : values=3,4,8,7,0,0,0,0
+
+Switch this back to ca_id in case of PCM audio so the correct channel
+map is reported again and set it to HDMI_CODEC_CHMAP_IDX_UNKNOWN in
+case of non-PCM audio so the PCM channel map control returns "Unknown"
+channels (value 0).
+
+Fixes: 4e0871333661 ("ASoC: hdmi-codec: fix channel info for compressed formats")
+Cc: stable@vger.kernel.org
+Signed-off-by: Matthias Reichl <hias@horus.com>
+Link: https://lore.kernel.org/r/20230929195027.97136-1-hias@horus.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ sound/soc/codecs/hdmi-codec.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/sound/soc/codecs/hdmi-codec.c
++++ b/sound/soc/codecs/hdmi-codec.c
+@@ -520,7 +520,10 @@ static int hdmi_codec_fill_codec_params(
+ 	hp->sample_rate = sample_rate;
+ 	hp->channels = channels;
+ 
+-	hcp->chmap_idx = idx;
++	if (pcm_audio)
++		hcp->chmap_idx = ca_id;
++	else
++		hcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;
+ 
+ 	return 0;
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-0997-media-rp1-cfe-Fix-use-of-freed-memory-on-errors.patch b/target/linux/bcm27xx/patches-6.1/950-0997-media-rp1-cfe-Fix-use-of-freed-memory-on-errors.patch
new file mode 100644
index 0000000000..7f1b505336
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0997-media-rp1-cfe-Fix-use-of-freed-memory-on-errors.patch
@@ -0,0 +1,48 @@
+From 3922bebc11fcc8459c798cfcb582828f9bbaa9e9 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Thu, 28 Sep 2023 11:33:53 +0300
+Subject: [PATCH] media: rp1: cfe: Fix use of freed memory on errors
+
+cfe_probe_complete() calls cfe_put() on both success and fail code paths.
+This works for the success path, but causes the cfe_device struct to be
+freed, even if it will be used later in the teardown code.
+
+Fix this by making the ref handling a bit saner: Let the video nodes
+have the refs as they do now, but also keep a ref in the "main" driver,
+released only at cfe_remove() time. This way the driver does not depend
+on the video nodes keeping the refs.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 9 ++-------
+ 1 file changed, 2 insertions(+), 7 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -1837,17 +1837,10 @@ static int cfe_probe_complete(struct cfe
+ 		goto unregister;
+ 	}
+ 
+-	/*
+-	 * Release the initial reference, all references are now owned by the
+-	 * video devices.
+-	 */
+-	cfe_put(cfe);
+ 	return 0;
+ 
+ unregister:
+ 	cfe_unregister_nodes(cfe);
+-	cfe_put(cfe);
+-
+ 	return ret;
+ }
+ 
+@@ -2129,6 +2122,8 @@ static int cfe_remove(struct platform_de
+ 
+ 	v4l2_device_unregister(&cfe->v4l2_dev);
+ 
++	cfe_put(cfe);
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-0998-media-rp1-cfe-Fix-width-height-in-cfe_start_channel.patch b/target/linux/bcm27xx/patches-6.1/950-0998-media-rp1-cfe-Fix-width-height-in-cfe_start_channel.patch
new file mode 100644
index 0000000000..d49856c32d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0998-media-rp1-cfe-Fix-width-height-in-cfe_start_channel.patch
@@ -0,0 +1,88 @@
+From 84c9958dd71b8a4dcf16cbf6fdb867c668652634 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Wed, 27 Sep 2023 16:00:39 +0300
+Subject: [PATCH] media: rp1: cfe: Fix width & height in cfe_start_channel()
+
+The logic for handling width & height in cfe_start_channel() is somewhat
+odd and, afaics, broken. The code reads:
+
+bool start_fe = is_fe_enabled(cfe) &&
+                test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING);
+
+if (start_fe || is_image_output_node(node)) {
+        width = node->fmt.fmt.pix.width;
+        height = node->fmt.fmt.pix.height;
+}
+
+cfe_start_channel() is called for all video nodes that will be used. So
+this means that if, say, fe_stats is enabled as the last node, start_fe
+will be true, and width and height will be taken from fe_stats' node.
+The width and height will thus contain garbage, which then gets
+programmed to the csi2 registers.
+
+It seems that this often still works fine, though, probably if the width
+& height are large enough.
+
+Drop the above code, and instead get the width & height from the csi2
+subdev's sink pad for the csi2 channel that is used. For metadata the
+width & height will be 0 as before.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 16 ++++++++++------
+ 1 file changed, 10 insertions(+), 6 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -763,20 +763,16 @@ static void cfe_start_channel(struct cfe
+ 	struct v4l2_mbus_framefmt *source_fmt;
+ 	const struct cfe_fmt *fmt;
+ 	unsigned long flags;
+-	unsigned int width = 0, height = 0;
+ 	bool start_fe = is_fe_enabled(cfe) &&
+ 			test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING);
+ 
+ 	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
+ 
+-	if (start_fe || is_image_output_node(node)) {
+-		width = node->fmt.fmt.pix.width;
+-		height = node->fmt.fmt.pix.height;
+-	}
+-
+ 	state = v4l2_subdev_lock_and_get_active_state(&cfe->csi2.sd);
+ 
+ 	if (start_fe) {
++		unsigned int width, height;
++
+ 		WARN_ON(!is_fe_enabled(cfe));
+ 		cfe_dbg("%s: %s using csi2 channel %d\n",
+ 			__func__, node_desc[FE_OUT0].name,
+@@ -785,6 +781,9 @@ static void cfe_start_channel(struct cfe
+ 		source_fmt = v4l2_subdev_get_pad_format(&cfe->csi2.sd, state, cfe->fe_csi2_channel);
+ 		fmt = find_format_by_code(source_fmt->code);
+ 
++		width = source_fmt->width;
++		height = source_fmt->height;
++
+ 		/*
+ 		 * Start the associated CSI2 Channel as well.
+ 		 *
+@@ -800,6 +799,8 @@ static void cfe_start_channel(struct cfe
+ 	}
+ 
+ 	if (is_csi2_node(node)) {
++		unsigned int width = 0, height = 0;
++
+ 		u32 mode = CSI2_MODE_NORMAL;
+ 
+ 		source_fmt = v4l2_subdev_get_pad_format(&cfe->csi2.sd, state,
+@@ -807,6 +808,9 @@ static void cfe_start_channel(struct cfe
+ 		fmt = find_format_by_code(source_fmt->code);
+ 
+ 		if (is_image_output_node(node)) {
++			width = source_fmt->width;
++			height = source_fmt->height;
++
+ 			if (node->fmt.fmt.pix.pixelformat ==
+ 					fmt->remap[CFE_REMAP_16BIT])
+ 				mode = CSI2_MODE_REMAP;
diff --git a/target/linux/bcm27xx/patches-6.1/950-0999-media-rp1-csi2-Fix-missing-reg-writes.patch b/target/linux/bcm27xx/patches-6.1/950-0999-media-rp1-csi2-Fix-missing-reg-writes.patch
new file mode 100644
index 0000000000..2a3915b6e3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-0999-media-rp1-csi2-Fix-missing-reg-writes.patch
@@ -0,0 +1,36 @@
+From 62e8ab88d2c230dad122aabe2ad0e227d7ceba40 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Thu, 28 Sep 2023 10:42:22 +0300
+Subject: [PATCH] media: rp1: csi2: Fix missing reg writes
+
+The driver has two places where it writes a register based on a
+condition, and when that condition is false, the driver presumes that
+the register has the reset value. This is not a good idea, so fix those
+places to always write the register.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/csi2.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -253,6 +253,7 @@ void csi2_start_channel(struct csi2_devi
+ 		 */
+ 		set_field(&ctrl, 0x3ff, LC_MASK);
+ 		set_field(&ctrl, 0x00, CH_MODE_MASK);
++		csi2_reg_write(csi2, CSI2_CH_FRAME_SIZE(channel), 0);
+ 	}
+ 
+ 	set_field(&ctrl, dt, DT_MASK);
+@@ -277,8 +278,8 @@ void csi2_open_rx(struct csi2_device *cs
+ {
+ 	dphy_start(&csi2->dphy);
+ 
+-	if (!csi2->multipacket_line)
+-		csi2_reg_write(csi2, CSI2_CTRL, EOP_IS_EOL);
++	csi2_reg_write(csi2, CSI2_CTRL,
++		       csi2->multipacket_line ? 0 : EOP_IS_EOL);
+ }
+ 
+ void csi2_close_rx(struct csi2_device *csi2)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1000-media-rp1-fe-Use-0-not-1-when-working-with-unsigned-.patch b/target/linux/bcm27xx/patches-6.1/950-1000-media-rp1-fe-Use-0-not-1-when-working-with-unsigned-.patch
new file mode 100644
index 0000000000..f468b7ac48
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1000-media-rp1-fe-Use-0-not-1-when-working-with-unsigned-.patch
@@ -0,0 +1,33 @@
+From 455c4ae2c70348a5842835d2f67f7cd8e665a2a6 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Thu, 21 Sep 2023 16:03:07 +0300
+Subject: [PATCH] media: rp1: fe: Use ~0, not -1, when working with unsigned
+ values
+
+Use ~0, not -1, when working with unsigned values (-1 is not unsigned).
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+@@ -372,7 +372,7 @@ void pisp_fe_submit_job(struct pisp_fe_d
+ void pisp_fe_start(struct pisp_fe_device *fe)
+ {
+ 	pisp_fe_reg_write(fe, FE_CONTROL, FE_CONTROL_RESET);
+-	pisp_fe_reg_write(fe, FE_INT_STATUS, -1);
++	pisp_fe_reg_write(fe, FE_INT_STATUS, ~0);
+ 	pisp_fe_reg_write(fe, FE_INT_EN, FE_INT_EOF | FE_INT_SOF | FE_INT_LINES0 | FE_INT_LINES1);
+ 	fe->inframe_count = 0;
+ }
+@@ -383,7 +383,7 @@ void pisp_fe_stop(struct pisp_fe_device
+ 	pisp_fe_reg_write(fe, FE_CONTROL, FE_CONTROL_ABORT);
+ 	usleep_range(1000, 2000);
+ 	WARN_ON(pisp_fe_reg_read(fe, FE_STATUS));
+-	pisp_fe_reg_write(fe, FE_INT_STATUS, -1);
++	pisp_fe_reg_write(fe, FE_INT_STATUS, ~0);
+ }
+ 
+ static struct pisp_fe_device *to_pisp_fe_device(struct v4l2_subdev *subdev)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1001-media-rp1-cfe-Fix-verbose-debug-print.patch b/target/linux/bcm27xx/patches-6.1/950-1001-media-rp1-cfe-Fix-verbose-debug-print.patch
new file mode 100644
index 0000000000..3344c32d29
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1001-media-rp1-cfe-Fix-verbose-debug-print.patch
@@ -0,0 +1,26 @@
+From bf1709d2cf2b57c4ea98b8363156835249ae02cc Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 22 Sep 2023 12:41:35 +0300
+Subject: [PATCH] media: rp1: cfe: Fix verbose debug print
+
+The debug print in cfe_schedule_next_csi2_job() is printed every frame,
+and should thus use cfe_dbg_irq() to avoid spamming, rather than cfe_dbg().
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -518,8 +518,8 @@ static void cfe_schedule_next_csi2_job(s
+ 		node->next_frm = buf;
+ 		list_del(&buf->list);
+ 
+-		cfe_dbg("%s: [%s] buffer:%p\n",
+-			__func__, node_desc[node->id].name, &buf->vb.vb2_buf);
++		cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__,
++			    node_desc[node->id].name, &buf->vb.vb2_buf);
+ 
+ 		if (is_meta_node(node)) {
+ 			size = node->fmt.fmt.meta.buffersize;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1002-media-rp1-cfe-Rename-xxx_dbg_irq-to-xxx_dbg_verbose.patch b/target/linux/bcm27xx/patches-6.1/950-1002-media-rp1-cfe-Rename-xxx_dbg_irq-to-xxx_dbg_verbose.patch
new file mode 100644
index 0000000000..14fa0447df
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1002-media-rp1-cfe-Rename-xxx_dbg_irq-to-xxx_dbg_verbose.patch
@@ -0,0 +1,227 @@
+From a1ea528e187ee045aeff929ff0f4b2e53fdd970f Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Wed, 4 Oct 2023 10:12:37 +0300
+Subject: [PATCH] media: rp1: cfe: Rename xxx_dbg_irq() to xxx_dbg_verbose()
+
+Rename the xxx_dbg_irq() macros to xxx_dbg_verbose(), as they can be
+used to verbose debugs outside irq context too.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 40 +++++++++----------
+ .../media/platform/raspberrypi/rp1_cfe/cfe.h  |  2 +-
+ .../media/platform/raspberrypi/rp1_cfe/csi2.c | 26 ++++++------
+ .../platform/raspberrypi/rp1_cfe/pisp_fe.c    | 12 +++---
+ 4 files changed, 40 insertions(+), 40 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -49,11 +49,11 @@
+ #define CFE_MODULE_NAME	"rp1-cfe"
+ #define CFE_VERSION	"1.0"
+ 
+-bool cfe_debug_irq;
++bool cfe_debug_verbose;
+ 
+-#define cfe_dbg_irq(fmt, arg...)                              \
++#define cfe_dbg_verbose(fmt, arg...)                          \
+ 	do {                                                  \
+-		if (cfe_debug_irq)                            \
++		if (cfe_debug_verbose)                        \
+ 			dev_dbg(&cfe->pdev->dev, fmt, ##arg); \
+ 	} while (0)
+ #define cfe_dbg(fmt, arg...) dev_dbg(&cfe->pdev->dev, fmt, ##arg)
+@@ -518,8 +518,8 @@ static void cfe_schedule_next_csi2_job(s
+ 		node->next_frm = buf;
+ 		list_del(&buf->list);
+ 
+-		cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__,
+-			    node_desc[node->id].name, &buf->vb.vb2_buf);
++		cfe_dbg_verbose("%s: [%s] buffer:%p\n", __func__,
++				node_desc[node->id].name, &buf->vb.vb2_buf);
+ 
+ 		if (is_meta_node(node)) {
+ 			size = node->fmt.fmt.meta.buffersize;
+@@ -550,8 +550,8 @@ static void cfe_schedule_next_pisp_job(s
+ 		buf = list_first_entry(&node->dma_queue, struct cfe_buffer,
+ 				       list);
+ 
+-		cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__,
+-			    node_desc[node->id].name, &buf->vb.vb2_buf);
++		cfe_dbg_verbose("%s: [%s] buffer:%p\n", __func__,
++				node_desc[node->id].name, &buf->vb.vb2_buf);
+ 
+ 		node->next_frm = buf;
+ 		vb2_bufs[node_desc[i].link_pad] = &buf->vb.vb2_buf;
+@@ -573,8 +573,8 @@ static bool cfe_check_job_ready(struct c
+ 			continue;
+ 
+ 		if (list_empty(&node->dma_queue)) {
+-			cfe_dbg_irq("%s: [%s] has no buffer, unable to schedule job\n",
+-				    __func__, node_desc[i].name);
++			cfe_dbg_verbose("%s: [%s] has no buffer, unable to schedule job\n",
++				__func__, node_desc[i].name);
+ 			return false;
+ 		}
+ 	}
+@@ -592,7 +592,7 @@ static void cfe_prepare_next_job(struct
+ 	/* Flag if another job is ready after this. */
+ 	cfe->job_ready = cfe_check_job_ready(cfe);
+ 
+-	cfe_dbg_irq("%s: end with scheduled job\n", __func__);
++	cfe_dbg_verbose("%s: end with scheduled job\n", __func__);
+ }
+ 
+ static void cfe_process_buffer_complete(struct cfe_node *node,
+@@ -600,8 +600,8 @@ static void cfe_process_buffer_complete(
+ {
+ 	struct cfe_device *cfe = node->cfe;
+ 
+-	cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__, node_desc[node->id].name,
+-		    &node->cur_frm->vb.vb2_buf);
++	cfe_dbg_verbose("%s: [%s] buffer:%p\n", __func__,
++			node_desc[node->id].name, &node->cur_frm->vb.vb2_buf);
+ 
+ 	node->cur_frm->vb.sequence = sequence;
+ 	vb2_buffer_done(&node->cur_frm->vb.vb2_buf, VB2_BUF_STATE_DONE);
+@@ -621,8 +621,8 @@ static void cfe_sof_isr_handler(struct c
+ {
+ 	struct cfe_device *cfe = node->cfe;
+ 
+-	cfe_dbg_irq("%s: [%s] seq %u\n", __func__, node_desc[node->id].name,
+-		    cfe->sequence);
++	cfe_dbg_verbose("%s: [%s] seq %u\n", __func__, node_desc[node->id].name,
++			cfe->sequence);
+ 
+ 	node->cur_frm = node->next_frm;
+ 	node->next_frm = NULL;
+@@ -651,8 +651,8 @@ static void cfe_eof_isr_handler(struct c
+ {
+ 	struct cfe_device *cfe = node->cfe;
+ 
+-	cfe_dbg_irq("%s: [%s] seq %u\n", __func__, node_desc[node->id].name,
+-		    cfe->sequence);
++	cfe_dbg_verbose("%s: [%s] seq %u\n", __func__, node_desc[node->id].name,
++			cfe->sequence);
+ 
+ 	if (node->cur_frm)
+ 		cfe_process_buffer_complete(node, cfe->sequence);
+@@ -921,8 +921,8 @@ static int cfe_buffer_prepare(struct vb2
+ 	struct cfe_buffer *buf = to_cfe_buffer(vb);
+ 	unsigned long size;
+ 
+-	cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__, node_desc[node->id].name,
+-		    vb);
++	cfe_dbg_verbose("%s: [%s] buffer:%p\n", __func__,
++			node_desc[node->id].name, vb);
+ 
+ 	size = is_image_output_node(node) ? node->fmt.fmt.pix.sizeimage :
+ 					    node->fmt.fmt.meta.buffersize;
+@@ -954,8 +954,8 @@ static void cfe_buffer_queue(struct vb2_
+ 	struct cfe_buffer *buf = to_cfe_buffer(vb);
+ 	unsigned long flags;
+ 
+-	cfe_dbg_irq("%s: [%s] buffer:%p\n", __func__, node_desc[node->id].name,
+-		    vb);
++	cfe_dbg_verbose("%s: [%s] buffer:%p\n", __func__,
++			node_desc[node->id].name, vb);
+ 
+ 	spin_lock_irqsave(&cfe->state_lock, flags);
+ 
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.h
+@@ -11,7 +11,7 @@
+ #include <linux/media-bus-format.h>
+ #include <linux/videodev2.h>
+ 
+-extern bool cfe_debug_irq;
++extern bool cfe_debug_verbose;
+ 
+ enum cfe_remap_types {
+ 	CFE_REMAP_16BIT,
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -16,9 +16,9 @@
+ #include "csi2.h"
+ #include "cfe.h"
+ 
+-#define csi2_dbg_irq(fmt, arg...)                                 \
++#define csi2_dbg_verbose(fmt, arg...)                             \
+ 	do {                                                      \
+-		if (cfe_debug_irq)                                \
++		if (cfe_debug_verbose)                            \
+ 			dev_dbg(csi2->v4l2_dev->dev, fmt, ##arg); \
+ 	} while (0)
+ #define csi2_dbg(fmt, arg...) dev_dbg(csi2->v4l2_dev->dev, fmt, ##arg)
+@@ -154,7 +154,7 @@ void csi2_isr(struct csi2_device *csi2,
+ 	u32 status;
+ 
+ 	status = csi2_reg_read(csi2, CSI2_STATUS);
+-	csi2_dbg_irq("ISR: STA: 0x%x\n", status);
++	csi2_dbg_verbose("ISR: STA: 0x%x\n", status);
+ 
+ 	/* Write value back to clear the interrupts */
+ 	csi2_reg_write(csi2, CSI2_STATUS, status);
+@@ -167,16 +167,16 @@ void csi2_isr(struct csi2_device *csi2,
+ 
+ 		dbg = csi2_reg_read(csi2, CSI2_CH_DEBUG(i));
+ 
+-		csi2_dbg_irq("ISR: [%u], %s%s%s%s%s frame: %u line: %u\n", i,
+-			     (status & IRQ_FS(i)) ? "FS " : "",
+-			     (status & IRQ_FE(i)) ? "FE " : "",
+-			     (status & IRQ_FE_ACK(i)) ? "FE_ACK " : "",
+-			     (status & IRQ_LE(i)) ? "LE " : "",
+-			     (status & IRQ_LE_ACK(i)) ? "LE_ACK " : "",
+-			     dbg >> 16,
+-			     csi2->num_lines[i] ?
+-				     ((dbg & 0xffff) % csi2->num_lines[i]) :
+-				     0);
++		csi2_dbg_verbose("ISR: [%u], %s%s%s%s%s frame: %u line: %u\n",
++				 i, (status & IRQ_FS(i)) ? "FS " : "",
++				 (status & IRQ_FE(i)) ? "FE " : "",
++				 (status & IRQ_FE_ACK(i)) ? "FE_ACK " : "",
++				 (status & IRQ_LE(i)) ? "LE " : "",
++				 (status & IRQ_LE_ACK(i)) ? "LE_ACK " : "",
++				 dbg >> 16,
++				 csi2->num_lines[i] ?
++					 ((dbg & 0xffff) % csi2->num_lines[i]) :
++					 0);
+ 
+ 		sof[i] = !!(status & IRQ_FS(i));
+ 		eof[i] = !!(status & IRQ_FE_ACK(i));
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+@@ -114,9 +114,9 @@ static const struct pisp_fe_config_param
+ 					sizeof(struct pisp_fe_output_config)         },
+ };
+ 
+-#define pisp_fe_dbg_irq(fmt, arg...)                            \
++#define pisp_fe_dbg_verbose(fmt, arg...)                        \
+ 	do {                                                    \
+-		if (cfe_debug_irq)                              \
++		if (cfe_debug_verbose)                          \
+ 			dev_dbg(fe->v4l2_dev->dev, fmt, ##arg); \
+ 	} while (0)
+ #define pisp_fe_dbg(fmt, arg...) dev_dbg(fe->v4l2_dev->dev, fmt, ##arg)
+@@ -202,9 +202,9 @@ void pisp_fe_isr(struct pisp_fe_device *
+ 	int_status = pisp_fe_reg_read(fe, FE_INT_STATUS);
+ 	pisp_fe_reg_write(fe, FE_INT_STATUS, int_status);
+ 
+-	pisp_fe_dbg_irq("%s: status 0x%x out 0x%x frame 0x%x error 0x%x int 0x%x\n",
+-			__func__, status, out_status, frame_status, error_status,
+-			int_status);
++	pisp_fe_dbg_verbose("%s: status 0x%x out 0x%x frame 0x%x error 0x%x int 0x%x\n",
++		__func__, status, out_status, frame_status, error_status,
++		int_status);
+ 
+ 	/* We do not report interrupts for the input/stream pad. */
+ 	for (i = 0; i < FE_NUM_PADS - 1; i++) {
+@@ -339,7 +339,7 @@ void pisp_fe_submit_job(struct pisp_fe_d
+ 	 * sequence of relaxed writes which follow.
+ 	 */
+ 	status = pisp_fe_reg_read(fe, FE_STATUS);
+-	pisp_fe_dbg_irq("%s: status = 0x%x\n", __func__, status);
++	pisp_fe_dbg_verbose("%s: status = 0x%x\n", __func__, status);
+ 	if (WARN_ON(status & FE_STATUS_QUEUED))
+ 		return;
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1003-media-rp1-Add-back-reg-write-debug-prints.patch b/target/linux/bcm27xx/patches-6.1/950-1003-media-rp1-Add-back-reg-write-debug-prints.patch
new file mode 100644
index 0000000000..c86f7a3e17
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1003-media-rp1-Add-back-reg-write-debug-prints.patch
@@ -0,0 +1,41 @@
+From 8240f1328ead0152f116b385b3169f8f010a7869 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 22 Sep 2023 12:39:33 +0300
+Subject: [PATCH] media: rp1: Add back reg write debug prints
+
+Add back debug prints in csi2 and pisp_fe reg_write() functions, but use
+the 'irq' variants to avoid spamming in normal situation.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/csi2.c    | 1 +
+ drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c | 2 ++
+ 2 files changed, 3 insertions(+)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -92,6 +92,7 @@ static inline u32 csi2_reg_read(struct c
+ static inline void csi2_reg_write(struct csi2_device *csi2, u32 offset, u32 val)
+ {
+ 	writel(val, csi2->base + offset);
++	csi2_dbg_verbose("csi2: write 0x%04x -> 0x%03x\n", val, offset);
+ }
+ 
+ static inline void set_field(u32 *valp, u32 field, u32 mask)
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+@@ -132,12 +132,14 @@ static inline void pisp_fe_reg_write(str
+ 				     u32 val)
+ {
+ 	writel(val, fe->base + offset);
++	pisp_fe_dbg_verbose("fe: write 0x%04x -> 0x%03x\n", val, offset);
+ }
+ 
+ static inline void pisp_fe_reg_write_relaxed(struct pisp_fe_device *fe, u32 offset,
+ 					     u32 val)
+ {
+ 	writel_relaxed(val, fe->base + offset);
++	pisp_fe_dbg_verbose("fe: write 0x%04x -> 0x%03x\n", val, offset);
+ }
+ 
+ static int pisp_regs_show(struct seq_file *s, void *data)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1004-media-rp1-cfe-Add-verbose-debug-module-parameter.patch b/target/linux/bcm27xx/patches-6.1/950-1004-media-rp1-cfe-Add-verbose-debug-module-parameter.patch
new file mode 100644
index 0000000000..f44cb50d10
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1004-media-rp1-cfe-Add-verbose-debug-module-parameter.patch
@@ -0,0 +1,23 @@
+From f2553458c0c1942731447aac3878f51aa1b326a7 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Wed, 4 Oct 2023 10:19:47 +0300
+Subject: [PATCH] media: rp1: cfe: Add verbose debug module parameter
+
+Expose the verbose debug flag as a module parameter.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -50,6 +50,8 @@
+ #define CFE_VERSION	"1.0"
+ 
+ bool cfe_debug_verbose;
++module_param_named(verbose_debug, cfe_debug_verbose, bool, 0644);
++MODULE_PARM_DESC(verbose_debug, "verbose debugging messages");
+ 
+ #define cfe_dbg_verbose(fmt, arg...)                          \
+ 	do {                                                  \
diff --git a/target/linux/bcm27xx/patches-6.1/950-1005-media-rp1-csi2-Track-CSI-2-errors.patch b/target/linux/bcm27xx/patches-6.1/950-1005-media-rp1-csi2-Track-CSI-2-errors.patch
new file mode 100644
index 0000000000..9d8da81887
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1005-media-rp1-csi2-Track-CSI-2-errors.patch
@@ -0,0 +1,245 @@
+From b19c2b5f88f141e58044e5d1012f867d46f74bf3 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Thu, 21 Sep 2023 18:18:53 +0300
+Subject: [PATCH] media: rp1: csi2: Track CSI-2 errors
+
+Track the errors from the CSI-2 receiver: overflows and discards. These
+are recorded in a table which can be read by the userspace via debugfs.
+
+As tracking the errors may cause much more interrupt load, the tracking
+needs to be enabled with a module parameter.
+
+Note that the recording is not perfect: we only record the last
+discarded DT for each discard type, instead of recording all of them.
+This means that e.g. if the device is discarding two unmatched DTs, the
+debugfs file only shows the last one recorded. Recording all of them
+would need a more sophisticated recording system to avoid the need of a
+very large table, or dynamic allocation.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/csi2.c | 123 ++++++++++++++++++
+ .../media/platform/raspberrypi/rp1_cfe/csi2.h |  16 +++
+ 2 files changed, 139 insertions(+)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -16,6 +16,10 @@
+ #include "csi2.h"
+ #include "cfe.h"
+ 
++static bool csi2_track_errors;
++module_param_named(track_csi2_errors, csi2_track_errors, bool, 0);
++MODULE_PARM_DESC(track_csi2_errors, "track csi-2 errors");
++
+ #define csi2_dbg_verbose(fmt, arg...)                             \
+ 	do {                                                      \
+ 		if (cfe_debug_verbose)                            \
+@@ -32,9 +36,28 @@
+ #define CSI2_DISCARDS_INACTIVE	0x00c
+ #define CSI2_DISCARDS_UNMATCHED	0x010
+ #define CSI2_DISCARDS_LEN_LIMIT	0x014
++
++#define CSI2_DISCARDS_AMOUNT_SHIFT	0
++#define CSI2_DISCARDS_AMOUNT_MASK	GENMASK(23, 0)
++#define CSI2_DISCARDS_DT_SHIFT		24
++#define CSI2_DISCARDS_DT_MASK		GENMASK(29, 24)
++#define CSI2_DISCARDS_VC_SHIFT		30
++#define CSI2_DISCARDS_VC_MASK		GENMASK(31, 30)
++
+ #define CSI2_LLEV_PANICS	0x018
+ #define CSI2_ULEV_PANICS	0x01c
+ #define CSI2_IRQ_MASK		0x020
++#define CSI2_IRQ_MASK_IRQ_OVERFLOW		BIT(0)
++#define CSI2_IRQ_MASK_IRQ_DISCARD_OVERFLOW	BIT(1)
++#define CSI2_IRQ_MASK_IRQ_DISCARD_LENGTH_LIMIT	BIT(2)
++#define CSI2_IRQ_MASK_IRQ_DISCARD_UNMATCHED	BIT(3)
++#define CSI2_IRQ_MASK_IRQ_DISCARD_INACTIVE	BIT(4)
++#define CSI2_IRQ_MASK_IRQ_ALL                                              \
++	(CSI2_IRQ_MASK_IRQ_OVERFLOW | CSI2_IRQ_MASK_IRQ_DISCARD_OVERFLOW | \
++	 CSI2_IRQ_MASK_IRQ_DISCARD_LENGTH_LIMIT |                          \
++	 CSI2_IRQ_MASK_IRQ_DISCARD_UNMATCHED |                             \
++	 CSI2_IRQ_MASK_IRQ_DISCARD_INACTIVE)
++
+ #define CSI2_CTRL		0x024
+ #define CSI2_CH_CTRL(x)		((x) * 0x40 + 0x28)
+ #define CSI2_CH_ADDR0(x)	((x) * 0x40 + 0x2c)
+@@ -149,6 +172,92 @@ static int csi2_regs_show(struct seq_fil
+ 
+ DEFINE_SHOW_ATTRIBUTE(csi2_regs);
+ 
++static int csi2_errors_show(struct seq_file *s, void *data)
++{
++	struct csi2_device *csi2 = s->private;
++	unsigned long flags;
++	u32 discards_table[DISCARDS_TABLE_NUM_VCS][DISCARDS_TABLE_NUM_ENTRIES];
++	u32 discards_dt_table[DISCARDS_TABLE_NUM_ENTRIES];
++	u32 overflows;
++
++	spin_lock_irqsave(&csi2->errors_lock, flags);
++
++	memcpy(discards_table, csi2->discards_table, sizeof(discards_table));
++	memcpy(discards_dt_table, csi2->discards_dt_table,
++	       sizeof(discards_dt_table));
++	overflows = csi2->overflows;
++
++	csi2->overflows = 0;
++	memset(csi2->discards_table, 0, sizeof(discards_table));
++	memset(csi2->discards_dt_table, 0, sizeof(discards_dt_table));
++
++	spin_unlock_irqrestore(&csi2->errors_lock, flags);
++
++	seq_printf(s, "Overflows %u\n", overflows);
++	seq_puts(s, "Discards:\n");
++	seq_puts(s, "VC            OVLF        LEN  UNMATCHED   INACTIVE\n");
++
++	for (unsigned int vc = 0; vc < DISCARDS_TABLE_NUM_VCS; ++vc) {
++		seq_printf(s, "%u       %10u %10u %10u %10u\n", vc,
++			   discards_table[vc][DISCARDS_TABLE_OVERFLOW],
++			   discards_table[vc][DISCARDS_TABLE_LENGTH_LIMIT],
++			   discards_table[vc][DISCARDS_TABLE_UNMATCHED],
++			   discards_table[vc][DISCARDS_TABLE_INACTIVE]);
++	}
++
++	seq_printf(s, "Last DT %10u %10u %10u %10u\n",
++		   discards_dt_table[DISCARDS_TABLE_OVERFLOW],
++		   discards_dt_table[DISCARDS_TABLE_LENGTH_LIMIT],
++		   discards_dt_table[DISCARDS_TABLE_UNMATCHED],
++		   discards_dt_table[DISCARDS_TABLE_INACTIVE]);
++
++	return 0;
++}
++
++DEFINE_SHOW_ATTRIBUTE(csi2_errors);
++
++static void csi2_isr_handle_errors(struct csi2_device *csi2, u32 status)
++{
++	spin_lock(&csi2->errors_lock);
++
++	if (status & IRQ_OVERFLOW)
++		csi2->overflows++;
++
++	for (unsigned int i = 0; i < DISCARDS_TABLE_NUM_ENTRIES; ++i) {
++		static const u32 discard_bits[] = {
++			IRQ_DISCARD_OVERFLOW,
++			IRQ_DISCARD_LEN_LIMIT,
++			IRQ_DISCARD_UNMATCHED,
++			IRQ_DISCARD_INACTIVE,
++		};
++		static const u8 discard_regs[] = {
++			CSI2_DISCARDS_OVERFLOW,
++			CSI2_DISCARDS_LEN_LIMIT,
++			CSI2_DISCARDS_UNMATCHED,
++			CSI2_DISCARDS_INACTIVE,
++		};
++		u32 amount;
++		u8 dt, vc;
++		u32 v;
++
++		if (!(status & discard_bits[i]))
++			continue;
++
++		v = csi2_reg_read(csi2, discard_regs[i]);
++		csi2_reg_write(csi2, discard_regs[i], 0);
++
++		amount = (v & CSI2_DISCARDS_AMOUNT_MASK) >>
++			 CSI2_DISCARDS_AMOUNT_SHIFT;
++		dt = (v & CSI2_DISCARDS_DT_MASK) >> CSI2_DISCARDS_DT_SHIFT;
++		vc = (v & CSI2_DISCARDS_VC_MASK) >> CSI2_DISCARDS_VC_SHIFT;
++
++		csi2->discards_table[vc][i] += amount;
++		csi2->discards_dt_table[i] = dt;
++	}
++
++	spin_unlock(&csi2->errors_lock);
++}
++
+ void csi2_isr(struct csi2_device *csi2, bool *sof, bool *eof, bool *lci)
+ {
+ 	unsigned int i;
+@@ -183,6 +292,9 @@ void csi2_isr(struct csi2_device *csi2,
+ 		eof[i] = !!(status & IRQ_FE_ACK(i));
+ 		lci[i] = !!(status & IRQ_LE_ACK(i));
+ 	}
++
++	if (csi2_track_errors)
++		csi2_isr_handle_errors(csi2, status);
+ }
+ 
+ void csi2_set_buffer(struct csi2_device *csi2, unsigned int channel,
+@@ -277,6 +389,9 @@ void csi2_stop_channel(struct csi2_devic
+ 
+ void csi2_open_rx(struct csi2_device *csi2)
+ {
++	csi2_reg_write(csi2, CSI2_IRQ_MASK,
++		       csi2_track_errors ? CSI2_IRQ_MASK_IRQ_ALL : 0);
++
+ 	dphy_start(&csi2->dphy);
+ 
+ 	csi2_reg_write(csi2, CSI2_CTRL,
+@@ -286,6 +401,8 @@ void csi2_open_rx(struct csi2_device *cs
+ void csi2_close_rx(struct csi2_device *csi2)
+ {
+ 	dphy_stop(&csi2->dphy);
++
++	csi2_reg_write(csi2, CSI2_IRQ_MASK, 0);
+ }
+ 
+ static struct csi2_device *to_csi2_device(struct v4l2_subdev *subdev)
+@@ -398,11 +515,17 @@ int csi2_init(struct csi2_device *csi2,
+ {
+ 	unsigned int i, ret;
+ 
++	spin_lock_init(&csi2->errors_lock);
++
+ 	csi2->dphy.dev = csi2->v4l2_dev->dev;
+ 	dphy_probe(&csi2->dphy);
+ 
+ 	debugfs_create_file("csi2_regs", 0444, debugfs, csi2, &csi2_regs_fops);
+ 
++	if (csi2_track_errors)
++		debugfs_create_file("csi2_errors", 0444, debugfs, csi2,
++				    &csi2_errors_fops);
++
+ 	for (i = 0; i < CSI2_NUM_CHANNELS * 2; i++)
+ 		csi2->pad[i].flags = i < CSI2_NUM_CHANNELS ?
+ 				     MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
+@@ -17,6 +17,8 @@
+ 
+ #define CSI2_NUM_CHANNELS 4
+ 
++#define DISCARDS_TABLE_NUM_VCS 4
++
+ enum csi2_mode {
+ 	CSI2_MODE_NORMAL,
+ 	CSI2_MODE_REMAP,
+@@ -37,6 +39,14 @@ struct csi2_cfg {
+ 	u32 buffer_size;
+ };
+ 
++enum discards_table_index {
++	DISCARDS_TABLE_OVERFLOW = 0,
++	DISCARDS_TABLE_LENGTH_LIMIT,
++	DISCARDS_TABLE_UNMATCHED,
++	DISCARDS_TABLE_INACTIVE,
++	DISCARDS_TABLE_NUM_ENTRIES,
++};
++
+ struct csi2_device {
+ 	/* Parent V4l2 device */
+ 	struct v4l2_device *v4l2_dev;
+@@ -53,6 +63,12 @@ struct csi2_device {
+ 
+ 	struct media_pad pad[CSI2_NUM_CHANNELS * 2];
+ 	struct v4l2_subdev sd;
++
++	/* lock for csi2 errors counters */
++	spinlock_t errors_lock;
++	u32 overflows;
++	u32 discards_table[DISCARDS_TABLE_NUM_VCS][DISCARDS_TABLE_NUM_ENTRIES];
++	u32 discards_dt_table[DISCARDS_TABLE_NUM_ENTRIES];
+ };
+ 
+ void csi2_isr(struct csi2_device *csi2, bool *sof, bool *eof, bool *lci);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1006-media-rp1-cfe-Drop-unused-field.patch b/target/linux/bcm27xx/patches-6.1/950-1006-media-rp1-cfe-Drop-unused-field.patch
new file mode 100644
index 0000000000..b53a5b6154
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1006-media-rp1-cfe-Drop-unused-field.patch
@@ -0,0 +1,31 @@
+From d6bd676b49cf10046665efde820b0cc00dc43994 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Thu, 28 Sep 2023 17:04:07 +0300
+Subject: [PATCH] media: rp1: cfe: Drop unused field
+
+Drop 'sensor_embedded_data' field, as it is unused.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 3 ---
+ 1 file changed, 3 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -292,7 +292,6 @@ struct cfe_device {
+ 	struct csi2_device csi2;
+ 	struct pisp_fe_device fe;
+ 
+-	bool sensor_embedded_data;
+ 	int fe_csi2_channel;
+ 
+ 	unsigned int sequence;
+@@ -1821,8 +1820,6 @@ static int cfe_probe_complete(struct cfe
+ 
+ 	cfe->v4l2_dev.notify = cfe_notify;
+ 
+-	cfe->sensor_embedded_data = (cfe->sensor->entity.num_pads >= 2);
+-
+ 	for (i = 0; i < NUM_NODES; i++) {
+ 		ret = cfe_register_node(cfe, i);
+ 		if (ret) {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1007-media-rp1-csi2-Set-values-for-enum-csi2_mode.patch b/target/linux/bcm27xx/patches-6.1/950-1007-media-rp1-csi2-Set-values-for-enum-csi2_mode.patch
new file mode 100644
index 0000000000..126ee2c493
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1007-media-rp1-csi2-Set-values-for-enum-csi2_mode.patch
@@ -0,0 +1,30 @@
+From c56b53d62116b4672962124afab02f3beada4244 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 29 Sep 2023 12:57:23 +0300
+Subject: [PATCH] media: rp1: csi2: Set values for enum csi2_mode
+
+Set hardcoded values for enum csi2_mode, as the values will be
+programmed to HW registers.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/csi2.h | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
+@@ -20,10 +20,10 @@
+ #define DISCARDS_TABLE_NUM_VCS 4
+ 
+ enum csi2_mode {
+-	CSI2_MODE_NORMAL,
+-	CSI2_MODE_REMAP,
+-	CSI2_MODE_COMPRESSED,
+-	CSI2_MODE_FE_STREAMING
++	CSI2_MODE_NORMAL = 0,
++	CSI2_MODE_REMAP = 1,
++	CSI2_MODE_COMPRESSED = 2,
++	CSI2_MODE_FE_STREAMING = 3,
+ };
+ 
+ enum csi2_compression_mode {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1008-media-rp1-fe-Fix-default-mbus-code.patch b/target/linux/bcm27xx/patches-6.1/950-1008-media-rp1-fe-Fix-default-mbus-code.patch
new file mode 100644
index 0000000000..e4ea9e1d16
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1008-media-rp1-fe-Fix-default-mbus-code.patch
@@ -0,0 +1,27 @@
+From 5edacf33de9e0349dd5a02ad684bfceae1d5565f Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 29 Sep 2023 13:29:15 +0300
+Subject: [PATCH] media: rp1: fe: Fix default mbus code
+
+When pisp_fe_pad_set_fmt() is given an mbus code that CFE does not
+support, it currently defaults to MEDIA_BUS_FMT_SBGGR10_1X10. This is
+not correct, as FE does not support SBGGR10.
+
+Set the default to MEDIA_BUS_FMT_SRGGB16_1X16 instead.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+@@ -437,7 +437,7 @@ static int pisp_fe_pad_set_fmt(struct v4
+ 	case FE_OUTPUT1_PAD:
+ 		cfe_fmt = find_format_by_code(format->format.code);
+ 		if (!cfe_fmt || !(cfe_fmt->flags & CFE_FORMAT_FLAG_FE_OUT))
+-			cfe_fmt = find_format_by_code(MEDIA_BUS_FMT_SBGGR10_1X10);
++			cfe_fmt = find_format_by_code(MEDIA_BUS_FMT_SRGGB16_1X16);
+ 
+ 		format->format.code = cfe_fmt->code;
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1009-media-rp1-cfe-Fix-default-meta-format-s-field.patch b/target/linux/bcm27xx/patches-6.1/950-1009-media-rp1-cfe-Fix-default-meta-format-s-field.patch
new file mode 100644
index 0000000000..2ac5e0e88a
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1009-media-rp1-cfe-Fix-default-meta-format-s-field.patch
@@ -0,0 +1,25 @@
+From 47fd9528bc1d93dd07ce9baa19c736966b536bd9 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Mon, 2 Oct 2023 14:38:07 +0300
+Subject: [PATCH] media: rp1: cfe: Fix default meta format's field
+
+Set default meta format's field to V4L2_FIELD_NONE, instead of zeroing
+it which indicates V4L2_FIELD_ANY. Metadata doesn't have fields, so NONE
+makes sense, and furthermore the default v4l2 link validation will check
+for matching fields, or that the sink field is NONE.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -110,6 +110,7 @@ const struct v4l2_mbus_framefmt cfe_defa
+ 	.width = 8192,
+ 	.height = 1,
+ 	.code = MEDIA_BUS_FMT_SENSOR_DATA,
++	.field = V4L2_FIELD_NONE,
+ };
+ 
+ enum node_ids {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1010-media-rp1-cfe-Fail-streaming-if-FE_CONFIG-node-is-no.patch b/target/linux/bcm27xx/patches-6.1/950-1010-media-rp1-cfe-Fail-streaming-if-FE_CONFIG-node-is-no.patch
new file mode 100644
index 0000000000..de469c3565
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1010-media-rp1-cfe-Fail-streaming-if-FE_CONFIG-node-is-no.patch
@@ -0,0 +1,31 @@
+From 3e2203b265ddd8630fea0fbb69b3a2ec1496f773 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Wed, 4 Oct 2023 09:39:59 +0100
+Subject: [PATCH] media: rp1: cfe: Fail streaming if FE_CONFIG node is not
+ enabled
+
+When the FE is enabled, ensure that the FE_CONFIG node is enabled.
+Otherwise fail cfe_start_streaming() entirely.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -997,6 +997,14 @@ static int cfe_start_streaming(struct vb
+ 		goto err_streaming;
+ 	}
+ 
++	/* When using the Frontend, we must enable the FE_CONFIG node. */
++	if (is_fe_enabled(cfe) &&
++	    !check_state(cfe, NODE_ENABLED, cfe->node[FE_CONFIG].id)) {
++		cfe_err("FE enabled, but FE_CONFIG node is not\n");
++		ret = -EINVAL;
++		goto err_streaming;
++	}
++
+ 	ret = media_pipeline_start(&node->pad, &cfe->pipe);
+ 	if (ret < 0) {
+ 		cfe_err("Failed to start media pipeline: %d\n", ret);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1011-media-i2c-Move-Kconfig-entry-for-IMX477-to-the-camer.patch b/target/linux/bcm27xx/patches-6.1/950-1011-media-i2c-Move-Kconfig-entry-for-IMX477-to-the-camer.patch
new file mode 100644
index 0000000000..37e1a86e16
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1011-media-i2c-Move-Kconfig-entry-for-IMX477-to-the-camer.patch
@@ -0,0 +1,51 @@
+From 52811174f534824f5e5bcdb681f0c508aa335244 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Wed, 4 Oct 2023 11:09:10 +0100
+Subject: [PATCH] media: i2c: Move Kconfig entry for IMX477 to the camera
+ sensor section
+
+It was accidentally placed in the audio decoder section.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/i2c/Kconfig | 22 +++++++++++-----------
+ 1 file changed, 11 insertions(+), 11 deletions(-)
+
+--- a/drivers/media/i2c/Kconfig
++++ b/drivers/media/i2c/Kconfig
+@@ -270,6 +270,17 @@ config VIDEO_IMX412
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called imx412.
+ 
++config VIDEO_IMX477
++	tristate "Sony IMX477 sensor support"
++	depends on I2C && VIDEO_DEV
++	select VIDEO_V4L2_SUBDEV_API
++	help
++	  This is a Video4Linux2 sensor driver for the Sony
++	  IMX477 camera. Also supports the Sony IMX378.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called imx477.
++
+ config VIDEO_IMX519
+ 	tristate "Arducam IMX519 sensor support"
+ 	depends on I2C && VIDEO_DEV
+@@ -1106,17 +1117,6 @@ config VIDEO_UDA1342
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called uda1342.
+ 
+-config VIDEO_IMX477
+-	tristate "Sony IMX477 sensor support"
+-	depends on I2C && VIDEO_DEV
+-	select VIDEO_V4L2_SUBDEV_API
+-	help
+-	  This is a Video4Linux2 sensor driver for the Sony
+-	  IMX477 camera. Also supports the Sony IMX378.
+-
+-	  To compile this driver as a module, choose M here: the
+-	  module will be called imx477.
+-
+ config VIDEO_VP27SMPX
+ 	tristate "Panasonic VP27's internal MPX"
+ 	depends on VIDEO_DEV && I2C
diff --git a/target/linux/bcm27xx/patches-6.1/950-1013-drm-Look-for-an-alias-for-the-displays-to-use-as-the.patch b/target/linux/bcm27xx/patches-6.1/950-1013-drm-Look-for-an-alias-for-the-displays-to-use-as-the.patch
new file mode 100644
index 0000000000..8de6c372c0
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1013-drm-Look-for-an-alias-for-the-displays-to-use-as-the.patch
@@ -0,0 +1,109 @@
+From 3aa1f2477545ea6298bc6f2d7ffae68f090af9b8 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 28 Sep 2023 18:27:09 +0100
+Subject: [PATCH] drm: Look for an alias for the displays to use as the DRM
+ device name
+
+Allow DT aliases of eg DSI2 to force make DRM allocate the
+display with the requested name.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/drm_connector.c | 60 ++++++++++++++++++++++++++++++---
+ 1 file changed, 56 insertions(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/drm_connector.c
++++ b/drivers/gpu/drm/drm_connector.c
+@@ -81,6 +81,7 @@ struct drm_conn_prop_enum_list {
+ 	int type;
+ 	const char *name;
+ 	struct ida ida;
++	int first_dyn_num;
+ };
+ 
+ /*
+@@ -110,12 +111,41 @@ static struct drm_conn_prop_enum_list dr
+ 	{ DRM_MODE_CONNECTOR_USB, "USB" },
+ };
+ 
++#define MAX_DT_NODE_NAME_LEN	20
++#define DT_DRM_NODE_PREFIX	"drm_"
++
++static void drm_connector_get_of_name(int type, char *node_name, int length)
++{
++	int i = 0;
++
++	strcpy(node_name, DT_DRM_NODE_PREFIX);
++
++	do {
++		node_name[i + strlen(DT_DRM_NODE_PREFIX)] =
++				tolower(drm_connector_enum_list[type].name[i]);
++
++	} while (drm_connector_enum_list[type].name[i++] &&
++		 i < length);
++
++	node_name[length - 1] = '\0';
++}
++
+ void drm_connector_ida_init(void)
+ {
+-	int i;
++	int i, id;
++	char node_name[MAX_DT_NODE_NAME_LEN];
+ 
+-	for (i = 0; i < ARRAY_SIZE(drm_connector_enum_list); i++)
++	for (i = 0; i < ARRAY_SIZE(drm_connector_enum_list); i++) {
+ 		ida_init(&drm_connector_enum_list[i].ida);
++
++		drm_connector_get_of_name(i, node_name, MAX_DT_NODE_NAME_LEN);
++
++		id = of_alias_get_highest_id(node_name);
++		if (id > 0)
++			drm_connector_enum_list[i].first_dyn_num = id + 1;
++		else
++			drm_connector_enum_list[i].first_dyn_num = 1;
++	}
+ }
+ 
+ void drm_connector_ida_destroy(void)
+@@ -222,7 +252,9 @@ static int __drm_connector_init(struct d
+ 				struct i2c_adapter *ddc)
+ {
+ 	struct drm_mode_config *config = &dev->mode_config;
++	char node_name[MAX_DT_NODE_NAME_LEN];
+ 	int ret;
++	int id;
+ 	struct ida *connector_ida =
+ 		&drm_connector_enum_list[connector_type].ida;
+ 
+@@ -252,8 +284,28 @@ static int __drm_connector_init(struct d
+ 	ret = 0;
+ 
+ 	connector->connector_type = connector_type;
+-	connector->connector_type_id =
+-		ida_alloc_min(connector_ida, 1, GFP_KERNEL);
++	connector->connector_type_id = 0;
++
++	drm_connector_get_of_name(connector_type, node_name, MAX_DT_NODE_NAME_LEN);
++	id = of_alias_get_id(dev->dev->of_node, node_name);
++	if (id > 0) {
++		/* Try and allocate the requested ID
++		 * Valid range is 1 to 31, hence ignoring 0 as an error
++		 */
++		int type_id = ida_alloc_range(connector_ida, id, id, GFP_KERNEL);
++
++		if (type_id > 0)
++			connector->connector_type_id = type_id;
++		else
++			drm_err(dev, "Failed to acquire type ID %d for interface type %s, ret %d\n",
++				id, drm_connector_enum_list[connector_type].name,
++				type_id);
++	}
++	if (!connector->connector_type_id)
++		connector->connector_type_id =
++				ida_alloc_min(connector_ida,
++					      drm_connector_enum_list[connector_type].first_dyn_num,
++					      GFP_KERNEL);
+ 	if (connector->connector_type_id < 0) {
+ 		ret = connector->connector_type_id;
+ 		goto out_put_id;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1014-dt-Add-DSI1-and-DSI2-aliases-to-2712.patch b/target/linux/bcm27xx/patches-6.1/950-1014-dt-Add-DSI1-and-DSI2-aliases-to-2712.patch
new file mode 100644
index 0000000000..6d79cb6c4d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1014-dt-Add-DSI1-and-DSI2-aliases-to-2712.patch
@@ -0,0 +1,24 @@
+From 7ec42740a45b21bca859cde5b7cbe2f09ef3d586 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 28 Sep 2023 18:40:36 +0100
+Subject: [PATCH] dt: Add DSI1 and DSI2 aliases to 2712
+
+In order to keep the DRM names consistent as DSI-1 and DSI-2, add
+aliases to the Pi5 DT.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -785,6 +785,8 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		gpio4 = &pinctrl_aon;
+ 		usb0 = &rp1_usb0;
+ 		usb1 = &rp1_usb1;
++		drm_dsi1 = &dsi0;
++		drm_dsi2 = &dsi1;
+ 	};
+ 
+ 	__overrides__ {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1015-vc4-drm-Remove-the-clear-of-SCALER_DISPBKGND_FILL.patch b/target/linux/bcm27xx/patches-6.1/950-1015-vc4-drm-Remove-the-clear-of-SCALER_DISPBKGND_FILL.patch
new file mode 100644
index 0000000000..a4c8aeadd3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1015-vc4-drm-Remove-the-clear-of-SCALER_DISPBKGND_FILL.patch
@@ -0,0 +1,64 @@
+From e6e0631fdeb0cd7d4c50e629b4b298e0b76e885b Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Wed, 4 Oct 2023 16:02:39 +0100
+Subject: [PATCH] vc4/drm: Remove the clear of SCALER_DISPBKGND_FILL
+
+Since "drm/vc4: hvs: Support BCM2712 HVS" booting Pi4
+with dual 4kp30 displays connected fails with:
+vc4-drm gpu: [drm] *ERROR* [CRTC:107:pixelvalve-4] flip_done timed out
+
+It has been tracked down to the referenced commit adding a
+path to clear the SCALER_DISPBKGND_FILL when not required.
+
+Dual 4kp30 works with a core clock of 297MHz when background fill
+is enabled, but requires a higher value with it disabled.
+320MHz still fails, while 330MHz seems okay.
+
+Lets always enable background fill for Pi0-4.
+
+Fixes: e84da235223d ("drm/vc4: hvs: Support BCM2712 HVS")
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 20 +++++++++-----------
+ 1 file changed, 9 insertions(+), 11 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -1349,27 +1349,25 @@ void vc4_hvs_atomic_flush(struct drm_crt
+ 	WARN_ON(!vc4_state->mm);
+ 	WARN_ON_ONCE(dlist_next - dlist_start != vc4_state->mm->mm_node.size);
+ 
+-	if (enable_bg_fill) {
++	if (vc4->gen >= VC4_GEN_6) {
+ 		/* This sets a black background color fill, as is the case
+ 		 * with other DRM drivers.
+ 		 */
+-		if (vc4->gen >= VC4_GEN_6)
++		if (enable_bg_fill)
+ 			HVS_WRITE(SCALER6_DISPX_CTRL1(channel),
+ 				  HVS_READ(SCALER6_DISPX_CTRL1(channel)) |
+ 				  SCALER6_DISPX_CTRL1_BGENB);
+ 		else
+-			HVS_WRITE(SCALER_DISPBKGNDX(channel),
+-				  HVS_READ(SCALER_DISPBKGNDX(channel)) |
+-				  SCALER_DISPBKGND_FILL);
+-	} else {
+-		if (vc4->gen >= VC4_GEN_6)
+ 			HVS_WRITE(SCALER6_DISPX_CTRL1(channel),
+ 				  HVS_READ(SCALER6_DISPX_CTRL1(channel)) &
+ 				  ~SCALER6_DISPX_CTRL1_BGENB);
+-		else
+-			HVS_WRITE(SCALER_DISPBKGNDX(channel),
+-				  HVS_READ(SCALER_DISPBKGNDX(channel)) &
+-				  ~SCALER_DISPBKGND_FILL);
++	} else {
++		/* we can actually run with a lower core clock when background
++		 * fill is enabled on VC4_GEN_5 so leave it enabled always.
++		 */
++		HVS_WRITE(SCALER_DISPBKGNDX(channel),
++			  HVS_READ(SCALER_DISPBKGNDX(channel)) |
++			  SCALER_DISPBKGND_FILL);
+ 	}
+ 
+ 	/* Only update DISPLIST if the CRTC was already running and is not
diff --git a/target/linux/bcm27xx/patches-6.1/950-1017-gpio-brcmstb-Use-dynamic-GPIO-base-numbers.patch b/target/linux/bcm27xx/patches-6.1/950-1017-gpio-brcmstb-Use-dynamic-GPIO-base-numbers.patch
new file mode 100644
index 0000000000..9bf9e6d96d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1017-gpio-brcmstb-Use-dynamic-GPIO-base-numbers.patch
@@ -0,0 +1,117 @@
+From 450d617786926b27c25e930241efbd2e37d66bb8 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 6 Oct 2023 16:30:35 +0100
+Subject: [PATCH] gpio: brcmstb: Use dynamic GPIO base numbers
+
+Forcing a gpiochip to have a fixed base number now leads to a warning
+message. Remove the need to do so by calculating hwirq numbers based
+on bank numbers.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+Fixes: 3b0213d56eb7 ("gpio: Add GPIO support for Broadcom STB SoCs")
+---
+ drivers/gpio/gpio-brcmstb.c | 21 ++++++++++-----------
+ 1 file changed, 10 insertions(+), 11 deletions(-)
+
+--- a/drivers/gpio/gpio-brcmstb.c
++++ b/drivers/gpio/gpio-brcmstb.c
+@@ -50,7 +50,6 @@ struct brcmstb_gpio_priv {
+ 	struct irq_domain *irq_domain;
+ 	struct irq_chip irq_chip;
+ 	int parent_irq;
+-	int gpio_base;
+ 	int num_gpios;
+ 	int parent_wake_irq;
+ };
+@@ -92,7 +91,7 @@ brcmstb_gpio_get_active_irqs(struct brcm
+ static int brcmstb_gpio_hwirq_to_offset(irq_hw_number_t hwirq,
+ 					struct brcmstb_gpio_bank *bank)
+ {
+-	return hwirq - (bank->gc.base - bank->parent_priv->gpio_base);
++	return hwirq - bank->id * 32;
+ }
+ 
+ static void brcmstb_gpio_set_imask(struct brcmstb_gpio_bank *bank,
+@@ -117,8 +116,9 @@ static void brcmstb_gpio_set_imask(struc
+ static int brcmstb_gpio_to_irq(struct gpio_chip *gc, unsigned offset)
+ {
+ 	struct brcmstb_gpio_priv *priv = brcmstb_gpio_gc_to_priv(gc);
++	struct brcmstb_gpio_bank *bank = gpiochip_get_data(gc);
+ 	/* gc_offset is relative to this gpio_chip; want real offset */
+-	int hwirq = offset + (gc->base - priv->gpio_base);
++	int hwirq = offset + bank->id * 32;
+ 
+ 	if (hwirq >= priv->num_gpios)
+ 		return -ENXIO;
+@@ -263,7 +263,7 @@ static void brcmstb_gpio_irq_bank_handle
+ {
+ 	struct brcmstb_gpio_priv *priv = bank->parent_priv;
+ 	struct irq_domain *domain = priv->irq_domain;
+-	int hwbase = bank->gc.base - priv->gpio_base;
++	int hwbase = bank->id * 32;
+ 	unsigned long status;
+ 
+ 	while ((status = brcmstb_gpio_get_active_irqs(bank))) {
+@@ -414,7 +414,7 @@ static int brcmstb_gpio_of_xlate(struct
+ 	if (WARN_ON(gpiospec->args_count < gc->of_gpio_n_cells))
+ 		return -EINVAL;
+ 
+-	offset = gpiospec->args[0] - (gc->base - priv->gpio_base);
++	offset = gpiospec->args[0] - bank->id * 32;
+ 	if (offset >= gc->ngpio || offset < 0)
+ 		return -EINVAL;
+ 
+@@ -598,8 +598,8 @@ static int brcmstb_gpio_probe(struct pla
+ 	const __be32 *p;
+ 	u32 bank_width;
+ 	int num_banks = 0;
++	int num_gpios = 0;
+ 	int err;
+-	static int gpio_base;
+ 	unsigned long flags = 0;
+ 	bool need_wakeup_event = false;
+ 
+@@ -614,7 +614,6 @@ static int brcmstb_gpio_probe(struct pla
+ 	if (IS_ERR(reg_base))
+ 		return PTR_ERR(reg_base);
+ 
+-	priv->gpio_base = gpio_base;
+ 	priv->reg_base = reg_base;
+ 	priv->pdev = pdev;
+ 
+@@ -656,7 +655,7 @@ static int brcmstb_gpio_probe(struct pla
+ 			dev_dbg(dev, "Width 0 found: Empty bank @ %d\n",
+ 				num_banks);
+ 			num_banks++;
+-			gpio_base += MAX_GPIO_PER_BANK;
++			num_gpios += MAX_GPIO_PER_BANK;
+ 			continue;
+ 		}
+ 
+@@ -698,7 +697,7 @@ static int brcmstb_gpio_probe(struct pla
+ 			err = -ENOMEM;
+ 			goto fail;
+ 		}
+-		gc->base = gpio_base;
++		gc->base = -1;
+ 		gc->of_gpio_n_cells = 2;
+ 		gc->of_xlate = brcmstb_gpio_of_xlate;
+ 		/* not all ngpio lines are valid, will use bank width later */
+@@ -722,7 +721,7 @@ static int brcmstb_gpio_probe(struct pla
+ 					bank->id);
+ 			goto fail;
+ 		}
+-		gpio_base += gc->ngpio;
++		num_gpios += gc->ngpio;
+ 
+ 		dev_dbg(dev, "bank=%d, base=%d, ngpio=%d, width=%d\n", bank->id,
+ 			gc->base, gc->ngpio, bank->width);
+@@ -733,7 +732,7 @@ static int brcmstb_gpio_probe(struct pla
+ 		num_banks++;
+ 	}
+ 
+-	priv->num_gpios = gpio_base - priv->gpio_base;
++	priv->num_gpios = num_gpios;
+ 	if (priv->parent_irq > 0) {
+ 		err = brcmstb_gpio_irq_setup(pdev, priv);
+ 		if (err)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1018-media-rpivid-Allow-use-of-iommu-in-rpivid.patch b/target/linux/bcm27xx/patches-6.1/950-1018-media-rpivid-Allow-use-of-iommu-in-rpivid.patch
new file mode 100644
index 0000000000..a6d199a8c7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1018-media-rpivid-Allow-use-of-iommu-in-rpivid.patch
@@ -0,0 +1,57 @@
+From 1770efc97981dbf756a18f5eb7615c4bafab665b Mon Sep 17 00:00:00 2001
+From: John Cox <jc@kynesim.co.uk>
+Date: Mon, 2 Oct 2023 15:12:52 +0100
+Subject: [PATCH] media/rpivid: Allow use of iommu in rpivid
+
+In order to use iommu on hevc set dma mask_and_coherent in probe.
+I am assured dma_set_mask_and_coherent is benign on Pi4 (which has
+no iommu) and it seems to be so in practice.
+Also adds a bit of debug to make internal buffer allocation failure
+easier to spot in future
+
+Signed-off-by: John Cox <jc@kynesim.co.uk>
+---
+ drivers/staging/media/rpivid/rpivid.c      |  7 +++++++
+ drivers/staging/media/rpivid/rpivid_h265.c | 12 ++++++++++--
+ 2 files changed, 17 insertions(+), 2 deletions(-)
+
+--- a/drivers/staging/media/rpivid/rpivid.c
++++ b/drivers/staging/media/rpivid/rpivid.c
+@@ -360,6 +360,13 @@ static int rpivid_probe(struct platform_
+ 	snprintf(vfd->name, sizeof(vfd->name), "%s", rpivid_video_device.name);
+ 	video_set_drvdata(vfd, dev);
+ 
++	ret = dma_set_mask_and_coherent(dev->dev, DMA_BIT_MASK(36));
++	if (ret) {
++		v4l2_err(&dev->v4l2_dev,
++			 "Failed dma_set_mask_and_coherent\n");
++		goto err_v4l2;
++	}
++
+ 	dev->m2m_dev = v4l2_m2m_init(&rpivid_m2m_ops);
+ 	if (IS_ERR(dev->m2m_dev)) {
+ 		v4l2_err(&dev->v4l2_dev,
+--- a/drivers/staging/media/rpivid/rpivid_h265.c
++++ b/drivers/staging/media/rpivid/rpivid_h265.c
+@@ -2495,11 +2495,19 @@ static int rpivid_h265_start(struct rpiv
+ 	for (i = 0; i != ARRAY_SIZE(ctx->pu_bufs); ++i) {
+ 		// Don't actually need a kernel mapping here
+ 		if (gptr_alloc(dev, ctx->pu_bufs + i, pu_alloc,
+-			       DMA_ATTR_NO_KERNEL_MAPPING))
++			       DMA_ATTR_NO_KERNEL_MAPPING)) {
++			v4l2_err(&dev->v4l2_dev,
++				 "Failed to alloc %#zx PU%d buffer\n",
++				 pu_alloc, i);
+ 			goto fail;
++		}
+ 		if (gptr_alloc(dev, ctx->coeff_bufs + i, coeff_alloc,
+-			       DMA_ATTR_NO_KERNEL_MAPPING))
++			       DMA_ATTR_NO_KERNEL_MAPPING)) {
++			v4l2_err(&dev->v4l2_dev,
++				 "Failed to alloc %#zx Coeff%d buffer\n",
++				 pu_alloc, i);
+ 			goto fail;
++		}
+ 	}
+ 	aux_q_init(ctx);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1019-dts-bcm2712-Add-iommu-to-rpivid.patch b/target/linux/bcm27xx/patches-6.1/950-1019-dts-bcm2712-Add-iommu-to-rpivid.patch
new file mode 100644
index 0000000000..9f7c8674fb
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1019-dts-bcm2712-Add-iommu-to-rpivid.patch
@@ -0,0 +1,22 @@
+From 10ff8ba24c68f704ecf5a58878617dfe149a14c6 Mon Sep 17 00:00:00 2001
+From: John Cox <jc@kynesim.co.uk>
+Date: Mon, 2 Oct 2023 15:15:13 +0100
+Subject: [PATCH] dts/bcm2712: Add iommu to rpivid
+
+Add iommu to rpivid so it can cope with scatter/gather
+
+Signed-off-by: John Cox <jc@kynesim.co.uk>
+---
+ arch/arm/boot/dts/bcm2712.dtsi | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm/boot/dts/bcm2712.dtsi
++++ b/arch/arm/boot/dts/bcm2712.dtsi
+@@ -1158,6 +1158,7 @@
+ 			clocks = <&firmware_clocks 11>;
+ 			clock-names = "hevc";
+ 			status = "disabled";
++			iommus = <&iommu2>;
+ 		};
+ 
+ 		sdio1: mmc@fff000 {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1020-drivers-media-rp1_cfe-Remove-PISP-specific-MBUS-form.patch b/target/linux/bcm27xx/patches-6.1/950-1020-drivers-media-rp1_cfe-Remove-PISP-specific-MBUS-form.patch
new file mode 100644
index 0000000000..fabc96e422
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1020-drivers-media-rp1_cfe-Remove-PISP-specific-MBUS-form.patch
@@ -0,0 +1,117 @@
+From b5c3cc7fd9fca73352310e61092fb445b56a362a Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Tue, 10 Oct 2023 12:41:15 +0100
+Subject: [PATCH] drivers: media: rp1_cfe: Remove PISP specific MBUS formats
+
+Remove the MEDIA_BUS_FMT_PISP* format codcs entirely. For the image
+pad formats, use the 16-bit Bayer format mbus codes instead. For the
+config and stats pad formats, use MEDIA_BUS_FMT_FIXED.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe_fmts.h  | 10 ++++++----
+ .../media/platform/raspberrypi/rp1_cfe/pisp_fe.c   | 11 ++++-------
+ include/uapi/linux/media-bus-format.h              | 14 --------------
+ 3 files changed, 10 insertions(+), 25 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
+@@ -215,25 +215,25 @@ static const struct cfe_fmt formats[] =
+ 	/* PiSP Compressed Mode 1 */
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_PISP_COMP1_RGGB,
+-		.code = MEDIA_BUS_FMT_PISP_COMP1_RGGB,
++		.code = MEDIA_BUS_FMT_SRGGB16_1X16,
+ 		.depth = 8,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_PISP_COMP1_BGGR,
+-		.code = MEDIA_BUS_FMT_PISP_COMP1_BGGR,
++		.code = MEDIA_BUS_FMT_SBGGR16_1X16,
+ 		.depth = 8,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_PISP_COMP1_GBRG,
+-		.code = MEDIA_BUS_FMT_PISP_COMP1_GBRG,
++		.code = MEDIA_BUS_FMT_SGBRG16_1X16,
+ 		.depth = 8,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_PISP_COMP1_GRBG,
+-		.code = MEDIA_BUS_FMT_PISP_COMP1_GRBG,
++		.code = MEDIA_BUS_FMT_SGRBG16_1X16,
+ 		.depth = 8,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
+ 	},
+@@ -283,10 +283,12 @@ static const struct cfe_fmt formats[] =
+ 	/* Frontend formats */
+ 	{
+ 		.fourcc = V4L2_META_FMT_RPI_FE_CFG,
++		.code = MEDIA_BUS_FMT_FIXED,
+ 		.flags = CFE_FORMAT_FLAG_META_OUT,
+ 	},
+ 	{
+ 		.fourcc = V4L2_META_FMT_RPI_FE_STATS,
++		.code = MEDIA_BUS_FMT_FIXED,
+ 		.flags = CFE_FORMAT_FLAG_META_CAP,
+ 	},
+ };
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+@@ -404,7 +404,7 @@ static int pisp_fe_init_cfg(struct v4l2_
+ 
+ 	fmt = v4l2_subdev_get_pad_format(sd, state, FE_CONFIG_PAD);
+ 	*fmt = cfe_default_meta_format;
+-	fmt->code = MEDIA_BUS_FMT_PISP_FE_CONFIG;
++	fmt->code = MEDIA_BUS_FMT_FIXED;
+ 
+ 	fmt = v4l2_subdev_get_pad_format(sd, state, FE_OUTPUT0_PAD);
+ 	*fmt = cfe_default_format;
+@@ -416,7 +416,7 @@ static int pisp_fe_init_cfg(struct v4l2_
+ 
+ 	fmt = v4l2_subdev_get_pad_format(sd, state, FE_STATS_PAD);
+ 	*fmt = cfe_default_meta_format;
+-	fmt->code = MEDIA_BUS_FMT_PISP_FE_STATS;
++	fmt->code = MEDIA_BUS_FMT_FIXED;
+ 
+ 	return 0;
+ }
+@@ -443,12 +443,9 @@ static int pisp_fe_pad_set_fmt(struct v4
+ 
+ 		break;
+ 
+-	case FE_CONFIG_PAD:
+-		format->format.code = MEDIA_BUS_FMT_PISP_FE_CONFIG;
+-		break;
+-
+ 	case FE_STATS_PAD:
+-		format->format.code = MEDIA_BUS_FMT_PISP_FE_STATS;
++	case FE_CONFIG_PAD:
++		format->format.code = MEDIA_BUS_FMT_FIXED;
+ 		break;
+ 	}
+ 
+--- a/include/uapi/linux/media-bus-format.h
++++ b/include/uapi/linux/media-bus-format.h
+@@ -175,18 +175,4 @@
+ /* Sensor ancillary metadata formats - next is 0x7002 */
+ #define MEDIA_BUS_FMT_SENSOR_DATA		0x7002
+ 
+-/* PiSP Formats */
+-#define MEDIA_BUS_FMT_PISP_COMP1_RGGB		0x8001
+-#define MEDIA_BUS_FMT_PISP_COMP1_GRBG		0x8002
+-#define MEDIA_BUS_FMT_PISP_COMP1_GBRG		0x8003
+-#define MEDIA_BUS_FMT_PISP_COMP1_BGGR		0x8004
+-#define MEDIA_BUS_FMT_PISP_COMP2_RGGB		0x8005
+-#define MEDIA_BUS_FMT_PISP_COMP2_GRBG		0x8006
+-#define MEDIA_BUS_FMT_PISP_COMP2_GBRG		0x8007
+-#define MEDIA_BUS_FMT_PISP_COMP2_BGGR		0x8008
+-
+-#define MEDIA_BUS_FMT_PISP_FE_CONFIG		0x8100
+-#define MEDIA_BUS_FMT_PISP_FE_STATS		0x8101
+-#define MEDIA_BUS_FMT_PISP_BE_CONFIG		0x8200
+-
+ #endif /* __LINUX_MEDIA_BUS_FORMAT_H */
diff --git a/target/linux/bcm27xx/patches-6.1/950-1022-vc04_services-bcm2835-codec-Correct-alignment-requir.patch b/target/linux/bcm27xx/patches-6.1/950-1022-vc04_services-bcm2835-codec-Correct-alignment-requir.patch
new file mode 100644
index 0000000000..313ca37738
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1022-vc04_services-bcm2835-codec-Correct-alignment-requir.patch
@@ -0,0 +1,53 @@
+From 9f4002165439d02a63760e68948246e3af764318 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 11 Oct 2023 15:05:38 +0100
+Subject: [PATCH] vc04_services: bcm2835-codec: Correct alignment requirements
+ for YUYV
+
+The firmware wants the YUYV format stride alignment to be to a multiple
+of 32pixels / 64 bytes. The kernel driver was configuring it to a multiple
+of 16 pixels / 32 bytes, which then failed when it tried starting to
+stream.
+
+Correct the alignment requirements.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ .../vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c      | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c
++++ b/drivers/staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c
+@@ -206,28 +206,28 @@ static const struct bcm2835_codec_fmt su
+ 	}, {
+ 		.fourcc			= V4L2_PIX_FMT_YUYV,
+ 		.depth			= 16,
+-		.bytesperline_align	= { 32, 32, 32, 32, 32 },
++		.bytesperline_align	= { 64, 64, 64, 64, 64 },
+ 		.flags			= 0,
+ 		.mmal_fmt		= MMAL_ENCODING_YUYV,
+ 		.size_multiplier_x2	= 2,
+ 	}, {
+ 		.fourcc			= V4L2_PIX_FMT_UYVY,
+ 		.depth			= 16,
+-		.bytesperline_align	= { 32, 32, 32, 32, 32 },
++		.bytesperline_align	= { 64, 64, 64, 64, 64 },
+ 		.flags			= 0,
+ 		.mmal_fmt		= MMAL_ENCODING_UYVY,
+ 		.size_multiplier_x2	= 2,
+ 	}, {
+ 		.fourcc			= V4L2_PIX_FMT_YVYU,
+ 		.depth			= 16,
+-		.bytesperline_align	= { 32, 32, 32, 32, 32 },
++		.bytesperline_align	= { 64, 64, 64, 64, 64 },
+ 		.flags			= 0,
+ 		.mmal_fmt		= MMAL_ENCODING_YVYU,
+ 		.size_multiplier_x2	= 2,
+ 	}, {
+ 		.fourcc			= V4L2_PIX_FMT_VYUY,
+ 		.depth			= 16,
+-		.bytesperline_align	= { 32, 32, 32, 32, 32 },
++		.bytesperline_align	= { 64, 64, 64, 64, 64 },
+ 		.flags			= 0,
+ 		.mmal_fmt		= MMAL_ENCODING_VYUY,
+ 		.size_multiplier_x2	= 2,
diff --git a/target/linux/bcm27xx/patches-6.1/950-1025-input-touchscreen-edt-ft5x06-Suppress-bogus-data-on-.patch b/target/linux/bcm27xx/patches-6.1/950-1025-input-touchscreen-edt-ft5x06-Suppress-bogus-data-on-.patch
new file mode 100644
index 0000000000..fe956c2ed4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1025-input-touchscreen-edt-ft5x06-Suppress-bogus-data-on-.patch
@@ -0,0 +1,96 @@
+From dd802fc03b1c71b4297e87068077bfcf9810300a Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Wed, 11 Oct 2023 15:14:59 +0100
+Subject: [PATCH] input: touchscreen: edt-ft5x06: Suppress bogus data on
+ startup
+
+When polled without the use of IRQ, FT5x06 registers may return
+undefined initial data, causing unwanted touches or event spamming.
+A simple way to filter this out is to suppress touches until the
+TD_STATUS register changes for the first time.
+
+Increase the delay before first polling to 300ms, to avoid
+transient I2C read flakiness that seems to occur after reset.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/input/touchscreen/edt-ft5x06.c | 31 +++++++++++++++++++++++---
+ 1 file changed, 28 insertions(+), 3 deletions(-)
+
+--- a/drivers/input/touchscreen/edt-ft5x06.c
++++ b/drivers/input/touchscreen/edt-ft5x06.c
+@@ -75,6 +75,8 @@
+ #define EDT_DEFAULT_NUM_X		1024
+ #define EDT_DEFAULT_NUM_Y		1024
+ 
++#define RESET_DELAY_MS			300	/* reset deassert to I2C */
++#define FIRST_POLL_DELAY_MS		300	/* in addition to the above */
+ #define POLL_INTERVAL_MS		17	/* 17ms = 60fps */
+ 
+ enum edt_pmode {
+@@ -134,6 +136,7 @@ struct edt_ft5x06_ts_data {
+ 
+ 	char name[EDT_NAME_LEN];
+ 	char fw_version[EDT_NAME_LEN];
++	int init_td_status;
+ 
+ 	struct edt_reg_addr reg_addr;
+ 	enum edt_ver version;
+@@ -268,12 +271,33 @@ static irqreturn_t edt_ft5x06_ts_isr(int
+ 		 * points.
+ 		 */
+ 		num_points = min(rdbuf[2] & 0xf, tsdata->max_support_points);
++
++		/* When polling FT5x06 without IRQ: initial register contents
++		 * could be stale or undefined; discard all readings until
++		 * TD_STATUS changes for the first time (or num_points is 0).
++		 */
++		if (tsdata->init_td_status) {
++			if (tsdata->init_td_status < 0)
++				tsdata->init_td_status = rdbuf[2];
++
++			if (num_points && rdbuf[2] == tsdata->init_td_status)
++				goto out;
++
++			tsdata->init_td_status = 0;
++		}
++
+ 		if (num_points) {
+ 			datalen = tplen * num_points + crclen;
+ 			cmd = offset;
+ 			error = edt_ft5x06_ts_readwrite(tsdata->client,
+ 							sizeof(cmd), &cmd,
+ 							datalen, &rdbuf[offset]);
++			if (error) {
++				dev_err_ratelimited(dev,
++						    "Unable to fetch data, error: %d\n",
++						    error);
++				goto out;
++			}
+ 		}
+ 	}
+ 
+@@ -1294,7 +1318,7 @@ static int edt_ft5x06_ts_probe(struct i2
+ 	if (tsdata->reset_gpio) {
+ 		usleep_range(5000, 6000);
+ 		gpiod_set_value_cansleep(tsdata->reset_gpio, 0);
+-		msleep(300);
++		msleep(RESET_DELAY_MS);
+ 	}
+ 
+ 	input = devm_input_allocate_device(&client->dev);
+@@ -1384,11 +1408,12 @@ static int edt_ft5x06_ts_probe(struct i2
+ 			return error;
+ 		}
+ 	} else {
++		tsdata->init_td_status = -1; /* filter bogus initial data */
+ 		INIT_WORK(&tsdata->work_i2c_poll,
+ 			  edt_ft5x06_ts_work_i2c_poll);
+ 		timer_setup(&tsdata->timer, edt_ft5x06_ts_irq_poll_timer, 0);
+-		tsdata->timer.expires = jiffies +
+-					msecs_to_jiffies(POLL_INTERVAL_MS);
++		tsdata->timer.expires =
++			jiffies + msecs_to_jiffies(FIRST_POLL_DELAY_MS);
+ 		add_timer(&tsdata->timer);
+ 	}
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1027-Revert-bcm2708_fb-Fix-more-build-warnings.patch b/target/linux/bcm27xx/patches-6.1/950-1027-Revert-bcm2708_fb-Fix-more-build-warnings.patch
new file mode 100644
index 0000000000..05bccd4a82
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1027-Revert-bcm2708_fb-Fix-more-build-warnings.patch
@@ -0,0 +1,44 @@
+From 5ca6201e6b2c84499402a0a0a757dac6a8ebbcd8 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Thu, 12 Oct 2023 15:52:24 +0100
+Subject: [PATCH] Revert "bcm2708_fb: Fix more build warnings"
+
+This reverts commit 7b11991e91e65ebeb315986fae05d363663d24c4.
+---
+ drivers/video/fbdev/bcm2708_fb.c | 8 +++-----
+ 1 file changed, 3 insertions(+), 5 deletions(-)
+
+--- a/drivers/video/fbdev/bcm2708_fb.c
++++ b/drivers/video/fbdev/bcm2708_fb.c
+@@ -955,7 +955,6 @@ static void bcm2708_fb_imageblit(struct
+ 	cfb_imageblit(info, image);
+ }
+ 
+-#if 0
+ static irqreturn_t bcm2708_fb_dma_irq(int irq, void *cxt)
+ {
+ 	struct bcm2708_fb_dev *fbdev = cxt;
+@@ -973,7 +972,6 @@ static irqreturn_t bcm2708_fb_dma_irq(in
+ 	wake_up(&fbdev->dma_waitq);
+ 	return IRQ_HANDLED;
+ }
+-#endif
+ 
+ static struct fb_ops bcm2708_fb_ops = {
+ 	.owner = THIS_MODULE,
+@@ -1197,12 +1195,12 @@ static int bcm2708_fb_probe(struct platf
+ 		return ret;
+ 	}
+ 
+-//free_dma_chan:
++free_dma_chan:
+ 	bcm_dma_chan_free(fbdev->dma_chan);
+-//free_cb:
++free_cb:
+ 	dma_free_wc(&dev->dev, SZ_64K, fbdev->cb_base,
+ 			      fbdev->cb_handle);
+-//free_fb:
++free_fb:
+ 	dev_err(&dev->dev, "probe failed, err %d\n", ret);
+ 
+ 	return ret;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1028-Revert-bcm2708_fb-Hack-out-dma-support.patch b/target/linux/bcm27xx/patches-6.1/950-1028-Revert-bcm2708_fb-Hack-out-dma-support.patch
new file mode 100644
index 0000000000..e946ade18c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1028-Revert-bcm2708_fb-Hack-out-dma-support.patch
@@ -0,0 +1,38 @@
+From 392b9849c8d147c25557fea5d6dbcddbcb9e72d5 Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Thu, 12 Oct 2023 15:52:38 +0100
+Subject: [PATCH] Revert "bcm2708_fb: Hack out dma support"
+
+This reverts commit d60956f30586ced37e2152f2ba338f547e6c64f7.
+---
+ drivers/video/fbdev/bcm2708_fb.c | 5 +----
+ 1 file changed, 1 insertion(+), 4 deletions(-)
+
+--- a/drivers/video/fbdev/bcm2708_fb.c
++++ b/drivers/video/fbdev/bcm2708_fb.c
+@@ -657,8 +657,6 @@ static long vc_mem_copy(struct bcm2708_f
+ 	long rc = 0;
+ 	size_t offset;
+ 
+-return -EFAULT;
+-
+ 	/* restrict this to root user */
+ 	if (!uid_eq(current_euid(), GLOBAL_ROOT_UID)) {
+ 		rc = -EFAULT;
+@@ -1111,7 +1109,6 @@ static int bcm2708_fb_probe(struct platf
+ 
+ 	dev_info(&dev->dev, "FB found %d display(s)\n", num_displays);
+ 
+-#if 0
+ 	/* Set up the DMA information. Note we have just one set of DMA
+ 	 * parameters to work with all the FB's so requires synchronising when
+ 	 * being used
+@@ -1144,7 +1141,7 @@ static int bcm2708_fb_probe(struct platf
+ 			"Failed to request DMA irq\n");
+ 		goto free_dma_chan;
+ 	}
+-#endif
++
+ 	rpi_firmware_property(fbdev->fw,
+ 			      RPI_FIRMWARE_GET_VC_MEMORY,
+ 			      &gpu_mem, sizeof(gpu_mem));
diff --git a/target/linux/bcm27xx/patches-6.1/950-1029-overlays-mcp23017-allow-specification-of-the-i2c-bus.patch b/target/linux/bcm27xx/patches-6.1/950-1029-overlays-mcp23017-allow-specification-of-the-i2c-bus.patch
new file mode 100644
index 0000000000..8cb35e1a79
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1029-overlays-mcp23017-allow-specification-of-the-i2c-bus.patch
@@ -0,0 +1,97 @@
+From 27f0e0e195568c06f21ce380f0736bdd219baf3c Mon Sep 17 00:00:00 2001
+From: Janis Streib <janis+github@dogcraft.de>
+Date: Sun, 15 Oct 2023 21:08:40 +0200
+Subject: [PATCH] overlays: mcp23017: allow specification of the i2c bus
+
+Analogous to i2c-rtc-overlay.dts
+
+See: https://github.com/raspberrypi/linux/pull/5650
+---
+ arch/arm/boot/dts/overlays/README             | 10 ++++++
+ .../boot/dts/overlays/mcp23017-overlay.dts    | 36 +++++++++++++++++--
+ 2 files changed, 44 insertions(+), 2 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -2810,6 +2810,16 @@ Params: gpiopin                 Gpio pin
+ 
+         mcp23008                Configure an MCP23008 instead.
+         noints                  Disable the interrupt GPIO line.
++        i2c0                    Choose the I2C0 bus on GPIOs 0&1
++        i2c_csi_dsi             Choose the I2C0 bus on GPIOs 44&45
++        i2c3                    Choose the I2C3 bus (configure with the i2c3
++                                overlay - BCM2711 only)
++        i2c4                    Choose the I2C4 bus (configure with the i2c4
++                                overlay - BCM2711 only)
++        i2c5                    Choose the I2C5 bus (configure with the i2c5
++                                overlay - BCM2711 only)
++        i2c6                    Choose the I2C6 bus (configure with the i2c6
++                                overlay - BCM2711 only)
+ 
+ 
+ Name:   mcp23s17
+--- a/arch/arm/boot/dts/overlays/mcp23017-overlay.dts
++++ b/arch/arm/boot/dts/overlays/mcp23017-overlay.dts
+@@ -7,7 +7,7 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2c1>;
++		target = <&i2cbus>;
+ 		__overlay__ {
+ 			status = "okay";
+ 		};
+@@ -24,7 +24,7 @@
+ 	};
+ 
+ 	fragment@2 {
+-		target = <&i2c1>;
++		target = <&i2cbus>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+@@ -58,12 +58,44 @@
+ 		};
+ 	};
+ 
++	frag100: fragment@100 {
++		target = <&i2c1>;
++		i2cbus: __overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@101 { 
++		target = <&i2c0if>; 
++		__dormant__ { 
++			status = "okay"; 
++		}; 
++	};
++
++	fragment@102 { 
++		target = <&i2c0mux>; 
++		__dormant__ { 
++			status = "okay"; 
++		}; 
++	};
++
+ 	__overrides__ {
+ 		gpiopin = <&mcp23017_pins>,"brcm,pins:0",
+ 				<&mcp23017_irq>,"interrupts:0";
+ 		addr = <&mcp23017>,"reg:0", <&mcp23017_pins>,"reg:0";
+ 		mcp23008 = <0>,"=3";
+ 		noints = <0>,"!1!4";
++		i2c0 = <&frag100>, "target:0=",<&i2c0>;
++		i2c_csi_dsi = <&frag100>, "target:0=",<&i2c_csi_dsi>,
++			      <0>,"+101+102";
++		i2c3 = <&frag100>, "target?=0",
++		       <&frag100>, "target-path=i2c3";
++		i2c4 = <&frag100>, "target?=0",
++		       <&frag100>, "target-path=i2c4";
++		i2c5 = <&frag100>, "target?=0",
++		       <&frag100>, "target-path=i2c5";
++		i2c6 = <&frag100>, "target?=0",
++		       <&frag100>, "target-path=i2c6";
+ 	};
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1030-dts-bcm2712-Set-default-I2C-baudrates-to-100kHz.patch b/target/linux/bcm27xx/patches-6.1/950-1030-dts-bcm2712-Set-default-I2C-baudrates-to-100kHz.patch
new file mode 100644
index 0000000000..e9422f1daa
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1030-dts-bcm2712-Set-default-I2C-baudrates-to-100kHz.patch
@@ -0,0 +1,46 @@
+From 0339c8c61ca6b54c529f699e7bafd65cda9f3733 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 16 Oct 2023 09:06:25 +0100
+Subject: [PATCH] dts: bcm2712: Set default I2C baudrates to 100kHz
+
+The RP1 I2C interfaces were being left with their default clock rates,
+apparently 400kHz.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 2 ++
+ arch/arm/boot/dts/bcm2712-rpi.dtsi    | 2 ++
+ 2 files changed, 4 insertions(+)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -250,11 +250,13 @@ i2c0mux: &rp1_gpio {};
+ i2c_csi_dsi0: &i2c6 { // Note: This is for MIPI0 connector only
+ 	pinctrl-0 = <&rp1_i2c6_38_39>;
+ 	pinctrl-names = "default";
++	clock-frequency = <100000>;
+ };
+ 
+ i2c_csi_dsi1: &i2c4 { // Note: This is for MIPI1 connector only
+ 	pinctrl-0 = <&rp1_i2c4_40_41>;
+ 	pinctrl-names = "default";
++	clock-frequency = <100000>;
+ };
+ 
+ i2c_csi_dsi: &i2c_csi_dsi1 { }; // An alias for compatibility
+--- a/arch/arm/boot/dts/bcm2712-rpi.dtsi
++++ b/arch/arm/boot/dts/bcm2712-rpi.dtsi
+@@ -204,11 +204,13 @@ uart4: &rp1_uart4 { };
+ i2c_vc: &i2c0 {      // This is pins 27,28 on the header (not MIPI)
+ 	pinctrl-0 = <&rp1_i2c0_0_1>;
+ 	pinctrl-names = "default";
++	clock-frequency = <100000>;
+ };
+ 
+ i2c_arm: &i2c1 {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&rp1_i2c1_2_3>;
++	clock-frequency = <100000>;
+ };
+ 
+ &i2c2 {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1031-vc_mem-Add-the-DMA-memcpy-support-from-bcm2708_fb.patch b/target/linux/bcm27xx/patches-6.1/950-1031-vc_mem-Add-the-DMA-memcpy-support-from-bcm2708_fb.patch
new file mode 100644
index 0000000000..23d428789f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1031-vc_mem-Add-the-DMA-memcpy-support-from-bcm2708_fb.patch
@@ -0,0 +1,345 @@
+From 2a47ccf97c6a91bc56f8cfb387d47f59cc347dd5 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Sat, 14 Oct 2023 14:57:49 +0100
+Subject: [PATCH] vc_mem: Add the DMA memcpy support from bcm2708_fb
+
+bcm2708_fb is disabled by the vc4-kms-v3d overlay, which means that the
+DMA memcpy support it provides is not available to allow vclog to read
+the VC logs from the top 16MB on Pi 2 and Pi 3. Add the code to the
+vc_mem driver, which will still be enabled.
+
+It ought to be possible to do a proper DMA_MEM_TO_MEM copy via the
+generic DMA customer API, but that can be a later step.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/char/broadcom/vc_mem.c | 259 +++++++++++++++++++++++++++++++++
+ 1 file changed, 259 insertions(+)
+
+--- a/drivers/char/broadcom/vc_mem.c
++++ b/drivers/char/broadcom/vc_mem.c
+@@ -23,9 +23,21 @@
+ #include <linux/uaccess.h>
+ #include <linux/dma-mapping.h>
+ #include <linux/broadcom/vc_mem.h>
++#include <linux/compat.h>
++#include <linux/platform_data/dma-bcm2708.h>
++#include <soc/bcm2835/raspberrypi-firmware.h>
+ 
+ #define DRIVER_NAME  "vc-mem"
+ 
++/* N.B. These use a different magic value for compatibility with bmc7208_fb */
++#define VC_MEM_IOC_DMACOPY   _IOW('z', 0x22, struct vc_mem_dmacopy)
++#define VC_MEM_IOC_DMACOPY32 _IOW('z', 0x22, struct vc_mem_dmacopy32)
++
++/* address with no aliases */
++#define INTALIAS_NORMAL(x) ((x) & ~0xc0000000)
++/* cache coherent but non-allocating in L1 and L2 */
++#define INTALIAS_L1L2_NONALLOCATING(x) (((x) & ~0xc0000000) | 0x80000000)
++
+ /* Device (/dev) related variables */
+ static dev_t vc_mem_devnum;
+ static struct class *vc_mem_class;
+@@ -36,6 +48,20 @@ static int vc_mem_inited;
+ static struct dentry *vc_mem_debugfs_entry;
+ #endif
+ 
++struct vc_mem_dmacopy {
++	void *dst;
++	__u32 src;
++	__u32 length;
++};
++
++#ifdef CONFIG_COMPAT
++struct vc_mem_dmacopy32 {
++	compat_uptr_t dst;
++	__u32 src;
++	__u32 length;
++};
++#endif
++
+ /*
+  * Videocore memory addresses and size
+  *
+@@ -62,6 +88,20 @@ static uint phys_addr;
+ static uint mem_size;
+ static uint mem_base;
+ 
++struct vc_mem_dma {
++	struct device *dev;
++	int dma_chan;
++	int dma_irq;
++	void __iomem *dma_chan_base;
++	wait_queue_head_t dma_waitq;
++	void *cb_base;	/* DMA control blocks */
++	dma_addr_t cb_handle;
++};
++
++struct { u32 base, length; } gpu_mem;
++static struct mutex dma_mutex;
++static struct vc_mem_dma vc_mem_dma;
++
+ static int
+ vc_mem_open(struct inode *inode, struct file *file)
+ {
+@@ -99,6 +139,189 @@ vc_mem_get_current_size(void)
+ }
+ EXPORT_SYMBOL_GPL(vc_mem_get_current_size);
+ 
++static int
++vc_mem_dma_init(void)
++{
++	struct vc_mem_dma *vcdma = &vc_mem_dma;
++	struct platform_device *pdev;
++	struct device_node *fwnode;
++	struct rpi_firmware *fw;
++	struct device *dev;
++	u32 revision;
++	int rc;
++
++	if (vcdma->dev)
++		return 0;
++
++	fwnode = of_find_node_by_path("/system");
++	rc = of_property_read_u32(fwnode, "linux,revision", &revision);
++	revision = (revision >> 12) & 0xf;
++	if (revision != 1 && revision != 2) {
++		/* Only BCM2709 and BCM2710 may have logs where the ARMs
++		 * can't see them.
++		 */
++		return -ENXIO;
++	}
++
++	fwnode = rpi_firmware_find_node();
++	if (!fwnode)
++		return -ENXIO;
++
++	pdev = of_find_device_by_node(fwnode);
++	dev = &pdev->dev;
++
++	rc = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
++	if (rc)
++		return rc;
++
++	fw = rpi_firmware_get(fwnode);
++	if (!fw)
++		return -ENXIO;
++	rc = rpi_firmware_property(fw, RPI_FIRMWARE_GET_VC_MEMORY,
++				   &gpu_mem, sizeof(gpu_mem));
++	if (rc)
++		return rc;
++
++	gpu_mem.base = INTALIAS_NORMAL(gpu_mem.base);
++
++	if (!gpu_mem.base || !gpu_mem.length) {
++		dev_err(dev, "%s: unable to determine gpu memory (%x,%x)\n",
++			__func__, gpu_mem.base, gpu_mem.length);
++		return -EFAULT;
++	}
++
++	vcdma->cb_base = dma_alloc_wc(dev, SZ_4K, &vcdma->cb_handle, GFP_KERNEL);
++	if (!vcdma->cb_base) {
++		dev_err(dev, "failed to allocate DMA CBs\n");
++		return -ENOMEM;
++	}
++
++	rc = bcm_dma_chan_alloc(BCM_DMA_FEATURE_BULK,
++				&vcdma->dma_chan_base,
++				&vcdma->dma_irq);
++	if (rc < 0) {
++		dev_err(dev, "failed to allocate a DMA channel\n");
++		goto free_cb;
++	}
++
++	vcdma->dma_chan = rc;
++
++	init_waitqueue_head(&vcdma->dma_waitq);
++
++	vcdma->dev = dev;
++
++	return 0;
++
++free_cb:
++	dma_free_wc(dev, SZ_4K, vcdma->cb_base, vcdma->cb_handle);
++
++	return rc;
++}
++
++static void
++vc_mem_dma_uninit(void)
++{
++	struct vc_mem_dma *vcdma = &vc_mem_dma;
++
++	if (vcdma->dev) {
++		bcm_dma_chan_free(vcdma->dma_chan);
++		dma_free_wc(vcdma->dev, SZ_4K, vcdma->cb_base, vcdma->cb_handle);
++		vcdma->dev = NULL;
++	}
++}
++
++static int dma_memcpy(struct vc_mem_dma *vcdma, dma_addr_t dst, dma_addr_t src,
++		      int size)
++{
++	struct bcm2708_dma_cb *cb = vcdma->cb_base;
++	int burst_size = (vcdma->dma_chan == 0) ? 8 : 2;
++
++	cb->info = BCM2708_DMA_BURST(burst_size) | BCM2708_DMA_S_WIDTH |
++		   BCM2708_DMA_S_INC | BCM2708_DMA_D_WIDTH |
++		   BCM2708_DMA_D_INC;
++	cb->dst = dst;
++	cb->src = src;
++	cb->length = size;
++	cb->stride = 0;
++	cb->pad[0] = 0;
++	cb->pad[1] = 0;
++	cb->next = 0;
++
++	bcm_dma_start(vcdma->dma_chan_base, vcdma->cb_handle);
++	bcm_dma_wait_idle(vcdma->dma_chan_base);
++
++	return 0;
++}
++
++static long vc_mem_copy(struct vc_mem_dmacopy *ioparam)
++{
++	struct vc_mem_dma *vcdma = &vc_mem_dma;
++	size_t size = PAGE_SIZE;
++	const u32 dma_xfer_chunk = 256;
++	u32 *buf = NULL;
++	dma_addr_t bus_addr;
++	long rc = 0;
++	size_t offset;
++
++	/* restrict this to root user */
++	if (!uid_eq(current_euid(), GLOBAL_ROOT_UID))
++		return -EFAULT;
++
++	if (mutex_lock_interruptible(&dma_mutex))
++		return -EINTR;
++
++	rc = vc_mem_dma_init();
++	if (rc)
++		goto out;
++
++	vcdma = &vc_mem_dma;
++
++	if (INTALIAS_NORMAL(ioparam->src) < gpu_mem.base ||
++	    INTALIAS_NORMAL(ioparam->src) >= gpu_mem.base + gpu_mem.length) {
++		pr_err("%s: invalid memory access %x (%x-%x)", __func__,
++		       INTALIAS_NORMAL(ioparam->src), gpu_mem.base,
++		       gpu_mem.base + gpu_mem.length);
++		rc = -EFAULT;
++		goto out;
++	}
++
++	buf = dma_alloc_coherent(vcdma->dev, PAGE_ALIGN(size), &bus_addr,
++				 GFP_ATOMIC);
++	if (!buf) {
++		rc = -ENOMEM;
++		goto out;
++	}
++
++	for (offset = 0; offset < ioparam->length; offset += size) {
++		size_t remaining = ioparam->length - offset;
++		size_t s = min(size, remaining);
++		u8 *p = (u8 *)((uintptr_t)ioparam->src + offset);
++		u8 *q = (u8 *)ioparam->dst + offset;
++
++		rc = dma_memcpy(vcdma, bus_addr,
++				INTALIAS_L1L2_NONALLOCATING((u32)(uintptr_t)p),
++				(s + dma_xfer_chunk - 1) & ~(dma_xfer_chunk - 1));
++		if (rc) {
++			dev_err(vcdma->dev, "dma_memcpy failed\n");
++			break;
++		}
++		if (copy_to_user(q, buf, s) != 0) {
++			pr_err("%s: copy_to_user failed\n", __func__);
++			rc = -EFAULT;
++			break;
++		}
++	}
++
++out:
++	if (buf)
++		dma_free_coherent(vcdma->dev, PAGE_ALIGN(size), buf,
++				  bus_addr);
++
++	mutex_unlock(&dma_mutex);
++
++	return rc;
++}
++
+ static long
+ vc_mem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+@@ -163,6 +386,21 @@ vc_mem_ioctl(struct file *file, unsigned
+ 			}
+ 			break;
+ 		}
++	case VC_MEM_IOC_DMACOPY:
++		{
++			struct vc_mem_dmacopy ioparam;
++			/* Get the parameter data.
++			 */
++			if (copy_from_user
++			    (&ioparam, (void *)arg, sizeof(ioparam))) {
++				pr_err("%s: copy_from_user failed\n", __func__);
++				rc = -EFAULT;
++				break;
++			}
++
++			rc = vc_mem_copy(&ioparam);
++			break;
++		}
+ 	default:
+ 		{
+ 			return -ENOTTY;
+@@ -193,6 +431,24 @@ vc_mem_compat_ioctl(struct file *file, u
+ 
+ 		break;
+ 
++	case VC_MEM_IOC_DMACOPY32:
++	{
++		struct vc_mem_dmacopy32 param32;
++		struct vc_mem_dmacopy param;
++		/* Get the parameter data.
++		 */
++		if (copy_from_user(&param32, (void *)arg, sizeof(param32))) {
++			pr_err("%s: copy_from_user failed\n", __func__);
++			rc = -EFAULT;
++			break;
++		}
++		param.dst = compat_ptr(param32.dst);
++		param.src = param32.src;
++		param.length = param32.length;
++		rc = vc_mem_copy(&param);
++		break;
++	}
++
+ 	default:
+ 		rc = vc_mem_ioctl(file, cmd, arg);
+ 		break;
+@@ -330,6 +586,7 @@ vc_mem_init(void)
+ 	vc_mem_debugfs_init(dev);
+ #endif
+ 
++	mutex_init(&dma_mutex);
+ 	vc_mem_inited = 1;
+ 	return 0;
+ 
+@@ -352,6 +609,7 @@ vc_mem_exit(void)
+ {
+ 	pr_debug("%s: called\n", __func__);
+ 
++	vc_mem_dma_uninit();
+ 	if (vc_mem_inited) {
+ #ifdef CONFIG_DEBUG_FS
+ 		vc_mem_debugfs_deinit();
+@@ -360,6 +618,7 @@ vc_mem_exit(void)
+ 		class_destroy(vc_mem_class);
+ 		cdev_del(&vc_mem_cdev);
+ 		unregister_chrdev_region(vc_mem_devnum, 1);
++		vc_mem_inited = 0;
+ 	}
+ }
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1032-drm-vc4-Correct-address-offset-for-planes-with-src_-.patch b/target/linux/bcm27xx/patches-6.1/950-1032-drm-vc4-Correct-address-offset-for-planes-with-src_-.patch
new file mode 100644
index 0000000000..32112f949b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1032-drm-vc4-Correct-address-offset-for-planes-with-src_-.patch
@@ -0,0 +1,48 @@
+From 6ab30a5dd3fb2ccbd918f147e91eb9bfe9849970 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Mon, 16 Oct 2023 12:13:38 +0100
+Subject: [PATCH] drm/vc4: Correct address offset for planes with src_[xy]
+ offsets
+
+11cf37e741b4 switched to using drm_fb_dma_get_gem_addr instead of
+drm_fb_dma_get_gem_obj and adding fb->offset[].
+
+However the tiled formats need to compute the offset in a more
+involved manner than drm_fb_dma_get_gem_addr applies, and we
+were ending up with the offset for src_[xy] being applied twice.
+
+Switch back to using drm_fb_dma_get_gem_obj and fully computing
+the offsets ourselves.
+
+Fixes: 11cf37e741b4 ("drm/vc4: Move the buffer offset out of the vc4_plane_state")
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_plane.c | 9 ++++-----
+ 1 file changed, 4 insertions(+), 5 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -1447,9 +1447,9 @@ static int vc4_plane_mode_set(struct drm
+ 	vc4_state->ptr0_offset[0] = vc4_state->dlist_count;
+ 
+ 	for (i = 0; i < num_planes; i++) {
+-		dma_addr_t paddr = drm_fb_dma_get_gem_addr(fb, state, i);
++		struct drm_gem_dma_object *bo = drm_fb_dma_get_gem_obj(fb, i);
+ 
+-		vc4_dlist_write(vc4_state, paddr + offsets[i]);
++		vc4_dlist_write(vc4_state, bo->dma_addr + fb->offsets[i] + offsets[i]);
+ 	}
+ 
+ 	/* Pointer Context Word 0/1/2: Written by the HVS */
+@@ -1842,9 +1842,8 @@ static int vc6_plane_mode_set(struct drm
+ 	 * TODO: This only covers Raster Scan Order planes
+ 	 */
+ 	for (i = 0; i < num_planes; i++) {
+-		dma_addr_t paddr = drm_fb_dma_get_gem_addr(fb, state, i);
+-
+-		paddr += offsets[i];
++		struct drm_gem_dma_object *bo = drm_fb_dma_get_gem_obj(fb, i);
++		dma_addr_t paddr = bo->dma_addr + fb->offsets[i] + offsets[i];
+ 
+ 		/* Pointer Word 0 */
+ 		vc4_state->ptr0_offset[i] = vc4_state->dlist_count;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1033-drivers-media-rp1_cfe-Fix-link-validate-test-for-pix.patch b/target/linux/bcm27xx/patches-6.1/950-1033-drivers-media-rp1_cfe-Fix-link-validate-test-for-pix.patch
new file mode 100644
index 0000000000..3e1d504da0
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1033-drivers-media-rp1_cfe-Fix-link-validate-test-for-pix.patch
@@ -0,0 +1,69 @@
+From c14550658832026e82111f2a89b3f7bf567afc1c Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Tue, 17 Oct 2023 09:35:44 +0100
+Subject: [PATCH] drivers: media: rp1_cfe: Fix link validate test for pixel
+ format
+
+Now that we have removed unique PISP media bus codes, the cfe format
+table has multiple entries with the same media bus code for 16-bit
+formats. The test in cfe_video_link_validate() did not account for this.
+Fix it by testing the media bus code and the V4L2 pixelformat 4cc
+together.
+
+As a drive-by, ensure we have a valid CSI2 datatype id when programming
+the hardware block.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 19 ++++++++++++++++---
+ 1 file changed, 16 insertions(+), 3 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -786,6 +786,9 @@ static void cfe_start_channel(struct cfe
+ 		width = source_fmt->width;
+ 		height = source_fmt->height;
+ 
++		/* Must have a valid CSI2 datatype. */
++		WARN_ON(!fmt->csi_dt);
++
+ 		/*
+ 		 * Start the associated CSI2 Channel as well.
+ 		 *
+@@ -809,6 +812,9 @@ static void cfe_start_channel(struct cfe
+ 			node_desc[node->id].link_pad - CSI2_NUM_CHANNELS);
+ 		fmt = find_format_by_code(source_fmt->code);
+ 
++		/* Must have a valid CSI2 datatype. */
++		WARN_ON(!fmt->csi_dt);
++
+ 		if (is_image_output_node(node)) {
+ 			width = source_fmt->width;
+ 			height = source_fmt->height;
+@@ -1504,7 +1510,8 @@ static int cfe_video_link_validate(struc
+ 
+ 	if (is_image_output_node(node)) {
+ 		struct v4l2_pix_format *pix_fmt = &node->fmt.fmt.pix;
+-		const struct cfe_fmt *fmt;
++		const struct cfe_fmt *fmt = NULL;
++		unsigned int i;
+ 
+ 		if (source_fmt->width != pix_fmt->width ||
+ 		    source_fmt->height != pix_fmt->height) {
+@@ -1516,8 +1523,14 @@ static int cfe_video_link_validate(struc
+ 			goto out;
+ 		}
+ 
+-		fmt = find_format_by_code(source_fmt->code);
+-		if (!fmt || fmt->fourcc != pix_fmt->pixelformat) {
++		for (i = 0; i < ARRAY_SIZE(formats); i++) {
++			if (formats[i].code == source_fmt->code &&
++			    formats[i].fourcc == pix_fmt->pixelformat) {
++				fmt = &formats[i];
++				break;
++			}
++		}
++		if (!fmt) {
+ 			cfe_err("Format mismatch!\n");
+ 			ret = -EINVAL;
+ 			goto out;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1034-dts-bcm2712-Use-the-new-model-name.patch b/target/linux/bcm27xx/patches-6.1/950-1034-dts-bcm2712-Use-the-new-model-name.patch
new file mode 100644
index 0000000000..f30456835a
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1034-dts-bcm2712-Use-the-new-model-name.patch
@@ -0,0 +1,23 @@
+From b6bfece0d9ddf21e1526fead81340ef02f98f6ad Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 17 Oct 2023 17:28:11 +0100
+Subject: [PATCH] dts: bcm2712: Use the new model name
+
+"Model B" is no more - "Raspberry Pi 5" is the official name.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -52,7 +52,7 @@
+ 
+ / {
+ 	compatible = "raspberrypi,5-model-b", "brcm,bcm2712";
+-	model = "Raspberry Pi 5 Model B";
++	model = "Raspberry Pi 5";
+ 
+ 	/* Will be filled by the bootloader */
+ 	memory@0 {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1035-fbdev-Allow-client-to-request-a-particular-dev-fbN-n.patch b/target/linux/bcm27xx/patches-6.1/950-1035-fbdev-Allow-client-to-request-a-particular-dev-fbN-n.patch
new file mode 100644
index 0000000000..df87a1b757
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1035-fbdev-Allow-client-to-request-a-particular-dev-fbN-n.patch
@@ -0,0 +1,93 @@
+From 0c7fb448e0e0e47c2b3be64e438208682c6a5e61 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Mon, 9 Oct 2023 16:32:45 +0100
+Subject: [PATCH] fbdev: Allow client to request a particular /dev/fbN node
+
+Add a flag custom_fb_num to denote that the client has
+requested a specific fbdev node number via node.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/video/fbdev/core/fbmem.c | 24 +++++++++++++++++-------
+ include/linux/fb.h               |  2 ++
+ 2 files changed, 19 insertions(+), 7 deletions(-)
+
+--- a/drivers/video/fbdev/core/fbmem.c
++++ b/drivers/video/fbdev/core/fbmem.c
+@@ -52,6 +52,7 @@ static DEFINE_MUTEX(registration_lock);
+ 
+ struct fb_info *registered_fb[FB_MAX] __read_mostly;
+ int num_registered_fb __read_mostly;
++int min_dynamic_fb __read_mostly;
+ #define for_each_registered_fb(i)		\
+ 	for (i = 0; i < FB_MAX; i++)		\
+ 		if (!registered_fb[i]) {} else
+@@ -1579,19 +1580,22 @@ static int do_register_framebuffer(struc
+ 		return -ENXIO;
+ 
+ 	num_registered_fb++;
+-	for (i = 0 ; i < FB_MAX; i++)
+-		if (!registered_fb[i])
+-			break;
+-	fb_info->node = i;
++	if (!fb_info->custom_fb_num || fb_info->node >= FB_MAX || registered_fb[fb_info->node]) {
++		for (i = min_dynamic_fb ; i < FB_MAX; i++)
++			if (!registered_fb[i])
++				break;
++		fb_info->node = i;
++	}
+ 	refcount_set(&fb_info->count, 1);
+ 	mutex_init(&fb_info->lock);
+ 	mutex_init(&fb_info->mm_lock);
+ 
+ 	fb_info->dev = device_create(fb_class, fb_info->device,
+-				     MKDEV(FB_MAJOR, i), NULL, "fb%d", i);
++				     MKDEV(FB_MAJOR, fb_info->node), NULL, "fb%d", fb_info->node);
+ 	if (IS_ERR(fb_info->dev)) {
+ 		/* Not fatal */
+-		printk(KERN_WARNING "Unable to create device for framebuffer %d; errno = %ld\n", i, PTR_ERR(fb_info->dev));
++		printk(KERN_WARNING "Unable to create device for framebuffer %d; errno = %ld\n",
++		       fb_info->node, PTR_ERR(fb_info->dev));
+ 		fb_info->dev = NULL;
+ 	} else
+ 		fb_init_device(fb_info);
+@@ -1624,7 +1628,7 @@ static int do_register_framebuffer(struc
+ 
+ 	fb_var_to_videomode(&mode, &fb_info->var);
+ 	fb_add_videomode(&mode, &fb_info->modelist);
+-	registered_fb[i] = fb_info;
++	registered_fb[fb_info->node] = fb_info;
+ 
+ #ifdef CONFIG_GUMSTIX_AM200EPD
+ 	{
+@@ -1719,6 +1723,12 @@ static int fb_aperture_acquire_for_platf
+ 	return ret;
+ }
+ 
++void fb_set_lowest_dynamic_fb(int min_fb_dev)
++{
++	min_dynamic_fb = min_fb_dev;
++}
++EXPORT_SYMBOL(fb_set_lowest_dynamic_fb);
++
+ /**
+  *	register_framebuffer - registers a frame buffer device
+  *	@fb_info: frame buffer info structure
+--- a/include/linux/fb.h
++++ b/include/linux/fb.h
+@@ -512,6 +512,7 @@ struct fb_info {
+ 	} *apertures;
+ 
+ 	bool skip_vt_switch; /* no VT switch on suspend/resume required */
++	bool custom_fb_num; /* Use value in node as the preferred node number */
+ };
+ 
+ static inline struct apertures_struct *alloc_apertures(unsigned int max_num) {
+@@ -614,6 +615,7 @@ extern ssize_t fb_sys_write(struct fb_in
+ 			    size_t count, loff_t *ppos);
+ 
+ /* drivers/video/fbmem.c */
++extern void fb_set_lowest_dynamic_fb(int min_fb_dev);
+ extern int register_framebuffer(struct fb_info *fb_info);
+ extern void unregister_framebuffer(struct fb_info *fb_info);
+ extern int fb_prepare_logo(struct fb_info *fb_info, int rotate);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1036-drm-fb-helper-Look-up-preferred-fbdev-node-number-fr.patch b/target/linux/bcm27xx/patches-6.1/950-1036-drm-fb-helper-Look-up-preferred-fbdev-node-number-fr.patch
new file mode 100644
index 0000000000..3e360be77b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1036-drm-fb-helper-Look-up-preferred-fbdev-node-number-fr.patch
@@ -0,0 +1,41 @@
+From 1216ea56c2e30aee4975b4dcce79ebd199afaf8f Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Mon, 9 Oct 2023 16:34:36 +0100
+Subject: [PATCH] drm/fb-helper: Look up preferred fbdev node number from DT
+
+For situations where there are multiple DRM cards in a system,
+add a query of DT for "drm_fb" designations for cards to set
+their preferred /dev/fbN designation.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/drm_fb_helper.c | 11 ++++++++++-
+ 1 file changed, 10 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/drm_fb_helper.c
++++ b/drivers/gpu/drm/drm_fb_helper.c
+@@ -1932,7 +1932,7 @@ __drm_fb_helper_initial_config_and_unloc
+ 	struct drm_device *dev = fb_helper->dev;
+ 	struct fb_info *info;
+ 	unsigned int width, height;
+-	int ret;
++	int ret, id;
+ 
+ 	width = dev->mode_config.max_width;
+ 	height = dev->mode_config.max_height;
+@@ -1967,6 +1967,15 @@ __drm_fb_helper_initial_config_and_unloc
+ 	 * register the fbdev emulation instance in kernel_fb_helper_list. */
+ 	mutex_unlock(&fb_helper->lock);
+ 
++	id = of_alias_get_highest_id("drm_fb");
++	if (id >= 0)
++		fb_set_lowest_dynamic_fb(id + 1);
++
++	id = of_alias_get_id(dev->dev->of_node, "drm_fb");
++	if (id >= 0) {
++		info->node = id;
++		info->custom_fb_num = true;
++	}
+ 	ret = register_framebuffer(info);
+ 	if (ret < 0)
+ 		return ret;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1037-dt-Add-overrides-for-drm-framebuffer-allocations-on-.patch b/target/linux/bcm27xx/patches-6.1/950-1037-dt-Add-overrides-for-drm-framebuffer-allocations-on-.patch
new file mode 100644
index 0000000000..924c1b9f19
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1037-dt-Add-overrides-for-drm-framebuffer-allocations-on-.patch
@@ -0,0 +1,72 @@
+From 61b138adaeaddefe749f421a3b69c67d4a49a8e3 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 11 Oct 2023 11:03:51 +0100
+Subject: [PATCH] dt: Add overrides for drm framebuffer allocations on Pi5
+
+Adds dtparam overrides to the base Pi5 DT such that vc4,
+DSI0, DSI1, or DPI can be requested to be /dev/fb[012].
+No override is specified by default, so the order will be
+based on probe order (aka semi-random). Any device that
+doesn't have an override specified will be placed above
+all specified overrides. Having an fb1 or fb2 override but
+no fb0 one will result in no console via fbcon.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 12 ++++++++++++
+ arch/arm/boot/dts/overlays/README     | 24 ++++++++++++++++++++++++
+ 2 files changed, 36 insertions(+)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -824,5 +824,17 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		act_led_trigger = <&act_led>, "linux,default-trigger";
+ 		pwr_led_activelow = <&pwr_led>, "gpios:8";
+ 		pwr_led_trigger = <&pwr_led>, "linux,default-trigger";
++		drm_fb0_rp1_dsi0 = <&aliases>, "drm_fb0=",&dsi0;
++		drm_fb0_rp1_dsi1 = <&aliases>, "drm_fb0=",&dsi1;
++		drm_fb0_rp1_dpi = <&aliases>, "drm_fb0=",&dpi;
++		drm_fb0_vc4 = <&aliases>, "drm_fb0=",&vc4;
++		drm_fb1_rp1_dsi0 = <&aliases>, "drm_fb1=",&dsi0;
++		drm_fb1_rp1_dsi1 = <&aliases>, "drm_fb1=",&dsi1;
++		drm_fb1_rp1_dpi = <&aliases>, "drm_fb1=",&dpi;
++		drm_fb1_vc4 = <&aliases>, "drm_fb1=",&vc4;
++		drm_fb2_rp1_dsi0 = <&aliases>, "drm_fb2=",&dsi0;
++		drm_fb2_rp1_dsi1 = <&aliases>, "drm_fb2=",&dsi1;
++		drm_fb2_rp1_dpi = <&aliases>, "drm_fb2=",&dpi;
++		drm_fb2_vc4 = <&aliases>, "drm_fb2=",&vc4;
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -173,6 +173,30 @@ Params:
+         cooling_fan             Enables the Pi 5 cooling fan (enabled
+                                 automatically by the firmware)
+ 
++        drm_fb0_rp1_dpi         Assign /dev/fb0 to the RP1 DPI output
++
++        drm_fb0_rp1_dsi0        Assign /dev/fb0 to the RP1 DSI0 output
++
++        drm_fb0_rp1_dsi1        Assign /dev/fb0 to the RP1 DSI1 output
++
++        drm_fb0_vc4             Assign /dev/fb0 to the vc4 outputs
++
++        drm_fb1_rp1_dpi         Assign /dev/fb1 to the RP1 DPI output
++
++        drm_fb1_rp1_dsi0        Assign /dev/fb1 to the RP1 DSI0 output
++
++        drm_fb1_rp1_dsi1        Assign /dev/fb1 to the RP1 DSI1 output
++
++        drm_fb1_vc4             Assign /dev/fb1 to the vc4 outputs
++
++        drm_fb2_rp1_dpi         Assign /dev/fb2 to the RP1 DPI output
++
++        drm_fb2_rp1_dsi0        Assign /dev/fb2 to the RP1 DSI0 output
++
++        drm_fb2_rp1_dsi1        Assign /dev/fb2 to the RP1 DSI1 output
++
++        drm_fb2_vc4             Assign /dev/fb2 to the vc4 outputs
++
+         eee                     Enable Energy Efficient Ethernet support for
+                                 compatible devices (default "on"). See also
+                                 "tx_lpi_timer". Pi3B+ only.
diff --git a/target/linux/bcm27xx/patches-6.1/950-1039-drm-connector-Change-DRM-card-alias-from-underscore-.patch b/target/linux/bcm27xx/patches-6.1/950-1039-drm-connector-Change-DRM-card-alias-from-underscore-.patch
new file mode 100644
index 0000000000..57782d51c3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1039-drm-connector-Change-DRM-card-alias-from-underscore-.patch
@@ -0,0 +1,26 @@
+From f429fc1a072d4bb35e622a1012a5a52914eba4e3 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 19 Oct 2023 10:34:58 +0100
+Subject: [PATCH] drm/connector: Change DRM card alias from underscore to
+ hyphen
+
+Apparently aliases are only allowed lower case and hyphens,
+so swap the use of underscore to hyphen.
+
+Fixes: 3aa1f2477545 ("drm: Look for an alias for the displays to use as the DRM device name")
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/drm_connector.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/drm_connector.c
++++ b/drivers/gpu/drm/drm_connector.c
+@@ -112,7 +112,7 @@ static struct drm_conn_prop_enum_list dr
+ };
+ 
+ #define MAX_DT_NODE_NAME_LEN	20
+-#define DT_DRM_NODE_PREFIX	"drm_"
++#define DT_DRM_NODE_PREFIX	"drm-"
+ 
+ static void drm_connector_get_of_name(int type, char *node_name, int length)
+ {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1040-dt-Alter-alias-names-from-_-to-for-drm_dsiN.patch b/target/linux/bcm27xx/patches-6.1/950-1040-dt-Alter-alias-names-from-_-to-for-drm_dsiN.patch
new file mode 100644
index 0000000000..0536924d05
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1040-dt-Alter-alias-names-from-_-to-for-drm_dsiN.patch
@@ -0,0 +1,24 @@
+From e33170e21494279801e9f17eeb910ec45ebd740c Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 19 Oct 2023 10:28:43 +0100
+Subject: [PATCH] dt: Alter alias names from _ to - for drm_dsiN
+
+Fixes: 7ec42740a45b ("dt: Add DSI1 and DSI2 aliases to 2712")
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -787,8 +787,8 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		gpio4 = &pinctrl_aon;
+ 		usb0 = &rp1_usb0;
+ 		usb1 = &rp1_usb1;
+-		drm_dsi1 = &dsi0;
+-		drm_dsi2 = &dsi1;
++		drm-dsi1 = &dsi0;
++		drm-dsi2 = &dsi1;
+ 	};
+ 
+ 	__overrides__ {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1041-drm-fb_helper-Change-query-for-FB-designation-from-d.patch b/target/linux/bcm27xx/patches-6.1/950-1041-drm-fb_helper-Change-query-for-FB-designation-from-d.patch
new file mode 100644
index 0000000000..78e5b89be4
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1041-drm-fb_helper-Change-query-for-FB-designation-from-d.patch
@@ -0,0 +1,28 @@
+From 0e9e925112fabdbd448e17947796317a6dbca96e Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 19 Oct 2023 10:32:04 +0100
+Subject: [PATCH] drm/fb_helper: Change query for FB designation from drm_fb to
+ drm-fb
+
+Fixes: 1216ea56c2e3 ("drm/fb-helper: Look up preferred fbdev node number from DT")
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/drm_fb_helper.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/drm_fb_helper.c
++++ b/drivers/gpu/drm/drm_fb_helper.c
+@@ -1967,11 +1967,11 @@ __drm_fb_helper_initial_config_and_unloc
+ 	 * register the fbdev emulation instance in kernel_fb_helper_list. */
+ 	mutex_unlock(&fb_helper->lock);
+ 
+-	id = of_alias_get_highest_id("drm_fb");
++	id = of_alias_get_highest_id("drm-fb");
+ 	if (id >= 0)
+ 		fb_set_lowest_dynamic_fb(id + 1);
+ 
+-	id = of_alias_get_id(dev->dev->of_node, "drm_fb");
++	id = of_alias_get_id(dev->dev->of_node, "drm-fb");
+ 	if (id >= 0) {
+ 		info->node = id;
+ 		info->custom_fb_num = true;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1042-dt-Alter-alias-names-from-_-to-for-drm_fbN_-override.patch b/target/linux/bcm27xx/patches-6.1/950-1042-dt-Alter-alias-names-from-_-to-for-drm_fbN_-override.patch
new file mode 100644
index 0000000000..42865dc7ff
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1042-dt-Alter-alias-names-from-_-to-for-drm_fbN_-override.patch
@@ -0,0 +1,43 @@
+From 87be94059193d0bc64d52a9535df4fb1891c72fe Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 19 Oct 2023 10:29:20 +0100
+Subject: [PATCH] dt: Alter alias names from _ to - for drm_fbN_* overrides
+
+Fixes: 61b138adaead ("dt: Add overrides for drm framebuffer allocations on Pi5")
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 24 ++++++++++++------------
+ 1 file changed, 12 insertions(+), 12 deletions(-)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -824,17 +824,17 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		act_led_trigger = <&act_led>, "linux,default-trigger";
+ 		pwr_led_activelow = <&pwr_led>, "gpios:8";
+ 		pwr_led_trigger = <&pwr_led>, "linux,default-trigger";
+-		drm_fb0_rp1_dsi0 = <&aliases>, "drm_fb0=",&dsi0;
+-		drm_fb0_rp1_dsi1 = <&aliases>, "drm_fb0=",&dsi1;
+-		drm_fb0_rp1_dpi = <&aliases>, "drm_fb0=",&dpi;
+-		drm_fb0_vc4 = <&aliases>, "drm_fb0=",&vc4;
+-		drm_fb1_rp1_dsi0 = <&aliases>, "drm_fb1=",&dsi0;
+-		drm_fb1_rp1_dsi1 = <&aliases>, "drm_fb1=",&dsi1;
+-		drm_fb1_rp1_dpi = <&aliases>, "drm_fb1=",&dpi;
+-		drm_fb1_vc4 = <&aliases>, "drm_fb1=",&vc4;
+-		drm_fb2_rp1_dsi0 = <&aliases>, "drm_fb2=",&dsi0;
+-		drm_fb2_rp1_dsi1 = <&aliases>, "drm_fb2=",&dsi1;
+-		drm_fb2_rp1_dpi = <&aliases>, "drm_fb2=",&dpi;
+-		drm_fb2_vc4 = <&aliases>, "drm_fb2=",&vc4;
++		drm_fb0_rp1_dsi0 = <&aliases>, "drm-fb0=",&dsi0;
++		drm_fb0_rp1_dsi1 = <&aliases>, "drm-fb0=",&dsi1;
++		drm_fb0_rp1_dpi = <&aliases>, "drm-fb0=",&dpi;
++		drm_fb0_vc4 = <&aliases>, "drm-fb0=",&vc4;
++		drm_fb1_rp1_dsi0 = <&aliases>, "drm-fb1=",&dsi0;
++		drm_fb1_rp1_dsi1 = <&aliases>, "drm-fb1=",&dsi1;
++		drm_fb1_rp1_dpi = <&aliases>, "drm-fb1=",&dpi;
++		drm_fb1_vc4 = <&aliases>, "drm-fb1=",&vc4;
++		drm_fb2_rp1_dsi0 = <&aliases>, "drm-fb2=",&dsi0;
++		drm_fb2_rp1_dsi1 = <&aliases>, "drm-fb2=",&dsi1;
++		drm_fb2_rp1_dpi = <&aliases>, "drm-fb2=",&dpi;
++		drm_fb2_vc4 = <&aliases>, "drm-fb2=",&vc4;
+ 	};
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-1044-Typo-in-overlays-README.patch b/target/linux/bcm27xx/patches-6.1/950-1044-Typo-in-overlays-README.patch
new file mode 100644
index 0000000000..19720e8645
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1044-Typo-in-overlays-README.patch
@@ -0,0 +1,21 @@
+From cb8a4adb586c5e926e415ac0dae3ffb4af30b0a9 Mon Sep 17 00:00:00 2001
+From: Andrew Scheller <andrew.scheller@raspberrypi.com>
+Date: Thu, 19 Oct 2023 14:13:36 +0100
+Subject: [PATCH] Typo in overlays README
+
+touchscreen-size-y for rpi-ft5406 defaults to 480, not 600
+---
+ arch/arm/boot/dts/overlays/README | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -3738,7 +3738,7 @@ Name:   rpi-ft5406
+ Info:   Official Raspberry Pi display touchscreen
+ Load:   dtoverlay=rpi-ft5406,<param>=<val>
+ Params: touchscreen-size-x      Touchscreen X resolution (default 800)
+-        touchscreen-size-y      Touchscreen Y resolution (default 600);
++        touchscreen-size-y      Touchscreen Y resolution (default 480);
+         touchscreen-inverted-x  Invert touchscreen X coordinates (default 0);
+         touchscreen-inverted-y  Invert touchscreen Y coordinates (default 0);
+         touchscreen-swapped-x-y Swap X and Y cordinates (default 0);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1045-dts-bcm2712-Add-the-krnbt-parameter.patch b/target/linux/bcm27xx/patches-6.1/950-1045-dts-bcm2712-Add-the-krnbt-parameter.patch
new file mode 100644
index 0000000000..95940dd830
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1045-dts-bcm2712-Add-the-krnbt-parameter.patch
@@ -0,0 +1,23 @@
+From 4cb97982f88d8fb623ace5a9511198e442e993ba Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 20 Oct 2023 17:15:25 +0100
+Subject: [PATCH] dts: bcm2712: Add the krnbt parameter
+
+Add a Pi 5 implementation of the krnbt parameter, for symmetry and
+for tinkering purposes.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -809,6 +809,7 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		i2c_baudrate = <&i2c_arm>, "clock-frequency:0";
+ 		i2c_arm_baudrate = <&i2c_arm>, "clock-frequency:0";
+ 		i2c_vc_baudrate = <&i2c_vc>, "clock-frequency:0";
++		krnbt = <&bluetooth>, "status";
+ 		nvme = <&pciex1>, "status";
+ 		pciex1 = <&pciex1>, "status";
+ 		pciex1_gen = <&pciex1> , "max-link-speed:0";
diff --git a/target/linux/bcm27xx/patches-6.1/950-1046-Revert-vc4-fkms-Remove-use-of-SMI-peripheral.patch b/target/linux/bcm27xx/patches-6.1/950-1046-Revert-vc4-fkms-Remove-use-of-SMI-peripheral.patch
new file mode 100644
index 0000000000..2c5df5baec
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1046-Revert-vc4-fkms-Remove-use-of-SMI-peripheral.patch
@@ -0,0 +1,77 @@
+From 93b52ae53a813608026bd2fb3c6b47cca353cd35 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 20 Oct 2023 15:21:34 +0100
+Subject: [PATCH] Revert "vc4/fkms: Remove use of SMI peripheral"
+
+This reverts commit 3fb20da9f3bff93f20b1a1fe2c950c6c8f4d1e1e.
+---
+ drivers/gpu/drm/vc4/vc4_firmware_kms.c | 24 +++++++++++++++++-------
+ 1 file changed, 17 insertions(+), 7 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_firmware_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_firmware_kms.c
+@@ -255,6 +255,13 @@ static const struct vc_image_format *vc4
+ /* The firmware delivers a vblank interrupt to us through the SMI
+  * hardware, which has only this one register.
+  */
++#define SMICS 0x0
++#define SMIDSW0 0x14
++#define SMIDSW1 0x1C
++#define SMICS_INTERRUPTS (BIT(9) | BIT(10) | BIT(11))
++
++/* Flag to denote that the firmware is giving multiple display callbacks */
++#define SMI_NEW 0xabcd0000
+ 
+ #define vc4_crtc vc4_kms_crtc
+ #define to_vc4_crtc to_vc4_kms_crtc
+@@ -1214,13 +1221,16 @@ static irqreturn_t vc4_crtc_irq_handler(
+ {
+ 	struct vc4_crtc **crtc_list = data;
+ 	int i;
++	u32 stat = readl(crtc_list[0]->regs + SMICS);
+ 	irqreturn_t ret = IRQ_NONE;
+ 	u32 chan;
+-	if (1) {
+ 
+-		chan = 0;
++	if (stat & SMICS_INTERRUPTS) {
++		writel(0, crtc_list[0]->regs + SMICS);
++
++		chan = readl(crtc_list[0]->regs + SMIDSW0);
+ 
+-		if (1) {
++		if ((chan & 0xFFFF0000) != SMI_NEW) {
+ 			/* Older firmware. Treat the one interrupt as vblank/
+ 			 * complete for all crtcs.
+ 			 */
+@@ -1231,7 +1241,7 @@ static irqreturn_t vc4_crtc_irq_handler(
+ 			}
+ 		} else {
+ 			if (chan & 1) {
+-				//writel(SMI_NEW, crtc_list[0]->regs + SMIDSW0);
++				writel(SMI_NEW, crtc_list[0]->regs + SMIDSW0);
+ 				if (crtc_list[0]->vblank_enabled)
+ 					drm_crtc_handle_vblank(&crtc_list[0]->base);
+ 				vc4_crtc_handle_page_flip(crtc_list[0]);
+@@ -1239,10 +1249,10 @@ static irqreturn_t vc4_crtc_irq_handler(
+ 
+ 			if (crtc_list[1]) {
+ 				/* Check for the secondary display too */
+-				//chan = readl(crtc_list[0]->regs + SMIDSW1);
++				chan = readl(crtc_list[0]->regs + SMIDSW1);
+ 
+ 				if (chan & 1) {
+-					//writel(SMI_NEW, crtc_list[0]->regs + SMIDSW1);
++					writel(SMI_NEW, crtc_list[0]->regs + SMIDSW1);
+ 
+ 					if (crtc_list[1]->vblank_enabled)
+ 						drm_crtc_handle_vblank(&crtc_list[1]->base);
+@@ -1982,7 +1992,7 @@ static int vc4_fkms_bind(struct device *
+ 		if (IS_ERR(crtc_list[0]->regs))
+ 			DRM_ERROR("Oh dear, failed to map registers\n");
+ 
+-		//writel(0, crtc_list[0]->regs + SMICS);
++		writel(0, crtc_list[0]->regs + SMICS);
+ 		ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
+ 				       vc4_crtc_irq_handler, 0,
+ 				       "vc4 firmware kms", crtc_list);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1047-drm-vc4_fkms-Fix-up-interrupt-handler-for-both-2835-.patch b/target/linux/bcm27xx/patches-6.1/950-1047-drm-vc4_fkms-Fix-up-interrupt-handler-for-both-2835-.patch
new file mode 100644
index 0000000000..99b8426e1c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1047-drm-vc4_fkms-Fix-up-interrupt-handler-for-both-2835-.patch
@@ -0,0 +1,109 @@
+From 4137b49989ce710305e476d0bd1086d7d906ff50 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 20 Oct 2023 17:09:54 +0100
+Subject: [PATCH] drm/vc4_fkms: Fix up interrupt handler for both 2835/2711 and
+ 2712
+
+2712 has switched from using the SMI peripheral to another interrupt
+source for the vsync interrupt, so handle both sources cleanly.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_firmware_kms.c | 48 ++++++++++++++++++++------
+ 1 file changed, 38 insertions(+), 10 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_firmware_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_firmware_kms.c
+@@ -47,9 +47,15 @@ struct get_display_cfg {
+ 	u32  max_pixel_clock[2];  //Max pixel clock for each display
+ };
+ 
++enum vc4_fkms_revision {
++	BCM2835_6_7,
++	BCM2711,
++	BCM2712,
++};
++
+ struct vc4_fkms {
+ 	struct get_display_cfg cfg;
+-	bool bcm2711;
++	enum vc4_fkms_revision revision;
+ };
+ 
+ #define PLANES_PER_CRTC		8
+@@ -1149,7 +1155,7 @@ vc4_crtc_mode_valid(struct drm_crtc *crt
+ 	/* Pi4 can't generate odd horizontal timings on HDMI, so reject modes
+ 	 * that would set them.
+ 	 */
+-	if (fkms->bcm2711 &&
++	if (fkms->revision >= BCM2711 &&
+ 	    (vc4_crtc->display_number == 2 || vc4_crtc->display_number == 7) &&
+ 	    !(mode->flags & DRM_MODE_FLAG_DBLCLK) &&
+ 	    ((mode->hdisplay |				/* active */
+@@ -1267,6 +1273,20 @@ static irqreturn_t vc4_crtc_irq_handler(
+ 	return ret;
+ }
+ 
++static irqreturn_t vc4_crtc2712_irq_handler(int irq, void *data)
++{
++	struct vc4_crtc **crtc_list = data;
++	int i;
++
++	for (i = 0; crtc_list[i]; i++) {
++		if (crtc_list[i]->vblank_enabled)
++			drm_crtc_handle_vblank(&crtc_list[i]->base);
++		vc4_crtc_handle_page_flip(crtc_list[i]);
++	}
++
++	return IRQ_HANDLED;
++}
++
+ static int vc4_fkms_page_flip(struct drm_crtc *crtc,
+ 			      struct drm_framebuffer *fb,
+ 			      struct drm_pending_vblank_event *event,
+@@ -1352,9 +1372,12 @@ static const struct drm_crtc_helper_func
+ };
+ 
+ static const struct of_device_id vc4_firmware_kms_dt_match[] = {
+-	{ .compatible = "raspberrypi,rpi-firmware-kms" },
++	{ .compatible = "raspberrypi,rpi-firmware-kms",
++	  .data = (void *)BCM2835_6_7 },
+ 	{ .compatible = "raspberrypi,rpi-firmware-kms-2711",
+-	  .data = (void *)1 },
++	  .data = (void *)BCM2711 },
++	{ .compatible = "raspberrypi,rpi-firmware-kms-2712",
++	  .data = (void *)BCM2712 },
+ 	{}
+ };
+ 
+@@ -1924,8 +1947,7 @@ static int vc4_fkms_bind(struct device *
+ 	match = of_match_device(vc4_firmware_kms_dt_match, dev);
+ 	if (!match)
+ 		return -ENODEV;
+-	if (match->data)
+-		fkms->bcm2711 = true;
++	fkms->revision = (enum vc4_fkms_revision)match->data;
+ 
+ 	firmware_node = of_parse_phandle(dev->of_node, "brcm,firmware", 0);
+ 	vc4->firmware = devm_rpi_firmware_get(&pdev->dev, firmware_node);
+@@ -1992,10 +2014,16 @@ static int vc4_fkms_bind(struct device *
+ 		if (IS_ERR(crtc_list[0]->regs))
+ 			DRM_ERROR("Oh dear, failed to map registers\n");
+ 
+-		writel(0, crtc_list[0]->regs + SMICS);
+-		ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
+-				       vc4_crtc_irq_handler, 0,
+-				       "vc4 firmware kms", crtc_list);
++		if (fkms->revision >= BCM2712) {
++			ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
++					       vc4_crtc2712_irq_handler, 0,
++					       "vc4 firmware kms", crtc_list);
++		} else {
++			writel(0, crtc_list[0]->regs + SMICS);
++			ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
++					       vc4_crtc_irq_handler, 0,
++					       "vc4 firmware kms", crtc_list);
++		}
+ 		if (ret)
+ 			DRM_ERROR("Oh dear, failed to register IRQ\n");
+ 	} else {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1048-dt-Switch-bcm2712-firmware-kms-node-to-using-the-271.patch b/target/linux/bcm27xx/patches-6.1/950-1048-dt-Switch-bcm2712-firmware-kms-node-to-using-the-271.patch
new file mode 100644
index 0000000000..9dea2d0fff
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1048-dt-Switch-bcm2712-firmware-kms-node-to-using-the-271.patch
@@ -0,0 +1,25 @@
+From 5a52cae54a05499a8487f392cf5dfc3d8a837e6f Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 20 Oct 2023 17:12:09 +0100
+Subject: [PATCH] dt: Switch bcm2712 firmware-kms node to using the 2712
+ compatible
+
+With the new compatible to handle the interrupts correctly, switch
+the base dt to use it.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712.dtsi | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/bcm2712.dtsi
++++ b/arch/arm/boot/dts/bcm2712.dtsi
+@@ -103,7 +103,7 @@
+ 		};
+ 
+ 		firmwarekms: firmwarekms@7d503000 {
+-			compatible = "raspberrypi,rpi-firmware-kms";
++			compatible = "raspberrypi,rpi-firmware-kms-2712";
+ 			/* SUN_L2 interrupt reg */
+ 			reg = <0x7d503000 0x18>;
+ 			interrupt-parent = <&cpu_l2_irq>;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1049-drivers-media-imx477-Disable-the-scaler.patch b/target/linux/bcm27xx/patches-6.1/950-1049-drivers-media-imx477-Disable-the-scaler.patch
new file mode 100644
index 0000000000..841fa42440
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1049-drivers-media-imx477-Disable-the-scaler.patch
@@ -0,0 +1,35 @@
+From f075893e9b0e241879998c0b12cf8af0ba7737da Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Mon, 23 Oct 2023 10:03:03 +0100
+Subject: [PATCH] drivers: media: imx477: Disable the scaler
+
+The horizontal scaler was enabled for the 2028x1520 and 2028x1080 modes,
+with a scale factor of 1. It caused a single column of bad pixels on the
+right edge of the image. Since scaling is not needed for these modes,
+disable it entirely.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/i2c/imx477.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/media/i2c/imx477.c
++++ b/drivers/media/i2c/imx477.c
+@@ -632,7 +632,7 @@ static const struct imx477_reg mode_2028
+ 	{0x9e9f, 0x00},
+ 	{0xa2a9, 0x60},
+ 	{0xa2b7, 0x00},
+-	{0x0401, 0x01},
++	{0x0401, 0x00},
+ 	{0x0404, 0x00},
+ 	{0x0405, 0x20},
+ 	{0x0408, 0x00},
+@@ -733,7 +733,7 @@ static const struct imx477_reg mode_2028
+ 	{0x9e9f, 0x00},
+ 	{0xa2a9, 0x60},
+ 	{0xa2b7, 0x00},
+-	{0x0401, 0x01},
++	{0x0401, 0x00},
+ 	{0x0404, 0x00},
+ 	{0x0405, 0x20},
+ 	{0x0408, 0x00},
diff --git a/target/linux/bcm27xx/patches-6.1/950-1050-dt-Add-drm_fbN_vc4-overrides-for-Pi0-4.patch b/target/linux/bcm27xx/patches-6.1/950-1050-dt-Add-drm_fbN_vc4-overrides-for-Pi0-4.patch
new file mode 100644
index 0000000000..77f30a345d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1050-dt-Add-drm_fbN_vc4-overrides-for-Pi0-4.patch
@@ -0,0 +1,37 @@
+From eccaa8588fca9c9ec950664f1d5894bd826b57b0 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Mon, 23 Oct 2023 14:10:15 +0100
+Subject: [PATCH] dt: Add drm_fbN_vc4 overrides for Pi0-4
+
+Follows up '61b138adaead ("dt: Add overrides for drm framebuffer
+allocations on Pi5")' with an equivalent for Pi0-4.
+
+These will have no effect on most normal systems, but drm_fb0_vc4
+will stop SPI displays jumping in and claiming /dev/fb0.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm270x-rpi.dtsi | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/bcm270x-rpi.dtsi
++++ b/arch/arm/boot/dts/bcm270x-rpi.dtsi
+@@ -1,7 +1,7 @@
+ /* Downstream modifications to bcm2835-rpi.dtsi */
+ 
+ / {
+-	aliases {
++	aliases: aliases {
+ 		aux = &aux;
+ 		sound = &sound;
+ 		soc = &soc;
+@@ -98,6 +98,9 @@
+ 		sdio_overclock = <&mmc>,"brcm,overclock-50:0",
+ 				 <&mmcnr>,"brcm,overclock-50:0";
+ 		axiperf      = <&axiperf>,"status";
++		drm_fb0_vc4 = <&aliases>, "drm-fb0=",&vc4;
++		drm_fb1_vc4 = <&aliases>, "drm-fb1=",&vc4;
++		drm_fb2_vc4 = <&aliases>, "drm-fb2=",&vc4;
+ 	};
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1051-fixup-overlays-mcp23017-allow-specification-of-the-i.patch b/target/linux/bcm27xx/patches-6.1/950-1051-fixup-overlays-mcp23017-allow-specification-of-the-i.patch
new file mode 100644
index 0000000000..5016e78778
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1051-fixup-overlays-mcp23017-allow-specification-of-the-i.patch
@@ -0,0 +1,95 @@
+From 3ed6d34d53e94ecbebc64c8fa3d1b6d3c41db8fb Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 24 Oct 2023 09:58:52 +0100
+Subject: [PATCH] fixup! overlays: mcp23017: allow specification of the i2c bus
+
+The incorrect fragment order (*) caused broke the interrupt usage, and
+while it was being fixed the lack of a reference to the pinctrl
+declaration was noticed.
+
+See: https://github.com/raspberrypi/linux/issues/5677
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+
+(*) Ideally all fragments would appear in the file in the order in which
+they should be merged, but that is easy to forget and can be awkward, so
+the firmware merges all "intra" fragments (those that target other
+fragments in the overlay) before "inter" fragments (those that target
+the base DTB). However, intra fragments that target other intra
+fragments is a level of nesting too far for this logic to cope, so they
+must appear before the fragments they target.
+---
+ .../boot/dts/overlays/mcp23017-overlay.dts    | 42 ++++++++++---------
+ 1 file changed, 22 insertions(+), 20 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/mcp23017-overlay.dts
++++ b/arch/arm/boot/dts/overlays/mcp23017-overlay.dts
+@@ -24,30 +24,13 @@
+ 	};
+ 
+ 	fragment@2 {
+-		target = <&i2cbus>;
+-		__overlay__ {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-
+-			mcp23017: mcp@20 {
+-				compatible = "microchip,mcp23017";
+-				reg = <0x20>;
+-				gpio-controller;
+-				#gpio-cells = <2>;
+-
+-				status = "okay";
+-			};
+-		};
+-	};
+-
+-	fragment@3 {
+ 		target = <&mcp23017>;
+ 		__dormant__ {
+ 			compatible = "microchip,mcp23008";
+ 		};
+ 	};
+ 
+-	fragment@4 {
++	fragment@3 {
+ 		target = <&mcp23017>;
+ 		mcp23017_irq: __overlay__ {
+ 			#interrupt-cells=<2>;
+@@ -58,6 +41,25 @@
+ 		};
+ 	};
+ 
++	fragment@4 {
++		target = <&i2cbus>;
++		__overlay__ {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			mcp23017: mcp@20 {
++				compatible = "microchip,mcp23017";
++				pinctrl-name = "default";
++				pinctrl-0 = <&mcp23017_pins>;
++				reg = <0x20>;
++				gpio-controller;
++				#gpio-cells = <2>;
++
++				status = "okay";
++			};
++		};
++	};
++
+ 	frag100: fragment@100 {
+ 		target = <&i2c1>;
+ 		i2cbus: __overlay__ {
+@@ -83,8 +85,8 @@
+ 		gpiopin = <&mcp23017_pins>,"brcm,pins:0",
+ 				<&mcp23017_irq>,"interrupts:0";
+ 		addr = <&mcp23017>,"reg:0", <&mcp23017_pins>,"reg:0";
+-		mcp23008 = <0>,"=3";
+-		noints = <0>,"!1!4";
++		mcp23008 = <0>,"=2";
++		noints = <0>,"!1!3";
+ 		i2c0 = <&frag100>, "target:0=",<&i2c0>;
+ 		i2c_csi_dsi = <&frag100>, "target:0=",<&i2c_csi_dsi>,
+ 			      <0>,"+101+102";
diff --git a/target/linux/bcm27xx/patches-6.1/950-1052-drivers-media-pisp_be-Add-back-V4L2_PIX_FMT_RPI_BE-f.patch b/target/linux/bcm27xx/patches-6.1/950-1052-drivers-media-pisp_be-Add-back-V4L2_PIX_FMT_RPI_BE-f.patch
new file mode 100644
index 0000000000..7fe0c50740
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1052-drivers-media-pisp_be-Add-back-V4L2_PIX_FMT_RPI_BE-f.patch
@@ -0,0 +1,54 @@
+From 8d53cc5b4b2a6f9baed7a0aa801a39ad9dce9bf8 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Thu, 26 Oct 2023 08:55:24 +0100
+Subject: [PATCH] drivers: media: pisp_be: Add back V4L2_PIX_FMT_RPI_BE format
+
+Add the opaque V4L2_PIX_FMT_RPI_BE format back to the format list as it
+is needed for the verification test suite. Also set the default format
+to YUV420 non-multiplanar.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/platform/raspberrypi/pisp_be/pisp_be.c     | 9 ++++++---
+ .../media/platform/raspberrypi/pisp_be/pisp_be_formats.h | 5 +++++
+ 2 files changed, 11 insertions(+), 3 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/pisp_be/pisp_be.c
++++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be.c
+@@ -1230,8 +1230,11 @@ static int try_format(struct v4l2_format
+ 		return verify_be_pix_format(f, node);
+ 
+ 	fmt = find_format(pixfmt);
+-	if (!fmt)
+-		fmt = find_format(V4L2_PIX_FMT_YUV420M);
++	if (!fmt) {
++		dev_dbg(pispbe->dev, "%s: [%s] Format not found, defaulting to YUV420\n",
++			__func__, NODE_NAME(node));
++		fmt = find_format(V4L2_PIX_FMT_YUV420);
++	}
+ 
+ 	f->fmt.pix_mp.pixelformat = fmt->fourcc;
+ 	f->fmt.pix_mp.num_planes = fmt->num_planes;
+@@ -1576,7 +1579,7 @@ static void node_set_default_format(stru
+ 	} else {
+ 		struct v4l2_format f = {0};
+ 
+-		f.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420M;
++		f.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420;
+ 		f.fmt.pix_mp.width = 1920;
+ 		f.fmt.pix_mp.height = 1080;
+ 		f.type = node->buf_type;
+--- a/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
++++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
+@@ -457,6 +457,11 @@ static const struct pisp_be_format suppo
+ 		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
+ 		.colorspace_default = V4L2_COLORSPACE_RAW,
+ 	},
++	/* Opaque BE format for HW verification. */
++	{
++		.fourcc		    = V4L2_PIX_FMT_RPI_BE,
++		.align		    = 32,
++	},
+ };
+ 
+ static const struct pisp_be_format meta_out_supported_formats[] = {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1053-dt-bindings-PCI-brcmstb-add-optional-property-brcm-t.patch b/target/linux/bcm27xx/patches-6.1/950-1053-dt-bindings-PCI-brcmstb-add-optional-property-brcm-t.patch
new file mode 100644
index 0000000000..3ef42e7967
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1053-dt-bindings-PCI-brcmstb-add-optional-property-brcm-t.patch
@@ -0,0 +1,32 @@
+From f1154884295a4bd00d6ebcaf01fa30141145903d Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Wed, 20 Sep 2023 10:04:15 +0100
+Subject: [PATCH] dt-bindings: PCI: brcmstb: add optional property -
+ "brcm,tperst-clk-ms"
+
+This property can be used to delay deassertion of external fundamental
+reset, which may be useful for endpoints that require an extended time for
+internal setup to complete.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ Documentation/devicetree/bindings/pci/brcm,stb-pcie.yaml | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/Documentation/devicetree/bindings/pci/brcm,stb-pcie.yaml
++++ b/Documentation/devicetree/bindings/pci/brcm,stb-pcie.yaml
+@@ -77,6 +77,14 @@ properties:
+       minItems: 1
+       maxItems: 3
+ 
++  brcm,tperst-clk-ms:
++    category: optional
++    type: int
++    description: u32 giving the number of milliseconds to extend
++      the time between internal release of fundamental reset and
++      the deassertion of the external PERST# pin. This has the
++      effect of increasing the Tperst_clk phase of link init.
++
+ required:
+   - compatible
+   - reg
diff --git a/target/linux/bcm27xx/patches-6.1/950-1054-drivers-pci-brcmstb-optionally-extend-Tperst_clk-tim.patch b/target/linux/bcm27xx/patches-6.1/950-1054-drivers-pci-brcmstb-optionally-extend-Tperst_clk-tim.patch
new file mode 100644
index 0000000000..021e210591
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1054-drivers-pci-brcmstb-optionally-extend-Tperst_clk-tim.patch
@@ -0,0 +1,71 @@
+From 4b0c6453808a662869a43c504913f3b7ed64486a Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Wed, 20 Sep 2023 13:01:11 +0100
+Subject: [PATCH] drivers: pci: brcmstb: optionally extend Tperst_clk time
+ during link-up
+
+The RC has a feature that allows for manual control over the deassertion
+of the PERST# output pin, which allows the time between refclk active
+and reset deassert at the EP to be increased.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/pci/controller/pcie-brcmstb.c | 24 +++++++++++++++++++++++-
+ 1 file changed, 23 insertions(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/pcie-brcmstb.c
++++ b/drivers/pci/controller/pcie-brcmstb.c
+@@ -138,6 +138,7 @@
+ 
+ #define PCIE_MISC_HARD_PCIE_HARD_DEBUG	pcie->reg_offsets[PCIE_HARD_DEBUG]
+ #define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_DEBUG_ENABLE_MASK	0x2
++#define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_PERST_ASSERT_MASK		0x8
+ #define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK		0x08000000
+ #define  PCIE_BMIPS_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK		0x00800000
+ #define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_L1SS_ENABLE_MASK		0x00200000
+@@ -352,6 +353,7 @@ struct brcm_pcie {
+ 	bool			(*rc_mode)(struct brcm_pcie *pcie);
+ 	struct subdev_regulators *sr;
+ 	bool			ep_wakeup_capable;
++	u32			tperst_clk_ms;
+ };
+ 
+ static inline bool is_bmips(const struct brcm_pcie *pcie)
+@@ -1388,9 +1390,28 @@ static int brcm_pcie_start_link(struct b
+ 	u16 nlw, cls, lnksta;
+ 	bool ssc_good = false;
+ 	int ret, i;
++	u32 tmp;
+ 
+ 	/* Unassert the fundamental reset */
+-	pcie->perst_set(pcie, 0);
++	if (pcie->tperst_clk_ms) {
++		/*
++		 * Increase Tperst_clk time by forcing PERST# output low while
++		 * the internal reset is released, so the PLL generates stable
++		 * refclk output further in advance of PERST# deassertion.
++		 */
++		tmp = readl(base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
++		u32p_replace_bits(&tmp, 1, PCIE_MISC_HARD_PCIE_HARD_DEBUG_PERST_ASSERT_MASK);
++		writel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
++
++		pcie->perst_set(pcie, 0);
++		msleep(pcie->tperst_clk_ms);
++
++		tmp = readl(base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
++		u32p_replace_bits(&tmp, 0, PCIE_MISC_HARD_PCIE_HARD_DEBUG_PERST_ASSERT_MASK);
++		writel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);
++	} else {
++		pcie->perst_set(pcie, 0);
++	}
+ 
+ 	/*
+ 	 * Wait for 100ms after PERST# deassertion; see PCIe CEM specification
+@@ -1923,6 +1944,7 @@ static int brcm_pcie_probe(struct platfo
+ 	pcie->ssc = of_property_read_bool(np, "brcm,enable-ssc");
+ 	pcie->l1ss = of_property_read_bool(np, "brcm,enable-l1ss");
+ 	pcie->rcb_mps_mode = of_property_read_bool(np, "brcm,enable-mps-rcb");
++	of_property_read_u32(np, "brcm,tperst-clk-ms", &pcie->tperst_clk_ms);
+ 
+ 	ret = clk_prepare_enable(pcie->clk);
+ 	if (ret) {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1055-arm-dt-add-dtparams-for-PCIe-reset-timing-override.patch b/target/linux/bcm27xx/patches-6.1/950-1055-arm-dt-add-dtparams-for-PCIe-reset-timing-override.patch
new file mode 100644
index 0000000000..a81d0383ac
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1055-arm-dt-add-dtparams-for-PCIe-reset-timing-override.patch
@@ -0,0 +1,59 @@
+From db90a5e5fc2fbd843b29eb8110ed5e03604a2887 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Wed, 20 Sep 2023 13:04:54 +0100
+Subject: [PATCH] arm: dt: add dtparams for PCIe reset timing override
+
+The Pi 5 variant gets two parameters so that the CM4-compatible
+name will also work on Pi 5.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2711-rpi-cm4.dts | 2 ++
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 2 ++
+ arch/arm/boot/dts/overlays/README     | 7 +++++++
+ 3 files changed, 11 insertions(+)
+
+--- a/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
++++ b/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
+@@ -446,5 +446,7 @@ i2c_csi_dsi0: &i2c0 {
+ 		cam1_reg = <&cam1_reg>,"status";
+ 		cam1_reg_gpio = <&cam1_reg>,"gpio:4",
+ 				  <&cam1_reg>,"gpio:0=", <&gpio>;
++
++		pcie_tperst_clk_ms = <&pcie0>,"brcm,tperst-clk-ms:0";
+ 	};
+ };
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -814,6 +814,8 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		pciex1 = <&pciex1>, "status";
+ 		pciex1_gen = <&pciex1> , "max-link-speed:0";
+ 		pciex1_no_l0s = <&pciex1>, "aspm-no-l0s?";
++		pciex1_tperst_clk_ms = <&pciex1>, "brcm,tperst-clk-ms:0";
++		pcie_tperst_clk_ms = <&pciex1>, "brcm,tperst-clk-ms:0";
+ 		random = <&random>, "status";
+ 		rtc_bbat_vchg = <&rpi_rtc>, "trickle-charge-microvolt:0";
+ 		spi = <&spi0>, "status";
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -280,6 +280,10 @@ Params:
+                                 (2711 only, but not applicable on CM4S)
+                                 N.B. USB-A ports on 4B are subsequently disabled
+ 
++        pcie_tperst_clk_ms      Add N milliseconds between PCIe reference clock
++                                activation and PERST# deassertion
++                                (CM4 and 2712, default "0")
++
+         pciex1                  Set to "on" to enable the external PCIe link
+                                 (2712 only, default "off")
+ 
+@@ -290,6 +294,9 @@ Params:
+                                 PCIe link for devices that have broken
+                                 implementations (2712 only, default "off")
+ 
++        pciex1_tperst_clk_ms    Alias for pcie_tperst_clk_ms
++                                (2712 only, default "0")
++
+         spi                     Set to "on" to enable the spi interfaces
+                                 (default "off")
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1056-arm-dt-bcm2712-don-t-unconditionally-enable-MPS-read.patch b/target/linux/bcm27xx/patches-6.1/950-1056-arm-dt-bcm2712-don-t-unconditionally-enable-MPS-read.patch
new file mode 100644
index 0000000000..b08a5720d5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1056-arm-dt-bcm2712-don-t-unconditionally-enable-MPS-read.patch
@@ -0,0 +1,35 @@
+From cb013b6602de32c647ed08faf899596664a18635 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Thu, 26 Oct 2023 13:47:54 +0100
+Subject: [PATCH] arm: dt: bcm2712: don't unconditionally enable MPS read
+ completions
+
+RP1 supports it, but it's not a given that an arbitrary EP device
+on PCIE2 will. Migrate the property to the rp1_target fragment.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 1 +
+ arch/arm/boot/dts/bcm2712.dtsi        | 1 -
+ 2 files changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -160,6 +160,7 @@
+ };
+ 
+ rp1_target: &pcie2 {
++	brcm,enable-mps-rcb;
+ 	brcm,vdm-qos-map = <0xbbaa9888>;
+ 	aspm-no-l0s;
+ 	status = "okay";
+--- a/arch/arm/boot/dts/bcm2712.dtsi
++++ b/arch/arm/boot/dts/bcm2712.dtsi
+@@ -1086,7 +1086,6 @@
+ 				      0x00 0x00000000
+ 				      0x10 0x00000000>;
+ 
+-			brcm,enable-mps-rcb;
+ 			brcm,enable-l1ss;
+ 			status = "disabled";
+ 		};
diff --git a/target/linux/bcm27xx/patches-6.1/950-1057-drivers-media-imx477-Set-horizontal-binning-when-dis.patch b/target/linux/bcm27xx/patches-6.1/950-1057-drivers-media-imx477-Set-horizontal-binning-when-dis.patch
new file mode 100644
index 0000000000..e6122e1a6b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1057-drivers-media-imx477-Set-horizontal-binning-when-dis.patch
@@ -0,0 +1,39 @@
+From 8dcc16f0adc50f5cb8a11a6dde238131d0ca45a0 Mon Sep 17 00:00:00 2001
+From: David Plowman <david.plowman@raspberrypi.com>
+Date: Fri, 27 Oct 2023 12:14:22 +0100
+Subject: [PATCH] drivers: media: imx477: Set horizontal binning when disabling
+ the scaler
+
+The horizontal scaler has been disabled but actually the sensor is not
+binning horizontally, resulting in images that are stretched 2x
+horizontally (missing the right half of the field of view completely).
+
+Therefore we must additionally set the horizontal binning mode. There
+is only marginal change in output quality and noise levels.
+
+Signed-off-by: David Plowman <david.plowman@raspberrypi.com>
+Fixes: f075893e9b0e ("drivers: media: imx477: Disable the scaler")
+---
+ drivers/media/i2c/imx477.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/media/i2c/imx477.c
++++ b/drivers/media/i2c/imx477.c
+@@ -607,7 +607,7 @@ static const struct imx477_reg mode_2028
+ 	{0x0385, 0x01},
+ 	{0x0387, 0x01},
+ 	{0x0900, 0x01},
+-	{0x0901, 0x12},
++	{0x0901, 0x22},
+ 	{0x0902, 0x02},
+ 	{0x3140, 0x02},
+ 	{0x3c00, 0x00},
+@@ -708,7 +708,7 @@ static const struct imx477_reg mode_2028
+ 	{0x0385, 0x01},
+ 	{0x0387, 0x01},
+ 	{0x0900, 0x01},
+-	{0x0901, 0x12},
++	{0x0901, 0x22},
+ 	{0x0902, 0x02},
+ 	{0x3140, 0x02},
+ 	{0x3c00, 0x00},
diff --git a/target/linux/bcm27xx/patches-6.1/950-1058-fixup-arch-arm64-Add-Revision-Serial-Model-to-cpuinf.patch b/target/linux/bcm27xx/patches-6.1/950-1058-fixup-arch-arm64-Add-Revision-Serial-Model-to-cpuinf.patch
new file mode 100644
index 0000000000..adedaf6d4b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1058-fixup-arch-arm64-Add-Revision-Serial-Model-to-cpuinf.patch
@@ -0,0 +1,25 @@
+From e641fd7a50987ad6b7ce1ab36189bc8817295e42 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 31 Oct 2023 16:34:56 +0000
+Subject: [PATCH] fixup! arch/arm64: Add Revision, Serial, Model to cpuinfo
+
+Delete the Hardware string, which is pointless and misleading.
+
+See: https://github.com/raspberrypi/bookworm-feedback/issues/129
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm64/kernel/cpuinfo.c | 2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/arch/arm64/kernel/cpuinfo.c
++++ b/arch/arm64/kernel/cpuinfo.c
+@@ -224,8 +224,6 @@ static int c_show(struct seq_file *m, vo
+ 		seq_printf(m, "CPU revision\t: %d\n\n", MIDR_REVISION(midr));
+ 	}
+ 
+-	seq_printf(m, "Hardware\t: BCM2835\n");
+-
+ 	np = of_find_node_by_path("/system");
+ 	if (np) {
+ 		if (!of_property_read_u32(np, "linux,revision", &revision))
diff --git a/target/linux/bcm27xx/patches-6.1/950-1060-dts-bcm2710-rpi-zero-2-w-Remove-WLAN-firmwares.patch b/target/linux/bcm27xx/patches-6.1/950-1060-dts-bcm2710-rpi-zero-2-w-Remove-WLAN-firmwares.patch
new file mode 100644
index 0000000000..18c12cd10f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1060-dts-bcm2710-rpi-zero-2-w-Remove-WLAN-firmwares.patch
@@ -0,0 +1,35 @@
+From e86c43b86179fba90a1d9dd5acb554767af6740f Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 12 Jun 2023 15:23:55 +0100
+Subject: [PATCH] dts: bcm2710-rpi-zero-2-w: Remove WLAN firmwares
+
+With careful use of qualified firmware names there is no need for the
+ability to override the device names based on Device Tree properties.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2710-rpi-zero-2-w.dts | 13 -------------
+ 1 file changed, 13 deletions(-)
+
+--- a/arch/arm/boot/dts/bcm2710-rpi-zero-2-w.dts
++++ b/arch/arm/boot/dts/bcm2710-rpi-zero-2-w.dts
+@@ -161,19 +161,6 @@
+ 	brcmf: wifi@1 {
+ 		reg = <1>;
+ 		compatible = "brcm,bcm4329-fmac";
+-
+-		firmwares {
+-			fw_43436p {
+-				chipid = <43430>;
+-				revmask = <4>;
+-				fw_base = "brcm/brcmfmac43436-sdio";
+-			};
+-			fw_43436s {
+-				chipid = <43430>;
+-				revmask = <2>;
+-				fw_base = "brcm/brcmfmac43436s-sdio";
+-			};
+-		};
+ 	};
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1061-drivers-media-cfe-Set-the-CSI-2-link-frequency-corre.patch b/target/linux/bcm27xx/patches-6.1/950-1061-drivers-media-cfe-Set-the-CSI-2-link-frequency-corre.patch
new file mode 100644
index 0000000000..d5aeae5333
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1061-drivers-media-cfe-Set-the-CSI-2-link-frequency-corre.patch
@@ -0,0 +1,111 @@
+From a11312709f46b71bf320a9dcc8cf4e09056552cd Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Wed, 1 Nov 2023 13:25:54 +0000
+Subject: [PATCH] drivers: media: cfe: Set the CSI-2 link frequency correctly
+
+Use the sensor provided link frequency to set the DPHY timing parameters
+on stream_on. This replaces the hard-coded 999 MHz value currently being
+used. As a fallback, revert to the original 999 Mhz link frequency.
+
+As a drive-by, fix a 80-character line formatting error.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 63 +++++++++++++++++--
+ 1 file changed, 58 insertions(+), 5 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -780,7 +780,8 @@ static void cfe_start_channel(struct cfe
+ 			__func__, node_desc[FE_OUT0].name,
+ 			cfe->fe_csi2_channel);
+ 
+-		source_fmt = v4l2_subdev_get_pad_format(&cfe->csi2.sd, state, cfe->fe_csi2_channel);
++		source_fmt = v4l2_subdev_get_pad_format(&cfe->csi2.sd, state,
++							cfe->fe_csi2_channel);
+ 		fmt = find_format_by_code(source_fmt->code);
+ 
+ 		width = source_fmt->width;
+@@ -982,6 +983,59 @@ static void cfe_buffer_queue(struct vb2_
+ 	spin_unlock_irqrestore(&cfe->state_lock, flags);
+ }
+ 
++static u64 sensor_link_frequency(struct cfe_device *cfe)
++{
++	struct v4l2_mbus_framefmt *source_fmt;
++	struct v4l2_subdev_state *state;
++	struct media_entity *entity;
++	struct v4l2_subdev *subdev;
++	const struct cfe_fmt *fmt;
++	struct media_pad *pad;
++	s64 link_freq;
++
++	state = v4l2_subdev_lock_and_get_active_state(&cfe->csi2.sd);
++	source_fmt = v4l2_subdev_get_pad_format(&cfe->csi2.sd, state, 0);
++	fmt = find_format_by_code(source_fmt->code);
++	v4l2_subdev_unlock_state(state);
++
++	/*
++	 * Walk up the media graph to find either the sensor entity, or another
++	 * entity that advertises the V4L2_CID_LINK_FREQ or V4L2_CID_PIXEL_RATE
++	 * control through the subdev.
++	 */
++	entity = &cfe->csi2.sd.entity;
++	while (1) {
++		pad = &entity->pads[0];
++		if (!(pad->flags & MEDIA_PAD_FL_SINK))
++			goto err;
++
++		pad = media_pad_remote_pad_first(pad);
++		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
++			goto err;
++
++		entity = pad->entity;
++		subdev = media_entity_to_v4l2_subdev(entity);
++		if (entity->function == MEDIA_ENT_F_CAM_SENSOR ||
++		    v4l2_ctrl_find(subdev->ctrl_handler, V4L2_CID_LINK_FREQ) ||
++		    v4l2_ctrl_find(subdev->ctrl_handler, V4L2_CID_PIXEL_RATE))
++			break;
++	}
++
++	link_freq = v4l2_get_link_freq(subdev->ctrl_handler, fmt->depth,
++				       cfe->csi2.active_data_lanes * 2);
++	if (link_freq < 0)
++		goto err;
++
++	/* x2 for DDR. */
++	link_freq *= 2;
++	cfe_info("Using a link frequency of %lld Hz\n", link_freq);
++	return link_freq;
++
++err:
++	cfe_err("Unable to determine sensor link frequency, using 999 MHz\n");
++	return 999 * 1000000UL;
++}
++
+ static int cfe_start_streaming(struct vb2_queue *vq, unsigned int count)
+ {
+ 	struct v4l2_mbus_config mbus_config = { 0 };
+@@ -1049,10 +1103,11 @@ static int cfe_start_streaming(struct vb
+ 		goto err_disable_cfe;
+ 	}
+ 
+-	cfe_dbg("Starting sensor streaming\n");
+-
++	cfe_dbg("Configuring CSI-2 block\n");
++	cfe->csi2.dphy.dphy_freq = sensor_link_frequency(cfe) / 1000000UL;
+ 	csi2_open_rx(&cfe->csi2);
+ 
++	cfe_dbg("Starting sensor streaming\n");
+ 	cfe->sequence = 0;
+ 	ret = v4l2_subdev_call(cfe->sensor, video, s_stream, 1);
+ 	if (ret < 0) {
+@@ -1945,8 +2000,6 @@ static int of_cfe_connect_subdevs(struct
+ 		}
+ 	}
+ 
+-	/* TODO: Get the frequency from devicetree */
+-	cfe->csi2.dphy.dphy_freq = 999;
+ 	cfe->csi2.dphy.num_lanes = ep.bus.mipi_csi2.num_data_lanes;
+ 	cfe->csi2.bus_flags = ep.bus.mipi_csi2.flags;
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1062-dts-bcm2712-rpi-5-b-Create-some-dummy-nodes.patch b/target/linux/bcm27xx/patches-6.1/950-1062-dts-bcm2712-rpi-5-b-Create-some-dummy-nodes.patch
new file mode 100644
index 0000000000..722714d56a
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1062-dts-bcm2712-rpi-5-b-Create-some-dummy-nodes.patch
@@ -0,0 +1,42 @@
+From fb78b2617e70e58e03e0d50e674758fdd2a80d45 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 2 Nov 2023 10:39:11 +0000
+Subject: [PATCH] dts: bcm2712-rpi-5-b: Create some dummy nodes
+
+The kernel now treats multiple fragments targeting the same node as an
+error. For this reason, it is important that labels created just for
+compatibility with other systems (e.g. i2c0if and i2c0mux) are
+attached to unique nodes, not just tacked onto existing nodes.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 11 ++++++-----
+ 1 file changed, 6 insertions(+), 5 deletions(-)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -157,6 +157,12 @@
+ 	dummy: dummy {
+ 		// A target for unwanted overlay fragments
+ 	};
++
++
++	// A few extra labels to keep overlays happy
++
++	i2c0if: i2c0if {};
++	i2c0mux: i2c0mux {};
+ };
+ 
+ rp1_target: &pcie2 {
+@@ -243,11 +249,6 @@ aux: &dummy {};
+ 
+ #include "bcm2712-rpi.dtsi"
+ 
+-// A few extra labels to keep overlays happy
+-
+-i2c0if: &rp1_gpio {};
+-i2c0mux: &rp1_gpio {};
+-
+ i2c_csi_dsi0: &i2c6 { // Note: This is for MIPI0 connector only
+ 	pinctrl-0 = <&rp1_i2c6_38_39>;
+ 	pinctrl-names = "default";
diff --git a/target/linux/bcm27xx/patches-6.1/950-1063-dts-rp1-Add-spi6-fix-spi1-address-cells.patch b/target/linux/bcm27xx/patches-6.1/950-1063-dts-rp1-Add-spi6-fix-spi1-address-cells.patch
new file mode 100644
index 0000000000..41ab025555
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1063-dts-rp1-Add-spi6-fix-spi1-address-cells.patch
@@ -0,0 +1,49 @@
+From cd66a0832351762b496bdce6f2f94a871d11484e Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 2 Nov 2023 13:12:55 +0000
+Subject: [PATCH] dts: rp1: Add spi6, fix spi1 #address-cells
+
+spi6 won't be useful on Pi 5 because it can't be enabled on the 40-pin
+header, but include it for completeness.
+
+Also fix the #address-cells value for spi1, otherwise the kernel will
+reject attempts to apply the, say, spi1-2cs overlay at runtime.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/rp1.dtsi | 17 ++++++++++++++++-
+ 1 file changed, 16 insertions(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/rp1.dtsi
++++ b/arch/arm/boot/dts/rp1.dtsi
+@@ -187,7 +187,7 @@
+ 			interrupts = <RP1_INT_SPI1 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS>;
+ 			clock-names = "ssi_clk";
+-			#address-cells = <0>;
++			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			num-cs = <2>;
+ 			dmas = <&rp1_dma RP1_DMA_SPI1_TX>,
+@@ -262,6 +262,21 @@
+ 			dma-names = "tx", "rx";
+ 			status = "disabled";
+ 		};
++
++		rp1_spi6: spi@68000 {
++			reg = <0xc0 0x40068000  0x0 0x130>;
++			compatible = "snps,dw-apb-ssi";
++			interrupts = <RP1_INT_SPI6 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			clock-names = "ssi_clk";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			num-cs = <2>;
++			dmas = <&rp1_dma RP1_DMA_SPI6_TX>,
++			       <&rp1_dma RP1_DMA_SPI6_RX>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
+ 
+ 		// SPI7 is a target/slave interface
+ 		rp1_spi7: spi@6c000 {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1064-overlays-uart-n-pi5-Add-the-pinctrl-0-property.patch b/target/linux/bcm27xx/patches-6.1/950-1064-overlays-uart-n-pi5-Add-the-pinctrl-0-property.patch
new file mode 100644
index 0000000000..b6e0c323db
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1064-overlays-uart-n-pi5-Add-the-pinctrl-0-property.patch
@@ -0,0 +1,67 @@
+From 17f135b742c4edb340afb365873c3a574f7e16cb Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 2 Nov 2023 17:05:46 +0000
+Subject: [PATCH] overlays: uart<n>-pi5: Add the pinctrl-0 property
+
+Without the pinctrl-0 property in the overlays, the UARTs may not be
+mapped correctly.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/uart0-pi5-overlay.dts | 1 +
+ arch/arm/boot/dts/overlays/uart1-pi5-overlay.dts | 1 +
+ arch/arm/boot/dts/overlays/uart2-pi5-overlay.dts | 1 +
+ arch/arm/boot/dts/overlays/uart3-pi5-overlay.dts | 1 +
+ arch/arm/boot/dts/overlays/uart4-pi5-overlay.dts | 1 +
+ 5 files changed, 5 insertions(+)
+
+--- a/arch/arm/boot/dts/overlays/uart0-pi5-overlay.dts
++++ b/arch/arm/boot/dts/overlays/uart0-pi5-overlay.dts
+@@ -8,6 +8,7 @@
+ 		target = <&uart0>;
+ 		frag0: __overlay__ {
+ 			status = "okay";
++			pinctrl-0 = <&uart0_pins>;
+ 		};
+ 	};
+ 
+--- a/arch/arm/boot/dts/overlays/uart1-pi5-overlay.dts
++++ b/arch/arm/boot/dts/overlays/uart1-pi5-overlay.dts
+@@ -8,6 +8,7 @@
+ 		target = <&uart1>;
+ 		frag0: __overlay__ {
+ 			status = "okay";
++			pinctrl-0 = <&uart1_pins>;
+ 		};
+ 	};
+ 
+--- a/arch/arm/boot/dts/overlays/uart2-pi5-overlay.dts
++++ b/arch/arm/boot/dts/overlays/uart2-pi5-overlay.dts
+@@ -8,6 +8,7 @@
+ 		target = <&uart2>;
+ 		frag0: __overlay__ {
+ 			status = "okay";
++			pinctrl-0 = <&uart2_pins>;
+ 		};
+ 	};
+ 
+--- a/arch/arm/boot/dts/overlays/uart3-pi5-overlay.dts
++++ b/arch/arm/boot/dts/overlays/uart3-pi5-overlay.dts
+@@ -8,6 +8,7 @@
+ 		target = <&uart3>;
+ 		frag0: __overlay__ {
+ 			status = "okay";
++			pinctrl-0 = <&uart3_pins>;
+ 		};
+ 	};
+ 
+--- a/arch/arm/boot/dts/overlays/uart4-pi5-overlay.dts
++++ b/arch/arm/boot/dts/overlays/uart4-pi5-overlay.dts
+@@ -8,6 +8,7 @@
+ 		target = <&uart4>;
+ 		frag0: __overlay__ {
+ 			status = "okay";
++			pinctrl-0 = <&uart4_pins>;
+ 		};
+ 	};
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1065-drivers-media-imx477-Add-V4L2_CID_LINK_FREQ-control.patch b/target/linux/bcm27xx/patches-6.1/950-1065-drivers-media-imx477-Add-V4L2_CID_LINK_FREQ-control.patch
new file mode 100644
index 0000000000..f0a652b520
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1065-drivers-media-imx477-Add-V4L2_CID_LINK_FREQ-control.patch
@@ -0,0 +1,51 @@
+From c9a785d57c302d5f1d4de4e67fa57522e66c7882 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Mon, 6 Nov 2023 09:40:50 +0000
+Subject: [PATCH] drivers: media: imx477: Add V4L2_CID_LINK_FREQ control
+
+Add V4L2_CID_LINK_FREQ as a read-only control with a value of 450 Mhz.
+This will be used by the CFE driver to corretly setup the DPHY timing
+parameters in the CSI-2 block.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/i2c/imx477.c | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+--- a/drivers/media/i2c/imx477.c
++++ b/drivers/media/i2c/imx477.c
+@@ -164,6 +164,10 @@ struct imx477_mode {
+ 	struct imx477_reg_list reg_list;
+ };
+ 
++static const s64 imx477_link_freq_menu[] = {
++	IMX477_DEFAULT_LINK_FREQ,
++};
++
+ static const struct imx477_reg mode_common_regs[] = {
+ 	{0x0136, 0x18},
+ 	{0x0137, 0x00},
+@@ -1110,6 +1114,7 @@ struct imx477 {
+ 	struct v4l2_ctrl_handler ctrl_handler;
+ 	/* V4L2 Controls */
+ 	struct v4l2_ctrl *pixel_rate;
++	struct v4l2_ctrl *link_freq;
+ 	struct v4l2_ctrl *exposure;
+ 	struct v4l2_ctrl *vflip;
+ 	struct v4l2_ctrl *hflip;
+@@ -1997,6 +2002,15 @@ static int imx477_init_controls(struct i
+ 					       IMX477_PIXEL_RATE, 1,
+ 					       IMX477_PIXEL_RATE);
+ 
++	/* LINK_FREQ is also read only */
++	imx477->link_freq =
++		v4l2_ctrl_new_int_menu(ctrl_hdlr, &imx477_ctrl_ops,
++				       V4L2_CID_LINK_FREQ,
++				       ARRAY_SIZE(imx477_link_freq_menu) - 1, 0,
++				       imx477_link_freq_menu);
++	if (imx477->link_freq)
++		imx477->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
++
+ 	/*
+ 	 * Create the controls here, but mode specific limits are setup
+ 	 * in the imx477_set_framing_limits() call below.
diff --git a/target/linux/bcm27xx/patches-6.1/950-1066-drivers-media-imx477-Correctly-set-IMX477_PIXEL_RATE.patch b/target/linux/bcm27xx/patches-6.1/950-1066-drivers-media-imx477-Correctly-set-IMX477_PIXEL_RATE.patch
new file mode 100644
index 0000000000..f62fbbe13d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1066-drivers-media-imx477-Correctly-set-IMX477_PIXEL_RATE.patch
@@ -0,0 +1,24 @@
+From 46913ee0590ee0e3f607ab189be19a4d0ce785f2 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Mon, 6 Nov 2023 09:42:37 +0000
+Subject: [PATCH] drivers: media: imx477: Correctly set IMX477_PIXEL_RATE as a
+ r/o control
+
+This control is meant to be read-only, mark it as such.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/i2c/imx477.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/media/i2c/imx477.c
++++ b/drivers/media/i2c/imx477.c
+@@ -2001,6 +2001,8 @@ static int imx477_init_controls(struct i
+ 					       IMX477_PIXEL_RATE,
+ 					       IMX477_PIXEL_RATE, 1,
+ 					       IMX477_PIXEL_RATE);
++	if (imx477->pixel_rate)
++		imx477->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+ 
+ 	/* LINK_FREQ is also read only */
+ 	imx477->link_freq =
diff --git a/target/linux/bcm27xx/patches-6.1/950-1067-drm-vc4-Correct-logic-on-stopping-an-HVS-channel.patch b/target/linux/bcm27xx/patches-6.1/950-1067-drm-vc4-Correct-logic-on-stopping-an-HVS-channel.patch
new file mode 100644
index 0000000000..948d79bfdb
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1067-drm-vc4-Correct-logic-on-stopping-an-HVS-channel.patch
@@ -0,0 +1,52 @@
+From 6e9f68bba01b9c36a77b68c4b3167c317da986da Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 26 Oct 2023 17:46:13 +0100
+Subject: [PATCH] drm/vc4: Correct logic on stopping an HVS channel
+
+When factoring out __vc4_hvs_stop_channel, the logic got inverted from
+	if (condition)
+	  // stop channel
+to
+	if (condition)
+	  goto out
+	//stop channel
+	out:
+and also changed the exact register writes used to stop the channel.
+
+Correct the logic so that the channel is actually stopped, and revert
+to the original register writes.
+
+Fixes: 6d01a106b4c8 ("drm/vc4: crtc: Move HVS init and close to a function")
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 10 ++++------
+ 1 file changed, 4 insertions(+), 6 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -992,13 +992,11 @@ static void __vc4_hvs_stop_channel(struc
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return;
+ 
+-	if (HVS_READ(SCALER_DISPCTRLX(chan)) & SCALER_DISPCTRLX_ENABLE)
++	if (!(HVS_READ(SCALER_DISPCTRLX(chan)) & SCALER_DISPCTRLX_ENABLE))
+ 		goto out;
+ 
+-	HVS_WRITE(SCALER_DISPCTRLX(chan),
+-		  HVS_READ(SCALER_DISPCTRLX(chan)) | SCALER_DISPCTRLX_RESET);
+-	HVS_WRITE(SCALER_DISPCTRLX(chan),
+-		  HVS_READ(SCALER_DISPCTRLX(chan)) & ~SCALER_DISPCTRLX_ENABLE);
++	HVS_WRITE(SCALER_DISPCTRLX(chan), SCALER_DISPCTRLX_RESET);
++	HVS_WRITE(SCALER_DISPCTRLX(chan), 0);
+ 
+ 	/* Once we leave, the scaler should be disabled and its fifo empty. */
+ 	WARN_ON_ONCE(HVS_READ(SCALER_DISPCTRLX(chan)) & SCALER_DISPCTRLX_RESET);
+@@ -1026,7 +1024,7 @@ static void __vc6_hvs_stop_channel(struc
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return;
+ 
+-	if (HVS_READ(SCALER6_DISPX_CTRL0(chan)) & SCALER6_DISPX_CTRL0_ENB)
++	if (!(HVS_READ(SCALER6_DISPX_CTRL0(chan)) & SCALER6_DISPX_CTRL0_ENB))
+ 		goto out;
+ 
+ 	HVS_WRITE(SCALER6_DISPX_CTRL0(chan),
diff --git a/target/linux/bcm27xx/patches-6.1/950-1068-drm-vc4-Drop-WARN-for-HVS-FIFOs-not-being-empty.patch b/target/linux/bcm27xx/patches-6.1/950-1068-drm-vc4-Drop-WARN-for-HVS-FIFOs-not-being-empty.patch
new file mode 100644
index 0000000000..627f22c845
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1068-drm-vc4-Drop-WARN-for-HVS-FIFOs-not-being-empty.patch
@@ -0,0 +1,30 @@
+From 31c4c359aa2dbb1a7c095f0a6ef4e13cd46cfd14 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 26 Oct 2023 18:05:09 +0100
+Subject: [PATCH] drm/vc4: Drop WARN for HVS FIFOs not being empty
+
+The reset condition for the EMPTY flag in DISPSTATx is 0,
+so seeing as we've just reset the pipeline there is no
+guarantee that the flag will denote empty if it hasn't been
+enabled.
+
+Drop the WARN.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 4 ----
+ 1 file changed, 4 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -1005,10 +1005,6 @@ static void __vc4_hvs_stop_channel(struc
+ 				   SCALER_DISPSTATX_MODE) !=
+ 		     SCALER_DISPSTATX_MODE_DISABLED);
+ 
+-	WARN_ON_ONCE((HVS_READ(SCALER_DISPSTATX(chan)) &
+-		      (SCALER_DISPSTATX_FULL | SCALER_DISPSTATX_EMPTY)) !=
+-		     SCALER_DISPSTATX_EMPTY);
+-
+ out:
+ 	drm_dev_exit(idx);
+ }
diff --git a/target/linux/bcm27xx/patches-6.1/950-1069-drm-vc4-Free-all-stale-dlists-if-channel-is-disabled.patch b/target/linux/bcm27xx/patches-6.1/950-1069-drm-vc4-Free-all-stale-dlists-if-channel-is-disabled.patch
new file mode 100644
index 0000000000..ce03224c39
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1069-drm-vc4-Free-all-stale-dlists-if-channel-is-disabled.patch
@@ -0,0 +1,85 @@
+From 8b7078d1bbd8bb548cc97d5214adb828e9f0037c Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 26 Oct 2023 18:23:31 +0100
+Subject: [PATCH] drm/vc4: Free all stale dlists if channel is disabled
+
+The code handling freeing stale dlists had 2 issues:
+- it disabled the interrupt as soon as the first EOF interrupt
+  occurred, even if it didn't clear all stale allocations, thus
+  leading to stale entries
+- It didn't free stale entries from disabled channels, so eg
+  "kmstest -c 0" could leave a stale alloc on channel 1 floating
+  around.
+
+Keep the interrupt enabled whilst there are any outstanding
+allocs, and discard those on disabled channels. This second
+channel does require us to call vc4_hvs_stop_channel from
+vc4_crtc_atomic_disable so that the channel actually gets stopped.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_crtc.c |  2 ++
+ drivers/gpu/drm/vc4/vc4_hvs.c  | 27 +++++++++++++++++++++++++--
+ 2 files changed, 27 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_crtc.c
++++ b/drivers/gpu/drm/vc4/vc4_crtc.c
+@@ -660,6 +660,8 @@ static void vc4_crtc_atomic_disable(stru
+ 
+ 	vc4_crtc_disable(crtc, encoder, state, old_vc4_state->assigned_channel);
+ 
++	vc4_hvs_atomic_disable(crtc, state);
++
+ 	/*
+ 	 * Make sure we issue a vblank event after disabling the CRTC if
+ 	 * someone was waiting it.
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -697,7 +697,8 @@ static void vc4_hvs_schedule_dlist_sweep
+ 	if (!list_empty(&hvs->stale_dlist_entries))
+ 		queue_work(system_unbound_wq, &hvs->free_dlist_work);
+ 
+-	vc4_hvs_irq_clear_eof(hvs, channel);
++	if (list_empty(&hvs->stale_dlist_entries))
++		vc4_hvs_irq_clear_eof(hvs, channel);
+ 
+ 	spin_unlock_irqrestore(&hvs->mm_lock, flags);
+ }
+@@ -712,6 +713,27 @@ static bool vc4_hvs_frcnt_lte(u8 cnt1, u
+ 	return (s8)((cnt1 << 2) - (cnt2 << 2)) <= 0;
+ }
+ 
++bool vc4_hvs_check_channel_active(struct vc4_hvs *hvs, unsigned int fifo)
++{
++	struct vc4_dev *vc4 = hvs->vc4;
++	struct drm_device *drm = &vc4->base;
++	bool enabled = false;
++	int idx;
++
++	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
++
++	if (!drm_dev_enter(drm, &idx))
++		return 0;
++
++	if (vc4->gen >= VC4_GEN_6)
++		enabled = HVS_READ(SCALER6_DISPX_CTRL0(fifo)) & SCALER6_DISPX_CTRL0_ENB;
++	else
++		enabled = HVS_READ(SCALER_DISPCTRLX(fifo)) & SCALER_DISPCTRLX_ENABLE;
++
++	drm_dev_exit(idx);
++	return enabled;
++}
++
+ /*
+  * Some atomic commits (legacy cursor updates, mostly) will not wait for
+  * the next vblank and will just return once the commit has been pushed
+@@ -746,7 +768,8 @@ static void vc4_hvs_dlist_free_work(stru
+ 		u8 frcnt;
+ 
+ 		frcnt = vc4_hvs_get_fifo_frame_count(hvs, cur->channel);
+-		if (!vc4_hvs_frcnt_lte(cur->target_frame_count, frcnt))
++		if (vc4_hvs_check_channel_active(hvs, cur->channel) &&
++		    !vc4_hvs_frcnt_lte(cur->target_frame_count, frcnt))
+ 			continue;
+ 
+ 		vc4_hvs_free_dlist_entry_locked(hvs, cur);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1070-drm-vc4-Add-hvs_dlist_allocs-debugfs-function.patch b/target/linux/bcm27xx/patches-6.1/950-1070-drm-vc4-Add-hvs_dlist_allocs-debugfs-function.patch
new file mode 100644
index 0000000000..b16489a12d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1070-drm-vc4-Add-hvs_dlist_allocs-debugfs-function.patch
@@ -0,0 +1,64 @@
+From 665e9810340abc37769b317445907bac1843dd64 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 27 Oct 2023 16:46:04 +0100
+Subject: [PATCH] drm/vc4: Add hvs_dlist_allocs debugfs function.
+
+Users are reporting running out of DLIST memory. Add a
+debugfs file to dump out all the allocations.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 35 +++++++++++++++++++++++++++++++++++
+ 1 file changed, 35 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -347,6 +347,36 @@ static int vc5_hvs_debugfs_gamma(struct
+ 	return 0;
+ }
+ 
++static int vc4_hvs_debugfs_dlist_allocs(struct seq_file *m, void *data)
++{
++	struct drm_info_node *node = m->private;
++	struct drm_device *dev = node->minor->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct vc4_hvs *hvs = vc4->hvs;
++	struct drm_printer p = drm_seq_file_printer(m);
++	struct vc4_hvs_dlist_allocation *cur, *next;
++	struct drm_mm_node *mm_node;
++	unsigned long flags;
++
++	spin_lock_irqsave(&hvs->mm_lock, flags);
++
++	drm_printf(&p, "Allocated nodes:\n");
++	list_for_each_entry(mm_node, drm_mm_nodes(&hvs->dlist_mm), node_list) {
++		drm_printf(&p, "node [%08llx + %08llx]\n", mm_node->start, mm_node->size);
++	}
++
++	drm_printf(&p, "Stale nodes:\n");
++	list_for_each_entry_safe(cur, next, &hvs->stale_dlist_entries, node) {
++		drm_printf(&p, "node [%08llx + %08llx] channel %u frcnt %u\n",
++			   cur->mm_node.start, cur->mm_node.size, cur->channel,
++			   cur->target_frame_count);
++	}
++
++	spin_unlock_irqrestore(&hvs->mm_lock, flags);
++
++	return 0;
++}
++
+ /* The filter kernel is composed of dwords each containing 3 9-bit
+  * signed integers packed next to each other.
+  */
+@@ -1602,6 +1632,11 @@ int vc4_hvs_debugfs_init(struct drm_mino
+ 	if (ret)
+ 		return ret;
+ 
++	ret = vc4_debugfs_add_file(minor, "hvs_dlist_allocs",
++				   vc4_hvs_debugfs_dlist_allocs, NULL);
++	if (ret)
++		return ret;
++
+ 	ret = vc4_debugfs_add_regset32(minor, "hvs_regs",
+ 				       &hvs->regset);
+ 	if (ret)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1071-drm-vc4-Log-the-size-of-the-dlist-allocation-that-wa.patch b/target/linux/bcm27xx/patches-6.1/950-1071-drm-vc4-Log-the-size-of-the-dlist-allocation-that-wa.patch
new file mode 100644
index 0000000000..aa38b182ba
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1071-drm-vc4-Log-the-size-of-the-dlist-allocation-that-wa.patch
@@ -0,0 +1,23 @@
+From 23ea21ef5f6efb3082c184843b35a2f8f2e4374c Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Tue, 31 Oct 2023 11:15:38 +0000
+Subject: [PATCH] drm/vc4: Log the size of the dlist allocation that was
+ attempted
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -659,7 +659,8 @@ vc4_hvs_alloc_dlist_entry(struct vc4_hvs
+ 				 dlist_count);
+ 	spin_unlock_irqrestore(&hvs->mm_lock, flags);
+ 	if (ret) {
+-		drm_err(dev, "Failed to allocate DLIST entry: %d\n", ret);
++		drm_err(dev, "Failed to allocate DLIST entry. Requested size=%zu. ret=%d\n",
++			dlist_count, ret);
+ 		return ERR_PTR(ret);
+ 	}
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1072-drm-vc4-crtc-Support-odd-horizontal-timings-on-BCM27.patch b/target/linux/bcm27xx/patches-6.1/950-1072-drm-vc4-crtc-Support-odd-horizontal-timings-on-BCM27.patch
new file mode 100644
index 0000000000..a72e3b8e5b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1072-drm-vc4-crtc-Support-odd-horizontal-timings-on-BCM27.patch
@@ -0,0 +1,104 @@
+From f9f480b04f1dc280bd4411477f5ee7336361367b Mon Sep 17 00:00:00 2001
+From: Dom Cobley <popcornmix@gmail.com>
+Date: Tue, 24 Oct 2023 16:20:42 +0100
+Subject: [PATCH] drm/vc4: crtc: Support odd horizontal timings on BCM2712
+
+BCM2711 runs pixelvalve at two pixels per clock cycle which results
+in an unfortunate limitation that odd horizontal timings are not
+possible. This is apparent on the standard DMT mode of 1366x768@60
+which cannot be driven with correct timing.
+
+BCM2712 defaults to the same behaviour, but has a mode to support
+odd timings. While internally it still runs at two pixels per clock,
+setting the PV_VCONTROL_ODD_TIMING bit makes it appear externally
+to behave as it is one pixel per clock.
+
+Switching to this mode fixes 1366x768@60 mode, and other custom
+resultions with odd horizontal timings.
+
+Signed-off-by: Dom Cobley <popcornmix@gmail.com>
+---
+ drivers/gpu/drm/vc4/vc4_crtc.c | 12 ++++--------
+ drivers/gpu/drm/vc4/vc4_hdmi.c |  4 ++--
+ drivers/gpu/drm/vc4/vc4_regs.h |  1 +
+ 3 files changed, 7 insertions(+), 10 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_crtc.c
++++ b/drivers/gpu/drm/vc4/vc4_crtc.c
+@@ -398,12 +398,6 @@ static void vc4_crtc_config_pv(struct dr
+ 
+ 	vc4_crtc_pixelvalve_reset(crtc);
+ 
+-	/*
+-	 * NOTE: The BCM2712 has a H_OTE (Horizontal Odd Timing Enable)
+-	 * bit that, when set, will allow to specify the timings in
+-	 * pixels instead of cycles, thus allowing to specify odd
+-	 * timings.
+-	 */
+ 	CRTC_WRITE(PV_HORZA,
+ 		   VC4_SET_FIELD((mode->htotal - mode->hsync_end) * pixel_rep / ppc,
+ 				 PV_HORZA_HBP) |
+@@ -448,6 +442,7 @@ static void vc4_crtc_config_pv(struct dr
+ 		 */
+ 		CRTC_WRITE(PV_V_CONTROL,
+ 			   PV_VCONTROL_CONTINUOUS |
++			   (vc4->gen >= VC4_GEN_6 ? PV_VCONTROL_ODD_TIMING : 0) |
+ 			   (is_dsi ? PV_VCONTROL_DSI : 0) |
+ 			   PV_VCONTROL_INTERLACE |
+ 			   (odd_field_first
+@@ -459,6 +454,7 @@ static void vc4_crtc_config_pv(struct dr
+ 	} else {
+ 		CRTC_WRITE(PV_V_CONTROL,
+ 			   PV_VCONTROL_CONTINUOUS |
++			   (vc4->gen >= VC4_GEN_6 ? PV_VCONTROL_ODD_TIMING : 0) |
+ 			   (is_dsi ? PV_VCONTROL_DSI : 0));
+ 		CRTC_WRITE(PV_VSYNCD_EVEN, 0);
+ 	}
+@@ -1334,7 +1330,7 @@ const struct vc4_pv_data bcm2712_pv0_dat
+ 		.hvs_output = 0,
+ 	},
+ 	.fifo_depth = 64,
+-	.pixels_per_clock = 2,
++	.pixels_per_clock = 1,
+ 	.encoder_types = {
+ 		[0] = VC4_ENCODER_TYPE_HDMI0,
+ 	},
+@@ -1347,7 +1343,7 @@ const struct vc4_pv_data bcm2712_pv1_dat
+ 		.hvs_output = 1,
+ 	},
+ 	.fifo_depth = 64,
+-	.pixels_per_clock = 2,
++	.pixels_per_clock = 1,
+ 	.encoder_types = {
+ 		[0] = VC4_ENCODER_TYPE_HDMI1,
+ 	},
+--- a/drivers/gpu/drm/vc4/vc4_hdmi.c
++++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
+@@ -3958,7 +3958,7 @@ static const struct vc4_hdmi_variant bcm
+ 		PHY_LANE_2,
+ 		PHY_LANE_CK,
+ 	},
+-	.unsupported_odd_h_timings	= true,
++	.unsupported_odd_h_timings	= false,
+ 	.external_irq_controller	= true,
+ 
+ 	.init_resources		= vc5_hdmi_init_resources,
+@@ -3985,7 +3985,7 @@ static const struct vc4_hdmi_variant bcm
+ 		PHY_LANE_2,
+ 		PHY_LANE_CK,
+ 	},
+-	.unsupported_odd_h_timings	= true,
++	.unsupported_odd_h_timings	= false,
+ 	.external_irq_controller	= true,
+ 
+ 	.init_resources		= vc5_hdmi_init_resources,
+--- a/drivers/gpu/drm/vc4/vc4_regs.h
++++ b/drivers/gpu/drm/vc4/vc4_regs.h
+@@ -155,6 +155,7 @@
+ # define PV_CONTROL_EN				BIT(0)
+ 
+ #define PV_V_CONTROL				0x04
++# define PV_VCONTROL_ODD_TIMING			BIT(29)
+ # define PV_VCONTROL_ODD_DELAY_MASK		VC4_MASK(22, 6)
+ # define PV_VCONTROL_ODD_DELAY_SHIFT		6
+ # define PV_VCONTROL_ODD_FIRST			BIT(5)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1073-spi-dw-dma-Get-the-last-DMA-scoop-out-of-the-FIFO.patch b/target/linux/bcm27xx/patches-6.1/950-1073-spi-dw-dma-Get-the-last-DMA-scoop-out-of-the-FIFO.patch
new file mode 100644
index 0000000000..caf8b1a462
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1073-spi-dw-dma-Get-the-last-DMA-scoop-out-of-the-FIFO.patch
@@ -0,0 +1,41 @@
+From 686fe776309fba5cad642c40177d39bf1fb320b2 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 7 Nov 2023 14:49:47 +0000
+Subject: [PATCH] spi: dw-dma: Get the last DMA scoop out of the FIFO
+
+With a DMA FIFO threshold greater than 1 (encoded as 0), it is possible
+for data in the FIFO to be inaccessible, causing the transfer to fail
+after a timeout. If the transfer includes a transmission, reduce the
+RX threshold when the TX completes, otherwise use 1 for the whole
+transfer (inefficient, but not catastrophic at SPI data rates).
+
+See: https://github.com/raspberrypi/linux/issues/5696
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/spi/spi-dw-dma.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/spi/spi-dw-dma.c
++++ b/drivers/spi/spi-dw-dma.c
+@@ -275,8 +275,10 @@ static void dw_spi_dma_tx_done(void *arg
+ 	struct dw_spi *dws = arg;
+ 
+ 	clear_bit(DW_SPI_TX_BUSY, &dws->dma_chan_busy);
+-	if (test_bit(DW_SPI_RX_BUSY, &dws->dma_chan_busy))
++	if (test_bit(DW_SPI_RX_BUSY, &dws->dma_chan_busy)) {
++		dw_writel(dws, DW_SPI_DMARDLR, 0);
+ 		return;
++	}
+ 
+ 	complete(&dws->dma_completion);
+ }
+@@ -602,6 +604,8 @@ static int dw_spi_dma_transfer(struct dw
+ 
+ 	nents = max(xfer->tx_sg.nents, xfer->rx_sg.nents);
+ 
++	dw_writel(dws, DW_SPI_DMARDLR, xfer->tx_buf ? (dws->rxburst - 1) : 0);
++
+ 	/*
+ 	 * Execute normal DMA-based transfer (which submits the Rx and Tx SG
+ 	 * lists directly to the DMA engine at once) if either full hardware
diff --git a/target/linux/bcm27xx/patches-6.1/950-1075-drivers-mmc-sdhci-add-SPURIOUS_INT_RESP-quirk.patch b/target/linux/bcm27xx/patches-6.1/950-1075-drivers-mmc-sdhci-add-SPURIOUS_INT_RESP-quirk.patch
new file mode 100644
index 0000000000..2ab224df05
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1075-drivers-mmc-sdhci-add-SPURIOUS_INT_RESP-quirk.patch
@@ -0,0 +1,62 @@
+From 4d2261fe86ce08bbee3c000718000e9f86593d88 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Wed, 8 Nov 2023 11:52:16 +0000
+Subject: [PATCH] drivers: mmc: sdhci: add SPURIOUS_INT_RESP quirk
+
+Certain controllers (dwc-mshc) generate timeout conditions separately to
+command-completion conditions, where the end result is interrupts are
+separated in time depending on the current SDCLK frequency.
+
+This causes spurious interrupts if SDCLK is slow compared to the CPU's
+ability to process and return from interrupt. This occurs during card
+probe with an empty slot where all commands that would generate a
+response time out.
+
+Add a quirk to squelch command response interrupts when a command
+timeout interrupt is received.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/mmc/host/sdhci.c | 11 +++++++++++
+ drivers/mmc/host/sdhci.h |  3 +++
+ 2 files changed, 14 insertions(+)
+
+--- a/drivers/mmc/host/sdhci.c
++++ b/drivers/mmc/host/sdhci.c
+@@ -1728,6 +1728,12 @@ static bool sdhci_send_command(struct sd
+ 	if (host->use_external_dma)
+ 		sdhci_external_dma_pre_transfer(host, cmd);
+ 
++	if (host->quirks2 & SDHCI_QUIRK2_SPURIOUS_INT_RESP) {
++		host->ier |= SDHCI_INT_RESPONSE;
++		sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
++		sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
++	}
++
+ 	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->opcode, flags), SDHCI_COMMAND);
+ 
+ 	return true;
+@@ -3330,6 +3336,11 @@ static void sdhci_cmd_irq(struct sdhci_h
+ 		if (intmask & SDHCI_INT_TIMEOUT) {
+ 			host->cmd->error = -ETIMEDOUT;
+ 			sdhci_err_stats_inc(host, CMD_TIMEOUT);
++			if (host->quirks2 & SDHCI_QUIRK2_SPURIOUS_INT_RESP) {
++				host->ier &= ~SDHCI_INT_RESPONSE;
++				sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
++				sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
++			}
+ 		} else {
+ 			host->cmd->error = -EILSEQ;
+ 			if (!mmc_op_tuning(host->cmd->opcode))
+--- a/drivers/mmc/host/sdhci.h
++++ b/drivers/mmc/host/sdhci.h
+@@ -486,6 +486,9 @@ struct sdhci_host {
+ #define SDHCI_QUIRK2_NO_SDR50  (1<<20)
+ #define SDHCI_QUIRK2_NO_SDR104	(1<<21)
+ 
++/* Command timeouts may generate a trailing INT_RESPONSE later */
++#define SDHCI_QUIRK2_SPURIOUS_INT_RESP			(1<<31)
++
+ 	int irq;		/* Device IRQ */
+ 	void __iomem *ioaddr;	/* Mapped address */
+ 	phys_addr_t mapbase;	/* physical address base */
diff --git a/target/linux/bcm27xx/patches-6.1/950-1076-dt-bindings-mmc-sdhci-of-dwcmhsc-Add-Raspberry-Pi-RP.patch b/target/linux/bcm27xx/patches-6.1/950-1076-dt-bindings-mmc-sdhci-of-dwcmhsc-Add-Raspberry-Pi-RP.patch
new file mode 100644
index 0000000000..ffdc1b1c5d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1076-dt-bindings-mmc-sdhci-of-dwcmhsc-Add-Raspberry-Pi-RP.patch
@@ -0,0 +1,42 @@
+From ebe13d0d4314255d226ba740e37a14172a8b9091 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Wed, 8 Nov 2023 16:10:13 +0000
+Subject: [PATCH] dt-bindings: mmc: sdhci-of-dwcmhsc: Add Raspberry Pi RP1
+ support
+
+The DWC MSHC controller on RP1 needs differentiating from the generic
+version.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ .../devicetree/bindings/mmc/snps,dwcmshc-sdhci.yaml          | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/Documentation/devicetree/bindings/mmc/snps,dwcmshc-sdhci.yaml
++++ b/Documentation/devicetree/bindings/mmc/snps,dwcmshc-sdhci.yaml
+@@ -16,6 +16,7 @@ allOf:
+ properties:
+   compatible:
+     enum:
++      - raspberrypi,rp1-dwcmshc
+       - rockchip,rk3568-dwcmshc
+       - rockchip,rk3588-dwcmshc
+       - snps,dwcmshc-sdhci
+@@ -34,6 +35,8 @@ properties:
+       - description: axi clock for rockchip specified
+       - description: block clock for rockchip specified
+       - description: timer clock for rockchip specified
++      - description: timeout clock for rp1 specified
++      - description: sdio clock generator for rp1 specified
+ 
+ 
+   clock-names:
+@@ -44,6 +47,8 @@ properties:
+       - const: axi
+       - const: block
+       - const: timer
++      - const: timeout
++      - const: sdio
+ 
+   rockchip,txclk-tapnum:
+     description: Specify the number of delay for tx sampling.
diff --git a/target/linux/bcm27xx/patches-6.1/950-1077-drivers-mmc-sdhci-of-dwcmshc-add-RP1-dt-ID-and-quirk.patch b/target/linux/bcm27xx/patches-6.1/950-1077-drivers-mmc-sdhci-of-dwcmshc-add-RP1-dt-ID-and-quirk.patch
new file mode 100644
index 0000000000..54b719c6ec
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1077-drivers-mmc-sdhci-of-dwcmshc-add-RP1-dt-ID-and-quirk.patch
@@ -0,0 +1,41 @@
+From 80dd8795ca631ac692fd3079487aea6d934a829c Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Wed, 8 Nov 2023 16:12:59 +0000
+Subject: [PATCH] drivers: mmc: sdhci-of-dwcmshc: add RP1 dt ID and quirks
+
+Differentiate the RP1 variant of the Designware MSHC controller(s).
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ drivers/mmc/host/sdhci-of-dwcmshc.c | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+--- a/drivers/mmc/host/sdhci-of-dwcmshc.c
++++ b/drivers/mmc/host/sdhci-of-dwcmshc.c
+@@ -373,6 +373,15 @@ static const struct sdhci_pltfm_data sdh
+ };
+ #endif
+ 
++static const struct sdhci_pltfm_data sdhci_dwcmshc_rp1_pdata = {
++	.ops = &sdhci_dwcmshc_ops,
++	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |
++		  SDHCI_QUIRK_BROKEN_CARD_DETECTION,
++	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
++		   SDHCI_QUIRK2_BROKEN_HS200 |
++		   SDHCI_QUIRK2_SPURIOUS_INT_RESP,
++};
++
+ static const struct sdhci_pltfm_data sdhci_dwcmshc_rk35xx_pdata = {
+ 	.ops = &sdhci_dwcmshc_rk35xx_ops,
+ 	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |
+@@ -441,6 +450,10 @@ static void dwcmshc_rk35xx_postinit(stru
+ 
+ static const struct of_device_id sdhci_dwcmshc_dt_ids[] = {
+ 	{
++		.compatible = "raspberrypi,rp1-dwcmshc",
++		.data = &sdhci_dwcmshc_rp1_pdata,
++	},
++	{
+ 		.compatible = "rockchip,rk3588-dwcmshc",
+ 		.data = &sdhci_dwcmshc_rk35xx_pdata,
+ 	},
diff --git a/target/linux/bcm27xx/patches-6.1/950-1078-arm-dts-change-RP1-SDHCI-controller-compatible-strin.patch b/target/linux/bcm27xx/patches-6.1/950-1078-arm-dts-change-RP1-SDHCI-controller-compatible-strin.patch
new file mode 100644
index 0000000000..c708bf1f71
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1078-arm-dts-change-RP1-SDHCI-controller-compatible-strin.patch
@@ -0,0 +1,104 @@
+From 51cdff455e3c3df29764f71bc0c9dd0e099945d6 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Wed, 8 Nov 2023 16:14:25 +0000
+Subject: [PATCH] arm: dts: change RP1 SDHCI controller compatible string
+
+Also add a sdio-pi5 overlay which enables mmc0 on GPIOs 22-27, as was
+possible with earlier models of Pi.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/Makefile           |  1 +
+ arch/arm/boot/dts/overlays/README             |  7 ++++++
+ arch/arm/boot/dts/overlays/overlay_map.dts    |  4 ++++
+ .../boot/dts/overlays/sdio-pi5-overlay.dts    | 24 +++++++++++++++++++
+ arch/arm/boot/dts/rp1.dtsi                    |  4 ++--
+ 5 files changed, 38 insertions(+), 2 deletions(-)
+ create mode 100644 arch/arm/boot/dts/overlays/sdio-pi5-overlay.dts
+
+--- a/arch/arm/boot/dts/overlays/Makefile
++++ b/arch/arm/boot/dts/overlays/Makefile
+@@ -225,6 +225,7 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	sc16is752-spi1.dtbo \
+ 	sdhost.dtbo \
+ 	sdio.dtbo \
++	sdio-pi5.dtbo \
+ 	seeed-can-fd-hat-v1.dtbo \
+ 	seeed-can-fd-hat-v2.dtbo \
+ 	sh1106-spi.dtbo \
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -3932,6 +3932,13 @@ Info:   This overlay is now deprecated.
+ Load:   <Deprecated>
+ 
+ 
++Name:   sdio-pi5
++Info:   Selects the rp1_mmc0 interface and enables it on GPIOs 22-27.
++        Pi 5 only.
++Load:   dtoverlay=sdio-pi5
++Params: <None>
++
++
+ Name:   sdtweak
+ Info:   This overlay is now deprecated. Use the sd_* dtparams in the
+         base DTB, e.g. "dtoverlay=sdtweak,poll_once" becomes
+--- a/arch/arm/boot/dts/overlays/overlay_map.dts
++++ b/arch/arm/boot/dts/overlays/overlay_map.dts
+@@ -250,6 +250,10 @@
+ 		deprecated = "use sdio,bus_width=1,gpios_22_25";
+ 	};
+ 
++	sdio-pi5 {
++		bcm2712;
++	};
++
+ 	sdtweak {
+ 		deprecated = "use 'dtparam=sd_poll_once' etc.";
+ 	};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/sdio-pi5-overlay.dts
+@@ -0,0 +1,24 @@
++/dts-v1/;
++/plugin/;
++
++/* SDIO/SD/MMC on RP1 bank 0 */
++
++/{
++	compatible = "brcm,bcm2712";
++
++	fragment@0 {
++		target = <&rp1_mmc0>;
++		frag0: __overlay__ {
++			status = "okay";
++			pinctrl-0 = <&rp1_sdio0_22_27>;
++			pinctrl-names = "default";
++		};
++	};
++
++	fragment@1 {
++		target = <&rp1_sdio_clk0>;
++		frag1: __overlay__ {
++			status = "okay";
++		};
++	};
++};
+--- a/arch/arm/boot/dts/rp1.dtsi
++++ b/arch/arm/boot/dts/rp1.dtsi
+@@ -962,7 +962,7 @@
+ 
+ 		rp1_mmc0: mmc@180000 {
+ 			reg = <0xc0 0x40180000  0x0 0x100>;
+-			compatible = "snps,dwcmshc-sdhci";
++			compatible = "raspberrypi,rp1-dwcmshc";
+ 			interrupts = <RP1_INT_SDIO0 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS &sdhci_core
+ 			          &rp1_clocks RP1_CLK_SDIO_TIMER
+@@ -978,7 +978,7 @@
+ 
+ 		rp1_mmc1: mmc@184000 {
+ 			reg = <0xc0 0x40184000  0x0 0x100>;
+-			compatible = "snps,dwcmshc-sdhci";
++			compatible = "raspberrypi,rp1-dwcmshc";
+ 			interrupts = <RP1_INT_SDIO1 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS &sdhci_core
+ 			          &rp1_clocks RP1_CLK_SDIO_TIMER
diff --git a/target/linux/bcm27xx/patches-6.1/950-1079-ASoC-bcm-audioinjector_octo-Add-soundcard-owner.patch b/target/linux/bcm27xx/patches-6.1/950-1079-ASoC-bcm-audioinjector_octo-Add-soundcard-owner.patch
new file mode 100644
index 0000000000..aa025125e7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1079-ASoC-bcm-audioinjector_octo-Add-soundcard-owner.patch
@@ -0,0 +1,22 @@
+From 020ee5029ab0b11e47696f538418105ccfdb44de Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 8 Nov 2023 19:17:33 +0000
+Subject: [PATCH] ASoC: bcm: audioinjector_octo: Add soundcard "owner"
+
+See: https://github.com/raspberrypi/linux/issues/5697
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/bcm/audioinjector-octo-soundcard.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/sound/soc/bcm/audioinjector-octo-soundcard.c
++++ b/sound/soc/bcm/audioinjector-octo-soundcard.c
+@@ -252,6 +252,7 @@ static const struct snd_soc_dapm_route a
+ 
+ static struct snd_soc_card snd_soc_audioinjector_octo = {
+ 	.name = "audioinjector-octo-soundcard",
++	.owner = THIS_MODULE,
+ 	.dai_link = audioinjector_octo_dai,
+ 	.num_links = ARRAY_SIZE(audioinjector_octo_dai),
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1080-drivers-media-imx708-Adjust-broken-line-correction-p.patch b/target/linux/bcm27xx/patches-6.1/950-1080-drivers-media-imx708-Adjust-broken-line-correction-p.patch
new file mode 100644
index 0000000000..60f489c6c0
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1080-drivers-media-imx708-Adjust-broken-line-correction-p.patch
@@ -0,0 +1,139 @@
+From f364e0eb8f973e1aa24a3c451d18e84247a8efcd Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Wed, 8 Nov 2023 10:57:45 +0000
+Subject: [PATCH] drivers: media: imx708: Adjust broken line correction
+ parameter
+
+In full-resolution mode, the LPF_INTENSITY_EN and LPF_INTENSITY
+registers control Quad Bayer Re-mosaic broken line correction.
+Expose this as a module parameter "qbc_adjust": zero disables
+the correction and values in the range 2 to 5 set its strength.
+
+There is a trade-off between coloured and monochrome patterns.
+The previous fixed value 4 could produce ladder/spots artefacts
+in coloured textures. The new default value 2 may suit a wider
+range of scenes.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/media/i2c/imx708.c | 50 ++++++++++++++++++++++++++++++++------
+ 1 file changed, 42 insertions(+), 8 deletions(-)
+
+--- a/drivers/media/i2c/imx708.c
++++ b/drivers/media/i2c/imx708.c
+@@ -20,6 +20,14 @@
+ #include <media/v4l2-fwnode.h>
+ #include <media/v4l2-mediabus.h>
+ 
++/*
++ * Parameter to adjust Quad Bayer re-mosaic broken line correction
++ * strength, used in full-resolution mode only. Set zero to disable.
++ */
++static int qbc_adjust = 2;
++module_param(qbc_adjust, int, 0644);
++MODULE_PARM_DESC(qbc_adjust, "Quad Bayer broken line correction strength [0,2-5]");
++
+ #define IMX708_REG_VALUE_08BIT		1
+ #define IMX708_REG_VALUE_16BIT		2
+ 
+@@ -99,11 +107,17 @@
+ 
+ /* HDR exposure ratio (long:med == med:short) */
+ #define IMX708_HDR_EXPOSURE_RATIO       4
+-#define IMX708_REG_MID_EXPOSURE	0x3116
+-#define IMX708_REG_SHT_EXPOSURE	0x0224
++#define IMX708_REG_MID_EXPOSURE		0x3116
++#define IMX708_REG_SHT_EXPOSURE		0x0224
+ #define IMX708_REG_MID_ANALOG_GAIN	0x3118
+ #define IMX708_REG_SHT_ANALOG_GAIN	0x0216
+ 
++/* QBC Re-mosaic broken line correction registers */
++#define IMX708_LPF_INTENSITY_EN		0xC428
++#define IMX708_LPF_INTENSITY_ENABLED	0x00
++#define IMX708_LPF_INTENSITY_DISABLED	0x01
++#define IMX708_LPF_INTENSITY		0xC429
++
+ /*
+  * Metadata buffer holds a variety of data, all sent with the same VC/DT (0x12).
+  * It comprises two scanlines (of up to 5760 bytes each, for 4608 pixels)
+@@ -171,6 +185,9 @@ struct imx708_mode {
+ 
+ 	/* HDR flag, used for checking if the current mode is HDR */
+ 	bool hdr;
++
++	/* Quad Bayer Re-mosaic flag */
++	bool remosaic;
+ };
+ 
+ /* Default PDAF pixel correction gains */
+@@ -363,8 +380,6 @@ static const struct imx708_reg mode_4608
+ 	{0x341f, 0x20},
+ 	{0x3420, 0x00},
+ 	{0x3421, 0xd8},
+-	{0xC428, 0x00},
+-	{0xC429, 0x04},
+ 	{0x3366, 0x00},
+ 	{0x3367, 0x00},
+ 	{0x3368, 0x00},
+@@ -677,7 +692,8 @@ static const struct imx708_mode supporte
+ 		.pixel_rate = 595200000,
+ 		.exposure_lines_min = 8,
+ 		.exposure_lines_step = 1,
+-		.hdr = false
++		.hdr = false,
++		.remosaic = true
+ 	},
+ 	{
+ 		/* regular 2x2 binned. */
+@@ -699,7 +715,8 @@ static const struct imx708_mode supporte
+ 		.pixel_rate = 585600000,
+ 		.exposure_lines_min = 4,
+ 		.exposure_lines_step = 2,
+-		.hdr = false
++		.hdr = false,
++		.remosaic = false
+ 	},
+ 	{
+ 		/* 2x2 binned and cropped for 720p. */
+@@ -721,7 +738,8 @@ static const struct imx708_mode supporte
+ 		.pixel_rate = 566400000,
+ 		.exposure_lines_min = 4,
+ 		.exposure_lines_step = 2,
+-		.hdr = false
++		.hdr = false,
++		.remosaic = false
+ 	},
+ };
+ 
+@@ -746,7 +764,8 @@ static const struct imx708_mode supporte
+ 		.pixel_rate = 777600000,
+ 		.exposure_lines_min = 8 * IMX708_HDR_EXPOSURE_RATIO * IMX708_HDR_EXPOSURE_RATIO,
+ 		.exposure_lines_step = 2 * IMX708_HDR_EXPOSURE_RATIO * IMX708_HDR_EXPOSURE_RATIO,
+-		.hdr = true
++		.hdr = true,
++		.remosaic = false
+ 	}
+ };
+ 
+@@ -1515,6 +1534,21 @@ static int imx708_start_streaming(struct
+ 		return ret;
+ 	}
+ 
++	/* Quad Bayer re-mosaic adjustments (for full-resolution mode only) */
++	if (imx708->mode->remosaic && qbc_adjust > 0) {
++		imx708_write_reg(imx708, IMX708_LPF_INTENSITY,
++				 IMX708_REG_VALUE_08BIT, qbc_adjust);
++		imx708_write_reg(imx708,
++				 IMX708_LPF_INTENSITY_EN,
++				 IMX708_REG_VALUE_08BIT,
++				 IMX708_LPF_INTENSITY_ENABLED);
++	} else {
++		imx708_write_reg(imx708,
++				 IMX708_LPF_INTENSITY_EN,
++				 IMX708_REG_VALUE_08BIT,
++				 IMX708_LPF_INTENSITY_DISABLED);
++	}
++
+ 	/* Apply customized values from user */
+ 	ret =  __v4l2_ctrl_handler_setup(imx708->sd.ctrl_handler);
+ 	if (ret)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1081-Revert-media-i2c-imx296-Add-2ms-delay-after-releasin.patch b/target/linux/bcm27xx/patches-6.1/950-1081-Revert-media-i2c-imx296-Add-2ms-delay-after-releasin.patch
new file mode 100644
index 0000000000..d66326e704
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1081-Revert-media-i2c-imx296-Add-2ms-delay-after-releasin.patch
@@ -0,0 +1,24 @@
+From a054d44b23e3619e4fa2d09139e76fd8cf3f8c7b Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Tue, 14 Nov 2023 16:03:54 +0000
+Subject: [PATCH] Revert "media: i2c: imx296: Add 2ms delay after releasing
+ standby"
+
+This reverts commit ecbc04aa0c2e7c8879764c9d2c769ecc74fd9093
+which duplicated 5fb3b300557d6a6902e7321f42fdabb8c09eef54
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/media/i2c/imx296.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+--- a/drivers/media/i2c/imx296.c
++++ b/drivers/media/i2c/imx296.c
+@@ -1031,7 +1031,6 @@ static int imx296_identify_model(struct
+ 			"failed to get sensor out of standby (%d)\n", ret);
+ 		return ret;
+ 	}
+-	usleep_range(2000, 5000);
+ 
+ 	usleep_range(2000, 5000);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1082-drivers-media-cfe-Don-t-confuse-MHz-and-Mbps.patch b/target/linux/bcm27xx/patches-6.1/950-1082-drivers-media-cfe-Don-t-confuse-MHz-and-Mbps.patch
new file mode 100644
index 0000000000..ea0ea396ba
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1082-drivers-media-cfe-Don-t-confuse-MHz-and-Mbps.patch
@@ -0,0 +1,96 @@
+From 65407c54fb4119e528b70b329448269657e0941e Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Wed, 8 Nov 2023 10:05:05 +0000
+Subject: [PATCH] drivers: media: cfe: Don't confuse MHz and Mbps
+
+The driver was interchaning these units when talking about link rate.
+Fix this to avoid confusion. Apart from the logging message change,
+there is no function change in this commit.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c  |  8 ++++----
+ drivers/media/platform/raspberrypi/rp1_cfe/dphy.c | 10 +++++-----
+ drivers/media/platform/raspberrypi/rp1_cfe/dphy.h |  2 +-
+ 3 files changed, 10 insertions(+), 10 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -983,7 +983,7 @@ static void cfe_buffer_queue(struct vb2_
+ 	spin_unlock_irqrestore(&cfe->state_lock, flags);
+ }
+ 
+-static u64 sensor_link_frequency(struct cfe_device *cfe)
++static u64 sensor_link_rate(struct cfe_device *cfe)
+ {
+ 	struct v4l2_mbus_framefmt *source_fmt;
+ 	struct v4l2_subdev_state *state;
+@@ -1028,11 +1028,11 @@ static u64 sensor_link_frequency(struct
+ 
+ 	/* x2 for DDR. */
+ 	link_freq *= 2;
+-	cfe_info("Using a link frequency of %lld Hz\n", link_freq);
++	cfe_info("Using a link rate of %lld Mbps\n", link_freq / (1000 * 1000));
+ 	return link_freq;
+ 
+ err:
+-	cfe_err("Unable to determine sensor link frequency, using 999 MHz\n");
++	cfe_err("Unable to determine sensor link rate, using 999 Mbps\n");
+ 	return 999 * 1000000UL;
+ }
+ 
+@@ -1104,7 +1104,7 @@ static int cfe_start_streaming(struct vb
+ 	}
+ 
+ 	cfe_dbg("Configuring CSI-2 block\n");
+-	cfe->csi2.dphy.dphy_freq = sensor_link_frequency(cfe) / 1000000UL;
++	cfe->csi2.dphy.dphy_rate = sensor_link_rate(cfe) / 1000000UL;
+ 	csi2_open_rx(&cfe->csi2);
+ 
+ 	cfe_dbg("Starting sensor streaming\n");
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/dphy.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/dphy.c
+@@ -96,7 +96,7 @@ static uint8_t dphy_transaction(struct d
+ 	return get_tstdout(dphy);
+ }
+ 
+-static void dphy_set_hsfreqrange(struct dphy_data *dphy, uint32_t freq_mhz)
++static void dphy_set_hsfreqrange(struct dphy_data *dphy, uint32_t mbps)
+ {
+ 	/* See Table 5-1 on page 65 of dphy databook */
+ 	static const u16 hsfreqrange_table[][2] = {
+@@ -116,11 +116,11 @@ static void dphy_set_hsfreqrange(struct
+ 	};
+ 	unsigned int i;
+ 
+-	if (freq_mhz < 80 || freq_mhz > 1500)
+-		dphy_err("DPHY: Frequency %u MHz out of range\n", freq_mhz);
++	if (mbps < 80 || mbps > 1500)
++		dphy_err("DPHY: Datarate %u Mbps out of range\n", mbps);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(hsfreqrange_table) - 1; i++) {
+-		if (freq_mhz <= hsfreqrange_table[i][0])
++		if (mbps <= hsfreqrange_table[i][0])
+ 			break;
+ 	}
+ 
+@@ -139,7 +139,7 @@ static void dphy_init(struct dphy_data *
+ 	set_tstclr(dphy, 0);
+ 	usleep_range(15, 20);
+ 
+-	dphy_set_hsfreqrange(dphy, dphy->dphy_freq);
++	dphy_set_hsfreqrange(dphy, dphy->dphy_rate);
+ 
+ 	usleep_range(5, 10);
+ 	dw_csi2_host_write(dphy, PHY_SHUTDOWNZ, 1);
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/dphy.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/dphy.h
+@@ -15,7 +15,7 @@ struct dphy_data {
+ 
+ 	void __iomem *base;
+ 
+-	u32 dphy_freq;
++	u32 dphy_rate;
+ 	u32 num_lanes;
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1083-overlays-imx296-Fix-cam-port-override-for-regulators.patch b/target/linux/bcm27xx/patches-6.1/950-1083-overlays-imx296-Fix-cam-port-override-for-regulators.patch
new file mode 100644
index 0000000000..1b6d2041f1
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1083-overlays-imx296-Fix-cam-port-override-for-regulators.patch
@@ -0,0 +1,25 @@
+From 6137fb168c08bd8c41c8421bf26f09ed29479f08 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Wed, 15 Nov 2023 08:25:11 +0000
+Subject: [PATCH] overlays: imx296: Fix cam port override for regulators
+
+The override was missing/incorrect for the regulator labels.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/imx296-overlay.dts | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/overlays/imx296-overlay.dts
++++ b/arch/arm/boot/dts/overlays/imx296-overlay.dts
+@@ -97,8 +97,9 @@
+ 		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
++		       <&reg_frag>, "target:0=",<&cam0_reg>,
+ 		       <&imx296>, "clocks:0=",<&cam0_clk>,
+-		       <&imx296>, "VANA-supply:0=",<&cam0_reg>;
++		       <&imx296>, "avdd-supply:0=",<&cam0_reg>;
+ 		clock-frequency = <&clk_over>, "clock-frequency:0";
+ 	};
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-1148-overlays-ov5647-Regularise-vcm-node-label-name.patch b/target/linux/bcm27xx/patches-6.1/950-1148-overlays-ov5647-Regularise-vcm-node-label-name.patch
new file mode 100644
index 0000000000..28017989a9
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1148-overlays-ov5647-Regularise-vcm-node-label-name.patch
@@ -0,0 +1,32 @@
+From 7443b602cb503b42dd0ae8e957e26decb420d632 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 20 Nov 2023 10:15:15 +0000
+Subject: [PATCH] overlays: ov5647: Regularise vcm node label name
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/ov5647-overlay.dts | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/ov5647-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ov5647-overlay.dts
+@@ -15,7 +15,7 @@
+ 
+ 			#include "ov5647.dtsi"
+ 
+-			vcm: ad5398@c {
++			vcm_node: ad5398@c {
+ 				compatible = "adi,ad5398";
+ 				reg = <0x0c>;
+ 				status = "disabled";
+@@ -78,8 +78,8 @@
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+ 		       <&cam_node>, "avdd-supply:0=",<&cam0_reg>;
+-		vcm = <&vcm>, "status=okay",
+-		      <&cam_node>,"lens-focus:0=", <&vcm>;
++		vcm = <&vcm_node>, "status=okay",
++		       <&cam_node>,"lens-focus:0=", <&vcm_node>;
+ 	};
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1149-overlays-ov5647-cam0-mode-should-use-cam0_reg.patch b/target/linux/bcm27xx/patches-6.1/950-1149-overlays-ov5647-cam0-mode-should-use-cam0_reg.patch
new file mode 100644
index 0000000000..f079756133
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1149-overlays-ov5647-cam0-mode-should-use-cam0_reg.patch
@@ -0,0 +1,27 @@
+From d484bef133af9c87d64899fc1e1d0be2a7c7785b Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 20 Nov 2023 10:16:10 +0000
+Subject: [PATCH] overlays: ov5647: cam0 mode should use cam0_reg
+
+When the cam0 parameter is used, the vcm should be updated to refer to
+the cam0 regulator.
+
+See: https://github.com/raspberrypi/linux/issues/5722
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/ov5647-overlay.dts | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/overlays/ov5647-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ov5647-overlay.dts
+@@ -77,7 +77,8 @@
+ 		       <&reg_frag>, "target:0=",<&cam0_reg>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+-		       <&cam_node>, "avdd-supply:0=",<&cam0_reg>;
++		       <&cam_node>, "avdd-supply:0=",<&cam0_reg>,
++		       <&vcm_node>, "VANA-supply:0=",<&cam0_reg>;
+ 		vcm = <&vcm_node>, "status=okay",
+ 		       <&cam_node>,"lens-focus:0=", <&vcm_node>;
+ 	};
diff --git a/target/linux/bcm27xx/patches-6.1/950-1150-w1-Disable-kernel-log-spam.patch b/target/linux/bcm27xx/patches-6.1/950-1150-w1-Disable-kernel-log-spam.patch
new file mode 100644
index 0000000000..457a0e9ec5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1150-w1-Disable-kernel-log-spam.patch
@@ -0,0 +1,25 @@
+From 0924b74687bd195b98f223814ff88b4227654e85 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 20 Nov 2023 14:46:14 +0000
+Subject: [PATCH] w1: Disable kernel log spam
+
+See: https://forums.raspberrypi.com/viewtopic.php?p=2159344
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/w1/w1.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/w1/w1.c
++++ b/drivers/w1/w1.c
+@@ -742,8 +742,10 @@ int w1_attach_slave_device(struct w1_mas
+ 	atomic_set(&sl->refcnt, 1);
+ 	atomic_inc(&sl->master->refcnt);
+ 	dev->slave_count++;
++#if 0
+ 	dev_info(&dev->dev, "Attaching one wire slave %02x.%012llx crc %02x\n",
+ 		  rn->family, (unsigned long long)rn->id, rn->crc);
++#endif
+ 
+ 	/* slave modules need to be loaded in a context with unlocked mutex */
+ 	mutex_unlock(&dev->mutex);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1151-include-uapi-mbus-Add-a-media-bus-format-enum-for-16.patch b/target/linux/bcm27xx/patches-6.1/950-1151-include-uapi-mbus-Add-a-media-bus-format-enum-for-16.patch
new file mode 100644
index 0000000000..b8933bcbb6
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1151-include-uapi-mbus-Add-a-media-bus-format-enum-for-16.patch
@@ -0,0 +1,21 @@
+From be8ca764e0530ec8ac18ca03c49e3cda13562d3a Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Thu, 16 Nov 2023 14:21:05 +0000
+Subject: [PATCH] include: uapi: mbus: Add a media bus format enum for 16-bit
+ mono output
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ include/uapi/linux/media-bus-format.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/include/uapi/linux/media-bus-format.h
++++ b/include/uapi/linux/media-bus-format.h
+@@ -95,6 +95,7 @@
+ #define MEDIA_BUS_FMT_YUYV12_2X12		0x201e
+ #define MEDIA_BUS_FMT_YVYU12_2X12		0x201f
+ #define MEDIA_BUS_FMT_Y14_1X14			0x202d
++#define MEDIA_BUS_FMT_Y16_1X16			0x202e
+ #define MEDIA_BUS_FMT_UYVY8_1X16		0x200f
+ #define MEDIA_BUS_FMT_VYUY8_1X16		0x2010
+ #define MEDIA_BUS_FMT_YUYV8_1X16		0x2011
diff --git a/target/linux/bcm27xx/patches-6.1/950-1152-include-uapi-v4l2-Add-additional-pixel-formats-for-u.patch b/target/linux/bcm27xx/patches-6.1/950-1152-include-uapi-v4l2-Add-additional-pixel-formats-for-u.patch
new file mode 100644
index 0000000000..56855184be
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1152-include-uapi-v4l2-Add-additional-pixel-formats-for-u.patch
@@ -0,0 +1,73 @@
+From 9abab2e8e5cfbeae6e1b33cc3a5ed773e4e31774 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Thu, 16 Nov 2023 14:25:39 +0000
+Subject: [PATCH] include: uapi: v4l2: Add additional pixel formats for use
+ with PiSP
+
+Add the following formats:
+
+- V4L2_PIX_FMT_RGB48/V4L2_PIX_FMT_BGR48
+  48-bit RGB where each colour sample is 16-bits.
+
+- V4L2_PIX_FMT_PISP_COMP1_MONO/V4L2_PIX_FMT_PISP_COMP2_MONO
+  16-bit to 8-bit pisp compressed monochrome pixel format.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/v4l2-core/v4l2-ioctl.c | 8 ++++++--
+ include/uapi/linux/videodev2.h       | 6 ++++++
+ 2 files changed, 12 insertions(+), 2 deletions(-)
+
+--- a/drivers/media/v4l2-core/v4l2-ioctl.c
++++ b/drivers/media/v4l2-core/v4l2-ioctl.c
+@@ -1304,6 +1304,8 @@ static void v4l_fill_fmtdesc(struct v4l2
+ 	case V4L2_PIX_FMT_BGRX32:	descr = "32-bit XBGR 8-8-8-8"; break;
+ 	case V4L2_PIX_FMT_RGBA32:	descr = "32-bit RGBA 8-8-8-8"; break;
+ 	case V4L2_PIX_FMT_RGBX32:	descr = "32-bit RGBX 8-8-8-8"; break;
++	case V4L2_PIX_FMT_BGR48:	descr = "48-bit BGR 16-16-16"; break;
++	case V4L2_PIX_FMT_RGB48:	descr = "48-bit RGB 16-16-16"; break;
+ 	case V4L2_PIX_FMT_GREY:		descr = "8-bit Greyscale"; break;
+ 	case V4L2_PIX_FMT_Y4:		descr = "4-bit Greyscale"; break;
+ 	case V4L2_PIX_FMT_Y6:		descr = "6-bit Greyscale"; break;
+@@ -1510,11 +1512,13 @@ static void v4l_fill_fmtdesc(struct v4l2
+ 		case V4L2_PIX_FMT_PISP_COMP1_RGGB:
+ 		case V4L2_PIX_FMT_PISP_COMP1_GRBG:
+ 		case V4L2_PIX_FMT_PISP_COMP1_GBRG:
+-		case V4L2_PIX_FMT_PISP_COMP1_BGGR: descr = "PiSP Bayer Comp 1"; break;
++		case V4L2_PIX_FMT_PISP_COMP1_BGGR:
++		case V4L2_PIX_FMT_PISP_COMP1_MONO: descr = "PiSP Bayer Comp 1"; break;
+ 		case V4L2_PIX_FMT_PISP_COMP2_RGGB:
+ 		case V4L2_PIX_FMT_PISP_COMP2_GRBG:
+ 		case V4L2_PIX_FMT_PISP_COMP2_GBRG:
+-		case V4L2_PIX_FMT_PISP_COMP2_BGGR: descr = "PiSP Bayer Comp 2"; break;
++		case V4L2_PIX_FMT_PISP_COMP2_BGGR:
++		case V4L2_PIX_FMT_PISP_COMP2_MONO: descr = "PiSP Bayer Comp 2"; break;
+ 		default:
+ 			if (fmt->description[0])
+ 				return;
+--- a/include/uapi/linux/videodev2.h
++++ b/include/uapi/linux/videodev2.h
+@@ -582,6 +582,10 @@ struct v4l2_pix_format {
+ #define V4L2_PIX_FMT_ARGB32  v4l2_fourcc('B', 'A', '2', '4') /* 32  ARGB-8-8-8-8  */
+ #define V4L2_PIX_FMT_XRGB32  v4l2_fourcc('B', 'X', '2', '4') /* 32  XRGB-8-8-8-8  */
+ 
++/* RGB formats (6 bytes per pixel) */
++#define V4L2_PIX_FMT_BGR48 v4l2_fourcc('B', 'G', 'R', '6') /* 16  BGR-16-16-16 */
++#define V4L2_PIX_FMT_RGB48 v4l2_fourcc('R', 'G', 'B', '6') /* 16  RGB-16-16-16 */
++
+ /* Grey formats */
+ #define V4L2_PIX_FMT_GREY    v4l2_fourcc('G', 'R', 'E', 'Y') /*  8  Greyscale     */
+ #define V4L2_PIX_FMT_Y4      v4l2_fourcc('Y', '0', '4', ' ') /*  4  Greyscale     */
+@@ -799,10 +803,12 @@ struct v4l2_pix_format {
+ #define V4L2_PIX_FMT_PISP_COMP1_GRBG	v4l2_fourcc('P', 'C', '1', 'G')
+ #define V4L2_PIX_FMT_PISP_COMP1_GBRG	v4l2_fourcc('P', 'C', '1', 'g')
+ #define V4L2_PIX_FMT_PISP_COMP1_BGGR	v4l2_fourcc('P', 'C', '1', 'B')
++#define V4L2_PIX_FMT_PISP_COMP1_MONO	v4l2_fourcc('P', 'C', '1', 'M')
+ #define V4L2_PIX_FMT_PISP_COMP2_RGGB	v4l2_fourcc('P', 'C', '2', 'R')
+ #define V4L2_PIX_FMT_PISP_COMP2_GRBG	v4l2_fourcc('P', 'C', '2', 'G')
+ #define V4L2_PIX_FMT_PISP_COMP2_GBRG	v4l2_fourcc('P', 'C', '2', 'g')
+ #define V4L2_PIX_FMT_PISP_COMP2_BGGR	v4l2_fourcc('P', 'C', '2', 'B')
++#define V4L2_PIX_FMT_PISP_COMP2_MONO	v4l2_fourcc('P', 'C', '2', 'M')
+ 
+ /* SDR formats - used only for Software Defined Radio devices */
+ #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
diff --git a/target/linux/bcm27xx/patches-6.1/950-1153-drivers-media-cfe-Add-16-bit-and-compressed-mono-for.patch b/target/linux/bcm27xx/patches-6.1/950-1153-drivers-media-cfe-Add-16-bit-and-compressed-mono-for.patch
new file mode 100644
index 0000000000..607f23eeb3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1153-drivers-media-cfe-Add-16-bit-and-compressed-mono-for.patch
@@ -0,0 +1,52 @@
+From 88d06a674009ad5b77234537527a800e6e0e88a3 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Thu, 16 Nov 2023 14:28:55 +0000
+Subject: [PATCH] drivers: media: cfe: Add 16-bit and compressed mono format
+ support
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe_fmts.h  | 14 ++++++++++----
+ 1 file changed, 10 insertions(+), 4 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
+@@ -249,28 +249,34 @@ static const struct cfe_fmt formats[] =
+ 		.code = MEDIA_BUS_FMT_Y10_1X10,
+ 		.depth = 10,
+ 		.csi_dt = 0x2b,
+-		.remap = { V4L2_PIX_FMT_Y16 },
++		.remap = { V4L2_PIX_FMT_Y16, V4L2_PIX_FMT_PISP_COMP1_MONO },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_Y12P,
+ 		.code = MEDIA_BUS_FMT_Y12_1X12,
+ 		.depth = 12,
+ 		.csi_dt = 0x2c,
+-		.remap = { V4L2_PIX_FMT_Y16 },
++		.remap = { V4L2_PIX_FMT_Y16, V4L2_PIX_FMT_PISP_COMP1_MONO },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_Y14P,
+ 		.code = MEDIA_BUS_FMT_Y14_1X14,
+ 		.depth = 14,
+ 		.csi_dt = 0x2d,
+-		.remap = { V4L2_PIX_FMT_Y16 },
++		.remap = { V4L2_PIX_FMT_Y16, V4L2_PIX_FMT_PISP_COMP1_MONO },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_Y16,
++		.code = MEDIA_BUS_FMT_Y16_1X16,
+ 		.depth = 16,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
+ 	},
+-
++	{
++		.fourcc = V4L2_PIX_FMT_PISP_COMP1_MONO,
++		.code = MEDIA_BUS_FMT_Y16_1X16,
++		.depth = 8,
++		.flags = CFE_FORMAT_FLAG_FE_OUT,
++	},
+ 	/* Embedded data format */
+ 	{
+ 		.fourcc = V4L2_META_FMT_SENSOR_DATA,
diff --git a/target/linux/bcm27xx/patches-6.1/950-1154-drivers-media-pisp_be-Add-mono-and-48-bit-RGB-pixel-.patch b/target/linux/bcm27xx/patches-6.1/950-1154-drivers-media-pisp_be-Add-mono-and-48-bit-RGB-pixel-.patch
new file mode 100644
index 0000000000..2ea4abd112
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1154-drivers-media-pisp_be-Add-mono-and-48-bit-RGB-pixel-.patch
@@ -0,0 +1,72 @@
+From 2affda8d2b172aa0fd22778983d983fc9522e621 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Thu, 16 Nov 2023 14:29:47 +0000
+Subject: [PATCH] drivers: media: pisp_be: Add mono and 48-bit RGB pixel format
+ support
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ .../raspberrypi/pisp_be/pisp_be_formats.h     | 45 +++++++++++++++++++
+ 1 file changed, 45 insertions(+)
+
+--- a/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
++++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
+@@ -234,6 +234,24 @@ static const struct pisp_be_format suppo
+ 		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
+ 		.colorspace_default = V4L2_COLORSPACE_SRGB,
+ 	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_RGB48,
++		.align		    = 64,
++		.bit_depth	    = 48,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SRGB,
++	},
++	{
++		.fourcc		    = V4L2_PIX_FMT_BGR48,
++		.align		    = 64,
++		.bit_depth	    = 48,
++		.plane_factor	    = { P3(1.0) },
++		.num_planes	    = 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
++		.colorspace_default = V4L2_COLORSPACE_SRGB,
++	},
+ 	/* Bayer formats - 8-bit */
+ 	{
+ 		.fourcc		    = V4L2_PIX_FMT_SRGGB8,
+@@ -457,6 +475,33 @@ static const struct pisp_be_format suppo
+ 		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
+ 		.colorspace_default = V4L2_COLORSPACE_RAW,
+ 	},
++	/* Greyscale Formats */
++	{
++		.fourcc		= V4L2_PIX_FMT_GREY,
++		.bit_depth	= 8,
++		.align		= 32,
++		.num_planes	= 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		= V4L2_PIX_FMT_Y16,
++		.bit_depth	= 16,
++		.align		= 32,
++		.plane_factor	= { P3(1.0) },
++		.num_planes	= 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
++	{
++		.fourcc		= V4L2_PIX_FMT_PISP_COMP1_MONO,
++		.bit_depth	= 8,
++		.align		= 32,
++		.plane_factor	= { P3(1.0) },
++		.num_planes	= 1,
++		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
++		.colorspace_default = V4L2_COLORSPACE_RAW,
++	},
+ 	/* Opaque BE format for HW verification. */
+ 	{
+ 		.fourcc		    = V4L2_PIX_FMT_RPI_BE,
diff --git a/target/linux/bcm27xx/patches-6.1/950-1155-ASoC-dwc-Remove-check-in-set_bclk_ratio-handling.patch b/target/linux/bcm27xx/patches-6.1/950-1155-ASoC-dwc-Remove-check-in-set_bclk_ratio-handling.patch
new file mode 100644
index 0000000000..88bb61a4c3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1155-ASoC-dwc-Remove-check-in-set_bclk_ratio-handling.patch
@@ -0,0 +1,32 @@
+From 52545628c07be2fd1c9df598a17130d92f12da23 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 20 Nov 2023 15:17:34 +0000
+Subject: [PATCH] ASoC: dwc: Remove check in set_bclk_ratio handling
+
+A check added to dw_i2s_set_bclk_ratio that the data format is
+consistent with the ratio seems reasonable but breaks when the
+ratio is changed before the format. Remove the check - it is
+unnecessary.
+
+See: https://github.com/raspberrypi/linux/issues/5724
+Fixes: 9c6694c24f26 ("ASOC: dwc: Fix 16-bit audio handling")
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 3 ---
+ 1 file changed, 3 deletions(-)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -427,11 +427,8 @@ static int dw_i2s_set_bclk_ratio(struct
+ 				 unsigned int ratio)
+ {
+ 	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+-	struct i2s_clk_config_data *config = &dev->config;
+ 
+ 	dev_dbg(dev->dev, "%s(%d)\n", __func__, ratio);
+-	if (ratio < config->data_width * 2)
+-		return -EINVAL;
+ 
+ 	switch (ratio) {
+ 	case 32:
diff --git a/target/linux/bcm27xx/patches-6.1/950-1159-overlays-README-Fix-cut-and-paste-errors.patch b/target/linux/bcm27xx/patches-6.1/950-1159-overlays-README-Fix-cut-and-paste-errors.patch
new file mode 100644
index 0000000000..30cc82b0cd
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1159-overlays-README-Fix-cut-and-paste-errors.patch
@@ -0,0 +1,39 @@
+From 5a0aa24b8ff58ceaf98c62670156bef7f48ed32b Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 21 Nov 2023 15:08:38 +0000
+Subject: [PATCH] overlays: README: Fix cut-and-paste errors
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -1673,7 +1673,7 @@ Params: 24db_digital_gain       Allow ga
+                                 responsibility of the user to ensure that
+                                 the Digital volume control is set to a value
+                                 that does not result in clipping/distortion!)
+-        slave                   Force DAC+ Pro into slave mode, using Pi as
++        slave                   Force AMP100 into slave mode, using Pi as
+                                 master for bit clock and frame clock.
+         leds_off                If set to 'true' the onboard indicator LEDs
+                                 are switched off at all times.
+@@ -1713,7 +1713,7 @@ Params: 24db_digital_gain       Allow ga
+                                 responsibility of the user to ensure that
+                                 the Digital volume control is set to a value
+                                 that does not result in clipping/distortion!)
+-        slave                   Force DAC+ Pro into slave mode, using Pi as
++        slave                   Force DAC+ into slave mode, using Pi as
+                                 master for bit clock and frame clock.
+         leds_off                If set to 'true' the onboard indicator LEDs
+                                 are switched off at all times.
+@@ -1736,7 +1736,7 @@ Params: 24db_digital_gain       Allow ga
+                                 responsibility of the user to ensure that
+                                 the Digital volume control is set to a value
+                                 that does not result in clipping/distortion!)
+-        slave                   Force DAC+ Pro into slave mode, using Pi as
++        slave                   Force DAC+ADC into slave mode, using Pi as
+                                 master for bit clock and frame clock.
+         leds_off                If set to 'true' the onboard indicator LEDs
+                                 are switched off at all times.
diff --git a/target/linux/bcm27xx/patches-6.1/950-1160-media-i2c-ov7251-Switch-from-V4L2_CID_GAIN-to-V4L2_C.patch b/target/linux/bcm27xx/patches-6.1/950-1160-media-i2c-ov7251-Switch-from-V4L2_CID_GAIN-to-V4L2_C.patch
new file mode 100644
index 0000000000..36565bf2d6
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1160-media-i2c-ov7251-Switch-from-V4L2_CID_GAIN-to-V4L2_C.patch
@@ -0,0 +1,38 @@
+From e60fbc34aa98b3ba2c9338ad628fc8d8137e9065 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Tue, 14 Nov 2023 18:36:19 +0000
+Subject: [PATCH] media/i2c: ov7251: Switch from V4L2_CID_GAIN to
+ V4L2_CID_ANALOGUE_GAIN
+
+The mainline driver has implemented analogue gain using the control
+V4L2_CID_GAIN instead of V4L2_CID_ANALOGUE_GAIN.
+
+libcamera requires V4L2_CID_ANALOGUE_GAIN, and therefore fails.
+
+Update the driver to use V4L2_CID_ANALOGUE_GAIN.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/media/i2c/ov7251.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/media/i2c/ov7251.c
++++ b/drivers/media/i2c/ov7251.c
+@@ -1063,7 +1063,7 @@ static int ov7251_s_ctrl(struct v4l2_ctr
+ 	case V4L2_CID_EXPOSURE:
+ 		ret = ov7251_set_exposure(ov7251, ctrl->val);
+ 		break;
+-	case V4L2_CID_GAIN:
++	case V4L2_CID_ANALOGUE_GAIN:
+ 		ret = ov7251_set_gain(ov7251, ctrl->val);
+ 		break;
+ 	case V4L2_CID_TEST_PATTERN:
+@@ -1588,7 +1588,7 @@ static int ov7251_init_ctrls(struct ov72
+ 	ov7251->exposure = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,
+ 					     V4L2_CID_EXPOSURE, 1, 32, 1, 32);
+ 	ov7251->gain = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,
+-					 V4L2_CID_GAIN, 16, 1023, 1, 16);
++					 V4L2_CID_ANALOGUE_GAIN, 16, 1023, 1, 16);
+ 	v4l2_ctrl_new_std_menu_items(&ov7251->ctrls, &ov7251_ctrl_ops,
+ 				     V4L2_CID_TEST_PATTERN,
+ 				     ARRAY_SIZE(ov7251_test_pattern_menu) - 1,
diff --git a/target/linux/bcm27xx/patches-6.1/950-1161-drm-vc4-Drop-planes-that-are-completely-off-screen.patch b/target/linux/bcm27xx/patches-6.1/950-1161-drm-vc4-Drop-planes-that-are-completely-off-screen.patch
new file mode 100644
index 0000000000..8cdbb51d55
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1161-drm-vc4-Drop-planes-that-are-completely-off-screen.patch
@@ -0,0 +1,63 @@
+From 444884f7b62bfe5ef313dd1d47f81a40e695ab0b Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 17 Nov 2023 14:43:44 +0000
+Subject: [PATCH] drm/vc4: Drop planes that are completely off-screen
+
+It is permitted for a plane to be configured such that none
+of it is on-screen via either negative dest rectangle X,Y
+offset, or just an offset that is greater than the crtc
+dimensions.
+
+These planes were resized via drm_atomic_helper_check_plane_state
+such that the source rectangle had a zero width or height, but
+they still created a dlist entry even though they contributed
+no pixels. In the case of vc6_plane_mode_set, that it could result
+in negative values being written into registers, which caused
+incorrect behaviour.
+
+Drop planes that result in a source width or height of 0 pixels
+to avoid the incorrect rendering.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_plane.c | 15 +++++++++++++++
+ 1 file changed, 15 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -1108,6 +1108,12 @@ static int vc4_plane_mode_set(struct drm
+ 	width = vc4_state->src_w[0] >> 16;
+ 	height = vc4_state->src_h[0] >> 16;
+ 
++	if (!width || !height) {
++		/* 0 source size probably means the plane is offscreen */
++		vc4_state->dlist_initialized = 1;
++		return 0;
++	}
++
+ 	/* SCL1 is used for Cb/Cr scaling of planar formats.  For RGB
+ 	 * and 4:4:4, scl1 should be set to scl0 so both channels of
+ 	 * the scaler do the same thing.  For YUV, the Y plane needs
+@@ -1623,6 +1629,12 @@ static int vc6_plane_mode_set(struct drm
+ 	width = vc4_state->src_w[0] >> 16;
+ 	height = vc4_state->src_h[0] >> 16;
+ 
++	if (!width || !height) {
++		/* 0 source size probably means the plane is offscreen */
++		vc4_state->dlist_initialized = 1;
++		return 0;
++	}
++
+ 	/* SCL1 is used for Cb/Cr scaling of planar formats.  For RGB
+ 	 * and 4:4:4, scl1 should be set to scl0 so both channels of
+ 	 * the scaler do the same thing.  For YUV, the Y plane needs
+@@ -1994,6 +2006,9 @@ int vc4_plane_atomic_check(struct drm_pl
+ 	if (ret)
+ 		return ret;
+ 
++	if (!vc4_state->src_w[0] || !vc4_state->src_h[0])
++		return 0;
++
+ 	ret = vc4_plane_allocate_lbm(new_plane_state);
+ 	if (ret)
+ 		return ret;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1162-drm-bridge-display-connector-Select-DRM_KMS_HELPER.patch b/target/linux/bcm27xx/patches-6.1/950-1162-drm-bridge-display-connector-Select-DRM_KMS_HELPER.patch
new file mode 100644
index 0000000000..270975e587
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1162-drm-bridge-display-connector-Select-DRM_KMS_HELPER.patch
@@ -0,0 +1,29 @@
+From 91ad217f93232fb3a0b52487fec67860fb29e93a Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 17 Nov 2023 14:50:11 +0000
+Subject: [PATCH] drm/bridge: display-connector: Select DRM_KMS_HELPER
+
+Commit 7cd70656d128 ("drm/bridge: display-connector: implement
+bus fmts callbacks") added use of drm_atomic_helper_bridge_*
+functions, but didn't select the dependency of DRM_KMS_HELPER.
+If nothing else selected that dependency it resulted in a
+build failure.
+
+Select the missing dependency.
+
+Fixes: 7cd70656d128 ("drm/bridge: display-connector: implement bus fmts callbacks")
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/bridge/Kconfig | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/gpu/drm/bridge/Kconfig
++++ b/drivers/gpu/drm/bridge/Kconfig
+@@ -67,6 +67,7 @@ config DRM_CROS_EC_ANX7688
+ config DRM_DISPLAY_CONNECTOR
+ 	tristate "Display connector support"
+ 	depends on OF
++	select DRM_KMS_HELPER
+ 	help
+ 	  Driver for display connectors with support for DDC and hot-plug
+ 	  detection. Most display controllers handle display connectors
diff --git a/target/linux/bcm27xx/patches-6.1/950-1163-drm-vc4-Free-the-dlist-alloc-immediately-if-it-never.patch b/target/linux/bcm27xx/patches-6.1/950-1163-drm-vc4-Free-the-dlist-alloc-immediately-if-it-never.patch
new file mode 100644
index 0000000000..49359362fe
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1163-drm-vc4-Free-the-dlist-alloc-immediately-if-it-never.patch
@@ -0,0 +1,56 @@
+From 51712a6493bf8824419f51ca7950e7d88f48b699 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 22 Nov 2023 18:36:54 +0000
+Subject: [PATCH] drm: vc4: Free the dlist alloc immediately if it never hit
+ the hw
+
+atomic_check creates a state, and allocates the dlist memory for
+it such that atomic_flush can not fail.
+
+On destroy that dlist allocation was being put in the stale list,
+even though it had never been programmed into the hardware,
+therefore doing lots of atomic_checks could consume all the dlist
+memory and fail.
+
+If the dlist has never been programmed into the hardware, then
+free it immediately.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h | 1 +
+ drivers/gpu/drm/vc4/vc4_hvs.c | 6 +++++-
+ 2 files changed, 6 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -696,6 +696,7 @@ struct vc4_hvs_dlist_allocation {
+ 	struct drm_mm_node mm_node;
+ 	unsigned int channel;
+ 	u8 target_frame_count;
++	bool dlist_programmed;
+ };
+ 
+ struct vc4_crtc_state {
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -697,8 +697,11 @@ void vc4_hvs_mark_dlist_entry_stale(stru
+ 	 * Kunit tests run with a mock device and we consider any hardware
+ 	 * access a test failure. Let's free the dlist allocation right away if
+ 	 * we're running under kunit, we won't risk a dlist corruption anyway.
++	 *
++	 * Likewise if the allocation was only checked and never programmed, we
++	 * can destroy the allocation immediately.
+ 	 */
+-	if (kunit_get_current_test()) {
++	if (kunit_get_current_test() || !alloc->dlist_programmed) {
+ 		spin_lock_irqsave(&hvs->mm_lock, flags);
+ 		vc4_hvs_free_dlist_entry_locked(hvs, alloc);
+ 		spin_unlock_irqrestore(&hvs->mm_lock, flags);
+@@ -1201,6 +1204,7 @@ static void vc4_hvs_install_dlist(struct
+ 		return;
+ 
+ 	WARN_ON(!vc4_state->mm);
++	vc4_state->mm->dlist_programmed = true;
+ 
+ 	if (vc4->gen >= VC4_GEN_6)
+ 		HVS_WRITE(SCALER6_DISPX_LPTRS(vc4_state->assigned_channel),
diff --git a/target/linux/bcm27xx/patches-6.1/950-1164-input-edt-ft5x06-Include-I2C-details-in-names-for-th.patch b/target/linux/bcm27xx/patches-6.1/950-1164-input-edt-ft5x06-Include-I2C-details-in-names-for-th.patch
new file mode 100644
index 0000000000..131e502406
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1164-input-edt-ft5x06-Include-I2C-details-in-names-for-th.patch
@@ -0,0 +1,48 @@
+From 2a6c3115f4142e23ca10c984d7f65ac8fb901cc2 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 8 Nov 2023 15:50:39 +0000
+Subject: [PATCH] input: edt-ft5x06: Include I2C details in names for the
+ devices
+
+libinput uses the input device name alone. If you have two
+identical input devices, then there is no way to differentiate
+between them, and in the case of touchscreens that means no
+way to associate them with the appropriate display device.
+
+Add the I2C bus and address to the start of the input device
+name so that the name is always unique within the system.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/input/touchscreen/edt-ft5x06.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/input/touchscreen/edt-ft5x06.c
++++ b/drivers/input/touchscreen/edt-ft5x06.c
+@@ -67,6 +67,7 @@
+ #define TOUCH_EVENT_RESERVED		0x03
+ 
+ #define EDT_NAME_LEN			23
++#define EDT_NAME_PREFIX_LEN		8
+ #define EDT_SWITCH_MODE_RETRIES		10
+ #define EDT_SWITCH_MODE_DELAY		5 /* msec */
+ #define EDT_RAW_DATA_RETRIES		100
+@@ -134,7 +135,7 @@ struct edt_ft5x06_ts_data {
+ 	int max_support_points;
+ 	unsigned int known_ids;
+ 
+-	char name[EDT_NAME_LEN];
++	char name[EDT_NAME_PREFIX_LEN + EDT_NAME_LEN];
+ 	char fw_version[EDT_NAME_LEN];
+ 	int init_td_status;
+ 
+@@ -965,6 +966,9 @@ static int edt_ft5x06_ts_identify(struct
+ 	char *model_name = tsdata->name;
+ 	char *fw_version = tsdata->fw_version;
+ 
++	snprintf(model_name, EDT_NAME_PREFIX_LEN, "%s ", dev_name(&client->dev));
++	model_name += strlen(model_name);
++
+ 	/* see what we find if we assume it is a M06 *
+ 	 * if we get less than EDT_NAME_LEN, we don't want
+ 	 * to have garbage in there
diff --git a/target/linux/bcm27xx/patches-6.1/950-1165-input-goodix-Include-I2C-details-in-names-for-the-de.patch b/target/linux/bcm27xx/patches-6.1/950-1165-input-goodix-Include-I2C-details-in-names-for-the-de.patch
new file mode 100644
index 0000000000..4b529e66f5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1165-input-goodix-Include-I2C-details-in-names-for-the-de.patch
@@ -0,0 +1,52 @@
+From a420bbde05f8a6691b0c3e0830092e443365aaa7 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 8 Nov 2023 16:20:27 +0000
+Subject: [PATCH] input: goodix: Include I2C details in names for the devices
+
+libinput uses the input device name alone. If you have two
+identical input devices, then there is no way to differentiate
+between them, and in the case of touchscreens that means no
+way to associate them with the appropriate display device.
+
+Add the I2C bus and address to the start of the input device
+name so that the name is always unique within the system.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/input/touchscreen/goodix.c | 5 ++++-
+ drivers/input/touchscreen/goodix.h | 3 +++
+ 2 files changed, 7 insertions(+), 1 deletion(-)
+
+--- a/drivers/input/touchscreen/goodix.c
++++ b/drivers/input/touchscreen/goodix.c
+@@ -1211,7 +1211,10 @@ static int goodix_configure_dev(struct g
+ 		return -ENOMEM;
+ 	}
+ 
+-	ts->input_dev->name = "Goodix Capacitive TouchScreen";
++	snprintf(ts->name, GOODIX_NAME_MAX_LEN, "%s Goodix Capacitive TouchScreen",
++		 dev_name(&ts->client->dev));
++
++	ts->input_dev->name = ts->name;
+ 	ts->input_dev->phys = "input/ts";
+ 	ts->input_dev->id.bustype = BUS_I2C;
+ 	ts->input_dev->id.vendor = 0x0416;
+--- a/drivers/input/touchscreen/goodix.h
++++ b/drivers/input/touchscreen/goodix.h
+@@ -57,6 +57,8 @@
+ #define GOODIX_CONFIG_MAX_LENGTH		240
+ #define GOODIX_MAX_KEYS				7
+ 
++#define GOODIX_NAME_MAX_LEN			38
++
+ enum goodix_irq_pin_access_method {
+ 	IRQ_PIN_ACCESS_NONE,
+ 	IRQ_PIN_ACCESS_GPIO,
+@@ -91,6 +93,7 @@ struct goodix_ts_data {
+ 	enum gpiod_flags gpiod_rst_flags;
+ 	char id[GOODIX_ID_MAX_LEN + 1];
+ 	char cfg_name[64];
++	char name[GOODIX_NAME_MAX_LEN];
+ 	u16 version;
+ 	bool reset_controller_at_probe;
+ 	bool load_cfg_from_disk;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1166-drm-vc4-Block-swiotlb-bounce-buffers-being-imported-.patch b/target/linux/bcm27xx/patches-6.1/950-1166-drm-vc4-Block-swiotlb-bounce-buffers-being-imported-.patch
new file mode 100644
index 0000000000..c40b77c957
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1166-drm-vc4-Block-swiotlb-bounce-buffers-being-imported-.patch
@@ -0,0 +1,84 @@
+From a984fda6b2c24dbf1ca21924f99c8f9418f5765e Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 22 Nov 2023 19:17:44 +0000
+Subject: [PATCH] drm: vc4: Block swiotlb bounce buffers being imported as
+ dmabuf
+
+The dmabuf import already checks that the backing buffer is contiguous
+and rejects it if it isn't. vc4 also requires that the buffer is
+in the bottom 1GB of RAM, and this is all correctly defined via
+dma-ranges.
+
+However the kernel silently uses swiotlb to bounce dma buffers
+around if they are in the wrong region. This relies on dma sync
+functions to be called in order to copy the data to/from the
+bounce buffer.
+
+DRM is based on all memory allocations being coherent with the
+GPU so that any updates to a framebuffer will be acted on without
+the need for any additional update. This is fairly fundamentally
+incompatible with needing to call dma_sync_ to handle the bounce
+buffer copies, and therefore we have to detect and reject mappings
+that use bounce buffers.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_drv.c | 26 ++++++++++++++++++++++++--
+ 1 file changed, 24 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.c
++++ b/drivers/gpu/drm/vc4/vc4_drv.c
+@@ -29,6 +29,7 @@
+ #include <linux/of_platform.h>
+ #include <linux/platform_device.h>
+ #include <linux/pm_runtime.h>
++#include <linux/dma-direct.h>
+ 
+ #include <drm/drm_aperture.h>
+ #include <drm/drm_atomic_helper.h>
+@@ -175,6 +176,19 @@ static void vc4_close(struct drm_device
+ 	kfree(vc4file);
+ }
+ 
++struct drm_gem_object *
++vc4_prime_import_sg_table(struct drm_device *dev,
++			  struct dma_buf_attachment *attach,
++			  struct sg_table *sgt)
++{
++	phys_addr_t phys = dma_to_phys(dev->dev, sg_dma_address(sgt->sgl));
++
++	if (is_swiotlb_buffer(dev->dev, phys))
++		return ERR_PTR(-EINVAL);
++
++	return drm_gem_dma_prime_import_sg_table(dev, attach, sgt);
++}
++
+ DEFINE_DRM_GEM_FOPS(vc4_drm_fops);
+ 
+ static const struct drm_ioctl_desc vc4_drm_ioctls[] = {
+@@ -211,7 +225,11 @@ const struct drm_driver vc4_drm_driver =
+ 
+ 	.gem_create_object = vc4_create_object,
+ 
+-	DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(vc4_bo_dumb_create),
++	.dumb_create		= vc4_bo_dumb_create,
++	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
++	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
++	.gem_prime_import_sg_table = vc4_prime_import_sg_table,
++	.gem_prime_mmap		= drm_gem_prime_mmap,
+ 
+ 	.ioctls = vc4_drm_ioctls,
+ 	.num_ioctls = ARRAY_SIZE(vc4_drm_ioctls),
+@@ -234,7 +252,11 @@ const struct drm_driver vc5_drm_driver =
+ 	.debugfs_init = vc4_debugfs_init,
+ #endif
+ 
+-	DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(vc5_dumb_create),
++	.dumb_create		= vc5_dumb_create,
++	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
++	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
++	.gem_prime_import_sg_table = vc4_prime_import_sg_table,
++	.gem_prime_mmap		= drm_gem_prime_mmap,
+ 
+ 	.fops = &vc4_drm_fops,
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1167-overlays-i2c-sensor-Add-adt7410-support.patch b/target/linux/bcm27xx/patches-6.1/950-1167-overlays-i2c-sensor-Add-adt7410-support.patch
new file mode 100644
index 0000000000..c7c9daba3f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1167-overlays-i2c-sensor-Add-adt7410-support.patch
@@ -0,0 +1,75 @@
+From 77a01f7da77446277139d8e9ce63f078cbe1ecfe Mon Sep 17 00:00:00 2001
+From: Kenny <aSmig+github@romhat.net>
+Date: Wed, 22 Nov 2023 16:22:37 -0800
+Subject: [PATCH] overlays: i2c-sensor: Add adt7410 support
+
+See https://github.com/raspberrypi/linux/pull/5738
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README              | 12 ++++++++----
+ .../boot/dts/overlays/i2c-sensor-common.dtsi   | 18 +++++++++++++++++-
+ 2 files changed, 25 insertions(+), 5 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -2144,10 +2144,14 @@ Name:   i2c-sensor
+ Info:   Adds support for a number of I2C barometric pressure, temperature,
+         light level and chemical sensors on i2c_arm
+ Load:   dtoverlay=i2c-sensor,<param>=<val>
+-Params: addr                    Set the address for the BH1750, BME280, BME680,
+-                                BMP280, BMP380, CCS811, DS1621, HDC100X, JC42,
+-                                LM75, MCP980x, MPU6050, MPU9250, MS5637, MS5803,
+-                                MS5805, MS5837, MS8607, SHT3x or TMP102
++Params: addr                    Set the address for the ADT7410, BH1750, BME280,
++                                BME680, BMP280, BMP380, CCS811, DS1621, HDC100X,
++                                JC42, LM75, MCP980x, MPU6050, MPU9250, MS5637,
++                                MS5803, MS5805, MS5837, MS8607, SHT3x or TMP102
++
++        adt7410                 Select the Analog Devices ADT7410 and ADT7420
++                                temperature sensors
++                                Valid address 0x48-0x4b, default 0x48
+ 
+         aht10                   Select the Aosong AHT10 temperature and humidity
+                                 sensor
+--- a/arch/arm/boot/dts/overlays/i2c-sensor-common.dtsi
++++ b/arch/arm/boot/dts/overlays/i2c-sensor-common.dtsi
+@@ -508,6 +508,21 @@
+ 		};
+ 	};
+ 
++	fragment@34 {
++		target = <&i2cbus>;
++		__dormant__ {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "okay";
++
++			adt7410: adt7410@48 {
++				compatible = "adi,adt7410", "adi,adt7420";
++				reg = <0x48>;
++				status = "okay";
++			};
++		};
++	};
++
+ 	__overrides__ {
+ 		bme280 = <0>,"+0";
+ 		bmp085 = <0>,"+1";
+@@ -543,6 +558,7 @@
+ 		mpu9250 = <0>,"+29";
+ 		bno055 = <0>,"+31";
+ 		sht4x = <0>,"+32";
++		adt7410 = <0>,"+34";
+ 
+ 		addr =	<&bme280>,"reg:0", <&bmp280>,"reg:0", <&tmp102>,"reg:0",
+ 			<&lm75>,"reg:0", <&hdc100x>,"reg:0", <&sht3x>,"reg:0",
+@@ -552,7 +568,7 @@
+ 			<&ms5837>,"reg:0", <&ms8607>,"reg:0",
+ 			<&mpu6050>,"reg:0", <&mpu9250>,"reg:0",
+ 			<&bno055>,"reg:0", <&sht4x>,"reg:0",
+-			<&bmp380>,"reg:0";
++			<&bmp380>,"reg:0", <&adt7410>,"reg:0";
+ 		int_pin = <&max30102>, "interrupts:0",
+ 			<&mpu6050>, "interrupts:0",
+ 			<&mpu9250>, "interrupts:0";
diff --git a/target/linux/bcm27xx/patches-6.1/950-1168-overlays-hat_map-Add-pisound-mapping.patch b/target/linux/bcm27xx/patches-6.1/950-1168-overlays-hat_map-Add-pisound-mapping.patch
new file mode 100644
index 0000000000..2620a598f7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1168-overlays-hat_map-Add-pisound-mapping.patch
@@ -0,0 +1,26 @@
+From 7c185b18a1c6a6cd6ab8805fef03a4a8c9931656 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Fri, 24 Nov 2023 13:57:09 +0000
+Subject: [PATCH] overlays: hat_map: Add pisound mapping
+
+See: https://github.com/raspberrypi/linux/issues/5741
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/hat_map.dts | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/arch/arm/boot/dts/overlays/hat_map.dts
++++ b/arch/arm/boot/dts/overlays/hat_map.dts
+@@ -6,6 +6,11 @@
+ 		overlay = "iqaudio-codec";
+ 	};
+ 
++	pisound {
++		uuid = [ a7ee5d28 da03 41f5 bbd7 20438a4bec5d ];
++		overlay = "pisound";
++	};
++
+ 	recalbox-rgbdual {
+ 		uuid = [ 1c955808 681f 4bbc a2ef b7ea47cd388e ];
+ 		overlay = "recalboxrgbdual";
diff --git a/target/linux/bcm27xx/patches-6.1/950-1169-drm-vc4-Set-TV-margins-on-the-composite-connector-st.patch b/target/linux/bcm27xx/patches-6.1/950-1169-drm-vc4-Set-TV-margins-on-the-composite-connector-st.patch
new file mode 100644
index 0000000000..05da5d38c5
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1169-drm-vc4-Set-TV-margins-on-the-composite-connector-st.patch
@@ -0,0 +1,47 @@
+From bc76ab2e772242d0d92d38b2a5648485ee1a1b44 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20B=C3=BCchler?= <michael.buechler@posteo.net>
+Date: Sun, 19 Nov 2023 01:22:20 +0100
+Subject: [PATCH] drm/vc4: Set TV margins on the composite connector state
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The Raspberry Pi bootloader can pass a set of margin values to the
+kernel cmdline as part of the video= option. These should result in
+black borders on the output to compensate for TVs where the visible area
+on the screen is smaller than the full extents of the video image.
+
+With the VC4 driver this currently works on an HDMI connector, but not
+on a composite video connector.
+
+The TV margins from the kernel cmdline are available in the
+drm_cmdline_mode structure of the composite video connector. Apply them
+to the connector state in the connector reset function. This is how it
+is implemented for the VC4 HDMI connector.
+
+Signed-off-by: Michael Bchler <michael.buechler@posteo.net>
+---
+ drivers/gpu/drm/vc4/vc4_vec.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/gpu/drm/vc4/vc4_vec.c
++++ b/drivers/gpu/drm/vc4/vc4_vec.c
+@@ -436,6 +436,9 @@ static void vc4_vec_connector_reset(stru
+ 	/* preserve TV standard */
+ 	if (connector->state)
+ 		connector->state->tv.mode = vc4_vec_get_default_mode(connector);
++
++	/* apply TV margins from the cmdline_mode */
++	drm_atomic_helper_connector_tv_reset(connector);
+ }
+ 
+ static int vc4_vec_connector_atomic_check(struct drm_connector *conn,
+@@ -483,6 +486,8 @@ static int vc4_vec_connector_init(struct
+ 
+ 	drm_connector_helper_add(connector, &vc4_vec_connector_helper_funcs);
+ 
++	drm_connector_attach_tv_margin_properties(connector);
++
+ 	drm_object_attach_property(&connector->base,
+ 				   dev->mode_config.tv_mode_property,
+ 				   vc4_vec_get_default_mode(connector));
diff --git a/target/linux/bcm27xx/patches-6.1/950-1170-drm-panel-jdi-lt070me05000-Add-prepare_upstream_firs.patch b/target/linux/bcm27xx/patches-6.1/950-1170-drm-panel-jdi-lt070me05000-Add-prepare_upstream_firs.patch
new file mode 100644
index 0000000000..62e408b514
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1170-drm-panel-jdi-lt070me05000-Add-prepare_upstream_firs.patch
@@ -0,0 +1,26 @@
+From 63d8c0f5185169058384142547655fc038aae0bf Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Wed, 9 Aug 2023 21:04:40 +0100
+Subject: [PATCH] drm: panel: jdi-lt070me05000: Add prepare_upstream_first flag
+
+The panel driver wants to send DCS commands from the prepare
+hook, therefore the DSI host wants to be pre_enabled first.
+Set the flag to achieve this.
+
+https://forums.raspberrypi.com/viewtopic.php?t=354708
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/panel/panel-jdi-lt070me05000.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/gpu/drm/panel/panel-jdi-lt070me05000.c
++++ b/drivers/gpu/drm/panel/panel-jdi-lt070me05000.c
+@@ -437,6 +437,7 @@ static int jdi_panel_add(struct jdi_pane
+ 		return ret;
+ 	}
+ 
++	jdi->base.prepare_upstream_first = true;
+ 	drm_panel_init(&jdi->base, &jdi->dsi->dev, &jdi_panel_funcs,
+ 		       DRM_MODE_CONNECTOR_DSI);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1172-drivers-media-cfe-Find-the-source-pads-on-the-sensor.patch b/target/linux/bcm27xx/patches-6.1/950-1172-drivers-media-cfe-Find-the-source-pads-on-the-sensor.patch
new file mode 100644
index 0000000000..e1f16d0171
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1172-drivers-media-cfe-Find-the-source-pads-on-the-sensor.patch
@@ -0,0 +1,55 @@
+From 76b1bbf3ec3be0afdc768863ab7e9bbd2734b97b Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Fri, 24 Nov 2023 14:29:57 +0000
+Subject: [PATCH] drivers: media: cfe: Find the source pads on the sensor
+ entity
+
+The driver was assuming that pad 0 on the sensor entity was the
+appropriate source pad, but this isn't necessarily the case.
+With video-mux, it has the sink pads first, and then the source
+pad as the last one.
+
+Iterate through the sensor pads to find the relevant source pads.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 15 ++++++++++++---
+ 1 file changed, 12 insertions(+), 3 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -1826,7 +1826,7 @@ static void cfe_unregister_nodes(struct
+ 
+ static int cfe_link_node_pads(struct cfe_device *cfe)
+ {
+-	unsigned int i;
++	unsigned int i, source_pad = 0;
+ 	int ret;
+ 
+ 	for (i = 0; i < CSI2_NUM_CHANNELS; i++) {
+@@ -1835,14 +1835,23 @@ static int cfe_link_node_pads(struct cfe
+ 		if (!check_state(cfe, NODE_REGISTERED, i))
+ 			continue;
+ 
+-		if (i < cfe->sensor->entity.num_pads) {
++		/* Find next source pad */
++		while (source_pad < cfe->sensor->entity.num_pads &&
++		       !(cfe->sensor->entity.pads[source_pad].flags &
++							MEDIA_PAD_FL_SOURCE))
++			source_pad++;
++
++		if (source_pad < cfe->sensor->entity.num_pads) {
+ 			/* Sensor -> CSI2 */
+-			ret = media_create_pad_link(&cfe->sensor->entity, i,
++			ret = media_create_pad_link(&cfe->sensor->entity, source_pad,
+ 						    &cfe->csi2.sd.entity, i,
+ 						    MEDIA_LNK_FL_IMMUTABLE |
+ 						    MEDIA_LNK_FL_ENABLED);
+ 			if (ret)
+ 				return ret;
++
++			/* Dealt with that source_pad, look at the next one next time */
++			source_pad++;
+ 		}
+ 
+ 		/* CSI2 channel # -> /dev/video# */
diff --git a/target/linux/bcm27xx/patches-6.1/950-1173-dtoverlays-Add-option-for-cam0-to-camera-mux-Nport-o.patch b/target/linux/bcm27xx/patches-6.1/950-1173-dtoverlays-Add-option-for-cam0-to-camera-mux-Nport-o.patch
new file mode 100644
index 0000000000..09cdcc7928
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1173-dtoverlays-Add-option-for-cam0-to-camera-mux-Nport-o.patch
@@ -0,0 +1,101 @@
+From 08c5904ad00ffc54d37058ead19814f8a85f6f39 Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Mon, 27 Nov 2023 14:50:58 +0000
+Subject: [PATCH] dtoverlays: Add option for cam0 to camera-mux-Nport overlays
+
+Seeing as the mux can be connected to either CAM/DISP1 or
+CAM/DISP0 on a Pi5, add a cam0 override to allow configuration
+of which is used. Default (as with all camera overlays) is CAM/DISP1.
+
+The overlay does NOT update the camera regulator used by all the
+sensors as doing so would be a nightmare. The Arducam mulitplexer
+boards these overlays are initially supporting seem to tie the
+regulator GPIO for all the sensors high anyway.
+If it was viewed as necessary, then creating an additional
+regulator that listed cam[01]_reg as the parent should work.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README                       | 4 ++++
+ arch/arm/boot/dts/overlays/camera-mux-2port-overlay.dts | 7 +++++--
+ arch/arm/boot/dts/overlays/camera-mux-4port-overlay.dts | 7 +++++--
+ 3 files changed, 14 insertions(+), 4 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -823,6 +823,8 @@ Params: cam0-arducam-64mp       Select A
+         cam1-ov9281             Select OV9281 for camera on port 1
+         cam1-imx290-clk-freq    Set clock frequency for an IMX290 on port 1
+ 
++        cam0                    Connect the mux to CAM0 port (default is CAM1)
++
+ 
+ Name:   camera-mux-4port
+ Info:   Configures a 4 port camera multiplexer
+@@ -878,6 +880,8 @@ Params: cam0-arducam-64mp       Select A
+         cam3-ov9281             Select OV9281 for camera on port 3
+         cam3-imx290-clk-freq    Set clock frequency for an IMX290 on port 3
+ 
++        cam0                    Connect the mux to CAM0 port (default is CAM1)
++
+ 
+ Name:   cap1106
+ Info:   Enables the ability to use the cap1106 touch sensor as a keyboard
+--- a/arch/arm/boot/dts/overlays/camera-mux-2port-overlay.dts
++++ b/arch/arm/boot/dts/overlays/camera-mux-2port-overlay.dts
+@@ -77,7 +77,7 @@
+ 	};
+ 
+ 	/* Mux define */
+-	fragment@200 {
++	i2c_frag: fragment@200 {
+ 		target = <&i2c_csi_dsi>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+@@ -294,7 +294,7 @@
+ 		};
+ 	};
+ 
+-	fragment@201 {
++	csi_frag: fragment@201 {
+ 		target = <&csi1>;
+ 		__overlay__ {
+ 			status = "okay";
+@@ -501,5 +501,8 @@
+ 				       <&imx290_0>,"clock-frequency:0";
+ 		cam1-imx290-clk-freq = <&clk_imx290>,"clock-frequency:0",
+ 				       <&imx290_1>,"clock-frequency:0";
++
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
++		       <&csi_frag>, "target:0=",<&csi0>;
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/camera-mux-4port-overlay.dts
++++ b/arch/arm/boot/dts/overlays/camera-mux-4port-overlay.dts
+@@ -135,7 +135,7 @@
+ 	};
+ 
+ 	/* Mux define */
+-	fragment@200 {
++	i2c_frag: fragment@200 {
+ 		target = <&i2c_csi_dsi>;
+ 		__overlay__ {
+ 			#address-cells = <1>;
+@@ -552,7 +552,7 @@
+ 		};
+ 	};
+ 
+-	fragment@201 {
++	csi_frag: fragment@201 {
+ 		target = <&csi1>;
+ 		__overlay__ {
+ 			status = "okay";
+@@ -872,5 +872,8 @@
+ 				       <&imx290_2>,"clock-frequency:0";
+ 		cam3-imx290-clk-freq = <&clk_imx290>,"clock-frequency:0",
+ 				       <&imx290_3>,"clock-frequency:0";
++
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
++		       <&csi_frag>, "target:0=",<&csi0>;
+ 	};
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-1174-ASoC-dwc-Permit-sample-rates-up-to-384kHz.patch b/target/linux/bcm27xx/patches-6.1/950-1174-ASoC-dwc-Permit-sample-rates-up-to-384kHz.patch
new file mode 100644
index 0000000000..258b9de01c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1174-ASoC-dwc-Permit-sample-rates-up-to-384kHz.patch
@@ -0,0 +1,26 @@
+From 6fac5d5ed6d023733ef7304afc88c8d89467a204 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 27 Nov 2023 12:16:04 +0000
+Subject: [PATCH] ASoC: dwc: Permit sample rates up to 384kHz
+
+The BCM2835 I2S block advertises clock rates up to 384kHz, and there's
+no reason why RP1's DWC I2S block shouldn't do the same.
+
+See: https://github.com/raspberrypi/linux/issues/5748
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -667,7 +667,7 @@ static int dw_configure_dai_by_dt(struct
+ 	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))
+ 		return -EINVAL;
+ 
+-	ret = dw_configure_dai(dev, dw_i2s_dai, SNDRV_PCM_RATE_8000_192000);
++	ret = dw_configure_dai(dev, dw_i2s_dai, SNDRV_PCM_RATE_8000_384000);
+ 	if (ret < 0)
+ 		return ret;
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1176-ASoC-dwc-Fix-full-duplex-mode.patch b/target/linux/bcm27xx/patches-6.1/950-1176-ASoC-dwc-Fix-full-duplex-mode.patch
new file mode 100644
index 0000000000..f4b7098fae
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1176-ASoC-dwc-Fix-full-duplex-mode.patch
@@ -0,0 +1,63 @@
+From cbc65d9c95088d1437a5a84c7d6628b8d27a86f1 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 28 Nov 2023 12:14:03 +0000
+Subject: [PATCH] ASoC: dwc: Fix full-duplex mode
+
+Configuration of the DMA register was carelessly zeroing bits that may
+used by a stream in the other direction. Preserve them instead.
+
+See: https://github.com/raspberrypi/linux/issues/5741
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 20 +++++++++++++-------
+ 1 file changed, 13 insertions(+), 7 deletions(-)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -189,10 +189,17 @@ static void dw_i2s_config(struct dw_i2s_
+ {
+ 	struct i2s_clk_config_data *config = &dev->config;
+ 	u32 ch_reg;
+-	u32 dmacr = 0;
++	u32 dmacr;
+ 
+ 	i2s_disable_channels(dev, stream);
+ 
++	dmacr = i2s_read_reg(dev->i2s_base, DMACR);
++
++	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
++		dmacr &= ~(DMACR_DMAEN_TXCH0 * 0xf);
++	else
++		dmacr &= ~(DMACR_DMAEN_RXCH0 * 0xf);
++
+ 	for (ch_reg = 0; ch_reg < (config->chan_nr / 2); ch_reg++) {
+ 		if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+ 			i2s_write_reg(dev->i2s_base, TCR(ch_reg),
+@@ -210,10 +217,6 @@ static void dw_i2s_config(struct dw_i2s_
+ 			dmacr |= (DMACR_DMAEN_RXCH0 << ch_reg);
+ 		}
+ 	}
+-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+-		dmacr |= DMACR_DMAEN_TX;
+-	else if (stream == SNDRV_PCM_STREAM_CAPTURE)
+-		dmacr |= DMACR_DMAEN_RX;
+ 
+ 	i2s_write_reg(dev->i2s_base, DMACR, dmacr);
+ }
+@@ -319,10 +322,13 @@ static int dw_i2s_startup(struct snd_pcm
+ 
+ 	dw_i2s_config(dev, substream->stream);
+ 	dmacr = i2s_read_reg(dev->i2s_base, DMACR);
+-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+ 		dma_data = &dev->play_dma_data;
+-	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
++		dmacr |= DMACR_DMAEN_TX;
++	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+ 		dma_data = &dev->capture_dma_data;
++		dmacr |= DMACR_DMAEN_RX;
++	}
+ 
+ 	snd_soc_dai_set_dma_data(cpu_dai, substream, (void *)dma_data);
+ 	i2s_write_reg(dev->i2s_base, DMACR, dmacr);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1179-ASoC-pcm512x-Adds-bindings-for-TAS575x-devices.patch b/target/linux/bcm27xx/patches-6.1/950-1179-ASoC-pcm512x-Adds-bindings-for-TAS575x-devices.patch
new file mode 100644
index 0000000000..8472c3e9e1
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1179-ASoC-pcm512x-Adds-bindings-for-TAS575x-devices.patch
@@ -0,0 +1,45 @@
+From a7ac27fbac1aa3fb8316cf1ff6dd2f81109d46d2 Mon Sep 17 00:00:00 2001
+From: Joerg Schambacher <joerg.hifiberry@gmail.com>
+Date: Fri, 29 Sep 2023 17:05:55 +0200
+Subject: [PATCH] ASoC: pcm512x: Adds bindings for TAS575x devices
+
+commit 736b884a7b68c4eeb66dbf75b97c8ec9b9eeff7f upstream.
+
+The TAS5754/6 power amplifiers use the same pcm512x driver with
+only minor restictions described in the bindings document.
+
+Signed-off-by: Joerg Schambacher <joerg.hifiberry@gmail.com>
+Reviewed-by: Rob Herring <robh@kernel.org>
+Link: https://lore.kernel.org/r/20230929150555.405388-1-joerg.hifiberry@gmail.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ Documentation/devicetree/bindings/sound/pcm512x.txt | 9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+--- a/Documentation/devicetree/bindings/sound/pcm512x.txt
++++ b/Documentation/devicetree/bindings/sound/pcm512x.txt
+@@ -1,12 +1,12 @@
+-PCM512x audio CODECs
++PCM512x and TAS575x audio CODECs/amplifiers
+ 
+ These devices support both I2C and SPI (configured with pin strapping
+-on the board).
++on the board). The TAS575x devices only support I2C.
+ 
+ Required properties:
+ 
+-  - compatible : One of "ti,pcm5121", "ti,pcm5122", "ti,pcm5141" or
+-                 "ti,pcm5142"
++  - compatible : One of "ti,pcm5121", "ti,pcm5122", "ti,pcm5141",
++                 "ti,pcm5142", "ti,tas5754" or "ti,tas5756"
+ 
+   - reg : the I2C address of the device for I2C, the chip select
+           number for SPI.
+@@ -25,6 +25,7 @@ Optional properties:
+     through <6>.  The device will be configured for clock input on the
+     given pll-in pin and PLL output on the given pll-out pin.  An
+     external connection from the pll-out pin to the SCLK pin is assumed.
++    Caution: the TAS-desvices only support gpios 1,2 and 3
+ 
+ Examples:
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1180-ASoC-Adds-support-for-TAS575x-to-the-pcm512x-driver.patch b/target/linux/bcm27xx/patches-6.1/950-1180-ASoC-Adds-support-for-TAS575x-to-the-pcm512x-driver.patch
new file mode 100644
index 0000000000..5009b225a3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1180-ASoC-Adds-support-for-TAS575x-to-the-pcm512x-driver.patch
@@ -0,0 +1,102 @@
+From a535dd07aff73f3a6eb40174ab5dc413d05f36a1 Mon Sep 17 00:00:00 2001
+From: Joerg Schambacher <joerg.hifiberry@gmail.com>
+Date: Fri, 29 Sep 2023 17:07:20 +0200
+Subject: [PATCH] ASoC: Adds support for TAS575x to the pcm512x driver
+
+commit 1f817805262c2c34142291da376d4932d3c493bc upstream.
+
+Enables the existing pcm512x driver to control the almost
+compatible TAS5754 and -76 amplifers. Both amplifiers support
+only an I2C interface and the internal PLL must be always
+on to provide necessary clocks to the amplifier section.
+Tested on TAS5756 with support from Andreas Arbesser-Krasser
+from Texas Instruments <a-krasser@ti.com>
+
+Signed-off-by: Joerg Schambacher <joerg.hifiberry@gmail.com>
+Link: https://lore.kernel.org/r/20230929150722.405415-1-joerg.hifiberry@gmail.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ sound/soc/codecs/pcm512x-i2c.c |  4 ++++
+ sound/soc/codecs/pcm512x.c     | 36 +++++++++++++++++++++++++++++++---
+ 2 files changed, 37 insertions(+), 3 deletions(-)
+
+--- a/sound/soc/codecs/pcm512x-i2c.c
++++ b/sound/soc/codecs/pcm512x-i2c.c
+@@ -39,6 +39,8 @@ static const struct i2c_device_id pcm512
+ 	{ "pcm5122", },
+ 	{ "pcm5141", },
+ 	{ "pcm5142", },
++	{ "tas5754", },
++	{ "tas5756", },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(i2c, pcm512x_i2c_id);
+@@ -49,6 +51,8 @@ static const struct of_device_id pcm512x
+ 	{ .compatible = "ti,pcm5122", },
+ 	{ .compatible = "ti,pcm5141", },
+ 	{ .compatible = "ti,pcm5142", },
++	{ .compatible = "ti,tas5754", },
++	{ .compatible = "ti,tas5756", },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, pcm512x_of_match);
+--- a/sound/soc/codecs/pcm512x.c
++++ b/sound/soc/codecs/pcm512x.c
+@@ -48,6 +48,7 @@ struct pcm512x_priv {
+ 	int mute;
+ 	struct mutex mutex;
+ 	unsigned int bclk_ratio;
++	int force_pll_on;
+ };
+ 
+ /*
+@@ -1258,10 +1259,34 @@ static int pcm512x_hw_params(struct snd_
+ 			return ret;
+ 		}
+ 
+-		ret = regmap_update_bits(pcm512x->regmap, PCM512x_PLL_EN,
+-					 PCM512x_PLLE, 0);
++		if (!pcm512x->force_pll_on) {
++			ret = regmap_update_bits(pcm512x->regmap,
++						 PCM512x_PLL_EN, PCM512x_PLLE, 0);
++		} else {
++			/* provide minimum PLL config for TAS575x clocking
++			 * and leave PLL enabled
++			 */
++			ret = regmap_write(pcm512x->regmap,
++					   PCM512x_PLL_COEFF_0, 0x01);
++			if (ret != 0) {
++				dev_err(component->dev,
++					"Failed to set pll coefficient: %d\n", ret);
++				return ret;
++			}
++			ret = regmap_write(pcm512x->regmap,
++					   PCM512x_PLL_COEFF_1, 0x04);
++			if (ret != 0) {
++				dev_err(component->dev,
++					"Failed to set pll coefficient: %d\n", ret);
++				return ret;
++			}
++			ret = regmap_write(pcm512x->regmap,
++					   PCM512x_PLL_EN, 0x01);
++			dev_dbg(component->dev, "Enabling PLL for TAS575x\n");
++		}
++
+ 		if (ret != 0) {
+-			dev_err(component->dev, "Failed to disable pll: %d\n", ret);
++			dev_err(component->dev, "Failed to set pll mode: %d\n", ret);
+ 			return ret;
+ 		}
+ 	}
+@@ -1659,6 +1684,11 @@ int pcm512x_probe(struct device *dev, st
+ 			ret = -EINVAL;
+ 			goto err_pm;
+ 		}
++
++		if (!strcmp(np->name, "tas5756") ||
++		    !strcmp(np->name, "tas5754"))
++			pcm512x->force_pll_on = 1;
++		dev_dbg(dev, "Device ID: %s\n", np->name);
+ 	}
+ #endif
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1182-drm-panel-add-panel-dsi.patch b/target/linux/bcm27xx/patches-6.1/950-1182-drm-panel-add-panel-dsi.patch
new file mode 100644
index 0000000000..d914ab6d04
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1182-drm-panel-add-panel-dsi.patch
@@ -0,0 +1,176 @@
+From 0a0084b8621682ad96d001e798aa239b11a3cf00 Mon Sep 17 00:00:00 2001
+From: Timon Skerutsch <kernel@diodes-delight.com>
+Date: Mon, 13 Nov 2023 22:53:12 +0100
+Subject: [PATCH] drm/panel: add panel-dsi
+
+Equivalent to panel-dpi for configuring a simple DSI panel with
+device tree side timings and bus settings.
+Motiviation is the same as for panel-dpi of wanting to support
+new simple panels without needing to patch the kernel.
+
+Signed-off-by: Timon Skerutsch <kernel@diodes-delight.com>
+---
+ drivers/gpu/drm/panel/panel-simple.c | 123 ++++++++++++++++++++++++++-
+ 1 file changed, 122 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/panel/panel-simple.c
++++ b/drivers/gpu/drm/panel/panel-simple.c
+@@ -40,6 +40,7 @@
+ #include <drm/drm_edid.h>
+ #include <drm/drm_mipi_dsi.h>
+ #include <drm/drm_panel.h>
++#include <drm/drm_of.h>
+ 
+ /**
+  * struct panel_desc - Describes a simple panel.
+@@ -4660,6 +4661,9 @@ static const struct panel_desc_dsi osd10
+ 	.lanes = 4,
+ };
+ 
++// for panels using generic panel-dsi binding
++static struct panel_desc_dsi panel_dsi;
++
+ static const struct of_device_id dsi_of_match[] = {
+ 	{
+ 		.compatible = "auo,b080uan01",
+@@ -4683,14 +4687,118 @@ static const struct of_device_id dsi_of_
+ 		.compatible = "osddisplays,osd101t2045-53ts",
+ 		.data = &osd101t2045_53ts
+ 	}, {
++		/* Must be the last entry */
++		.compatible = "panel-dsi",
++		.data = &panel_dsi,
++	}, {
+ 		/* sentinel */
+ 	}
+ };
+ MODULE_DEVICE_TABLE(of, dsi_of_match);
+ 
++
++/* Checks for DSI panel definition in device-tree, analog to panel_dpi */
++static int panel_dsi_dt_probe(struct device *dev,
++			  struct panel_desc_dsi *desc_dsi)
++{
++	struct panel_desc *desc;
++	struct display_timing *timing;
++	const struct device_node *np;
++	const char *dsi_color_format;
++	const char *dsi_mode_flags;
++	struct property *prop;
++	int dsi_lanes, ret;
++
++	np = dev->of_node;
++
++	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
++	if (!desc)
++		return -ENOMEM;
++
++	timing = devm_kzalloc(dev, sizeof(*timing), GFP_KERNEL);
++	if (!timing)
++		return -ENOMEM;
++
++	ret = of_get_display_timing(np, "panel-timing", timing);
++	if (ret < 0) {
++		dev_err(dev, "%pOF: no panel-timing node found for \"panel-dsi\" binding\n",
++			np);
++		return ret;
++	}
++
++	desc->timings = timing;
++	desc->num_timings = 1;
++
++	of_property_read_u32(np, "width-mm", &desc->size.width);
++	of_property_read_u32(np, "height-mm", &desc->size.height);
++
++	dsi_lanes = drm_of_get_data_lanes_count_ep(np, 0, 0, 1, 4);
++
++	if (dsi_lanes < 0) {
++		dev_err(dev, "%pOF: no or too many data-lanes defined", np);
++		return dsi_lanes;
++	}
++
++	desc_dsi->lanes = dsi_lanes;
++
++	of_property_read_string(np, "dsi-color-format", &dsi_color_format);
++	if (!strcmp(dsi_color_format, "RGB888")) {
++		desc_dsi->format = MIPI_DSI_FMT_RGB888;
++		desc->bpc = 8;
++	} else if (!strcmp(dsi_color_format, "RGB565")) {
++		desc_dsi->format = MIPI_DSI_FMT_RGB565;
++		desc->bpc = 6;
++	} else if (!strcmp(dsi_color_format, "RGB666")) {
++		desc_dsi->format = MIPI_DSI_FMT_RGB666;
++		desc->bpc = 6;
++	} else if (!strcmp(dsi_color_format, "RGB666_PACKED")) {
++		desc_dsi->format = MIPI_DSI_FMT_RGB666_PACKED;
++		desc->bpc = 6;
++	} else {
++		dev_err(dev, "%pOF: no valid dsi-color-format defined", np);
++		return -EINVAL;
++	}
++
++
++	of_property_for_each_string(np, "mode", prop, dsi_mode_flags) {
++		if (!strcmp(dsi_mode_flags, "MODE_VIDEO"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VIDEO;
++		else if (!strcmp(dsi_mode_flags, "MODE_VIDEO_BURST"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VIDEO_BURST;
++		else if (!strcmp(dsi_mode_flags, "MODE_VIDEO_SYNC_PULSE"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
++		else if (!strcmp(dsi_mode_flags, "MODE_VIDEO_AUTO_VERT"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VIDEO_AUTO_VERT;
++		else if (!strcmp(dsi_mode_flags, "MODE_VIDEO_HSE"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VIDEO_HSE;
++		else if (!strcmp(dsi_mode_flags, "MODE_VIDEO_NO_HFP"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VIDEO_NO_HFP;
++		else if (!strcmp(dsi_mode_flags, "MODE_VIDEO_NO_HBP"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VIDEO_NO_HBP;
++		else if (!strcmp(dsi_mode_flags, "MODE_VIDEO_NO_HSA"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VIDEO_NO_HSA;
++		else if (!strcmp(dsi_mode_flags, "MODE_VSYNC_FLUSH"))
++			desc_dsi->flags |= MIPI_DSI_MODE_VSYNC_FLUSH;
++		else if (!strcmp(dsi_mode_flags, "MODE_NO_EOT_PACKET"))
++			desc_dsi->flags |= MIPI_DSI_MODE_NO_EOT_PACKET;
++		else if (!strcmp(dsi_mode_flags, "CLOCK_NON_CONTINUOUS"))
++			desc_dsi->flags |= MIPI_DSI_CLOCK_NON_CONTINUOUS;
++		else if (!strcmp(dsi_mode_flags, "MODE_LPM"))
++			desc_dsi->flags |= MIPI_DSI_MODE_LPM;
++		else if (!strcmp(dsi_mode_flags, "HS_PKT_END_ALIGNED"))
++			desc_dsi->flags |= MIPI_DSI_HS_PKT_END_ALIGNED;
++	}
++
++	desc->connector_type = DRM_MODE_CONNECTOR_DSI;
++	desc_dsi->desc = *desc;
++
++	return 0;
++}
++
+ static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)
+ {
+ 	const struct panel_desc_dsi *desc;
++	struct panel_desc_dsi *dt_desc;
+ 	const struct of_device_id *id;
+ 	int err;
+ 
+@@ -4698,7 +4806,20 @@ static int panel_simple_dsi_probe(struct
+ 	if (!id)
+ 		return -ENODEV;
+ 
+-	desc = id->data;
++	if (id->data == &panel_dsi) {
++		/* Handle the generic panel-dsi binding */
++		dt_desc = devm_kzalloc(&dsi->dev, sizeof(*dt_desc), GFP_KERNEL);
++		if (!dt_desc)
++			return -ENOMEM;
++
++		err = panel_dsi_dt_probe(&dsi->dev, dt_desc);
++		if (err < 0)
++			return err;
++
++		desc = dt_desc;
++	} else {
++		desc = id->data;
++	}
+ 
+ 	err = panel_simple_probe(&dsi->dev, &desc->desc);
+ 	if (err < 0)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1183-dt-bindings-display-panel-dsi-bindings.patch b/target/linux/bcm27xx/patches-6.1/950-1183-dt-bindings-display-panel-dsi-bindings.patch
new file mode 100644
index 0000000000..c75ca8e8ac
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1183-dt-bindings-display-panel-dsi-bindings.patch
@@ -0,0 +1,136 @@
+From e14ceeadfa5b9d8a41e73edfa416bbe92dd5b20d Mon Sep 17 00:00:00 2001
+From: Timon Skerutsch <kernel@diodes-delight.com>
+Date: Mon, 13 Nov 2023 22:53:22 +0100
+Subject: [PATCH] dt-bindings: display: panel-dsi bindings
+
+Bindings for the panel-dsi specific additions to panel-simple.
+Allow for DSI specific bus settings and panel timing
+to be define in devicetree. Very similar to panel-dpi.
+
+Signed-off-by: Timon Skerutsch <kernel@diodes-delight.com>
+---
+ .../bindings/display/panel/panel-dsi.yaml     | 118 ++++++++++++++++++
+ 1 file changed, 118 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/display/panel/panel-dsi.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/display/panel/panel-dsi.yaml
+@@ -0,0 +1,118 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/display/panel/panel-dsi.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Generic MIPI DSI Panel
++
++maintainers:
++  - Timon Skerutsch <kernel@diodes-delight.com>
++
++allOf:
++  - $ref: panel-common.yaml#
++
++properties:
++  compatible:
++    description:
++      Shall contain a panel specific compatible and "panel-dsi"
++      in that order.
++    items:
++      - {}
++      - const: panel-dsi
++
++  dsi-color-format:
++    description: |
++      The color format used by the panel. Only DSI supported formats are allowed.
++    enum:
++      - RGB888
++      - RGB666
++      - RGB666_PACKED
++      - RGB565
++
++  port:
++    $ref: /schemas/graph.yaml#/$defs/port-base
++    unevaluatedProperties: false
++    description:
++      Panel MIPI DSI input
++
++    properties:
++      endpoint:
++        $ref: /schemas/media/video-interfaces.yaml#
++        unevaluatedProperties: false
++
++        properties:
++          data-lanes: true
++
++        required:
++          - data-lanes
++
++  mode:
++    description: |
++      DSI mode flags. See DSI Specs for details.
++      These are driver independent features of the DSI bus.
++    items:
++      - const: MODE_VIDEO
++      - const: MODE_VIDEO_BURST
++      - const: MODE_VIDEO_SYNC_PULSE
++      - const: MODE_VIDEO_AUTO_VERT
++      - const: MODE_VIDEO_HSE
++      - const: MODE_VIDEO_NO_HFP
++      - const: MODE_VIDEO_NO_HBP
++      - const: MODE_VIDEO_NO_HSA
++      - const: MODE_VSYNC_FLUSH
++      - const: MODE_NO_EOT_PACKET
++      - const: CLOCK_NON_CONTINUOUS
++      - const: MODE_LPM
++      - const: HS_PKT_END_ALIGNED
++
++  reg: true
++  backlight: true
++  enable-gpios: true
++  width-mm: true
++  height-mm: true
++  panel-timing: true
++  power-supply: true
++  reset-gpios: true
++  ddc-i2c-bus: true
++
++required:
++  - panel-timing
++  - reg
++  - power-supply
++  - dsi-color-format
++  - port
++
++additionalProperties: false
++
++examples:
++  - |
++    panel {
++        compatible = "panel-mfgr,generic-dsi-panel","panel-dsi";
++        power-supply = <&vcc_supply>;
++        backlight = <&backlight>;
++        dsi-color-format = "RGB888";
++        reg = <0>;
++        mode = "MODE_VIDEO", "MODE_VIDEO_BURST", "MODE_NO_EOT_PACKET";
++
++        port {
++            panel_dsi_port: endpoint {
++                data-lanes = <1 2>;
++                remote-endpoint = <&dsi_out>;
++            };
++        };
++
++        panel-timing {
++            clock-frequency = <9200000>;
++            hactive = <800>;
++            vactive = <480>;
++            hfront-porch = <8>;
++            hback-porch = <4>;
++            hsync-len = <41>;
++            vback-porch = <2>;
++            vfront-porch = <4>;
++            vsync-len = <10>;
++        };
++    };
++
++...
diff --git a/target/linux/bcm27xx/patches-6.1/950-1184-overlays-example-overlay-for-using-panel-dsi-on-RPi.patch b/target/linux/bcm27xx/patches-6.1/950-1184-overlays-example-overlay-for-using-panel-dsi-on-RPi.patch
new file mode 100644
index 0000000000..28a82d596d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1184-overlays-example-overlay-for-using-panel-dsi-on-RPi.patch
@@ -0,0 +1,176 @@
+From ccf75f2a6f4045484c4539f7d47264f8f6b8453c Mon Sep 17 00:00:00 2001
+From: Timon Skerutsch <kernel@diodes-delight.com>
+Date: Mon, 13 Nov 2023 22:52:35 +0100
+Subject: [PATCH] overlays: example overlay for using panel-dsi on RPi
+
+Analog to the generic panel-dpi overlay to use panel-dsi with dtparam
+to not require a panel specific overlay for simple use cases that
+do not require setting more niche DSI modes.
+
+Signed-off-by: Timon Skerutsch <kernel@diodes-delight.com>
+---
+ arch/arm/boot/dts/overlays/Makefile           |   1 +
+ arch/arm/boot/dts/overlays/README             |  31 +++++
+ .../overlays/vc4-kms-dsi-generic-overlay.dts  | 106 ++++++++++++++++++
+ 3 files changed, 138 insertions(+)
+ create mode 100644 arch/arm/boot/dts/overlays/vc4-kms-dsi-generic-overlay.dts
+
+--- a/arch/arm/boot/dts/overlays/Makefile
++++ b/arch/arm/boot/dts/overlays/Makefile
+@@ -293,6 +293,7 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	vc4-kms-dpi-hyperpixel4sq.dtbo \
+ 	vc4-kms-dpi-panel.dtbo \
+ 	vc4-kms-dsi-7inch.dtbo \
++	vc4-kms-dsi-generic.dtbo \
+ 	vc4-kms-dsi-lt070me05000.dtbo \
+ 	vc4-kms-dsi-lt070me05000-v2.dtbo \
+ 	vc4-kms-dsi-waveshare-panel.dtbo \
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -4785,6 +4785,37 @@ Params: sizex                   Touchscr
+                                 the default DSI1 and i2c_csi_dsi).
+ 
+ 
++Name:   vc4-kms-dsi-generic
++Info:   Enable a generic DSI display under KMS.
++        Default timings are for a 840x480 RGB888 panel.
++        Requires vc4-kms-v3d to be loaded.
++Load:   dtoverlay=vc4-kms-dsi-generic,<param>=<val>
++Params: clock-frequency         Display clock frequency (Hz)
++        hactive                 Horizontal active pixels
++        hfp                     Horizontal front porch
++        hsync                   Horizontal sync pulse width
++        hbp                     Horizontal back porch
++        vactive                 Vertical active lines
++        vfp                     Vertical front porch
++        vsync                   Vertical sync pulse width
++        vbp                     Vertical back porch
++        width-mm                Define the screen width in mm
++        height-mm               Define the screen height in mm
++        rgb565                  Change to RGB565 output
++        rgb666                  Change to RGB666 output
++        rgb666p                 Change to RGB666 output with pixel packing
++        rgb888                  Change to RGB888 output, this is the default
++        one-lane                Use one DSI lane for data transmission
++                                This is the default
++        two-lane                Use two DSI lanes for data transmission
++        three-lane              Use three DSI lanes for data transmission
++                                Only supported on Pi5 and CM
++        four-lane               Use four DSI lanes for data transmission
++                                Only supported on Pi5 and CM
++        dsi0                    Switch DSI port to DSI0
++                                Only supported on Pi5 and CM
++
++
+ Name:   vc4-kms-dsi-lt070me05000
+ Info:   Enable a JDI LT070ME05000 DSI display on DSI1.
+         Note that this is a 4 lane DSI device, so it will only work on a Compute
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/vc4-kms-dsi-generic-overlay.dts
+@@ -0,0 +1,106 @@
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "brcm,bcm2835";
++
++	dsi_frag: fragment@0 {
++		target = <&dsi1>;
++		__overlay__{
++			status = "okay";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			port {
++				dsi_out:endpoint {
++					remote-endpoint = <&panel_dsi_port>;
++				};
++			};
++			panel: panel-dsi-generic@0 {
++				// See panel-dsi.yaml binding
++				// Using dummy name for panel model
++				compatible = "Generic,panel-dsi","panel-dsi";
++				reg = <0>;
++				power-supply = <0>;
++				backlight = <0>;
++				dsi-color-format = "RGB888";
++				mode = "MODE_VIDEO";
++				width-mm = <0>;
++				height-mm = <0>;
++
++				port {
++					panel_dsi_port: endpoint {
++						data-lanes = <1>;
++						remote-endpoint = <&dsi_out>;
++					};
++				};
++
++				timing: panel-timing {
++					clock-frequency = <30000000>;
++					hactive = <840>;
++					vactive = <480>;
++					hback-porch = <44>;
++					hfront-porch = <46>;
++					hsync-len = <2>;
++					vback-porch = <18>;
++					vfront-porch = <16>;
++					vsync-len = <2>;
++				};
++			};
++		};
++	};
++
++	fragment@1 {
++		target = <&panel_dsi_port>;
++		__dormant__ {
++			data-lanes = <1>;
++		};
++	};
++
++	fragment@2 {
++		target = <&panel_dsi_port>;
++		__dormant__ {
++			data-lanes = <1 2>;
++		};
++	};
++
++	fragment@3 {
++		target = <&panel_dsi_port>;
++		__dormant__ {
++			data-lanes = <1 2 3>;
++		};
++	};
++
++	fragment@4 {
++		target = <&panel_dsi_port>;
++		__dormant__ {
++			data-lanes = <1 2 3 4>;
++		};
++	};
++
++	__overrides__ {
++		dsi0 = <&dsi_frag>, "target:0=",<&dsi0>;
++
++		clock-frequency = <&timing>, "clock-frequency:0";
++		hactive = <&timing>, "hactive:0";
++		hfp = <&timing>, "hfront-porch:0";
++		hsync = <&timing>, "hsync-len:0";
++		hbp = <&timing>, "hback-porch:0";
++		vactive = <&timing>, "vactive:0";
++		vfp = <&timing>, "vfront-porch:0";
++		vsync = <&timing>, "vsync-len:0";
++		vbp = <&timing>, "vback-porch:0";
++
++		width-mm = <&panel>, "width-mm:0";
++		height-mm = <&panel>, "height-mm:0";
++
++		rgb565 = <&panel>, "dsi-color-format=RGB565";
++		rgb666p = <&panel>, "dsi-color-format=RGB666_PACKED";
++		rgb666 = <&panel>, "dsi-color-format=RGB666";
++		rgb888 = <&panel>, "dsi-color-format=RGB888";
++		one-lane = <0>,"+1";
++		two-lane = <0>,"+2";
++		three-lane = <0>,"+3";
++		four-lane = <0>,"+4";
++	};
++
++};
diff --git a/target/linux/bcm27xx/patches-6.1/950-1185-overlays-ADS1115-allow-specification-of-the-i2c-bus.patch b/target/linux/bcm27xx/patches-6.1/950-1185-overlays-ADS1115-allow-specification-of-the-i2c-bus.patch
new file mode 100644
index 0000000000..ef9328bd6f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1185-overlays-ADS1115-allow-specification-of-the-i2c-bus.patch
@@ -0,0 +1,159 @@
+From a477a6351575aa173f9f82857f5797e384fbc704 Mon Sep 17 00:00:00 2001
+From: JinShil <slavo5150@yahoo.com>
+Date: Tue, 28 Nov 2023 17:05:44 +0900
+Subject: [PATCH] overlays: ADS1115: allow specification of the i2c bus
+
+---
+ arch/arm/boot/dts/overlays/README             | 10 +++
+ .../arm/boot/dts/overlays/ads1115-overlay.dts | 80 +++++++++++++------
+ 2 files changed, 66 insertions(+), 24 deletions(-)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -489,6 +489,16 @@ Params: addr                    I2C bus
+         cha_gain                Set the gain of the Programmable Gain
+                                 Amplifier for this channel. (Default 1 sets the
+                                 full scale of the channel to 4.096 Volts)
++        i2c0                    Choose the I2C0 bus on GPIOs 0&1
++        i2c_csi_dsi             Choose the I2C0 bus on GPIOs 44&45
++        i2c3                    Choose the I2C3 bus (configure with the i2c3
++                                overlay - BCM2711 only)
++        i2c4                    Choose the I2C4 bus (configure with the i2c4
++                                overlay - BCM2711 only)
++        i2c5                    Choose the I2C5 bus (configure with the i2c5
++                                overlay - BCM2711 only)
++        i2c6                    Choose the I2C6 bus (configure with the i2c6
++                                overlay - BCM2711 only)
+ 
+         Channel parameters can be set for each enabled channel.
+         A maximum of 4 channels can be enabled (letters a thru d).
+--- a/arch/arm/boot/dts/overlays/ads1115-overlay.dts
++++ b/arch/arm/boot/dts/overlays/ads1115-overlay.dts
+@@ -9,23 +9,6 @@
+ 	compatible = "brcm,bcm2835";
+ 
+ 	fragment@0 {
+-		target = <&i2c_arm>;
+-		__overlay__ {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			status = "okay";
+-
+-			ads1115: ads1115@48 {
+-				compatible = "ti,ads1115";
+-				status = "okay";
+-				#address-cells = <1>;
+-				#size-cells = <0>;
+-				reg = <0x48>;
+-			};
+-		};
+-	};
+-
+-	fragment@1 {
+ 		target = <&ads1115>;
+ 		__dormant__ {
+ 			#address-cells = <1>;
+@@ -39,7 +22,7 @@
+ 		};
+ 	};
+ 
+-	fragment@2 {
++	fragment@1 {
+ 		target = <&ads1115>;
+ 		__dormant__ {
+ 			#address-cells = <1>;
+@@ -53,7 +36,7 @@
+ 		};
+ 	};
+ 
+-	fragment@3 {
++	fragment@2 {
+ 		target = <&ads1115>;
+ 		__dormant__ {
+ 			#address-cells = <1>;
+@@ -67,7 +50,7 @@
+ 		};
+ 	};
+ 
+-	fragment@4 {
++	fragment@3 {
+ 		target = <&ads1115>;
+ 		__dormant__ {
+ 			#address-cells = <1>;
+@@ -81,23 +64,72 @@
+ 		};
+ 	};
+ 
++	fragment@4 {
++		target = <&i2cbus>;
++		__overlay__ {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "okay";
++
++			ads1115: ads1115@48 {
++				compatible = "ti,ads1115";
++				status = "okay";
++				#address-cells = <1>;
++				#size-cells = <0>;
++				reg = <0x48>;
++			};
++		};
++	};
++
++	frag100: fragment@100 {
++		target = <&i2c1>;
++		i2cbus: __overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@101 {
++		target = <&i2c0if>;
++		__dormant__ {
++			status = "okay";
++		};
++	};
++
++	fragment@102 {
++		target = <&i2c0mux>;
++		__dormant__ {
++			status = "okay";
++		};
++	};
++
+ 	__overrides__ {
+ 		addr =            <&ads1115>,"reg:0";
+-		cha_enable =      <0>,"=1";
++		cha_enable =      <0>,"=0";
+ 		cha_cfg =         <&channel_a>,"reg:0";
+ 		cha_gain =        <&channel_a>,"ti,gain:0";
+ 		cha_datarate =    <&channel_a>,"ti,datarate:0";
+-		chb_enable =      <0>,"=2";
++		chb_enable =      <0>,"=1";
+ 		chb_cfg =         <&channel_b>,"reg:0";
+ 		chb_gain =        <&channel_b>,"ti,gain:0";
+ 		chb_datarate =    <&channel_b>,"ti,datarate:0";
+-		chc_enable =      <0>,"=3";
++		chc_enable =      <0>,"=2";
+ 		chc_cfg =         <&channel_c>,"reg:0";
+ 		chc_gain =        <&channel_c>,"ti,gain:0";
+ 		chc_datarate =    <&channel_c>,"ti,datarate:0";
+-		chd_enable =      <0>,"=4";
++		chd_enable =      <0>,"=3";
+ 		chd_cfg =         <&channel_d>,"reg:0";
+ 		chd_gain =        <&channel_d>,"ti,gain:0";
+ 		chd_datarate =    <&channel_d>,"ti,datarate:0";
++		i2c0 = <&frag100>, "target:0=",<&i2c0>;
++		i2c_csi_dsi = <&frag100>, "target:0=",<&i2c_csi_dsi>,
++			      <0>,"+101+102";
++		i2c3 = <&frag100>, "target?=0",
++		       <&frag100>, "target-path=i2c3";
++		i2c4 = <&frag100>, "target?=0",
++		       <&frag100>, "target-path=i2c4";
++		i2c5 = <&frag100>, "target?=0",
++		       <&frag100>, "target-path=i2c5";
++		i2c6 = <&frag100>, "target?=0",
++		       <&frag100>, "target-path=i2c6";
+ 	};
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-1186-dts-bcm2712-put-usb-under-axi-not-soc.patch b/target/linux/bcm27xx/patches-6.1/950-1186-dts-bcm2712-put-usb-under-axi-not-soc.patch
new file mode 100644
index 0000000000..b66265f5a1
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1186-dts-bcm2712-put-usb-under-axi-not-soc.patch
@@ -0,0 +1,59 @@
+From 82069a7a02632aa60fa5c69415bf891ede7d6fd4 Mon Sep 17 00:00:00 2001
+From: Jonathan Bell <jonathan@raspberrypi.com>
+Date: Tue, 5 Dec 2023 16:55:17 +0000
+Subject: [PATCH] dts: bcm2712: put usb under /axi not /soc
+
+On 2712, the DWC USB controller is no longer attached to the Videocore
+30-bit bus with its associated aliases, and can see the bottom 4GB of
+RAM directly.
+
+Ideally it should make use of IOMMU6 but for now software bounce buffers
+get it working.
+
+Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712.dtsi | 26 +++++++++++++-------------
+ 1 file changed, 13 insertions(+), 13 deletions(-)
+
+--- a/arch/arm/boot/dts/bcm2712.dtsi
++++ b/arch/arm/boot/dts/bcm2712.dtsi
+@@ -133,19 +133,6 @@
+ 			status = "disabled";
+ 		};
+ 
+-		usb: usb@7c480000 {
+-			compatible = "brcm,bcm2835-usb";
+-			reg = <0x7c480000 0x10000>;
+-			interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			clocks = <&clk_usb>;
+-			clock-names = "otg";
+-			phys = <&usbphy>;
+-			phy-names = "usb2-phy";
+-			status = "disabled";
+-		};
+-
+ 		mop: mop@7c500000 {
+ 			compatible = "brcm,bcm2712-mop";
+ 			reg = <0x7c500000 0x20>;
+@@ -1145,6 +1132,19 @@
+ 			reg = <0x10 0x00400018  0x0 0x18>;
+ 		};
+ 
++		usb: usb@480000 {
++			compatible = "brcm,bcm2835-usb";
++			reg = <0x10 0x00480000 0x0 0x10000>;
++			interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			clocks = <&clk_usb>;
++			clock-names = "otg";
++			phys = <&usbphy>;
++			phy-names = "usb2-phy";
++			status = "disabled";
++		};
++
+ 		rpivid: codec@800000 {
+ 			compatible = "raspberrypi,rpivid-vid-decoder";
+ 			reg = <0x10 0x00800000  0x0 0x10000>, /* HEVC */
diff --git a/target/linux/bcm27xx/patches-6.1/950-1187-drm-vc4-Correct-HVS-muxing-setup-for-the-moplet.patch b/target/linux/bcm27xx/patches-6.1/950-1187-drm-vc4-Correct-HVS-muxing-setup-for-the-moplet.patch
new file mode 100644
index 0000000000..be02fd27fa
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1187-drm-vc4-Correct-HVS-muxing-setup-for-the-moplet.patch
@@ -0,0 +1,26 @@
+From 01139e4e9141d031c6f4f00371e5eb52fa78839e Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Tue, 5 Dec 2023 18:28:19 +0000
+Subject: [PATCH] drm/vc4: Correct HVS muxing setup for the moplet
+
+The moplet registers as VC4_ENCODER_TYPE_TXP1 and can be
+fed from mux output 2 of HVS channel 1.
+
+Correct the option which checked for VC4_ENCODER_TYPE_TXP0
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_kms.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_kms.c
++++ b/drivers/gpu/drm/vc4/vc4_kms.c
+@@ -365,7 +365,7 @@ static void vc6_hvs_pv_muxing_commit(str
+ 			mux = 0;
+ 			break;
+ 
+-		case VC4_ENCODER_TYPE_TXP0:
++		case VC4_ENCODER_TYPE_TXP1:
+ 			mux = 2;
+ 			break;
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1188-drm-vc4-Mop-and-moplet-have-different-register-offse.patch b/target/linux/bcm27xx/patches-6.1/950-1188-drm-vc4-Mop-and-moplet-have-different-register-offse.patch
new file mode 100644
index 0000000000..f1bb26a26b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1188-drm-vc4-Mop-and-moplet-have-different-register-offse.patch
@@ -0,0 +1,68 @@
+From cc948130d3e1c70ef21ae9963b56e0d500cef70b Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Tue, 5 Dec 2023 18:29:34 +0000
+Subject: [PATCH] drm/vc4: Mop and moplet have different register offsets for
+ high addr
+
+MOP uses register offset 0x24 for the high bits of the address,
+whilst Moplet uses 0x1c.
+
+Handle this difference between the block types.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_drv.h | 1 +
+ drivers/gpu/drm/vc4/vc4_txp.c | 8 ++++++--
+ 2 files changed, 7 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_drv.h
++++ b/drivers/gpu/drm/vc4/vc4_drv.h
+@@ -564,6 +564,7 @@ struct vc4_crtc_data {
+ struct vc4_txp_data {
+ 	struct vc4_crtc_data	base;
+ 	enum vc4_encoder_type encoder_type;
++	unsigned int high_addr_ptr_reg;
+ 	unsigned int has_byte_enable:1;
+ 	unsigned int size_minus_one:1;
+ 	unsigned int supports_40bit_addresses:1;
+--- a/drivers/gpu/drm/vc4/vc4_txp.c
++++ b/drivers/gpu/drm/vc4/vc4_txp.c
+@@ -145,7 +145,8 @@
+ /* Number of lines received and committed to memory. */
+ #define TXP_PROGRESS		0x10
+ 
+-#define TXP_DST_PTR_HIGH	0x1c
++#define TXP_DST_PTR_HIGH_MOPLET	0x1c
++#define TXP_DST_PTR_HIGH_MOP	0x24
+ 
+ #define TXP_READ(offset)								\
+ 	({										\
+@@ -338,10 +339,11 @@ static void vc4_txp_connector_atomic_com
+ 
+ 	gem = drm_fb_dma_get_gem_obj(fb, 0);
+ 	addr = gem->dma_addr + fb->offsets[0];
++
+ 	TXP_WRITE(TXP_DST_PTR, lower_32_bits(addr));
+ 
+ 	if (txp_data->supports_40bit_addresses)
+-		TXP_WRITE(TXP_DST_PTR_HIGH, upper_32_bits(addr) & 0xff);
++		TXP_WRITE(txp_data->high_addr_ptr_reg, upper_32_bits(addr) & 0xff);
+ 
+ 	TXP_WRITE(TXP_DST_PITCH, fb->pitches[0]);
+ 
+@@ -520,6 +522,7 @@ const struct vc4_txp_data bcm2712_mop_da
+ 		.hvs_output = 2,
+ 	},
+ 	.encoder_type = VC4_ENCODER_TYPE_TXP0,
++	.high_addr_ptr_reg = TXP_DST_PTR_HIGH_MOP,
+ 	.has_byte_enable = true,
+ 	.size_minus_one = true,
+ 	.supports_40bit_addresses = true,
+@@ -533,6 +536,7 @@ const struct vc4_txp_data bcm2712_moplet
+ 		.hvs_output = 4,
+ 	},
+ 	.encoder_type = VC4_ENCODER_TYPE_TXP1,
++	.high_addr_ptr_reg = TXP_DST_PTR_HIGH_MOPLET,
+ 	.size_minus_one = true,
+ 	.supports_40bit_addresses = true,
+ };
diff --git a/target/linux/bcm27xx/patches-6.1/950-1189-arm-dt-bcm2712-Correct-the-size-of-the-register-rang.patch b/target/linux/bcm27xx/patches-6.1/950-1189-arm-dt-bcm2712-Correct-the-size-of-the-register-rang.patch
new file mode 100644
index 0000000000..ece5c716e7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1189-arm-dt-bcm2712-Correct-the-size-of-the-register-rang.patch
@@ -0,0 +1,25 @@
+From 36593e2e27769d635ef18301f25b5e219a23949a Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Tue, 5 Dec 2023 18:31:25 +0000
+Subject: [PATCH] arm: dt: bcm2712: Correct the size of the register range for
+ MOP
+
+The Mop covers 0x28 bytes of registers, so ensure the range is
+defined appropriately.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712.dtsi | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/bcm2712.dtsi
++++ b/arch/arm/boot/dts/bcm2712.dtsi
+@@ -135,7 +135,7 @@
+ 
+ 		mop: mop@7c500000 {
+ 			compatible = "brcm,bcm2712-mop";
+-			reg = <0x7c500000 0x20>;
++			reg = <0x7c500000 0x28>;
+ 			interrupt-parent = <&disp_intr>;
+ 			interrupts = <1>;
+ 			status = "disabled";
diff --git a/target/linux/bcm27xx/patches-6.1/950-1192-media-Add-MIPI-CCI-register-access-helper-functions.patch b/target/linux/bcm27xx/patches-6.1/950-1192-media-Add-MIPI-CCI-register-access-helper-functions.patch
new file mode 100644
index 0000000000..3305e66986
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1192-media-Add-MIPI-CCI-register-access-helper-functions.patch
@@ -0,0 +1,388 @@
+From ae0e1b70f675f6ac7966e427f0d8f57812dbc312 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Tue, 27 Jun 2023 14:51:04 +0200
+Subject: [PATCH] media: Add MIPI CCI register access helper functions
+
+The CSI2 specification specifies a standard method to access camera sensor
+registers called "Camera Control Interface (CCI)".
+
+This uses either 8 or 16 bit (big-endian wire order) register addresses
+and supports 8, 16, 24 or 32 bit (big-endian wire order) register widths.
+
+Currently a lot of Linux camera sensor drivers all have their own custom
+helpers for this, often copy and pasted from other drivers.
+
+Add a set of generic helpers for this so that all sensor drivers can
+switch to a single common implementation.
+
+These helpers take an extra optional "int *err" function parameter,
+this can be used to chain a bunch of register accesses together with
+only a single error check at the end, rather than needing to error
+check each individual register access. The first failing call will
+set the contents of err to a non 0 value and all other calls will
+then become no-ops.
+
+Link: https://lore.kernel.org/linux-media/59aefa7f-7bf9-6736-6040-39551329cd0a@redhat.com/
+
+Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
+Tested-by: Tommaso Merciai <tomm.merciai@gmail.com>
+Reviewed-by: Tommaso Merciai <tomm.merciai@gmail.com>
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
+Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
+(cherry picked from commit 613cbb91e9cee7cf5a61f0816d2acab7bc117407)
+---
+ Documentation/driver-api/media/v4l2-cci.rst  |   5 +
+ Documentation/driver-api/media/v4l2-core.rst |   1 +
+ drivers/media/v4l2-core/Kconfig              |   9 +
+ drivers/media/v4l2-core/Makefile             |   1 +
+ drivers/media/v4l2-core/v4l2-cci.c           | 166 +++++++++++++++++++
+ include/media/v4l2-cci.h                     | 125 ++++++++++++++
+ 6 files changed, 307 insertions(+)
+ create mode 100644 Documentation/driver-api/media/v4l2-cci.rst
+ create mode 100644 drivers/media/v4l2-core/v4l2-cci.c
+ create mode 100644 include/media/v4l2-cci.h
+
+--- /dev/null
++++ b/Documentation/driver-api/media/v4l2-cci.rst
+@@ -0,0 +1,5 @@
++.. SPDX-License-Identifier: GPL-2.0
++
++V4L2 CCI kAPI
++^^^^^^^^^^^^^
++.. kernel-doc:: include/media/v4l2-cci.h
+--- a/Documentation/driver-api/media/v4l2-core.rst
++++ b/Documentation/driver-api/media/v4l2-core.rst
+@@ -22,6 +22,7 @@ Video4Linux devices
+     v4l2-mem2mem
+     v4l2-async
+     v4l2-fwnode
++    v4l2-cci
+     v4l2-rect
+     v4l2-tuner
+     v4l2-common
+--- a/drivers/media/v4l2-core/Kconfig
++++ b/drivers/media/v4l2-core/Kconfig
+@@ -74,6 +74,15 @@ config V4L2_FWNODE
+ config V4L2_ASYNC
+ 	tristate
+ 
++config V4L2_CCI
++	tristate
++
++config V4L2_CCI_I2C
++	tristate
++	depends on I2C
++	select REGMAP_I2C
++	select V4L2_CCI
++
+ # Used by drivers that need Videobuf modules
+ config VIDEOBUF_GEN
+ 	tristate
+--- a/drivers/media/v4l2-core/Makefile
++++ b/drivers/media/v4l2-core/Makefile
+@@ -25,6 +25,7 @@ videodev-$(CONFIG_VIDEO_V4L2_I2C) += v4l
+ # (e. g. LC_ALL=C sort Makefile)
+ 
+ obj-$(CONFIG_V4L2_ASYNC) += v4l2-async.o
++obj-$(CONFIG_V4L2_CCI) += v4l2-cci.o
+ obj-$(CONFIG_V4L2_FLASH_LED_CLASS) += v4l2-flash-led-class.o
+ obj-$(CONFIG_V4L2_FWNODE) += v4l2-fwnode.o
+ obj-$(CONFIG_V4L2_H264) += v4l2-h264.o
+--- /dev/null
++++ b/drivers/media/v4l2-core/v4l2-cci.c
+@@ -0,0 +1,166 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * MIPI Camera Control Interface (CCI) register access helpers.
++ *
++ * Copyright (C) 2023 Hans de Goede <hansg@kernel.org>
++ */
++
++#include <linux/bitfield.h>
++#include <linux/delay.h>
++#include <linux/dev_printk.h>
++#include <linux/module.h>
++#include <linux/regmap.h>
++#include <linux/types.h>
++
++#include <asm/unaligned.h>
++
++#include <media/v4l2-cci.h>
++
++int cci_read(struct regmap *map, u32 reg, u64 *val, int *err)
++{
++	unsigned int len;
++	u8 buf[8];
++	int ret;
++
++	if (err && *err)
++		return *err;
++
++	len = FIELD_GET(CCI_REG_WIDTH_MASK, reg);
++	reg = FIELD_GET(CCI_REG_ADDR_MASK, reg);
++
++	ret = regmap_bulk_read(map, reg, buf, len);
++	if (ret) {
++		dev_err(regmap_get_device(map), "Error reading reg 0x%4x: %d\n",
++			reg, ret);
++		goto out;
++	}
++
++	switch (len) {
++	case 1:
++		*val = buf[0];
++		break;
++	case 2:
++		*val = get_unaligned_be16(buf);
++		break;
++	case 3:
++		*val = get_unaligned_be24(buf);
++		break;
++	case 4:
++		*val = get_unaligned_be32(buf);
++		break;
++	case 8:
++		*val = get_unaligned_be64(buf);
++		break;
++	default:
++		dev_err(regmap_get_device(map), "Error invalid reg-width %u for reg 0x%04x\n",
++			len, reg);
++		ret = -EINVAL;
++		break;
++	}
++
++out:
++	if (ret && err)
++		*err = ret;
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(cci_read);
++
++int cci_write(struct regmap *map, u32 reg, u64 val, int *err)
++{
++	unsigned int len;
++	u8 buf[8];
++	int ret;
++
++	if (err && *err)
++		return *err;
++
++	len = FIELD_GET(CCI_REG_WIDTH_MASK, reg);
++	reg = FIELD_GET(CCI_REG_ADDR_MASK, reg);
++
++	switch (len) {
++	case 1:
++		buf[0] = val;
++		break;
++	case 2:
++		put_unaligned_be16(val, buf);
++		break;
++	case 3:
++		put_unaligned_be24(val, buf);
++		break;
++	case 4:
++		put_unaligned_be32(val, buf);
++		break;
++	case 8:
++		put_unaligned_be64(val, buf);
++		break;
++	default:
++		dev_err(regmap_get_device(map), "Error invalid reg-width %u for reg 0x%04x\n",
++			len, reg);
++		ret = -EINVAL;
++		goto out;
++	}
++
++	ret = regmap_bulk_write(map, reg, buf, len);
++	if (ret)
++		dev_err(regmap_get_device(map), "Error writing reg 0x%4x: %d\n",
++			reg, ret);
++
++out:
++	if (ret && err)
++		*err = ret;
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(cci_write);
++
++int cci_update_bits(struct regmap *map, u32 reg, u64 mask, u64 val, int *err)
++{
++	u64 readval;
++	int ret;
++
++	ret = cci_read(map, reg, &readval, err);
++	if (ret)
++		return ret;
++
++	val = (readval & ~mask) | (val & mask);
++
++	return cci_write(map, reg, val, err);
++}
++EXPORT_SYMBOL_GPL(cci_update_bits);
++
++int cci_multi_reg_write(struct regmap *map, const struct cci_reg_sequence *regs,
++			unsigned int num_regs, int *err)
++{
++	unsigned int i;
++	int ret;
++
++	for (i = 0; i < num_regs; i++) {
++		ret = cci_write(map, regs[i].reg, regs[i].val, err);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(cci_multi_reg_write);
++
++#if IS_ENABLED(CONFIG_V4L2_CCI_I2C)
++struct regmap *devm_cci_regmap_init_i2c(struct i2c_client *client,
++					int reg_addr_bits)
++{
++	struct regmap_config config = {
++		.reg_bits = reg_addr_bits,
++		.val_bits = 8,
++		.reg_format_endian = REGMAP_ENDIAN_BIG,
++		.disable_locking = true,
++	};
++
++	return devm_regmap_init_i2c(client, &config);
++}
++EXPORT_SYMBOL_GPL(devm_cci_regmap_init_i2c);
++#endif
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Hans de Goede <hansg@kernel.org>");
++MODULE_DESCRIPTION("MIPI Camera Control Interface (CCI) support");
+--- /dev/null
++++ b/include/media/v4l2-cci.h
+@@ -0,0 +1,125 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * MIPI Camera Control Interface (CCI) register access helpers.
++ *
++ * Copyright (C) 2023 Hans de Goede <hansg@kernel.org>
++ */
++#ifndef _V4L2_CCI_H
++#define _V4L2_CCI_H
++
++#include <linux/types.h>
++
++struct i2c_client;
++struct regmap;
++
++/**
++ * struct cci_reg_sequence - An individual write from a sequence of CCI writes
++ *
++ * @reg: Register address, use CCI_REG#() macros to encode reg width
++ * @val: Register value
++ *
++ * Register/value pairs for sequences of writes.
++ */
++struct cci_reg_sequence {
++	u32 reg;
++	u64 val;
++};
++
++/*
++ * Macros to define register address with the register width encoded
++ * into the higher bits.
++ */
++#define CCI_REG_ADDR_MASK		GENMASK(15, 0)
++#define CCI_REG_WIDTH_SHIFT		16
++#define CCI_REG_WIDTH_MASK		GENMASK(19, 16)
++
++#define CCI_REG8(x)			((1 << CCI_REG_WIDTH_SHIFT) | (x))
++#define CCI_REG16(x)			((2 << CCI_REG_WIDTH_SHIFT) | (x))
++#define CCI_REG24(x)			((3 << CCI_REG_WIDTH_SHIFT) | (x))
++#define CCI_REG32(x)			((4 << CCI_REG_WIDTH_SHIFT) | (x))
++#define CCI_REG64(x)			((8 << CCI_REG_WIDTH_SHIFT) | (x))
++
++/**
++ * cci_read() - Read a value from a single CCI register
++ *
++ * @map: Register map to read from
++ * @reg: Register address to read, use CCI_REG#() macros to encode reg width
++ * @val: Pointer to store read value
++ * @err: Optional pointer to store errors, if a previous error is set
++ *       then the read will be skipped
++ *
++ * Return: %0 on success or a negative error code on failure.
++ */
++int cci_read(struct regmap *map, u32 reg, u64 *val, int *err);
++
++/**
++ * cci_write() - Write a value to a single CCI register
++ *
++ * @map: Register map to write to
++ * @reg: Register address to write, use CCI_REG#() macros to encode reg width
++ * @val: Value to be written
++ * @err: Optional pointer to store errors, if a previous error is set
++ *       then the write will be skipped
++ *
++ * Return: %0 on success or a negative error code on failure.
++ */
++int cci_write(struct regmap *map, u32 reg, u64 val, int *err);
++
++/**
++ * cci_update_bits() - Perform a read/modify/write cycle on
++ *                     a single CCI register
++ *
++ * @map: Register map to update
++ * @reg: Register address to update, use CCI_REG#() macros to encode reg width
++ * @mask: Bitmask to change
++ * @val: New value for bitmask
++ * @err: Optional pointer to store errors, if a previous error is set
++ *       then the update will be skipped
++ *
++ * Note this uses read-modify-write to update the bits, atomicity with regards
++ * to other cci_*() register access functions is NOT guaranteed.
++ *
++ * Return: %0 on success or a negative error code on failure.
++ */
++int cci_update_bits(struct regmap *map, u32 reg, u64 mask, u64 val, int *err);
++
++/**
++ * cci_multi_reg_write() - Write multiple registers to the device
++ *
++ * @map: Register map to write to
++ * @regs: Array of structures containing register-address, -value pairs to be
++ *        written, register-addresses use CCI_REG#() macros to encode reg width
++ * @num_regs: Number of registers to write
++ * @err: Optional pointer to store errors, if a previous error is set
++ *       then the write will be skipped
++ *
++ * Write multiple registers to the device where the set of register, value
++ * pairs are supplied in any order, possibly not all in a single range.
++ *
++ * Use of the CCI_REG#() macros to encode reg width is mandatory.
++ *
++ * For raw lists of register-address, -value pairs with only 8 bit
++ * wide writes regmap_multi_reg_write() can be used instead.
++ *
++ * Return: %0 on success or a negative error code on failure.
++ */
++int cci_multi_reg_write(struct regmap *map, const struct cci_reg_sequence *regs,
++			unsigned int num_regs, int *err);
++
++#if IS_ENABLED(CONFIG_V4L2_CCI_I2C)
++/**
++ * devm_cci_regmap_init_i2c() - Create regmap to use with cci_*() register
++ *                              access functions
++ *
++ * @client: i2c_client to create the regmap for
++ * @reg_addr_bits: register address width to use (8 or 16)
++ *
++ * Note the memory for the created regmap is devm() managed, tied to the client.
++ *
++ * Return: %0 on success or a negative error code on failure.
++ */
++struct regmap *devm_cci_regmap_init_i2c(struct i2c_client *client,
++					int reg_addr_bits);
++#endif
++
++#endif
diff --git a/target/linux/bcm27xx/patches-6.1/950-1193-media-dt-bindings-Add-OmniVision-OV64A40.patch b/target/linux/bcm27xx/patches-6.1/950-1193-media-dt-bindings-Add-OmniVision-OV64A40.patch
new file mode 100644
index 0000000000..649e8bc393
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1193-media-dt-bindings-Add-OmniVision-OV64A40.patch
@@ -0,0 +1,114 @@
+From 3d108604ca669b83bb4918c4f5f0a02ddef84972 Mon Sep 17 00:00:00 2001
+From: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+Date: Sun, 1 Oct 2023 13:20:12 +0200
+Subject: [PATCH] media: dt-bindings: Add OmniVision OV64A40
+
+Add bindings for OmniVision OV64A40.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+---
+ .../bindings/media/i2c/ovti,ov64a40.yaml      | 98 +++++++++++++++++++
+ 1 file changed, 98 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/media/i2c/ovti,ov64a40.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/media/i2c/ovti,ov64a40.yaml
+@@ -0,0 +1,98 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/media/i2c/ovti,ov64a40.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: OmniVision OV64A40 Image Sensor
++
++maintainers:
++  - Jacopo Mondi <jacopo.mondi@ideasonboard.com>
++
++allOf:
++  - $ref: /schemas/media/video-interface-devices.yaml#
++
++properties:
++  compatible:
++    const: ovti,ov64a40
++
++  reg:
++    maxItems: 1
++
++  clocks:
++    maxItems: 1
++
++  avdd-supply:
++    description: Analog voltage supply, 2.8 volts
++
++  dvdd-supply:
++    description: Digital core voltage supply, 1.1 volts
++
++  dovdd-supply:
++    description: Digital I/O voltage supply, 1.8 volts
++
++  powerdown-gpios:
++    maxItems: 1
++
++  reset-gpios:
++    maxItems: 1
++
++  port:
++    $ref: /schemas/graph.yaml#/$defs/port-base
++    additionalProperties: false
++
++    properties:
++      endpoint:
++        $ref: /schemas/media/video-interfaces.yaml#
++        additionalProperties: false
++
++        properties:
++          bus-type:
++            enum:
++              - 1 # MIPI CSI-2 C-PHY
++              - 4 # MIPI CSI-2 D-PHY
++          data-lanes: true
++          link-frequencies: true
++          clock-noncontinuous: true
++          remote-endpoint: true
++
++required:
++  - compatible
++  - reg
++  - clocks
++  - port
++
++unevaluatedProperties: false
++
++examples:
++  - |
++      #include <dt-bindings/gpio/gpio.h>
++
++      i2c {
++          #address-cells = <1>;
++          #size-cells = <0>;
++
++          camera@36 {
++              compatible = "ovti,ov64a40";
++              reg = <0x36>;
++              clocks = <&camera_clk>;
++              dovdd-supply = <&vgen4_reg>;
++              avdd-supply = <&vgen3_reg>;
++              dvdd-supply = <&vgen2_reg>;
++              powerdown-gpios = <&gpio1 9 GPIO_ACTIVE_HIGH>;
++              reset-gpios = <&gpio1 10 GPIO_ACTIVE_LOW>;
++              rotation = <180>;
++              orientation = <2>;
++
++              port {
++                  endpoint {
++                      remote-endpoint = <&mipi_csi2_in>;
++                      bus-type = <4>;
++                      data-lanes = <1 2 3 4>;
++                      link-frequencies = /bits/ 64 <456000000>;
++                  };
++              };
++          };
++      };
++
++...
diff --git a/target/linux/bcm27xx/patches-6.1/950-1194-media-dt-bindings-i2c-Add-Rohm-BU64754-bindings.patch b/target/linux/bcm27xx/patches-6.1/950-1194-media-dt-bindings-i2c-Add-Rohm-BU64754-bindings.patch
new file mode 100644
index 0000000000..82eda14173
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1194-media-dt-bindings-i2c-Add-Rohm-BU64754-bindings.patch
@@ -0,0 +1,83 @@
+From 31c2999e543c245f7b96af3e73cd18e1036bfe7b Mon Sep 17 00:00:00 2001
+From: Kieran Bingham <kieran.bingham@ideasonboard.com>
+Date: Thu, 14 Sep 2023 17:03:24 +0100
+Subject: [PATCH] media: dt-bindings: i2c: Add Rohm BU64754 bindings
+
+Add YAML device tree bindings for the ROHM BU64754 VCM Motor Driver for
+Camera Autofocus.
+
+Signed-off-by: Kieran Bingham <kieran.bingham@ideasonboard.com>
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+---
+ .../bindings/media/i2c/rohm,bu64754.yaml      | 48 +++++++++++++++++++
+ MAINTAINERS                                   |  7 +++
+ 2 files changed, 55 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/media/i2c/rohm,bu64754.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/media/i2c/rohm,bu64754.yaml
+@@ -0,0 +1,48 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++# Copyright (C) 2023 Ideas on Board Oy.
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/media/i2c/rohm,bu64754.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: ROHM BU64754 Actuator Driver for Camera Autofocus
++
++maintainers:
++  - Kieran Bingham <kieran.bingham@ideasonboard.com>
++
++description: |
++  The BU64754GWZ is an actuator driver IC which can control the actuator
++  position precisely using an internal Hall Sensor.
++
++properties:
++  compatible:
++    items:
++      - enum:
++          - rohm,bu64754
++
++  reg:
++    maxItems: 1
++
++  vdd-supply:
++    description:
++      Definition of the regulator used as VDD power supply to the driver.
++
++required:
++  - compatible
++  - reg
++
++additionalProperties: false
++
++examples:
++  - |
++    i2c {
++        #address-cells = <1>;
++        #size-cells = <0>;
++
++        lens@76 {
++            compatible = "rohm,bu64754";
++            reg = <0x76>;
++            vdd-supply = <&cam1_reg>;
++        };
++    };
++...
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -17895,6 +17895,13 @@ S:	Maintained
+ F:	Documentation/devicetree/bindings/iio/light/bh1750.yaml
+ F:	drivers/iio/light/bh1750.c
+ 
++ROHM BU64754 MOTOR DRIVER FOR CAMERA AUTOFOCUS
++M:	Kieran Bingham <kieran.bingham@ideasonboard.com>
++L:	linux-media@vger.kernel.org
++S:	Maintained
++T:	git git://linuxtv.org/media_tree.git
++F:	Documentation/devicetree/bindings/media/i2c/rohm,bu64754.yaml
++
+ ROHM MULTIFUNCTION BD9571MWV-M PMIC DEVICE DRIVERS
+ M:	Marek Vasut <marek.vasut+renesas@gmail.com>
+ L:	linux-kernel@vger.kernel.org
diff --git a/target/linux/bcm27xx/patches-6.1/950-1195-media-i2c-Add-driver-for-OmniVision-OV64A40.patch b/target/linux/bcm27xx/patches-6.1/950-1195-media-i2c-Add-driver-for-OmniVision-OV64A40.patch
new file mode 100644
index 0000000000..2f3ea4b072
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1195-media-i2c-Add-driver-for-OmniVision-OV64A40.patch
@@ -0,0 +1,3763 @@
+From 87e3fcaad3017bdc91a7a79d2d1c874422ef87b0 Mon Sep 17 00:00:00 2001
+From: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+Date: Thu, 20 Jul 2023 11:44:40 +0200
+Subject: [PATCH] media: i2c: Add driver for OmniVision OV64A40
+
+Add a driver for the OmniVision OV64A40 image sensor.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+---
+ MAINTAINERS                 |    8 +
+ drivers/media/i2c/Kconfig   |   14 +
+ drivers/media/i2c/Makefile  |    1 +
+ drivers/media/i2c/ov64a40.c | 3694 +++++++++++++++++++++++++++++++++++
+ 4 files changed, 3717 insertions(+)
+ create mode 100644 drivers/media/i2c/ov64a40.c
+
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -15321,6 +15321,14 @@ S:	Maintained
+ T:	git git://linuxtv.org/media_tree.git
+ F:	drivers/media/i2c/ov5695.c
+ 
++OMNIVISION OV64A40 SENSOR DRIVER
++M:	Jacopo Mondi <jacopo.mondi@ideasonboard.com>
++L:	linux-media@vger.kernel.org
++S:	Maintained
++T:	git git://linuxtv.org/media_tree.git
++F:	Documentation/devicetree/bindings/media/i2c/ovti,ov64a40.yaml
++F:	drivers/media/i2c/ov64a40.c
++
+ OMNIVISION OV7670 SENSOR DRIVER
+ L:	linux-media@vger.kernel.org
+ S:	Orphan
+--- a/drivers/media/i2c/Kconfig
++++ b/drivers/media/i2c/Kconfig
+@@ -631,6 +631,20 @@ config VIDEO_OV5695
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called ov5695.
+ 
++config VIDEO_OV64A40
++	tristate "OmniVision OV64A40 sensor support"
++	depends on I2C && VIDEO_DEV
++	select MEDIA_CONTROLLER
++	select VIDEO_V4L2_SUBDEV_API
++	select V4L2_FWNODE
++	select V4L2_CCI_I2C
++	help
++	  This is a Video4Linux2 sensor driver for the OmniVision
++	  OV64A40 camera.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called ov64a40.
++
+ config VIDEO_OV6650
+ 	tristate "OmniVision OV6650 sensor support"
+ 	depends on I2C && VIDEO_DEV
+--- a/drivers/media/i2c/Makefile
++++ b/drivers/media/i2c/Makefile
+@@ -96,6 +96,7 @@ obj-$(CONFIG_VIDEO_OV5670) += ov5670.o
+ obj-$(CONFIG_VIDEO_OV5675) += ov5675.o
+ obj-$(CONFIG_VIDEO_OV5693) += ov5693.o
+ obj-$(CONFIG_VIDEO_OV5695) += ov5695.o
++obj-$(CONFIG_VIDEO_OV64A40) += ov64a40.o
+ obj-$(CONFIG_VIDEO_OV6650) += ov6650.o
+ obj-$(CONFIG_VIDEO_OV7251) += ov7251.o
+ obj-$(CONFIG_VIDEO_OV7640) += ov7640.o
+--- /dev/null
++++ b/drivers/media/i2c/ov64a40.c
+@@ -0,0 +1,3694 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * V4L2 sensor driver for OmniVision OV64A40
++ *
++ * Copyright (C) 2023 Ideas On Board Oy
++ * Copyright (C) 2023 Arducam
++ */
++
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/gpio/consumer.h>
++#include <linux/i2c.h>
++#include <linux/mod_devicetable.h>
++#include <linux/module.h>
++#include <linux/pm_runtime.h>
++#include <linux/regulator/consumer.h>
++
++#include <media/v4l2-cci.h>
++#include <media/v4l2-ctrls.h>
++#include <media/v4l2-device.h>
++#include <media/v4l2-event.h>
++#include <media/v4l2-fwnode.h>
++#include <media/v4l2-mediabus.h>
++#include <media/v4l2-subdev.h>
++
++#define OV64A40_XCLK_FREQ		24000000
++
++#define OV64A40_NATIVE_WIDTH		9286
++#define OV64A40_NATIVE_HEIGHT		6976
++#define OV64A40_PIXEL_ARRAY_TOP		0
++#define OV64A40_PIXEL_ARRAY_LEFT	0
++#define OV64A40_PIXEL_ARRAY_WIDTH	9248
++#define OV64A40_PIXEL_ARRAY_HEIGHT	6944
++
++#define OV64A40_PIXEL_RATE		300000000
++
++#define OV64A40_LINK_FREQ_360M		360000000
++#define OV64A40_LINK_FREQ_456M		456000000
++
++#define OV64A40_PLL1_PRE_DIV0		CCI_REG8(0x0301)
++#define OV64A40_PLL1_PRE_DIV		CCI_REG8(0x0303)
++#define OV64A40_PLL1_MULTIPLIER		CCI_REG16(0x0304)
++#define OV64A40_PLL1_M_DIV		CCI_REG8(0x0307)
++#define OV64A40_PLL2_SEL_BAK_SA1	CCI_REG8(0x0320)
++#define OV64A40_PLL2_PRE_DIV		CCI_REG8(0x0323)
++#define OV64A40_PLL2_MULTIPLIER		CCI_REG16(0x0324)
++#define OV64A40_PLL2_PRE_DIV0		CCI_REG8(0x0326)
++#define OV64A40_PLL2_DIVDAC		CCI_REG8(0x0329)
++#define OV64A40_PLL2_DIVSP		CCI_REG8(0x032d)
++#define OV64A40_PLL2_DACPREDIV		CCI_REG8(0x032e)
++
++/* TODO: validate vblank_min, it's not characterized in the datasheet. */
++#define OV64A40_VBLANK_MIN		128
++#define OV64A40_VTS_MAX			0xffffff
++
++#define OV64A40_REG_MEC_LONG_EXPO	CCI_REG24(0x3500)
++#define OV64A40_EXPOSURE_MIN		16
++#define OV64A40_EXPOSURE_MARGIN		32
++
++#define OV64A40_REG_MEC_LONG_GAIN	CCI_REG16(0x3508)
++#define OV64A40_ANA_GAIN_MIN		0x80
++#define OV64A40_ANA_GAIN_MAX		0x7ff
++#define OV64A40_ANA_GAIN_DEFAULT	0x80
++
++#define OV64A40_REG_TIMING_CTRL0	CCI_REG16(0x3800)
++#define OV64A40_REG_TIMING_CTRL2	CCI_REG16(0x3802)
++#define OV64A40_REG_TIMING_CTRL4	CCI_REG16(0x3804)
++#define OV64A40_REG_TIMING_CTRL6	CCI_REG16(0x3806)
++#define OV64A40_REG_TIMING_CTRL8	CCI_REG16(0x3808)
++#define OV64A40_REG_TIMING_CTRLA	CCI_REG16(0x380a)
++#define OV64A40_REG_TIMING_CTRLC	CCI_REG16(0x380c)
++#define OV64A40_REG_TIMING_CTRLE	CCI_REG16(0x380e)
++#define OV64A40_REG_TIMING_CTRL10	CCI_REG16(0x3810)
++#define OV64A40_REG_TIMING_CTRL12	CCI_REG16(0x3812)
++
++/*
++ * Careful: a typo in the datasheet calls this register
++ * OV64A40_REG_TIMING_CTRL20.
++ */
++#define OV64A40_REG_TIMING_CTRL14	CCI_REG8(0x3814)
++#define OV64A40_REG_TIMING_CTRL15	CCI_REG8(0x3815)
++#define OV64A40_ODD_INC_SHIFT		4
++#define OV64A40_SKIPPING_CONFIG(_odd, _even) \
++				(((_odd) << OV64A40_ODD_INC_SHIFT) | (_even))
++
++#define OV64A40_REG_TIMING_CTRL_20	CCI_REG8(0x3820)
++#define OV64A40_TIMING_CTRL_20_VFLIP	BIT(2)
++#define OV64A40_TIMING_CTRL_20_VBIN	BIT(1)
++
++#define OV64A40_REG_TIMING_CTRL_21	CCI_REG8(0x3821)
++#define OV64A40_TIMING_CTRL_21_HBIN	BIT(4)
++#define OV64A40_TIMING_CTRL_21_HFLIP	BIT(2)
++#define OV64A40_TIMING_CTRL_21_DSPEED	BIT(0)
++#define OV64A40_TIMING_CTRL_21_HBIN_CONF \
++					(OV64A40_TIMING_CTRL_21_HBIN | \
++					 OV64A40_TIMING_CTRL_21_DSPEED)
++
++#define OV64A40_REG_TIMINGS_VTS_HIGH	CCI_REG8(0x3840)
++#define OV64A40_REG_TIMINGS_VTS_MID	CCI_REG8(0x380e)
++#define OV64A40_REG_TIMINGS_VTS_LOW	CCI_REG8(0x380f)
++
++/* The test pattern control is weirdly named PRE_ISP_2325_D2V2_TOP_1 in TRM. */
++#define OV64A40_REG_TEST_PATTERN	CCI_REG8(0x50c1)
++#define OV64A40_TEST_PATTERN_DISABLED	0x00
++#define OV64A40_TEST_PATTERN_TYPE1	BIT(0)
++#define OV64A40_TEST_PATTERN_TYPE2	(BIT(4) | BIT(0))
++#define OV64A40_TEST_PATTERN_TYPE3	(BIT(5) | BIT(0))
++#define OV64A40_TEST_PATTERN_TYPE4	(BIT(5) | BIT(4) | BIT(0))
++
++#define OV64A40_REG_CHIP_ID		CCI_REG24(0x300a)
++#define OV64A40_CHIP_ID			0x566441
++
++#define OV64A40_REG_SMIA		CCI_REG8(0x0100)
++#define OV64A40_REG_SMIA_STREAMING	BIT(0)
++
++enum ov64a40_link_freq_ids {
++	OV64A40_LINK_FREQ_456M_ID,
++	OV64A40_LINK_FREQ_360M_ID,
++	OV64A40_NUM_LINK_FREQ,
++};
++
++static const char * const ov64a40_supply_names[] = {
++	/* Supplies can be enabled in any order */
++	"avdd",		/* Analog (2.8V) supply */
++	"dovdd",	/* Digital Core (1.8V) supply */
++	"dvdd",		/* IF (1.1V) supply */
++};
++
++static const char * const ov64a40_test_pattern_menu[] = {
++	"Disabled",
++	"Type1",
++	"Type2",
++	"Type3",
++	"Type4",
++};
++
++static const int ov64a40_test_pattern_val[] = {
++	OV64A40_TEST_PATTERN_DISABLED,
++	OV64A40_TEST_PATTERN_TYPE1,
++	OV64A40_TEST_PATTERN_TYPE2,
++	OV64A40_TEST_PATTERN_TYPE3,
++	OV64A40_TEST_PATTERN_TYPE4,
++};
++
++static const unsigned int ov64a40_mbus_codes[] = {
++	MEDIA_BUS_FMT_SBGGR10_1X10,
++	MEDIA_BUS_FMT_SGRBG10_1X10,
++	MEDIA_BUS_FMT_SGBRG10_1X10,
++	MEDIA_BUS_FMT_SRGGB10_1X10,
++};
++
++static const struct cci_reg_sequence ov64a40_init[] = {
++	{ CCI_REG8(0x0103), 0x01 }, { CCI_REG8(0x0301), 0x88 },
++	{ CCI_REG8(0x0304), 0x00 }, { CCI_REG8(0x0305), 0x96 },
++	{ CCI_REG8(0x0306), 0x03 }, { CCI_REG8(0x0307), 0x00 },
++	{ CCI_REG8(0x0345), 0x2c }, { CCI_REG8(0x034a), 0x02 },
++	{ CCI_REG8(0x034b), 0x02 }, { CCI_REG8(0x0350), 0xc0 },
++	{ CCI_REG8(0x0360), 0x09 }, { CCI_REG8(0x3012), 0x31 },
++	{ CCI_REG8(0x3015), 0xf0 }, { CCI_REG8(0x3017), 0xf0 },
++	{ CCI_REG8(0x301d), 0xf6 }, { CCI_REG8(0x301e), 0xf1 },
++	{ CCI_REG8(0x3022), 0xf0 }, { CCI_REG8(0x3400), 0x08 },
++	{ CCI_REG8(0x3608), 0x41 }, { CCI_REG8(0x3421), 0x02 },
++	{ CCI_REG8(0x3500), 0x00 }, { CCI_REG8(0x3501), 0x00 },
++	{ CCI_REG8(0x3502), 0x18 }, { CCI_REG8(0x3504), 0x0c },
++	{ CCI_REG8(0x3508), 0x01 }, { CCI_REG8(0x3509), 0x00 },
++	{ CCI_REG8(0x350a), 0x01 }, { CCI_REG8(0x350b), 0x00 },
++	{ CCI_REG8(0x350b), 0x00 }, { CCI_REG8(0x3540), 0x00 },
++	{ CCI_REG8(0x3541), 0x00 }, { CCI_REG8(0x3542), 0x08 },
++	{ CCI_REG8(0x3548), 0x01 }, { CCI_REG8(0x3549), 0xa0 },
++	{ CCI_REG8(0x3549), 0x00 }, { CCI_REG8(0x3549), 0x00 },
++	{ CCI_REG8(0x3549), 0x00 }, { CCI_REG8(0x3580), 0x00 },
++	{ CCI_REG8(0x3581), 0x00 }, { CCI_REG8(0x3582), 0x04 },
++	{ CCI_REG8(0x3588), 0x01 }, { CCI_REG8(0x3589), 0xf0 },
++	{ CCI_REG8(0x3589), 0x00 }, { CCI_REG8(0x3589), 0x00 },
++	{ CCI_REG8(0x3589), 0x00 }, { CCI_REG8(0x360d), 0x83 },
++	{ CCI_REG8(0x3616), 0xa0 }, { CCI_REG8(0x3617), 0x31 },
++	{ CCI_REG8(0x3623), 0x10 }, { CCI_REG8(0x3633), 0x03 },
++	{ CCI_REG8(0x3634), 0x03 }, { CCI_REG8(0x3635), 0x77 },
++	{ CCI_REG8(0x3640), 0x19 }, { CCI_REG8(0x3641), 0x80 },
++	{ CCI_REG8(0x364d), 0x0f }, { CCI_REG8(0x3680), 0x80 },
++	{ CCI_REG8(0x3682), 0x00 }, { CCI_REG8(0x3683), 0x00 },
++	{ CCI_REG8(0x3684), 0x07 }, { CCI_REG8(0x3688), 0x01 },
++	{ CCI_REG8(0x3689), 0x08 }, { CCI_REG8(0x368a), 0x26 },
++	{ CCI_REG8(0x368b), 0xc8 }, { CCI_REG8(0x368e), 0x70 },
++	{ CCI_REG8(0x368f), 0x00 }, { CCI_REG8(0x3692), 0x04 },
++	{ CCI_REG8(0x3693), 0x00 }, { CCI_REG8(0x3696), 0xd1 },
++	{ CCI_REG8(0x3697), 0xe0 }, { CCI_REG8(0x3698), 0x80 },
++	{ CCI_REG8(0x3699), 0x2b }, { CCI_REG8(0x369a), 0x00 },
++	{ CCI_REG8(0x369d), 0x00 }, { CCI_REG8(0x369e), 0x14 },
++	{ CCI_REG8(0x369f), 0x20 }, { CCI_REG8(0x36a5), 0x80 },
++	{ CCI_REG8(0x36a6), 0x00 }, { CCI_REG8(0x36a7), 0x00 },
++	{ CCI_REG8(0x36a8), 0x00 }, { CCI_REG8(0x36b5), 0x17 },
++	{ CCI_REG8(0x3701), 0x30 }, { CCI_REG8(0x3706), 0x2b },
++	{ CCI_REG8(0x3709), 0x8d }, { CCI_REG8(0x370b), 0x4f },
++	{ CCI_REG8(0x3711), 0x00 }, { CCI_REG8(0x3712), 0x01 },
++	{ CCI_REG8(0x3713), 0x00 }, { CCI_REG8(0x3720), 0x08 },
++	{ CCI_REG8(0x3727), 0x22 }, { CCI_REG8(0x3728), 0x01 },
++	{ CCI_REG8(0x375e), 0x00 }, { CCI_REG8(0x3760), 0x08 },
++	{ CCI_REG8(0x3761), 0x10 }, { CCI_REG8(0x3762), 0x08 },
++	{ CCI_REG8(0x3765), 0x10 }, { CCI_REG8(0x3766), 0x18 },
++	{ CCI_REG8(0x376a), 0x08 }, { CCI_REG8(0x376b), 0x00 },
++	{ CCI_REG8(0x376d), 0x1b }, { CCI_REG8(0x3791), 0x2b },
++	{ CCI_REG8(0x3793), 0x2b }, { CCI_REG8(0x3795), 0x2b },
++	{ CCI_REG8(0x3797), 0x4f }, { CCI_REG8(0x3799), 0x4f },
++	{ CCI_REG8(0x379b), 0x4f }, { CCI_REG8(0x37a0), 0x22 },
++	{ CCI_REG8(0x37da), 0x04 }, { CCI_REG8(0x37f9), 0x02 },
++	{ CCI_REG8(0x37fa), 0x02 }, { CCI_REG8(0x37fb), 0x02 },
++	{ CCI_REG8(0x3814), 0x11 }, { CCI_REG8(0x3815), 0x11 },
++	{ CCI_REG8(0x3820), 0x40 }, { CCI_REG8(0x3821), 0x04 },
++	{ CCI_REG8(0x3822), 0x00 }, { CCI_REG8(0x3823), 0x04 },
++	{ CCI_REG8(0x3827), 0x08 }, { CCI_REG8(0x3828), 0x00 },
++	{ CCI_REG8(0x382a), 0x81 }, { CCI_REG8(0x382e), 0x70 },
++	{ CCI_REG8(0x3837), 0x10 }, { CCI_REG8(0x3839), 0x00 },
++	{ CCI_REG8(0x383b), 0x00 }, { CCI_REG8(0x383c), 0x00 },
++	{ CCI_REG8(0x383d), 0x10 }, { CCI_REG8(0x383f), 0x00 },
++	{ CCI_REG8(0x384c), 0x02 }, { CCI_REG8(0x384d), 0x8c },
++	{ CCI_REG8(0x3852), 0x00 }, { CCI_REG8(0x3856), 0x10 },
++	{ CCI_REG8(0x3857), 0x10 }, { CCI_REG8(0x3858), 0x20 },
++	{ CCI_REG8(0x3859), 0x20 }, { CCI_REG8(0x3894), 0x00 },
++	{ CCI_REG8(0x3895), 0x00 }, { CCI_REG8(0x3896), 0x00 },
++	{ CCI_REG8(0x3897), 0x00 }, { CCI_REG8(0x3900), 0x40 },
++	{ CCI_REG8(0x3aed), 0x6e }, { CCI_REG8(0x3af1), 0x73 },
++	{ CCI_REG8(0x3d86), 0x12 }, { CCI_REG8(0x3d87), 0x30 },
++	{ CCI_REG8(0x3d8c), 0xab }, { CCI_REG8(0x3d8d), 0xb0 },
++	{ CCI_REG8(0x3f00), 0x12 }, { CCI_REG8(0x3f00), 0x12 },
++	{ CCI_REG8(0x3f00), 0x12 }, { CCI_REG8(0x3f01), 0x03 },
++	{ CCI_REG8(0x4009), 0x01 }, { CCI_REG8(0x400e), 0xc6 },
++	{ CCI_REG8(0x400f), 0x00 }, { CCI_REG8(0x4010), 0x28 },
++	{ CCI_REG8(0x4011), 0x01 }, { CCI_REG8(0x4012), 0x0c },
++	{ CCI_REG8(0x4015), 0x00 }, { CCI_REG8(0x4016), 0x1f },
++	{ CCI_REG8(0x4017), 0x00 }, { CCI_REG8(0x4018), 0x07 },
++	{ CCI_REG8(0x401a), 0x40 }, { CCI_REG8(0x4028), 0x01 },
++	{ CCI_REG8(0x4504), 0x00 }, { CCI_REG8(0x4506), 0x01 },
++	{ CCI_REG8(0x4508), 0x00 }, { CCI_REG8(0x4509), 0x35 },
++	{ CCI_REG8(0x450a), 0x08 }, { CCI_REG8(0x450c), 0x00 },
++	{ CCI_REG8(0x450d), 0x20 }, { CCI_REG8(0x450e), 0x00 },
++	{ CCI_REG8(0x450f), 0x20 }, { CCI_REG8(0x451e), 0x00 },
++	{ CCI_REG8(0x451f), 0x00 }, { CCI_REG8(0x4523), 0x00 },
++	{ CCI_REG8(0x4526), 0x00 }, { CCI_REG8(0x4527), 0x18 },
++	{ CCI_REG8(0x4580), 0x01 }, { CCI_REG8(0x4583), 0x00 },
++	{ CCI_REG8(0x4584), 0x00 }, { CCI_REG8(0x45c0), 0xa1 },
++	{ CCI_REG8(0x4602), 0x08 }, { CCI_REG8(0x4603), 0x05 },
++	{ CCI_REG8(0x4606), 0x12 }, { CCI_REG8(0x4607), 0x30 },
++	{ CCI_REG8(0x460b), 0x00 }, { CCI_REG8(0x460d), 0x00 },
++	{ CCI_REG8(0x4640), 0x00 }, { CCI_REG8(0x4641), 0x24 },
++	{ CCI_REG8(0x4643), 0x08 }, { CCI_REG8(0x4645), 0x14 },
++	{ CCI_REG8(0x4648), 0x0a }, { CCI_REG8(0x4649), 0x06 },
++	{ CCI_REG8(0x464a), 0x00 }, { CCI_REG8(0x464b), 0x30 },
++	{ CCI_REG8(0x4800), 0x04 }, { CCI_REG8(0x4802), 0x02 },
++	{ CCI_REG8(0x480b), 0x10 }, { CCI_REG8(0x480c), 0x80 },
++	{ CCI_REG8(0x480e), 0x04 }, { CCI_REG8(0x480f), 0x32 },
++	{ CCI_REG8(0x481b), 0x12 }, { CCI_REG8(0x4833), 0x30 },
++	{ CCI_REG8(0x4837), 0x08 }, { CCI_REG8(0x484b), 0x27 },
++	{ CCI_REG8(0x4850), 0x42 }, { CCI_REG8(0x4851), 0xaa },
++	{ CCI_REG8(0x4860), 0x01 }, { CCI_REG8(0x4861), 0xec },
++	{ CCI_REG8(0x4862), 0x25 }, { CCI_REG8(0x4888), 0x00 },
++	{ CCI_REG8(0x4889), 0x03 }, { CCI_REG8(0x488c), 0x60 },
++	{ CCI_REG8(0x4910), 0x28 }, { CCI_REG8(0x4911), 0x01 },
++	{ CCI_REG8(0x4912), 0x0c }, { CCI_REG8(0x491a), 0x40 },
++	{ CCI_REG8(0x4915), 0x00 }, { CCI_REG8(0x4916), 0x0f },
++	{ CCI_REG8(0x4917), 0x00 }, { CCI_REG8(0x4918), 0x07 },
++	{ CCI_REG8(0x4a10), 0x28 }, { CCI_REG8(0x4a11), 0x01 },
++	{ CCI_REG8(0x4a12), 0x0c }, { CCI_REG8(0x4a1a), 0x40 },
++	{ CCI_REG8(0x4a15), 0x00 }, { CCI_REG8(0x4a16), 0x0f },
++	{ CCI_REG8(0x4a17), 0x00 }, { CCI_REG8(0x4a18), 0x07 },
++	{ CCI_REG8(0x4d00), 0x04 }, { CCI_REG8(0x4d01), 0x5a },
++	{ CCI_REG8(0x4d02), 0xbb }, { CCI_REG8(0x4d03), 0x84 },
++	{ CCI_REG8(0x4d04), 0xd1 }, { CCI_REG8(0x4d05), 0x68 },
++	{ CCI_REG8(0xc4fa), 0x10 }, { CCI_REG8(0x3b56), 0x0a },
++	{ CCI_REG8(0x3b57), 0x0a }, { CCI_REG8(0x3b58), 0x0c },
++	{ CCI_REG8(0x3b59), 0x10 }, { CCI_REG8(0x3a1d), 0x30 },
++	{ CCI_REG8(0x3a1e), 0x30 }, { CCI_REG8(0x3a21), 0x30 },
++	{ CCI_REG8(0x3a22), 0x30 }, { CCI_REG8(0x3992), 0x02 },
++	{ CCI_REG8(0x399e), 0x02 }, { CCI_REG8(0x39fb), 0x30 },
++	{ CCI_REG8(0x39fc), 0x30 }, { CCI_REG8(0x39fd), 0x30 },
++	{ CCI_REG8(0x39fe), 0x30 }, { CCI_REG8(0x3a6d), 0x83 },
++	{ CCI_REG8(0x3a5e), 0x83 }, { CCI_REG8(0xc500), 0x12 },
++	{ CCI_REG8(0xc501), 0x12 }, { CCI_REG8(0xc502), 0x12 },
++	{ CCI_REG8(0xc503), 0x12 }, { CCI_REG8(0xc505), 0x12 },
++	{ CCI_REG8(0xc506), 0x12 }, { CCI_REG8(0xc507), 0x12 },
++	{ CCI_REG8(0xc508), 0x12 }, { CCI_REG8(0x3a77), 0x12 },
++	{ CCI_REG8(0x3a73), 0x12 }, { CCI_REG8(0x3a7b), 0x12 },
++	{ CCI_REG8(0x3a7f), 0x12 }, { CCI_REG8(0x3b2e), 0x13 },
++	{ CCI_REG8(0x3b29), 0x13 }, { CCI_REG8(0xc439), 0x13 },
++	{ CCI_REG8(0xc469), 0x13 }, { CCI_REG8(0xc41c), 0x89 },
++	{ CCI_REG8(0x3618), 0x80 }, { CCI_REG8(0xc514), 0x51 },
++	{ CCI_REG8(0xc515), 0x2c }, { CCI_REG8(0xc516), 0x16 },
++	{ CCI_REG8(0xc517), 0x0d }, { CCI_REG8(0x3615), 0x7f },
++	{ CCI_REG8(0x3632), 0x99 }, { CCI_REG8(0x3642), 0x00 },
++	{ CCI_REG8(0x3645), 0x80 }, { CCI_REG8(0x3702), 0x2a },
++	{ CCI_REG8(0x3703), 0x2a }, { CCI_REG8(0x3708), 0x2f },
++	{ CCI_REG8(0x3721), 0x15 }, { CCI_REG8(0x3744), 0x28 },
++	{ CCI_REG8(0x3991), 0x0c }, { CCI_REG8(0x371d), 0x24 },
++	{ CCI_REG8(0x371f), 0x0c }, { CCI_REG8(0x374b), 0x03 },
++	{ CCI_REG8(0x37d0), 0x00 }, { CCI_REG8(0x391d), 0x55 },
++	{ CCI_REG8(0x391e), 0x52 }, { CCI_REG8(0x399d), 0x0c },
++	{ CCI_REG8(0x3a2f), 0x01 }, { CCI_REG8(0x3a30), 0x01 },
++	{ CCI_REG8(0x3a31), 0x01 }, { CCI_REG8(0x3a32), 0x01 },
++	{ CCI_REG8(0x3a34), 0x01 }, { CCI_REG8(0x3a35), 0x01 },
++	{ CCI_REG8(0x3a36), 0x01 }, { CCI_REG8(0x3a37), 0x01 },
++	{ CCI_REG8(0x3a43), 0x01 }, { CCI_REG8(0x3a44), 0x01 },
++	{ CCI_REG8(0x3a45), 0x01 }, { CCI_REG8(0x3a46), 0x01 },
++	{ CCI_REG8(0x3a48), 0x01 }, { CCI_REG8(0x3a49), 0x01 },
++	{ CCI_REG8(0x3a4a), 0x01 }, { CCI_REG8(0x3a4b), 0x01 },
++	{ CCI_REG8(0x3a50), 0x14 }, { CCI_REG8(0x3a54), 0x14 },
++	{ CCI_REG8(0x3a60), 0x20 }, { CCI_REG8(0x3a6f), 0x20 },
++	{ CCI_REG8(0x3ac5), 0x01 }, { CCI_REG8(0x3ac6), 0x01 },
++	{ CCI_REG8(0x3ac7), 0x01 }, { CCI_REG8(0x3ac8), 0x01 },
++	{ CCI_REG8(0x3ac9), 0x01 }, { CCI_REG8(0x3aca), 0x01 },
++	{ CCI_REG8(0x3acb), 0x01 }, { CCI_REG8(0x3acc), 0x01 },
++	{ CCI_REG8(0x3acd), 0x01 }, { CCI_REG8(0x3ace), 0x01 },
++	{ CCI_REG8(0x3acf), 0x01 }, { CCI_REG8(0x3ad0), 0x01 },
++	{ CCI_REG8(0x3ad1), 0x01 }, { CCI_REG8(0x3ad2), 0x01 },
++	{ CCI_REG8(0x3ad3), 0x01 }, { CCI_REG8(0x3ad4), 0x01 },
++	{ CCI_REG8(0x3add), 0x1f }, { CCI_REG8(0x3adf), 0x24 },
++	{ CCI_REG8(0x3aef), 0x1f }, { CCI_REG8(0x3af0), 0x24 },
++	{ CCI_REG8(0x3b92), 0x08 }, { CCI_REG8(0x3b93), 0x08 },
++	{ CCI_REG8(0x3b94), 0x08 }, { CCI_REG8(0x3b95), 0x08 },
++	{ CCI_REG8(0x3be7), 0x1e }, { CCI_REG8(0x3be8), 0x26 },
++	{ CCI_REG8(0xc44a), 0x20 }, { CCI_REG8(0xc44c), 0x20 },
++	{ CCI_REG8(0xc483), 0x00 }, { CCI_REG8(0xc484), 0x00 },
++	{ CCI_REG8(0xc485), 0x00 }, { CCI_REG8(0xc486), 0x00 },
++	{ CCI_REG8(0xc487), 0x01 }, { CCI_REG8(0xc488), 0x01 },
++	{ CCI_REG8(0xc489), 0x01 }, { CCI_REG8(0xc48a), 0x01 },
++	{ CCI_REG8(0xc4c1), 0x00 }, { CCI_REG8(0xc4c2), 0x00 },
++	{ CCI_REG8(0xc4c3), 0x00 }, { CCI_REG8(0xc4c4), 0x00 },
++	{ CCI_REG8(0xc4c6), 0x10 }, { CCI_REG8(0xc4c7), 0x10 },
++	{ CCI_REG8(0xc4c8), 0x10 }, { CCI_REG8(0xc4c9), 0x10 },
++	{ CCI_REG8(0xc4ca), 0x10 }, { CCI_REG8(0xc4cb), 0x10 },
++	{ CCI_REG8(0xc4cc), 0x10 }, { CCI_REG8(0xc4cd), 0x10 },
++	{ CCI_REG8(0xc4ea), 0x07 }, { CCI_REG8(0xc4eb), 0x07 },
++	{ CCI_REG8(0xc4ec), 0x07 }, { CCI_REG8(0xc4ed), 0x07 },
++	{ CCI_REG8(0xc4ee), 0x07 }, { CCI_REG8(0xc4f6), 0x10 },
++	{ CCI_REG8(0xc4f7), 0x10 }, { CCI_REG8(0xc4f8), 0x10 },
++	{ CCI_REG8(0xc4f9), 0x10 }, { CCI_REG8(0xc518), 0x0e },
++	{ CCI_REG8(0xc519), 0x0e }, { CCI_REG8(0xc51a), 0x0e },
++	{ CCI_REG8(0xc51b), 0x0e }, { CCI_REG8(0xc51c), 0x0e },
++	{ CCI_REG8(0xc51d), 0x0e }, { CCI_REG8(0xc51e), 0x0e },
++	{ CCI_REG8(0xc51f), 0x0e }, { CCI_REG8(0xc520), 0x0e },
++	{ CCI_REG8(0xc521), 0x0e }, { CCI_REG8(0xc522), 0x0e },
++	{ CCI_REG8(0xc523), 0x0e }, { CCI_REG8(0xc524), 0x0e },
++	{ CCI_REG8(0xc525), 0x0e }, { CCI_REG8(0xc526), 0x0e },
++	{ CCI_REG8(0xc527), 0x0e }, { CCI_REG8(0xc528), 0x0e },
++	{ CCI_REG8(0xc529), 0x0e }, { CCI_REG8(0xc52a), 0x0e },
++	{ CCI_REG8(0xc52b), 0x0e }, { CCI_REG8(0xc52c), 0x0e },
++	{ CCI_REG8(0xc52d), 0x0e }, { CCI_REG8(0xc52e), 0x0e },
++	{ CCI_REG8(0xc52f), 0x0e }, { CCI_REG8(0xc530), 0x0e },
++	{ CCI_REG8(0xc531), 0x0e }, { CCI_REG8(0xc532), 0x0e },
++	{ CCI_REG8(0xc533), 0x0e }, { CCI_REG8(0xc534), 0x0e },
++	{ CCI_REG8(0xc535), 0x0e }, { CCI_REG8(0xc536), 0x0e },
++	{ CCI_REG8(0xc537), 0x0e }, { CCI_REG8(0xc538), 0x0e },
++	{ CCI_REG8(0xc539), 0x0e }, { CCI_REG8(0xc53a), 0x0e },
++	{ CCI_REG8(0xc53b), 0x0e }, { CCI_REG8(0xc53c), 0x0e },
++	{ CCI_REG8(0xc53d), 0x0e }, { CCI_REG8(0xc53e), 0x0e },
++	{ CCI_REG8(0xc53f), 0x0e }, { CCI_REG8(0xc540), 0x0e },
++	{ CCI_REG8(0xc541), 0x0e }, { CCI_REG8(0xc542), 0x0e },
++	{ CCI_REG8(0xc543), 0x0e }, { CCI_REG8(0xc544), 0x0e },
++	{ CCI_REG8(0xc545), 0x0e }, { CCI_REG8(0xc546), 0x0e },
++	{ CCI_REG8(0xc547), 0x0e }, { CCI_REG8(0xc548), 0x0e },
++	{ CCI_REG8(0xc549), 0x0e }, { CCI_REG8(0xc57f), 0x22 },
++	{ CCI_REG8(0xc580), 0x22 }, { CCI_REG8(0xc581), 0x22 },
++	{ CCI_REG8(0xc582), 0x22 }, { CCI_REG8(0xc583), 0x22 },
++	{ CCI_REG8(0xc584), 0x22 }, { CCI_REG8(0xc585), 0x22 },
++	{ CCI_REG8(0xc586), 0x22 }, { CCI_REG8(0xc587), 0x22 },
++	{ CCI_REG8(0xc588), 0x22 }, { CCI_REG8(0xc589), 0x22 },
++	{ CCI_REG8(0xc58a), 0x22 }, { CCI_REG8(0xc58b), 0x22 },
++	{ CCI_REG8(0xc58c), 0x22 }, { CCI_REG8(0xc58d), 0x22 },
++	{ CCI_REG8(0xc58e), 0x22 }, { CCI_REG8(0xc58f), 0x22 },
++	{ CCI_REG8(0xc590), 0x22 }, { CCI_REG8(0xc591), 0x22 },
++	{ CCI_REG8(0xc592), 0x22 }, { CCI_REG8(0xc598), 0x22 },
++	{ CCI_REG8(0xc599), 0x22 }, { CCI_REG8(0xc59a), 0x22 },
++	{ CCI_REG8(0xc59b), 0x22 }, { CCI_REG8(0xc59c), 0x22 },
++	{ CCI_REG8(0xc59d), 0x22 }, { CCI_REG8(0xc59e), 0x22 },
++	{ CCI_REG8(0xc59f), 0x22 }, { CCI_REG8(0xc5a0), 0x22 },
++	{ CCI_REG8(0xc5a1), 0x22 }, { CCI_REG8(0xc5a2), 0x22 },
++	{ CCI_REG8(0xc5a3), 0x22 }, { CCI_REG8(0xc5a4), 0x22 },
++	{ CCI_REG8(0xc5a5), 0x22 }, { CCI_REG8(0xc5a6), 0x22 },
++	{ CCI_REG8(0xc5a7), 0x22 }, { CCI_REG8(0xc5a8), 0x22 },
++	{ CCI_REG8(0xc5a9), 0x22 }, { CCI_REG8(0xc5aa), 0x22 },
++	{ CCI_REG8(0xc5ab), 0x22 }, { CCI_REG8(0xc5b1), 0x2a },
++	{ CCI_REG8(0xc5b2), 0x2a }, { CCI_REG8(0xc5b3), 0x2a },
++	{ CCI_REG8(0xc5b4), 0x2a }, { CCI_REG8(0xc5b5), 0x2a },
++	{ CCI_REG8(0xc5b6), 0x2a }, { CCI_REG8(0xc5b7), 0x2a },
++	{ CCI_REG8(0xc5b8), 0x2a }, { CCI_REG8(0xc5b9), 0x2a },
++	{ CCI_REG8(0xc5ba), 0x2a }, { CCI_REG8(0xc5bb), 0x2a },
++	{ CCI_REG8(0xc5bc), 0x2a }, { CCI_REG8(0xc5bd), 0x2a },
++	{ CCI_REG8(0xc5be), 0x2a }, { CCI_REG8(0xc5bf), 0x2a },
++	{ CCI_REG8(0xc5c0), 0x2a }, { CCI_REG8(0xc5c1), 0x2a },
++	{ CCI_REG8(0xc5c2), 0x2a }, { CCI_REG8(0xc5c3), 0x2a },
++	{ CCI_REG8(0xc5c4), 0x2a }, { CCI_REG8(0xc5ca), 0x2a },
++	{ CCI_REG8(0xc5cb), 0x2a }, { CCI_REG8(0xc5cc), 0x2a },
++	{ CCI_REG8(0xc5cd), 0x2a }, { CCI_REG8(0xc5ce), 0x2a },
++	{ CCI_REG8(0xc5cf), 0x2a }, { CCI_REG8(0xc5d0), 0x2a },
++	{ CCI_REG8(0xc5d1), 0x2a }, { CCI_REG8(0xc5d2), 0x2a },
++	{ CCI_REG8(0xc5d3), 0x2a }, { CCI_REG8(0xc5d4), 0x2a },
++	{ CCI_REG8(0xc5d5), 0x2a }, { CCI_REG8(0xc5d6), 0x2a },
++	{ CCI_REG8(0xc5d7), 0x2a }, { CCI_REG8(0xc5d8), 0x2a },
++	{ CCI_REG8(0xc5d9), 0x2a }, { CCI_REG8(0xc5da), 0x2a },
++	{ CCI_REG8(0xc5db), 0x2a }, { CCI_REG8(0xc5dc), 0x2a },
++	{ CCI_REG8(0xc5dd), 0x2a }, { CCI_REG8(0xc5e8), 0x22 },
++	{ CCI_REG8(0xc5ea), 0x22 }, { CCI_REG8(0x4540), 0x12 },
++	{ CCI_REG8(0x4541), 0x30 }, { CCI_REG8(0x3d86), 0x12 },
++	{ CCI_REG8(0x3d87), 0x30 }, { CCI_REG8(0x4606), 0x12 },
++	{ CCI_REG8(0x4607), 0x30 }, { CCI_REG8(0x4648), 0x0a },
++	{ CCI_REG8(0x4649), 0x06 }, { CCI_REG8(0x3220), 0x12 },
++	{ CCI_REG8(0x3221), 0x30 }, { CCI_REG8(0x40c2), 0x12 },
++	{ CCI_REG8(0x49c2), 0x12 }, { CCI_REG8(0x4ac2), 0x12 },
++	{ CCI_REG8(0x40c3), 0x30 }, { CCI_REG8(0x49c3), 0x30 },
++	{ CCI_REG8(0x4ac3), 0x30 }, { CCI_REG8(0x36b0), 0x12 },
++	{ CCI_REG8(0x36b1), 0x30 }, { CCI_REG8(0x45cb), 0x12 },
++	{ CCI_REG8(0x45cc), 0x30 }, { CCI_REG8(0x4585), 0x12 },
++	{ CCI_REG8(0x4586), 0x30 }, { CCI_REG8(0x36b2), 0x12 },
++	{ CCI_REG8(0x36b3), 0x30 }, { CCI_REG8(0x5a40), 0x75 },
++	{ CCI_REG8(0x5a41), 0x75 }, { CCI_REG8(0x5a42), 0x75 },
++	{ CCI_REG8(0x5a43), 0x75 }, { CCI_REG8(0x5a44), 0x75 },
++	{ CCI_REG8(0x5a45), 0x75 }, { CCI_REG8(0x5a46), 0x75 },
++	{ CCI_REG8(0x5a47), 0x75 }, { CCI_REG8(0x5a48), 0x75 },
++	{ CCI_REG8(0x5a49), 0x75 }, { CCI_REG8(0x5a4a), 0x75 },
++	{ CCI_REG8(0x5a4b), 0x75 }, { CCI_REG8(0x5a4c), 0x75 },
++	{ CCI_REG8(0x5a4d), 0x75 }, { CCI_REG8(0x5a4e), 0x75 },
++	{ CCI_REG8(0x5a4f), 0x75 }, { CCI_REG8(0x5a50), 0x75 },
++	{ CCI_REG8(0x5a51), 0x75 }, { CCI_REG8(0x5a52), 0x75 },
++	{ CCI_REG8(0x5a53), 0x75 }, { CCI_REG8(0x5a54), 0x75 },
++	{ CCI_REG8(0x5a55), 0x75 }, { CCI_REG8(0x5a56), 0x75 },
++	{ CCI_REG8(0x5a57), 0x75 }, { CCI_REG8(0x5a58), 0x75 },
++	{ CCI_REG8(0x5a59), 0x75 }, { CCI_REG8(0x5a5a), 0x75 },
++	{ CCI_REG8(0x5a5b), 0x75 }, { CCI_REG8(0x5a5c), 0x75 },
++	{ CCI_REG8(0x5a5d), 0x75 }, { CCI_REG8(0x5a5e), 0x75 },
++	{ CCI_REG8(0x5a5f), 0x75 }, { CCI_REG8(0x5a60), 0x75 },
++	{ CCI_REG8(0x5a61), 0x75 }, { CCI_REG8(0x5a62), 0x75 },
++	{ CCI_REG8(0x5a63), 0x75 }, { CCI_REG8(0x5a64), 0x75 },
++	{ CCI_REG8(0x5a65), 0x75 }, { CCI_REG8(0x5a66), 0x75 },
++	{ CCI_REG8(0x5a67), 0x75 }, { CCI_REG8(0x5a68), 0x75 },
++	{ CCI_REG8(0x5a69), 0x75 }, { CCI_REG8(0x5a6a), 0x75 },
++	{ CCI_REG8(0x5a6b), 0x75 }, { CCI_REG8(0x5a6c), 0x75 },
++	{ CCI_REG8(0x5a6d), 0x75 }, { CCI_REG8(0x5a6e), 0x75 },
++	{ CCI_REG8(0x5a6f), 0x75 }, { CCI_REG8(0x5a70), 0x75 },
++	{ CCI_REG8(0x5a71), 0x75 }, { CCI_REG8(0x5a72), 0x75 },
++	{ CCI_REG8(0x5a73), 0x75 }, { CCI_REG8(0x5a74), 0x75 },
++	{ CCI_REG8(0x5a75), 0x75 }, { CCI_REG8(0x5a76), 0x75 },
++	{ CCI_REG8(0x5a77), 0x75 }, { CCI_REG8(0x5a78), 0x75 },
++	{ CCI_REG8(0x5a79), 0x75 }, { CCI_REG8(0x5a7a), 0x75 },
++	{ CCI_REG8(0x5a7b), 0x75 }, { CCI_REG8(0x5a7c), 0x75 },
++	{ CCI_REG8(0x5a7d), 0x75 }, { CCI_REG8(0x5a7e), 0x75 },
++	{ CCI_REG8(0x5a7f), 0x75 }, { CCI_REG8(0x5a80), 0x75 },
++	{ CCI_REG8(0x5a81), 0x75 }, { CCI_REG8(0x5a82), 0x75 },
++	{ CCI_REG8(0x5a83), 0x75 }, { CCI_REG8(0x5a84), 0x75 },
++	{ CCI_REG8(0x5a85), 0x75 }, { CCI_REG8(0x5a86), 0x75 },
++	{ CCI_REG8(0x5a87), 0x75 }, { CCI_REG8(0x5a88), 0x75 },
++	{ CCI_REG8(0x5a89), 0x75 }, { CCI_REG8(0x5a8a), 0x75 },
++	{ CCI_REG8(0x5a8b), 0x75 }, { CCI_REG8(0x5a8c), 0x75 },
++	{ CCI_REG8(0x5a8d), 0x75 }, { CCI_REG8(0x5a8e), 0x75 },
++	{ CCI_REG8(0x5a8f), 0x75 }, { CCI_REG8(0x5a90), 0x75 },
++	{ CCI_REG8(0x5a91), 0x75 }, { CCI_REG8(0x5a92), 0x75 },
++	{ CCI_REG8(0x5a93), 0x75 }, { CCI_REG8(0x5a94), 0x75 },
++	{ CCI_REG8(0x5a95), 0x75 }, { CCI_REG8(0x5a96), 0x75 },
++	{ CCI_REG8(0x5a97), 0x75 }, { CCI_REG8(0x5a98), 0x75 },
++	{ CCI_REG8(0x5a99), 0x75 }, { CCI_REG8(0x5a9a), 0x75 },
++	{ CCI_REG8(0x5a9b), 0x75 }, { CCI_REG8(0x5a9c), 0x75 },
++	{ CCI_REG8(0x5a9d), 0x75 }, { CCI_REG8(0x5a9e), 0x75 },
++	{ CCI_REG8(0x5a9f), 0x75 }, { CCI_REG8(0x5aa0), 0x75 },
++	{ CCI_REG8(0x5aa1), 0x75 }, { CCI_REG8(0x5aa2), 0x75 },
++	{ CCI_REG8(0x5aa3), 0x75 }, { CCI_REG8(0x5aa4), 0x75 },
++	{ CCI_REG8(0x5aa5), 0x75 }, { CCI_REG8(0x5aa6), 0x75 },
++	{ CCI_REG8(0x5aa7), 0x75 }, { CCI_REG8(0x5aa8), 0x75 },
++	{ CCI_REG8(0x5aa9), 0x75 }, { CCI_REG8(0x5aaa), 0x75 },
++	{ CCI_REG8(0x5aab), 0x75 }, { CCI_REG8(0x5aac), 0x75 },
++	{ CCI_REG8(0x5aad), 0x75 }, { CCI_REG8(0x5aae), 0x75 },
++	{ CCI_REG8(0x5aaf), 0x75 }, { CCI_REG8(0x5ab0), 0x75 },
++	{ CCI_REG8(0x5ab1), 0x75 }, { CCI_REG8(0x5ab2), 0x75 },
++	{ CCI_REG8(0x5ab3), 0x75 }, { CCI_REG8(0x5ab4), 0x75 },
++	{ CCI_REG8(0x5ab5), 0x75 }, { CCI_REG8(0x5ab6), 0x75 },
++	{ CCI_REG8(0x5ab7), 0x75 }, { CCI_REG8(0x5ab8), 0x75 },
++	{ CCI_REG8(0x5ab9), 0x75 }, { CCI_REG8(0x5aba), 0x75 },
++	{ CCI_REG8(0x5abb), 0x75 }, { CCI_REG8(0x5abc), 0x75 },
++	{ CCI_REG8(0x5abd), 0x75 }, { CCI_REG8(0x5abe), 0x75 },
++	{ CCI_REG8(0x5abf), 0x75 }, { CCI_REG8(0x5ac0), 0x75 },
++	{ CCI_REG8(0x5ac1), 0x75 }, { CCI_REG8(0x5ac2), 0x75 },
++	{ CCI_REG8(0x5ac3), 0x75 }, { CCI_REG8(0x5ac4), 0x75 },
++	{ CCI_REG8(0x5ac5), 0x75 }, { CCI_REG8(0x5ac6), 0x75 },
++	{ CCI_REG8(0x5ac7), 0x75 }, { CCI_REG8(0x5ac8), 0x75 },
++	{ CCI_REG8(0x5ac9), 0x75 }, { CCI_REG8(0x5aca), 0x75 },
++	{ CCI_REG8(0x5acb), 0x75 }, { CCI_REG8(0x5acc), 0x75 },
++	{ CCI_REG8(0x5acd), 0x75 }, { CCI_REG8(0x5ace), 0x75 },
++	{ CCI_REG8(0x5acf), 0x75 }, { CCI_REG8(0x5ad0), 0x75 },
++	{ CCI_REG8(0x5ad1), 0x75 }, { CCI_REG8(0x5ad2), 0x75 },
++	{ CCI_REG8(0x5ad3), 0x75 }, { CCI_REG8(0x5ad4), 0x75 },
++	{ CCI_REG8(0x5ad5), 0x75 }, { CCI_REG8(0x5ad6), 0x75 },
++	{ CCI_REG8(0x5ad7), 0x75 }, { CCI_REG8(0x5ad8), 0x75 },
++	{ CCI_REG8(0x5ad9), 0x75 }, { CCI_REG8(0x5ada), 0x75 },
++	{ CCI_REG8(0x5adb), 0x75 }, { CCI_REG8(0x5adc), 0x75 },
++	{ CCI_REG8(0x5add), 0x75 }, { CCI_REG8(0x5ade), 0x75 },
++	{ CCI_REG8(0x5adf), 0x75 }, { CCI_REG8(0x5ae0), 0x75 },
++	{ CCI_REG8(0x5ae1), 0x75 }, { CCI_REG8(0x5ae2), 0x75 },
++	{ CCI_REG8(0x5ae3), 0x75 }, { CCI_REG8(0x5ae4), 0x75 },
++	{ CCI_REG8(0x5ae5), 0x75 }, { CCI_REG8(0x5ae6), 0x75 },
++	{ CCI_REG8(0x5ae7), 0x75 }, { CCI_REG8(0x5ae8), 0x75 },
++	{ CCI_REG8(0x5ae9), 0x75 }, { CCI_REG8(0x5aea), 0x75 },
++	{ CCI_REG8(0x5aeb), 0x75 }, { CCI_REG8(0x5aec), 0x75 },
++	{ CCI_REG8(0x5aed), 0x75 }, { CCI_REG8(0x5aee), 0x75 },
++	{ CCI_REG8(0x5aef), 0x75 }, { CCI_REG8(0x5af0), 0x75 },
++	{ CCI_REG8(0x5af1), 0x75 }, { CCI_REG8(0x5af2), 0x75 },
++	{ CCI_REG8(0x5af3), 0x75 }, { CCI_REG8(0x5af4), 0x75 },
++	{ CCI_REG8(0x5af5), 0x75 }, { CCI_REG8(0x5af6), 0x75 },
++	{ CCI_REG8(0x5af7), 0x75 }, { CCI_REG8(0x5af8), 0x75 },
++	{ CCI_REG8(0x5af9), 0x75 }, { CCI_REG8(0x5afa), 0x75 },
++	{ CCI_REG8(0x5afb), 0x75 }, { CCI_REG8(0x5afc), 0x75 },
++	{ CCI_REG8(0x5afd), 0x75 }, { CCI_REG8(0x5afe), 0x75 },
++	{ CCI_REG8(0x5aff), 0x75 }, { CCI_REG8(0x5b00), 0x75 },
++	{ CCI_REG8(0x5b01), 0x75 }, { CCI_REG8(0x5b02), 0x75 },
++	{ CCI_REG8(0x5b03), 0x75 }, { CCI_REG8(0x5b04), 0x75 },
++	{ CCI_REG8(0x5b05), 0x75 }, { CCI_REG8(0x5b06), 0x75 },
++	{ CCI_REG8(0x5b07), 0x75 }, { CCI_REG8(0x5b08), 0x75 },
++	{ CCI_REG8(0x5b09), 0x75 }, { CCI_REG8(0x5b0a), 0x75 },
++	{ CCI_REG8(0x5b0b), 0x75 }, { CCI_REG8(0x5b0c), 0x75 },
++	{ CCI_REG8(0x5b0d), 0x75 }, { CCI_REG8(0x5b0e), 0x75 },
++	{ CCI_REG8(0x5b0f), 0x75 }, { CCI_REG8(0x5b10), 0x75 },
++	{ CCI_REG8(0x5b11), 0x75 }, { CCI_REG8(0x5b12), 0x75 },
++	{ CCI_REG8(0x5b13), 0x75 }, { CCI_REG8(0x5b14), 0x75 },
++	{ CCI_REG8(0x5b15), 0x75 }, { CCI_REG8(0x5b16), 0x75 },
++	{ CCI_REG8(0x5b17), 0x75 }, { CCI_REG8(0x5b18), 0x75 },
++	{ CCI_REG8(0x5b19), 0x75 }, { CCI_REG8(0x5b1a), 0x75 },
++	{ CCI_REG8(0x5b1b), 0x75 }, { CCI_REG8(0x5b1c), 0x75 },
++	{ CCI_REG8(0x5b1d), 0x75 }, { CCI_REG8(0x5b1e), 0x75 },
++	{ CCI_REG8(0x5b1f), 0x75 }, { CCI_REG8(0x5b20), 0x75 },
++	{ CCI_REG8(0x5b21), 0x75 }, { CCI_REG8(0x5b22), 0x75 },
++	{ CCI_REG8(0x5b23), 0x75 }, { CCI_REG8(0x5b24), 0x75 },
++	{ CCI_REG8(0x5b25), 0x75 }, { CCI_REG8(0x5b26), 0x75 },
++	{ CCI_REG8(0x5b27), 0x75 }, { CCI_REG8(0x5b28), 0x75 },
++	{ CCI_REG8(0x5b29), 0x75 }, { CCI_REG8(0x5b2a), 0x75 },
++	{ CCI_REG8(0x5b2b), 0x75 }, { CCI_REG8(0x5b2c), 0x75 },
++	{ CCI_REG8(0x5b2d), 0x75 }, { CCI_REG8(0x5b2e), 0x75 },
++	{ CCI_REG8(0x5b2f), 0x75 }, { CCI_REG8(0x5b30), 0x75 },
++	{ CCI_REG8(0x5b31), 0x75 }, { CCI_REG8(0x5b32), 0x75 },
++	{ CCI_REG8(0x5b33), 0x75 }, { CCI_REG8(0x5b34), 0x75 },
++	{ CCI_REG8(0x5b35), 0x75 }, { CCI_REG8(0x5b36), 0x75 },
++	{ CCI_REG8(0x5b37), 0x75 }, { CCI_REG8(0x5b38), 0x75 },
++	{ CCI_REG8(0x5b39), 0x75 }, { CCI_REG8(0x5b3a), 0x75 },
++	{ CCI_REG8(0x5b3b), 0x75 }, { CCI_REG8(0x5b3c), 0x75 },
++	{ CCI_REG8(0x5b3d), 0x75 }, { CCI_REG8(0x5b3e), 0x75 },
++	{ CCI_REG8(0x5b3f), 0x75 }, { CCI_REG8(0x5b40), 0x75 },
++	{ CCI_REG8(0x5b41), 0x75 }, { CCI_REG8(0x5b42), 0x75 },
++	{ CCI_REG8(0x5b43), 0x75 }, { CCI_REG8(0x5b44), 0x75 },
++	{ CCI_REG8(0x5b45), 0x75 }, { CCI_REG8(0x5b46), 0x75 },
++	{ CCI_REG8(0x5b47), 0x75 }, { CCI_REG8(0x5b48), 0x75 },
++	{ CCI_REG8(0x5b49), 0x75 }, { CCI_REG8(0x5b4a), 0x75 },
++	{ CCI_REG8(0x5b4b), 0x75 }, { CCI_REG8(0x5b4c), 0x75 },
++	{ CCI_REG8(0x5b4d), 0x75 }, { CCI_REG8(0x5b4e), 0x75 },
++	{ CCI_REG8(0x5b4f), 0x75 }, { CCI_REG8(0x5b50), 0x75 },
++	{ CCI_REG8(0x5b51), 0x75 }, { CCI_REG8(0x5b52), 0x75 },
++	{ CCI_REG8(0x5b53), 0x75 }, { CCI_REG8(0x5b54), 0x75 },
++	{ CCI_REG8(0x5b55), 0x75 }, { CCI_REG8(0x5b56), 0x75 },
++	{ CCI_REG8(0x5b57), 0x75 }, { CCI_REG8(0x5b58), 0x75 },
++	{ CCI_REG8(0x5b59), 0x75 }, { CCI_REG8(0x5b5a), 0x75 },
++	{ CCI_REG8(0x5b5b), 0x75 }, { CCI_REG8(0x5b5c), 0x75 },
++	{ CCI_REG8(0x5b5d), 0x75 }, { CCI_REG8(0x5b5e), 0x75 },
++	{ CCI_REG8(0x5b5f), 0x75 }, { CCI_REG8(0x5b80), 0x75 },
++	{ CCI_REG8(0x5b81), 0x75 }, { CCI_REG8(0x5b82), 0x75 },
++	{ CCI_REG8(0x5b83), 0x75 }, { CCI_REG8(0x5b84), 0x75 },
++	{ CCI_REG8(0x5b85), 0x75 }, { CCI_REG8(0x5b86), 0x75 },
++	{ CCI_REG8(0x5b87), 0x75 }, { CCI_REG8(0x5b88), 0x75 },
++	{ CCI_REG8(0x5b89), 0x75 }, { CCI_REG8(0x5b8a), 0x75 },
++	{ CCI_REG8(0x5b8b), 0x75 }, { CCI_REG8(0x5b8c), 0x75 },
++	{ CCI_REG8(0x5b8d), 0x75 }, { CCI_REG8(0x5b8e), 0x75 },
++	{ CCI_REG8(0x5b8f), 0x75 }, { CCI_REG8(0x5b90), 0x75 },
++	{ CCI_REG8(0x5b91), 0x75 }, { CCI_REG8(0x5b92), 0x75 },
++	{ CCI_REG8(0x5b93), 0x75 }, { CCI_REG8(0x5b94), 0x75 },
++	{ CCI_REG8(0x5b95), 0x75 }, { CCI_REG8(0x5b96), 0x75 },
++	{ CCI_REG8(0x5b97), 0x75 }, { CCI_REG8(0x5b98), 0x75 },
++	{ CCI_REG8(0x5b99), 0x75 }, { CCI_REG8(0x5b9a), 0x75 },
++	{ CCI_REG8(0x5b9b), 0x75 }, { CCI_REG8(0x5b9c), 0x75 },
++	{ CCI_REG8(0x5b9d), 0x75 }, { CCI_REG8(0x5b9e), 0x75 },
++	{ CCI_REG8(0x5b9f), 0x75 }, { CCI_REG8(0x5ba0), 0x75 },
++	{ CCI_REG8(0x5ba1), 0x75 }, { CCI_REG8(0x5ba2), 0x75 },
++	{ CCI_REG8(0x5ba3), 0x75 }, { CCI_REG8(0x5ba4), 0x75 },
++	{ CCI_REG8(0x5ba5), 0x75 }, { CCI_REG8(0x5ba6), 0x75 },
++	{ CCI_REG8(0x5ba7), 0x75 }, { CCI_REG8(0x5ba8), 0x75 },
++	{ CCI_REG8(0x5ba9), 0x75 }, { CCI_REG8(0x5baa), 0x75 },
++	{ CCI_REG8(0x5bab), 0x75 }, { CCI_REG8(0x5bac), 0x75 },
++	{ CCI_REG8(0x5bad), 0x75 }, { CCI_REG8(0x5bae), 0x75 },
++	{ CCI_REG8(0x5baf), 0x75 }, { CCI_REG8(0x5bb0), 0x75 },
++	{ CCI_REG8(0x5bb1), 0x75 }, { CCI_REG8(0x5bb2), 0x75 },
++	{ CCI_REG8(0x5bb3), 0x75 }, { CCI_REG8(0x5bb4), 0x75 },
++	{ CCI_REG8(0x5bb5), 0x75 }, { CCI_REG8(0x5bb6), 0x75 },
++	{ CCI_REG8(0x5bb7), 0x75 }, { CCI_REG8(0x5bb8), 0x75 },
++	{ CCI_REG8(0x5bb9), 0x75 }, { CCI_REG8(0x5bba), 0x75 },
++	{ CCI_REG8(0x5bbb), 0x75 }, { CCI_REG8(0x5bbc), 0x75 },
++	{ CCI_REG8(0x5bbd), 0x75 }, { CCI_REG8(0x5bbe), 0x75 },
++	{ CCI_REG8(0x5bbf), 0x75 }, { CCI_REG8(0x5bc0), 0x75 },
++	{ CCI_REG8(0x5bc1), 0x75 }, { CCI_REG8(0x5bc2), 0x75 },
++	{ CCI_REG8(0x5bc3), 0x75 }, { CCI_REG8(0x5bc4), 0x75 },
++	{ CCI_REG8(0x5bc5), 0x75 }, { CCI_REG8(0x5bc6), 0x75 },
++	{ CCI_REG8(0x5bc7), 0x75 }, { CCI_REG8(0x5bc8), 0x75 },
++	{ CCI_REG8(0x5bc9), 0x75 }, { CCI_REG8(0x5bca), 0x75 },
++	{ CCI_REG8(0x5bcb), 0x75 }, { CCI_REG8(0x5bcc), 0x75 },
++	{ CCI_REG8(0x5bcd), 0x75 }, { CCI_REG8(0x5bce), 0x75 },
++	{ CCI_REG8(0x5bcf), 0x75 }, { CCI_REG8(0x5bd0), 0x75 },
++	{ CCI_REG8(0x5bd1), 0x75 }, { CCI_REG8(0x5bd2), 0x75 },
++	{ CCI_REG8(0x5bd3), 0x75 }, { CCI_REG8(0x5bd4), 0x75 },
++	{ CCI_REG8(0x5bd5), 0x75 }, { CCI_REG8(0x5bd6), 0x75 },
++	{ CCI_REG8(0x5bd7), 0x75 }, { CCI_REG8(0x5bd8), 0x75 },
++	{ CCI_REG8(0x5bd9), 0x75 }, { CCI_REG8(0x5bda), 0x75 },
++	{ CCI_REG8(0x5bdb), 0x75 }, { CCI_REG8(0x5bdc), 0x75 },
++	{ CCI_REG8(0x5bdd), 0x75 }, { CCI_REG8(0x5bde), 0x75 },
++	{ CCI_REG8(0x5bdf), 0x75 }, { CCI_REG8(0x5be0), 0x75 },
++	{ CCI_REG8(0x5be1), 0x75 }, { CCI_REG8(0x5be2), 0x75 },
++	{ CCI_REG8(0x5be3), 0x75 }, { CCI_REG8(0x5be4), 0x75 },
++	{ CCI_REG8(0x5be5), 0x75 }, { CCI_REG8(0x5be6), 0x75 },
++	{ CCI_REG8(0x5be7), 0x75 }, { CCI_REG8(0x5be8), 0x75 },
++	{ CCI_REG8(0x5be9), 0x75 }, { CCI_REG8(0x5bea), 0x75 },
++	{ CCI_REG8(0x5beb), 0x75 }, { CCI_REG8(0x5bec), 0x75 },
++	{ CCI_REG8(0x5bed), 0x75 }, { CCI_REG8(0x5bee), 0x75 },
++	{ CCI_REG8(0x5bef), 0x75 }, { CCI_REG8(0x5bf0), 0x75 },
++	{ CCI_REG8(0x5bf1), 0x75 }, { CCI_REG8(0x5bf2), 0x75 },
++	{ CCI_REG8(0x5bf3), 0x75 }, { CCI_REG8(0x5bf4), 0x75 },
++	{ CCI_REG8(0x5bf5), 0x75 }, { CCI_REG8(0x5bf6), 0x75 },
++	{ CCI_REG8(0x5bf7), 0x75 }, { CCI_REG8(0x5bf8), 0x75 },
++	{ CCI_REG8(0x5bf9), 0x75 }, { CCI_REG8(0x5bfa), 0x75 },
++	{ CCI_REG8(0x5bfb), 0x75 }, { CCI_REG8(0x5bfc), 0x75 },
++	{ CCI_REG8(0x5bfd), 0x75 }, { CCI_REG8(0x5bfe), 0x75 },
++	{ CCI_REG8(0x5bff), 0x75 }, { CCI_REG8(0x5c00), 0x75 },
++	{ CCI_REG8(0x5c01), 0x75 }, { CCI_REG8(0x5c02), 0x75 },
++	{ CCI_REG8(0x5c03), 0x75 }, { CCI_REG8(0x5c04), 0x75 },
++	{ CCI_REG8(0x5c05), 0x75 }, { CCI_REG8(0x5c06), 0x75 },
++	{ CCI_REG8(0x5c07), 0x75 }, { CCI_REG8(0x5c08), 0x75 },
++	{ CCI_REG8(0x5c09), 0x75 }, { CCI_REG8(0x5c0a), 0x75 },
++	{ CCI_REG8(0x5c0b), 0x75 }, { CCI_REG8(0x5c0c), 0x75 },
++	{ CCI_REG8(0x5c0d), 0x75 }, { CCI_REG8(0x5c0e), 0x75 },
++	{ CCI_REG8(0x5c0f), 0x75 }, { CCI_REG8(0x5c10), 0x75 },
++	{ CCI_REG8(0x5c11), 0x75 }, { CCI_REG8(0x5c12), 0x75 },
++	{ CCI_REG8(0x5c13), 0x75 }, { CCI_REG8(0x5c14), 0x75 },
++	{ CCI_REG8(0x5c15), 0x75 }, { CCI_REG8(0x5c16), 0x75 },
++	{ CCI_REG8(0x5c17), 0x75 }, { CCI_REG8(0x5c18), 0x75 },
++	{ CCI_REG8(0x5c19), 0x75 }, { CCI_REG8(0x5c1a), 0x75 },
++	{ CCI_REG8(0x5c1b), 0x75 }, { CCI_REG8(0x5c1c), 0x75 },
++	{ CCI_REG8(0x5c1d), 0x75 }, { CCI_REG8(0x5c1e), 0x75 },
++	{ CCI_REG8(0x5c1f), 0x75 }, { CCI_REG8(0x5c20), 0x75 },
++	{ CCI_REG8(0x5c21), 0x75 }, { CCI_REG8(0x5c22), 0x75 },
++	{ CCI_REG8(0x5c23), 0x75 }, { CCI_REG8(0x5c24), 0x75 },
++	{ CCI_REG8(0x5c25), 0x75 }, { CCI_REG8(0x5c26), 0x75 },
++	{ CCI_REG8(0x5c27), 0x75 }, { CCI_REG8(0x5c28), 0x75 },
++	{ CCI_REG8(0x5c29), 0x75 }, { CCI_REG8(0x5c2a), 0x75 },
++	{ CCI_REG8(0x5c2b), 0x75 }, { CCI_REG8(0x5c2c), 0x75 },
++	{ CCI_REG8(0x5c2d), 0x75 }, { CCI_REG8(0x5c2e), 0x75 },
++	{ CCI_REG8(0x5c2f), 0x75 }, { CCI_REG8(0x5c30), 0x75 },
++	{ CCI_REG8(0x5c31), 0x75 }, { CCI_REG8(0x5c32), 0x75 },
++	{ CCI_REG8(0x5c33), 0x75 }, { CCI_REG8(0x5c34), 0x75 },
++	{ CCI_REG8(0x5c35), 0x75 }, { CCI_REG8(0x5c36), 0x75 },
++	{ CCI_REG8(0x5c37), 0x75 }, { CCI_REG8(0x5c38), 0x75 },
++	{ CCI_REG8(0x5c39), 0x75 }, { CCI_REG8(0x5c3a), 0x75 },
++	{ CCI_REG8(0x5c3b), 0x75 }, { CCI_REG8(0x5c3c), 0x75 },
++	{ CCI_REG8(0x5c3d), 0x75 }, { CCI_REG8(0x5c3e), 0x75 },
++	{ CCI_REG8(0x5c3f), 0x75 }, { CCI_REG8(0x5c40), 0x75 },
++	{ CCI_REG8(0x5c41), 0x75 }, { CCI_REG8(0x5c42), 0x75 },
++	{ CCI_REG8(0x5c43), 0x75 }, { CCI_REG8(0x5c44), 0x75 },
++	{ CCI_REG8(0x5c45), 0x75 }, { CCI_REG8(0x5c46), 0x75 },
++	{ CCI_REG8(0x5c47), 0x75 }, { CCI_REG8(0x5c48), 0x75 },
++	{ CCI_REG8(0x5c49), 0x75 }, { CCI_REG8(0x5c4a), 0x75 },
++	{ CCI_REG8(0x5c4b), 0x75 }, { CCI_REG8(0x5c4c), 0x75 },
++	{ CCI_REG8(0x5c4d), 0x75 }, { CCI_REG8(0x5c4e), 0x75 },
++	{ CCI_REG8(0x5c4f), 0x75 }, { CCI_REG8(0x5c50), 0x75 },
++	{ CCI_REG8(0x5c51), 0x75 }, { CCI_REG8(0x5c52), 0x75 },
++	{ CCI_REG8(0x5c53), 0x75 }, { CCI_REG8(0x5c54), 0x75 },
++	{ CCI_REG8(0x5c55), 0x75 }, { CCI_REG8(0x5c56), 0x75 },
++	{ CCI_REG8(0x5c57), 0x75 }, { CCI_REG8(0x5c58), 0x75 },
++	{ CCI_REG8(0x5c59), 0x75 }, { CCI_REG8(0x5c5a), 0x75 },
++	{ CCI_REG8(0x5c5b), 0x75 }, { CCI_REG8(0x5c5c), 0x75 },
++	{ CCI_REG8(0x5c5d), 0x75 }, { CCI_REG8(0x5c5e), 0x75 },
++	{ CCI_REG8(0x5c5f), 0x75 }, { CCI_REG8(0x5c60), 0x75 },
++	{ CCI_REG8(0x5c61), 0x75 }, { CCI_REG8(0x5c62), 0x75 },
++	{ CCI_REG8(0x5c63), 0x75 }, { CCI_REG8(0x5c64), 0x75 },
++	{ CCI_REG8(0x5c65), 0x75 }, { CCI_REG8(0x5c66), 0x75 },
++	{ CCI_REG8(0x5c67), 0x75 }, { CCI_REG8(0x5c68), 0x75 },
++	{ CCI_REG8(0x5c69), 0x75 }, { CCI_REG8(0x5c6a), 0x75 },
++	{ CCI_REG8(0x5c6b), 0x75 }, { CCI_REG8(0x5c6c), 0x75 },
++	{ CCI_REG8(0x5c6d), 0x75 }, { CCI_REG8(0x5c6e), 0x75 },
++	{ CCI_REG8(0x5c6f), 0x75 }, { CCI_REG8(0x5c70), 0x75 },
++	{ CCI_REG8(0x5c71), 0x75 }, { CCI_REG8(0x5c72), 0x75 },
++	{ CCI_REG8(0x5c73), 0x75 }, { CCI_REG8(0x5c74), 0x75 },
++	{ CCI_REG8(0x5c75), 0x75 }, { CCI_REG8(0x5c76), 0x75 },
++	{ CCI_REG8(0x5c77), 0x75 }, { CCI_REG8(0x5c78), 0x75 },
++	{ CCI_REG8(0x5c79), 0x75 }, { CCI_REG8(0x5c7a), 0x75 },
++	{ CCI_REG8(0x5c7b), 0x75 }, { CCI_REG8(0x5c7c), 0x75 },
++	{ CCI_REG8(0x5c7d), 0x75 }, { CCI_REG8(0x5c7e), 0x75 },
++	{ CCI_REG8(0x5c7f), 0x75 }, { CCI_REG8(0x5c80), 0x75 },
++	{ CCI_REG8(0x5c81), 0x75 }, { CCI_REG8(0x5c82), 0x75 },
++	{ CCI_REG8(0x5c83), 0x75 }, { CCI_REG8(0x5c84), 0x75 },
++	{ CCI_REG8(0x5c85), 0x75 }, { CCI_REG8(0x5c86), 0x75 },
++	{ CCI_REG8(0x5c87), 0x75 }, { CCI_REG8(0x5c88), 0x75 },
++	{ CCI_REG8(0x5c89), 0x75 }, { CCI_REG8(0x5c8a), 0x75 },
++	{ CCI_REG8(0x5c8b), 0x75 }, { CCI_REG8(0x5c8c), 0x75 },
++	{ CCI_REG8(0x5c8d), 0x75 }, { CCI_REG8(0x5c8e), 0x75 },
++	{ CCI_REG8(0x5c8f), 0x75 }, { CCI_REG8(0x5c90), 0x75 },
++	{ CCI_REG8(0x5c91), 0x75 }, { CCI_REG8(0x5c92), 0x75 },
++	{ CCI_REG8(0x5c93), 0x75 }, { CCI_REG8(0x5c94), 0x75 },
++	{ CCI_REG8(0x5c95), 0x75 }, { CCI_REG8(0x5c96), 0x75 },
++	{ CCI_REG8(0x5c97), 0x75 }, { CCI_REG8(0x5c98), 0x75 },
++	{ CCI_REG8(0x5c99), 0x75 }, { CCI_REG8(0x5c9a), 0x75 },
++	{ CCI_REG8(0x5c9b), 0x75 }, { CCI_REG8(0x5c9c), 0x75 },
++	{ CCI_REG8(0x5c9d), 0x75 }, { CCI_REG8(0x5c9e), 0x75 },
++	{ CCI_REG8(0x5c9f), 0x75 }, { CCI_REG8(0x5ca0), 0x75 },
++	{ CCI_REG8(0x5ca1), 0x75 }, { CCI_REG8(0x5ca2), 0x75 },
++	{ CCI_REG8(0x5ca3), 0x75 }, { CCI_REG8(0x5ca4), 0x75 },
++	{ CCI_REG8(0x5ca5), 0x75 }, { CCI_REG8(0x5ca6), 0x75 },
++	{ CCI_REG8(0x5ca7), 0x75 }, { CCI_REG8(0x5ca8), 0x75 },
++	{ CCI_REG8(0x5ca9), 0x75 }, { CCI_REG8(0x5caa), 0x75 },
++	{ CCI_REG8(0x5cab), 0x75 }, { CCI_REG8(0x5cac), 0x75 },
++	{ CCI_REG8(0x5cad), 0x75 }, { CCI_REG8(0x5cae), 0x75 },
++	{ CCI_REG8(0x5caf), 0x75 }, { CCI_REG8(0x5cb0), 0x75 },
++	{ CCI_REG8(0x5cb1), 0x75 }, { CCI_REG8(0x5cb2), 0x75 },
++	{ CCI_REG8(0x5cb3), 0x75 }, { CCI_REG8(0x5cb4), 0x75 },
++	{ CCI_REG8(0x5cb5), 0x75 }, { CCI_REG8(0x5cb6), 0x75 },
++	{ CCI_REG8(0x5cb7), 0x75 }, { CCI_REG8(0x5cb8), 0x75 },
++	{ CCI_REG8(0x5cb9), 0x75 }, { CCI_REG8(0x5cba), 0x75 },
++	{ CCI_REG8(0x5cbb), 0x75 }, { CCI_REG8(0x5cbc), 0x75 },
++	{ CCI_REG8(0x5cbd), 0x75 }, { CCI_REG8(0x5cbe), 0x75 },
++	{ CCI_REG8(0x5cbf), 0x75 }, { CCI_REG8(0x5cc0), 0x75 },
++	{ CCI_REG8(0x5cc1), 0x75 }, { CCI_REG8(0x5cc2), 0x75 },
++	{ CCI_REG8(0x5cc3), 0x75 }, { CCI_REG8(0x5cc4), 0x75 },
++	{ CCI_REG8(0x5cc5), 0x75 }, { CCI_REG8(0x5cc6), 0x75 },
++	{ CCI_REG8(0x5cc7), 0x75 }, { CCI_REG8(0x5cc8), 0x75 },
++	{ CCI_REG8(0x5cc9), 0x75 }, { CCI_REG8(0x5cca), 0x75 },
++	{ CCI_REG8(0x5ccb), 0x75 }, { CCI_REG8(0x5ccc), 0x75 },
++	{ CCI_REG8(0x5ccd), 0x75 }, { CCI_REG8(0x5cce), 0x75 },
++	{ CCI_REG8(0x5ccf), 0x75 }, { CCI_REG8(0x5cd0), 0x75 },
++	{ CCI_REG8(0x5cd1), 0x75 }, { CCI_REG8(0x5cd2), 0x75 },
++	{ CCI_REG8(0x5cd3), 0x75 }, { CCI_REG8(0x5cd4), 0x75 },
++	{ CCI_REG8(0x5cd5), 0x75 }, { CCI_REG8(0x5cd6), 0x75 },
++	{ CCI_REG8(0x5cd7), 0x75 }, { CCI_REG8(0x5cd8), 0x75 },
++	{ CCI_REG8(0x5cd9), 0x75 }, { CCI_REG8(0x5cda), 0x75 },
++	{ CCI_REG8(0x5cdb), 0x75 }, { CCI_REG8(0x5cdc), 0x75 },
++	{ CCI_REG8(0x5cdd), 0x75 }, { CCI_REG8(0x5cde), 0x75 },
++	{ CCI_REG8(0x5cdf), 0x75 }, { CCI_REG8(0x5ce0), 0x75 },
++	{ CCI_REG8(0x5ce1), 0x75 }, { CCI_REG8(0x5ce2), 0x75 },
++	{ CCI_REG8(0x5ce3), 0x75 }, { CCI_REG8(0x5ce4), 0x75 },
++	{ CCI_REG8(0x5ce5), 0x75 }, { CCI_REG8(0x5ce6), 0x75 },
++	{ CCI_REG8(0x5ce7), 0x75 }, { CCI_REG8(0x5ce8), 0x75 },
++	{ CCI_REG8(0x5ce9), 0x75 }, { CCI_REG8(0x5cea), 0x75 },
++	{ CCI_REG8(0x5ceb), 0x75 }, { CCI_REG8(0x5cec), 0x75 },
++	{ CCI_REG8(0x5ced), 0x75 }, { CCI_REG8(0x5cee), 0x75 },
++	{ CCI_REG8(0x5cef), 0x75 }, { CCI_REG8(0x5cf0), 0x75 },
++	{ CCI_REG8(0x5cf1), 0x75 }, { CCI_REG8(0x5cf2), 0x75 },
++	{ CCI_REG8(0x5cf3), 0x75 }, { CCI_REG8(0x5cf4), 0x75 },
++	{ CCI_REG8(0x5cf5), 0x75 }, { CCI_REG8(0x5cf6), 0x75 },
++	{ CCI_REG8(0x5cf7), 0x75 }, { CCI_REG8(0x5cf8), 0x75 },
++	{ CCI_REG8(0x5cf9), 0x75 }, { CCI_REG8(0x5cfa), 0x75 },
++	{ CCI_REG8(0x5cfb), 0x75 }, { CCI_REG8(0x5cfc), 0x75 },
++	{ CCI_REG8(0x5cfd), 0x75 }, { CCI_REG8(0x5cfe), 0x75 },
++	{ CCI_REG8(0x5cff), 0x75 }, { CCI_REG8(0x5d00), 0x75 },
++	{ CCI_REG8(0x5d01), 0x75 }, { CCI_REG8(0x5d02), 0x75 },
++	{ CCI_REG8(0x5d03), 0x75 }, { CCI_REG8(0x5d04), 0x75 },
++	{ CCI_REG8(0x5d05), 0x75 }, { CCI_REG8(0x5d06), 0x75 },
++	{ CCI_REG8(0x5d07), 0x75 }, { CCI_REG8(0x5d08), 0x75 },
++	{ CCI_REG8(0x5d09), 0x75 }, { CCI_REG8(0x5d0a), 0x75 },
++	{ CCI_REG8(0x5d0b), 0x75 }, { CCI_REG8(0x5d0c), 0x75 },
++	{ CCI_REG8(0x5d0d), 0x75 }, { CCI_REG8(0x5d0e), 0x75 },
++	{ CCI_REG8(0x5d0f), 0x75 }, { CCI_REG8(0x5d10), 0x75 },
++	{ CCI_REG8(0x5d11), 0x75 }, { CCI_REG8(0x5d12), 0x75 },
++	{ CCI_REG8(0x5d13), 0x75 }, { CCI_REG8(0x5d14), 0x75 },
++	{ CCI_REG8(0x5d15), 0x75 }, { CCI_REG8(0x5d16), 0x75 },
++	{ CCI_REG8(0x5d17), 0x75 }, { CCI_REG8(0x5d18), 0x75 },
++	{ CCI_REG8(0x5d19), 0x75 }, { CCI_REG8(0x5d1a), 0x75 },
++	{ CCI_REG8(0x5d1b), 0x75 }, { CCI_REG8(0x5d1c), 0x75 },
++	{ CCI_REG8(0x5d1d), 0x75 }, { CCI_REG8(0x5d1e), 0x75 },
++	{ CCI_REG8(0x5d1f), 0x75 }, { CCI_REG8(0x5d20), 0x75 },
++	{ CCI_REG8(0x5d21), 0x75 }, { CCI_REG8(0x5d22), 0x75 },
++	{ CCI_REG8(0x5d23), 0x75 }, { CCI_REG8(0x5d24), 0x75 },
++	{ CCI_REG8(0x5d25), 0x75 }, { CCI_REG8(0x5d26), 0x75 },
++	{ CCI_REG8(0x5d27), 0x75 }, { CCI_REG8(0x5d28), 0x75 },
++	{ CCI_REG8(0x5d29), 0x75 }, { CCI_REG8(0x5d2a), 0x75 },
++	{ CCI_REG8(0x5d2b), 0x75 }, { CCI_REG8(0x5d2c), 0x75 },
++	{ CCI_REG8(0x5d2d), 0x75 }, { CCI_REG8(0x5d2e), 0x75 },
++	{ CCI_REG8(0x5d2f), 0x75 }, { CCI_REG8(0x5d30), 0x75 },
++	{ CCI_REG8(0x5d31), 0x75 }, { CCI_REG8(0x5d32), 0x75 },
++	{ CCI_REG8(0x5d33), 0x75 }, { CCI_REG8(0x5d34), 0x75 },
++	{ CCI_REG8(0x5d35), 0x75 }, { CCI_REG8(0x5d36), 0x75 },
++	{ CCI_REG8(0x5d37), 0x75 }, { CCI_REG8(0x5d38), 0x75 },
++	{ CCI_REG8(0x5d39), 0x75 }, { CCI_REG8(0x5d3a), 0x75 },
++	{ CCI_REG8(0x5d3b), 0x75 }, { CCI_REG8(0x5d3c), 0x75 },
++	{ CCI_REG8(0x5d3d), 0x75 }, { CCI_REG8(0x5d3e), 0x75 },
++	{ CCI_REG8(0x5d3f), 0x75 }, { CCI_REG8(0x5d40), 0x75 },
++	{ CCI_REG8(0x5d41), 0x75 }, { CCI_REG8(0x5d42), 0x75 },
++	{ CCI_REG8(0x5d43), 0x75 }, { CCI_REG8(0x5d44), 0x75 },
++	{ CCI_REG8(0x5d45), 0x75 }, { CCI_REG8(0x5d46), 0x75 },
++	{ CCI_REG8(0x5d47), 0x75 }, { CCI_REG8(0x5d48), 0x75 },
++	{ CCI_REG8(0x5d49), 0x75 }, { CCI_REG8(0x5d4a), 0x75 },
++	{ CCI_REG8(0x5d4b), 0x75 }, { CCI_REG8(0x5d4c), 0x75 },
++	{ CCI_REG8(0x5d4d), 0x75 }, { CCI_REG8(0x5d4e), 0x75 },
++	{ CCI_REG8(0x5d4f), 0x75 }, { CCI_REG8(0x5d50), 0x75 },
++	{ CCI_REG8(0x5d51), 0x75 }, { CCI_REG8(0x5d52), 0x75 },
++	{ CCI_REG8(0x5d53), 0x75 }, { CCI_REG8(0x5d54), 0x75 },
++	{ CCI_REG8(0x5d55), 0x75 }, { CCI_REG8(0x5d56), 0x75 },
++	{ CCI_REG8(0x5d57), 0x75 }, { CCI_REG8(0x5d58), 0x75 },
++	{ CCI_REG8(0x5d59), 0x75 }, { CCI_REG8(0x5d5a), 0x75 },
++	{ CCI_REG8(0x5d5b), 0x75 }, { CCI_REG8(0x5d5c), 0x75 },
++	{ CCI_REG8(0x5d5d), 0x75 }, { CCI_REG8(0x5d5e), 0x75 },
++	{ CCI_REG8(0x5d5f), 0x75 }, { CCI_REG8(0x5d60), 0x75 },
++	{ CCI_REG8(0x5d61), 0x75 }, { CCI_REG8(0x5d62), 0x75 },
++	{ CCI_REG8(0x5d63), 0x75 }, { CCI_REG8(0x5d64), 0x75 },
++	{ CCI_REG8(0x5d65), 0x75 }, { CCI_REG8(0x5d66), 0x75 },
++	{ CCI_REG8(0x5d67), 0x75 }, { CCI_REG8(0x5d68), 0x75 },
++	{ CCI_REG8(0x5d69), 0x75 }, { CCI_REG8(0x5d6a), 0x75 },
++	{ CCI_REG8(0x5d6b), 0x75 }, { CCI_REG8(0x5d6c), 0x75 },
++	{ CCI_REG8(0x5d6d), 0x75 }, { CCI_REG8(0x5d6e), 0x75 },
++	{ CCI_REG8(0x5d6f), 0x75 }, { CCI_REG8(0x5d70), 0x75 },
++	{ CCI_REG8(0x5d71), 0x75 }, { CCI_REG8(0x5d72), 0x75 },
++	{ CCI_REG8(0x5d73), 0x75 }, { CCI_REG8(0x5d74), 0x75 },
++	{ CCI_REG8(0x5d75), 0x75 }, { CCI_REG8(0x5d76), 0x75 },
++	{ CCI_REG8(0x5d77), 0x75 }, { CCI_REG8(0x5d78), 0x75 },
++	{ CCI_REG8(0x5d79), 0x75 }, { CCI_REG8(0x5d7a), 0x75 },
++	{ CCI_REG8(0x5d7b), 0x75 }, { CCI_REG8(0x5d7c), 0x75 },
++	{ CCI_REG8(0x5d7d), 0x75 }, { CCI_REG8(0x5d7e), 0x75 },
++	{ CCI_REG8(0x5d7f), 0x75 }, { CCI_REG8(0x5d80), 0x75 },
++	{ CCI_REG8(0x5d81), 0x75 }, { CCI_REG8(0x5d82), 0x75 },
++	{ CCI_REG8(0x5d83), 0x75 }, { CCI_REG8(0x5d84), 0x75 },
++	{ CCI_REG8(0x5d85), 0x75 }, { CCI_REG8(0x5d86), 0x75 },
++	{ CCI_REG8(0x5d87), 0x75 }, { CCI_REG8(0x5d88), 0x75 },
++	{ CCI_REG8(0x5d89), 0x75 }, { CCI_REG8(0x5d8a), 0x75 },
++	{ CCI_REG8(0x5d8b), 0x75 }, { CCI_REG8(0x5d8c), 0x75 },
++	{ CCI_REG8(0x5d8d), 0x75 }, { CCI_REG8(0x5d8e), 0x75 },
++	{ CCI_REG8(0x5d8f), 0x75 }, { CCI_REG8(0x5d90), 0x75 },
++	{ CCI_REG8(0x5d91), 0x75 }, { CCI_REG8(0x5d92), 0x75 },
++	{ CCI_REG8(0x5d93), 0x75 }, { CCI_REG8(0x5d94), 0x75 },
++	{ CCI_REG8(0x5d95), 0x75 }, { CCI_REG8(0x5d96), 0x75 },
++	{ CCI_REG8(0x5d97), 0x75 }, { CCI_REG8(0x5d98), 0x75 },
++	{ CCI_REG8(0x5d99), 0x75 }, { CCI_REG8(0x5d9a), 0x75 },
++	{ CCI_REG8(0x5d9b), 0x75 }, { CCI_REG8(0x5d9c), 0x75 },
++	{ CCI_REG8(0x5d9d), 0x75 }, { CCI_REG8(0x5d9e), 0x75 },
++	{ CCI_REG8(0x5d9f), 0x75 }, { CCI_REG8(0x5da0), 0x75 },
++	{ CCI_REG8(0x5da1), 0x75 }, { CCI_REG8(0x5da2), 0x75 },
++	{ CCI_REG8(0x5da3), 0x75 }, { CCI_REG8(0x5da4), 0x75 },
++	{ CCI_REG8(0x5da5), 0x75 }, { CCI_REG8(0x5da6), 0x75 },
++	{ CCI_REG8(0x5da7), 0x75 }, { CCI_REG8(0x5da8), 0x75 },
++	{ CCI_REG8(0x5da9), 0x75 }, { CCI_REG8(0x5daa), 0x75 },
++	{ CCI_REG8(0x5dab), 0x75 }, { CCI_REG8(0x5dac), 0x75 },
++	{ CCI_REG8(0x5dad), 0x75 }, { CCI_REG8(0x5dae), 0x75 },
++	{ CCI_REG8(0x5daf), 0x75 }, { CCI_REG8(0x5db0), 0x75 },
++	{ CCI_REG8(0x5db1), 0x75 }, { CCI_REG8(0x5db2), 0x75 },
++	{ CCI_REG8(0x5db3), 0x75 }, { CCI_REG8(0x5db4), 0x75 },
++	{ CCI_REG8(0x5db5), 0x75 }, { CCI_REG8(0x5db6), 0x75 },
++	{ CCI_REG8(0x5db7), 0x75 }, { CCI_REG8(0x5db8), 0x75 },
++	{ CCI_REG8(0x5db9), 0x75 }, { CCI_REG8(0x5dba), 0x75 },
++	{ CCI_REG8(0x5dbb), 0x75 }, { CCI_REG8(0x5dbc), 0x75 },
++	{ CCI_REG8(0x5dbd), 0x75 }, { CCI_REG8(0x5dbe), 0x75 },
++	{ CCI_REG8(0x5dbf), 0x75 }, { CCI_REG8(0x5dc0), 0x75 },
++	{ CCI_REG8(0x5dc1), 0x75 }, { CCI_REG8(0x5dc2), 0x75 },
++	{ CCI_REG8(0x5dc3), 0x75 }, { CCI_REG8(0x5dc4), 0x75 },
++	{ CCI_REG8(0x5dc5), 0x75 }, { CCI_REG8(0x5dc6), 0x75 },
++	{ CCI_REG8(0x5dc7), 0x75 }, { CCI_REG8(0x5dc8), 0x75 },
++	{ CCI_REG8(0x5dc9), 0x75 }, { CCI_REG8(0x5dca), 0x75 },
++	{ CCI_REG8(0x5dcb), 0x75 }, { CCI_REG8(0x5dcc), 0x75 },
++	{ CCI_REG8(0x5dcd), 0x75 }, { CCI_REG8(0x5dce), 0x75 },
++	{ CCI_REG8(0x5dcf), 0x75 }, { CCI_REG8(0x5dd0), 0x75 },
++	{ CCI_REG8(0x5dd1), 0x75 }, { CCI_REG8(0x5dd2), 0x75 },
++	{ CCI_REG8(0x5dd3), 0x75 }, { CCI_REG8(0x5dd4), 0x75 },
++	{ CCI_REG8(0x5dd5), 0x75 }, { CCI_REG8(0x5dd6), 0x75 },
++	{ CCI_REG8(0x5dd7), 0x75 }, { CCI_REG8(0x5dd8), 0x75 },
++	{ CCI_REG8(0x5dd9), 0x75 }, { CCI_REG8(0x5dda), 0x75 },
++	{ CCI_REG8(0x5ddb), 0x75 }, { CCI_REG8(0x5ddc), 0x75 },
++	{ CCI_REG8(0x5ddd), 0x75 }, { CCI_REG8(0x5dde), 0x75 },
++	{ CCI_REG8(0x5ddf), 0x75 }, { CCI_REG8(0x5de0), 0x75 },
++	{ CCI_REG8(0x5de1), 0x75 }, { CCI_REG8(0x5de2), 0x75 },
++	{ CCI_REG8(0x5de3), 0x75 }, { CCI_REG8(0x5de4), 0x75 },
++	{ CCI_REG8(0x5de5), 0x75 }, { CCI_REG8(0x5de6), 0x75 },
++	{ CCI_REG8(0x5de7), 0x75 }, { CCI_REG8(0x5de8), 0x75 },
++	{ CCI_REG8(0x5de9), 0x75 }, { CCI_REG8(0x5dea), 0x75 },
++	{ CCI_REG8(0x5deb), 0x75 }, { CCI_REG8(0x5dec), 0x75 },
++	{ CCI_REG8(0x5ded), 0x75 }, { CCI_REG8(0x5dee), 0x75 },
++	{ CCI_REG8(0x5def), 0x75 }, { CCI_REG8(0x5df0), 0x75 },
++	{ CCI_REG8(0x5df1), 0x75 }, { CCI_REG8(0x5df2), 0x75 },
++	{ CCI_REG8(0x5df3), 0x75 }, { CCI_REG8(0x5df4), 0x75 },
++	{ CCI_REG8(0x5df5), 0x75 }, { CCI_REG8(0x5df6), 0x75 },
++	{ CCI_REG8(0x5df7), 0x75 }, { CCI_REG8(0x5df8), 0x75 },
++	{ CCI_REG8(0x5df9), 0x75 }, { CCI_REG8(0x5dfa), 0x75 },
++	{ CCI_REG8(0x5dfb), 0x75 }, { CCI_REG8(0x5dfc), 0x75 },
++	{ CCI_REG8(0x5dfd), 0x75 }, { CCI_REG8(0x5dfe), 0x75 },
++	{ CCI_REG8(0x5dff), 0x75 }, { CCI_REG8(0x5e00), 0x75 },
++	{ CCI_REG8(0x5e01), 0x75 }, { CCI_REG8(0x5e02), 0x75 },
++	{ CCI_REG8(0x5e03), 0x75 }, { CCI_REG8(0x5e04), 0x75 },
++	{ CCI_REG8(0x5e05), 0x75 }, { CCI_REG8(0x5e06), 0x75 },
++	{ CCI_REG8(0x5e07), 0x75 }, { CCI_REG8(0x5e08), 0x75 },
++	{ CCI_REG8(0x5e09), 0x75 }, { CCI_REG8(0x5e0a), 0x75 },
++	{ CCI_REG8(0x5e0b), 0x75 }, { CCI_REG8(0x5e0c), 0x75 },
++	{ CCI_REG8(0x5e0d), 0x75 }, { CCI_REG8(0x5e0e), 0x75 },
++	{ CCI_REG8(0x5e0f), 0x75 }, { CCI_REG8(0x5e10), 0x75 },
++	{ CCI_REG8(0x5e11), 0x75 }, { CCI_REG8(0x5e12), 0x75 },
++	{ CCI_REG8(0x5e13), 0x75 }, { CCI_REG8(0x5e14), 0x75 },
++	{ CCI_REG8(0x5e15), 0x75 }, { CCI_REG8(0x5e16), 0x75 },
++	{ CCI_REG8(0x5e17), 0x75 }, { CCI_REG8(0x5e18), 0x75 },
++	{ CCI_REG8(0x5e19), 0x75 }, { CCI_REG8(0x5e1a), 0x75 },
++	{ CCI_REG8(0x5e1b), 0x75 }, { CCI_REG8(0x5e1c), 0x75 },
++	{ CCI_REG8(0x5e1d), 0x75 }, { CCI_REG8(0x5e1e), 0x75 },
++	{ CCI_REG8(0x5e1f), 0x75 }, { CCI_REG8(0x5e20), 0x75 },
++	{ CCI_REG8(0x5e21), 0x75 }, { CCI_REG8(0x5e22), 0x75 },
++	{ CCI_REG8(0x5e23), 0x75 }, { CCI_REG8(0x5e24), 0x75 },
++	{ CCI_REG8(0x5e25), 0x75 }, { CCI_REG8(0x5e26), 0x75 },
++	{ CCI_REG8(0x5e27), 0x75 }, { CCI_REG8(0x5e28), 0x75 },
++	{ CCI_REG8(0x5e29), 0x75 }, { CCI_REG8(0x5e2a), 0x75 },
++	{ CCI_REG8(0x5e2b), 0x75 }, { CCI_REG8(0x5e2c), 0x75 },
++	{ CCI_REG8(0x5e2d), 0x75 }, { CCI_REG8(0x5e2e), 0x75 },
++	{ CCI_REG8(0x5e2f), 0x75 }, { CCI_REG8(0x5e30), 0x75 },
++	{ CCI_REG8(0x5e31), 0x75 }, { CCI_REG8(0x5e32), 0x75 },
++	{ CCI_REG8(0x5e33), 0x75 }, { CCI_REG8(0x5e34), 0x75 },
++	{ CCI_REG8(0x5e35), 0x75 }, { CCI_REG8(0x5e36), 0x75 },
++	{ CCI_REG8(0x5e37), 0x75 }, { CCI_REG8(0x5e38), 0x75 },
++	{ CCI_REG8(0x5e39), 0x75 }, { CCI_REG8(0x5e3a), 0x75 },
++	{ CCI_REG8(0x5e3b), 0x75 }, { CCI_REG8(0x5e3c), 0x75 },
++	{ CCI_REG8(0x5e3d), 0x75 }, { CCI_REG8(0x5e3e), 0x75 },
++	{ CCI_REG8(0x5e3f), 0x75 }, { CCI_REG8(0x5e40), 0x75 },
++	{ CCI_REG8(0x5e41), 0x75 }, { CCI_REG8(0x5e42), 0x75 },
++	{ CCI_REG8(0x5e43), 0x75 }, { CCI_REG8(0x5e44), 0x75 },
++	{ CCI_REG8(0x5e45), 0x75 }, { CCI_REG8(0x5e46), 0x75 },
++	{ CCI_REG8(0x5e47), 0x75 }, { CCI_REG8(0x5e48), 0x75 },
++	{ CCI_REG8(0x5e49), 0x75 }, { CCI_REG8(0x5e4a), 0x75 },
++	{ CCI_REG8(0x5e4b), 0x75 }, { CCI_REG8(0x5e4c), 0x75 },
++	{ CCI_REG8(0x5e4d), 0x75 }, { CCI_REG8(0x5e4e), 0x75 },
++	{ CCI_REG8(0x5e4f), 0x75 }, { CCI_REG8(0x5e50), 0x75 },
++	{ CCI_REG8(0x5e51), 0x75 }, { CCI_REG8(0x5e52), 0x75 },
++	{ CCI_REG8(0x5e53), 0x75 }, { CCI_REG8(0x5e54), 0x75 },
++	{ CCI_REG8(0x5e55), 0x75 }, { CCI_REG8(0x5e56), 0x75 },
++	{ CCI_REG8(0x5e57), 0x75 }, { CCI_REG8(0x5e58), 0x75 },
++	{ CCI_REG8(0x5e59), 0x75 }, { CCI_REG8(0x5e5a), 0x75 },
++	{ CCI_REG8(0x5e5b), 0x75 }, { CCI_REG8(0x5e5c), 0x75 },
++	{ CCI_REG8(0x5e5d), 0x75 }, { CCI_REG8(0x5e5e), 0x75 },
++	{ CCI_REG8(0x5e5f), 0x75 }, { CCI_REG8(0x5e60), 0x75 },
++	{ CCI_REG8(0x5e61), 0x75 }, { CCI_REG8(0x5e62), 0x75 },
++	{ CCI_REG8(0x5e63), 0x75 }, { CCI_REG8(0x5e64), 0x75 },
++	{ CCI_REG8(0x5e65), 0x75 }, { CCI_REG8(0x5e66), 0x75 },
++	{ CCI_REG8(0x5e67), 0x75 }, { CCI_REG8(0x5e68), 0x75 },
++	{ CCI_REG8(0x5e69), 0x75 }, { CCI_REG8(0x5e6a), 0x75 },
++	{ CCI_REG8(0x5e6b), 0x75 }, { CCI_REG8(0x5e6c), 0x75 },
++	{ CCI_REG8(0x5e6d), 0x75 }, { CCI_REG8(0x5e6e), 0x75 },
++	{ CCI_REG8(0x5e6f), 0x75 }, { CCI_REG8(0x5e70), 0x75 },
++	{ CCI_REG8(0x5e71), 0x75 }, { CCI_REG8(0x5e72), 0x75 },
++	{ CCI_REG8(0x5e73), 0x75 }, { CCI_REG8(0x5e74), 0x75 },
++	{ CCI_REG8(0x5e75), 0x75 }, { CCI_REG8(0x5e76), 0x75 },
++	{ CCI_REG8(0x5e77), 0x75 }, { CCI_REG8(0x5e78), 0x75 },
++	{ CCI_REG8(0x5e79), 0x75 }, { CCI_REG8(0x5e7a), 0x75 },
++	{ CCI_REG8(0x5e7b), 0x75 }, { CCI_REG8(0x5e7c), 0x75 },
++	{ CCI_REG8(0x5e7d), 0x75 }, { CCI_REG8(0x5e7e), 0x75 },
++	{ CCI_REG8(0x5e7f), 0x75 }, { CCI_REG8(0x5e80), 0x75 },
++	{ CCI_REG8(0x5e81), 0x75 }, { CCI_REG8(0x5e82), 0x75 },
++	{ CCI_REG8(0x5e83), 0x75 }, { CCI_REG8(0x5e84), 0x75 },
++	{ CCI_REG8(0x5e85), 0x75 }, { CCI_REG8(0x5e86), 0x75 },
++	{ CCI_REG8(0x5e87), 0x75 }, { CCI_REG8(0x5e88), 0x75 },
++	{ CCI_REG8(0x5e89), 0x75 }, { CCI_REG8(0x5e8a), 0x75 },
++	{ CCI_REG8(0x5e8b), 0x75 }, { CCI_REG8(0x5e8c), 0x75 },
++	{ CCI_REG8(0x5e8d), 0x75 }, { CCI_REG8(0x5e8e), 0x75 },
++	{ CCI_REG8(0x5e8f), 0x75 }, { CCI_REG8(0x5e90), 0x75 },
++	{ CCI_REG8(0x5e91), 0x75 }, { CCI_REG8(0x5e92), 0x75 },
++	{ CCI_REG8(0x5e93), 0x75 }, { CCI_REG8(0x5e94), 0x75 },
++	{ CCI_REG8(0x5e95), 0x75 }, { CCI_REG8(0x5e96), 0x75 },
++	{ CCI_REG8(0x5e97), 0x75 }, { CCI_REG8(0x5e98), 0x75 },
++	{ CCI_REG8(0x5e99), 0x75 }, { CCI_REG8(0x5e9a), 0x75 },
++	{ CCI_REG8(0x5e9b), 0x75 }, { CCI_REG8(0x5e9c), 0x75 },
++	{ CCI_REG8(0x5e9d), 0x75 }, { CCI_REG8(0x5e9e), 0x75 },
++	{ CCI_REG8(0x5e9f), 0x75 }, { CCI_REG8(0x5ea0), 0x75 },
++	{ CCI_REG8(0x5ea1), 0x75 }, { CCI_REG8(0x5ea2), 0x75 },
++	{ CCI_REG8(0x5ea3), 0x75 }, { CCI_REG8(0x5ea4), 0x75 },
++	{ CCI_REG8(0x5ea5), 0x75 }, { CCI_REG8(0x5ea6), 0x75 },
++	{ CCI_REG8(0x5ea7), 0x75 }, { CCI_REG8(0x5ea8), 0x75 },
++	{ CCI_REG8(0x5ea9), 0x75 }, { CCI_REG8(0x5eaa), 0x75 },
++	{ CCI_REG8(0x5eab), 0x75 }, { CCI_REG8(0x5eac), 0x75 },
++	{ CCI_REG8(0x5ead), 0x75 }, { CCI_REG8(0x5eae), 0x75 },
++	{ CCI_REG8(0x5eaf), 0x75 }, { CCI_REG8(0x5eb0), 0x75 },
++	{ CCI_REG8(0x5eb1), 0x75 }, { CCI_REG8(0x5eb2), 0x75 },
++	{ CCI_REG8(0x5eb3), 0x75 }, { CCI_REG8(0x5eb4), 0x75 },
++	{ CCI_REG8(0x5eb5), 0x75 }, { CCI_REG8(0x5eb6), 0x75 },
++	{ CCI_REG8(0x5eb7), 0x75 }, { CCI_REG8(0x5eb8), 0x75 },
++	{ CCI_REG8(0x5eb9), 0x75 }, { CCI_REG8(0x5eba), 0x75 },
++	{ CCI_REG8(0x5ebb), 0x75 }, { CCI_REG8(0x5ebc), 0x75 },
++	{ CCI_REG8(0x5ebd), 0x75 }, { CCI_REG8(0x5ebe), 0x75 },
++	{ CCI_REG8(0x5ebf), 0x75 }, { CCI_REG8(0x5ec0), 0x75 },
++	{ CCI_REG8(0x5ec1), 0x75 }, { CCI_REG8(0x5ec2), 0x75 },
++	{ CCI_REG8(0x5ec3), 0x75 }, { CCI_REG8(0x5ec4), 0x75 },
++	{ CCI_REG8(0x5ec5), 0x75 }, { CCI_REG8(0x5ec6), 0x75 },
++	{ CCI_REG8(0x5ec7), 0x75 }, { CCI_REG8(0x5ec8), 0x75 },
++	{ CCI_REG8(0x5ec9), 0x75 }, { CCI_REG8(0x5eca), 0x75 },
++	{ CCI_REG8(0x5ecb), 0x75 }, { CCI_REG8(0x5ecc), 0x75 },
++	{ CCI_REG8(0x5ecd), 0x75 }, { CCI_REG8(0x5ece), 0x75 },
++	{ CCI_REG8(0x5ecf), 0x75 }, { CCI_REG8(0x5ed0), 0x75 },
++	{ CCI_REG8(0x5ed1), 0x75 }, { CCI_REG8(0x5ed2), 0x75 },
++	{ CCI_REG8(0x5ed3), 0x75 }, { CCI_REG8(0x5ed4), 0x75 },
++	{ CCI_REG8(0x5ed5), 0x75 }, { CCI_REG8(0x5ed6), 0x75 },
++	{ CCI_REG8(0x5ed7), 0x75 }, { CCI_REG8(0x5ed8), 0x75 },
++	{ CCI_REG8(0x5ed9), 0x75 }, { CCI_REG8(0x5eda), 0x75 },
++	{ CCI_REG8(0x5edb), 0x75 }, { CCI_REG8(0x5edc), 0x75 },
++	{ CCI_REG8(0x5edd), 0x75 }, { CCI_REG8(0x5ede), 0x75 },
++	{ CCI_REG8(0x5edf), 0x75 }, { CCI_REG8(0xfff9), 0x08 },
++	{ CCI_REG8(0x1570), 0x00 }, { CCI_REG8(0x15d0), 0x00 },
++	{ CCI_REG8(0x15a0), 0x02 }, { CCI_REG8(0x15a1), 0x00 },
++	{ CCI_REG8(0x15a2), 0x02 }, { CCI_REG8(0x15a3), 0x76 },
++	{ CCI_REG8(0x15a4), 0x03 }, { CCI_REG8(0x15a5), 0x08 },
++	{ CCI_REG8(0x15a6), 0x00 }, { CCI_REG8(0x15a7), 0x60 },
++	{ CCI_REG8(0x15a8), 0x01 }, { CCI_REG8(0x15a9), 0x00 },
++	{ CCI_REG8(0x15aa), 0x02 }, { CCI_REG8(0x15ab), 0x00 },
++	{ CCI_REG8(0x1600), 0x02 }, { CCI_REG8(0x1601), 0x00 },
++	{ CCI_REG8(0x1602), 0x02 }, { CCI_REG8(0x1603), 0x76 },
++	{ CCI_REG8(0x1604), 0x03 }, { CCI_REG8(0x1605), 0x08 },
++	{ CCI_REG8(0x1606), 0x00 }, { CCI_REG8(0x1607), 0x60 },
++	{ CCI_REG8(0x1608), 0x01 }, { CCI_REG8(0x1609), 0x00 },
++	{ CCI_REG8(0x160a), 0x02 }, { CCI_REG8(0x160b), 0x00 },
++	{ CCI_REG8(0x1633), 0x03 }, { CCI_REG8(0x1634), 0x01 },
++	{ CCI_REG8(0x163c), 0x3a }, { CCI_REG8(0x163d), 0x01 },
++	{ CCI_REG8(0x1648), 0x32 }, { CCI_REG8(0x1658), 0x01 },
++	{ CCI_REG8(0x1659), 0x01 }, { CCI_REG8(0x165f), 0x01 },
++	{ CCI_REG8(0x1677), 0x01 }, { CCI_REG8(0x1690), 0x08 },
++	{ CCI_REG8(0x1691), 0x00 }, { CCI_REG8(0x1692), 0x20 },
++	{ CCI_REG8(0x1693), 0x00 }, { CCI_REG8(0x1694), 0x10 },
++	{ CCI_REG8(0x1695), 0x14 }, { CCI_REG8(0x1696), 0x10 },
++	{ CCI_REG8(0x1697), 0x0e }, { CCI_REG8(0x1730), 0x01 },
++	{ CCI_REG8(0x1732), 0x00 }, { CCI_REG8(0x1733), 0x10 },
++	{ CCI_REG8(0x1734), 0x01 }, { CCI_REG8(0x1735), 0x00 },
++	{ CCI_REG8(0x1748), 0x01 }, { CCI_REG8(0xfff9), 0x06 },
++	{ CCI_REG8(0x5000), 0xff }, { CCI_REG8(0x5001), 0x3d },
++	{ CCI_REG8(0x5002), 0xf5 }, { CCI_REG8(0x5004), 0x80 },
++	{ CCI_REG8(0x5006), 0x04 }, { CCI_REG8(0x5061), 0x20 },
++	{ CCI_REG8(0x5063), 0x20 }, { CCI_REG8(0x5064), 0x24 },
++	{ CCI_REG8(0x5065), 0x00 }, { CCI_REG8(0x5066), 0x1b },
++	{ CCI_REG8(0x5067), 0x00 }, { CCI_REG8(0x5068), 0x03 },
++	{ CCI_REG8(0x5069), 0x10 }, { CCI_REG8(0x506a), 0x20 },
++	{ CCI_REG8(0x506b), 0x04 }, { CCI_REG8(0x506c), 0x04 },
++	{ CCI_REG8(0x506d), 0x0c }, { CCI_REG8(0x506e), 0x0c },
++	{ CCI_REG8(0x506f), 0x04 }, { CCI_REG8(0x5070), 0x0c },
++	{ CCI_REG8(0x5071), 0x14 }, { CCI_REG8(0x5072), 0x1c },
++	{ CCI_REG8(0x5073), 0x01 }, { CCI_REG8(0x5074), 0x01 },
++	{ CCI_REG8(0x5075), 0xbe }, { CCI_REG8(0x5083), 0x00 },
++	{ CCI_REG8(0x5114), 0x03 }, { CCI_REG8(0x51b0), 0x00 },
++	{ CCI_REG8(0x51b3), 0x0e }, { CCI_REG8(0x51b5), 0x02 },
++	{ CCI_REG8(0x51b6), 0x00 }, { CCI_REG8(0x51b7), 0x00 },
++	{ CCI_REG8(0x51b8), 0x00 }, { CCI_REG8(0x51b9), 0x70 },
++	{ CCI_REG8(0x51ba), 0x00 }, { CCI_REG8(0x51bb), 0x10 },
++	{ CCI_REG8(0x51bc), 0x00 }, { CCI_REG8(0x51bd), 0x00 },
++	{ CCI_REG8(0x51d2), 0xff }, { CCI_REG8(0x51d3), 0x1c },
++	{ CCI_REG8(0x5250), 0x34 }, { CCI_REG8(0x5251), 0x00 },
++	{ CCI_REG8(0x525b), 0x00 }, { CCI_REG8(0x525d), 0x00 },
++	{ CCI_REG8(0x527a), 0x00 }, { CCI_REG8(0x527b), 0x38 },
++	{ CCI_REG8(0x527c), 0x00 }, { CCI_REG8(0x527d), 0x4b },
++	{ CCI_REG8(0x5286), 0x1b }, { CCI_REG8(0x5287), 0x40 },
++	{ CCI_REG8(0x5290), 0x00 }, { CCI_REG8(0x5291), 0x50 },
++	{ CCI_REG8(0x5292), 0x00 }, { CCI_REG8(0x5293), 0x50 },
++	{ CCI_REG8(0x5294), 0x00 }, { CCI_REG8(0x5295), 0x50 },
++	{ CCI_REG8(0x5296), 0x00 }, { CCI_REG8(0x5297), 0x50 },
++	{ CCI_REG8(0x5298), 0x00 }, { CCI_REG8(0x5299), 0x50 },
++	{ CCI_REG8(0x529a), 0x01 }, { CCI_REG8(0x529b), 0x00 },
++	{ CCI_REG8(0x529c), 0x01 }, { CCI_REG8(0x529d), 0x00 },
++	{ CCI_REG8(0x529e), 0x00 }, { CCI_REG8(0x529f), 0x50 },
++	{ CCI_REG8(0x52a0), 0x00 }, { CCI_REG8(0x52a1), 0x50 },
++	{ CCI_REG8(0x52a2), 0x01 }, { CCI_REG8(0x52a3), 0x00 },
++	{ CCI_REG8(0x52a4), 0x01 }, { CCI_REG8(0x52a5), 0x00 },
++	{ CCI_REG8(0x52a6), 0x00 }, { CCI_REG8(0x52a7), 0x50 },
++	{ CCI_REG8(0x52a8), 0x00 }, { CCI_REG8(0x52a9), 0x50 },
++	{ CCI_REG8(0x52aa), 0x00 }, { CCI_REG8(0x52ab), 0x50 },
++	{ CCI_REG8(0x52ac), 0x00 }, { CCI_REG8(0x52ad), 0x50 },
++	{ CCI_REG8(0x52ae), 0x00 }, { CCI_REG8(0x52af), 0x50 },
++	{ CCI_REG8(0x52b0), 0x00 }, { CCI_REG8(0x52b1), 0x50 },
++	{ CCI_REG8(0x52b2), 0x00 }, { CCI_REG8(0x52b3), 0x50 },
++	{ CCI_REG8(0x52b4), 0x00 }, { CCI_REG8(0x52b5), 0x50 },
++	{ CCI_REG8(0x52b6), 0x00 }, { CCI_REG8(0x52b7), 0x50 },
++	{ CCI_REG8(0x52b8), 0x00 }, { CCI_REG8(0x52b9), 0x50 },
++	{ CCI_REG8(0x52ba), 0x01 }, { CCI_REG8(0x52bb), 0x00 },
++	{ CCI_REG8(0x52bc), 0x01 }, { CCI_REG8(0x52bd), 0x00 },
++	{ CCI_REG8(0x52be), 0x00 }, { CCI_REG8(0x52bf), 0x50 },
++	{ CCI_REG8(0x52c0), 0x00 }, { CCI_REG8(0x52c1), 0x50 },
++	{ CCI_REG8(0x52c2), 0x01 }, { CCI_REG8(0x52c3), 0x00 },
++	{ CCI_REG8(0x52c4), 0x01 }, { CCI_REG8(0x52c5), 0x00 },
++	{ CCI_REG8(0x52c6), 0x00 }, { CCI_REG8(0x52c7), 0x50 },
++	{ CCI_REG8(0x52c8), 0x00 }, { CCI_REG8(0x52c9), 0x50 },
++	{ CCI_REG8(0x52ca), 0x00 }, { CCI_REG8(0x52cb), 0x50 },
++	{ CCI_REG8(0x52cc), 0x00 }, { CCI_REG8(0x52cd), 0x50 },
++	{ CCI_REG8(0x52ce), 0x00 }, { CCI_REG8(0x52cf), 0x50 },
++	{ CCI_REG8(0x52f0), 0x04 }, { CCI_REG8(0x52f1), 0x03 },
++	{ CCI_REG8(0x52f2), 0x02 }, { CCI_REG8(0x52f3), 0x01 },
++	{ CCI_REG8(0x52f4), 0x08 }, { CCI_REG8(0x52f5), 0x07 },
++	{ CCI_REG8(0x52f6), 0x06 }, { CCI_REG8(0x52f7), 0x05 },
++	{ CCI_REG8(0x52f8), 0x0c }, { CCI_REG8(0x52f9), 0x0b },
++	{ CCI_REG8(0x52fa), 0x0a }, { CCI_REG8(0x52fb), 0x09 },
++	{ CCI_REG8(0x52fc), 0x10 }, { CCI_REG8(0x52fd), 0x0f },
++	{ CCI_REG8(0x52fe), 0x0e }, { CCI_REG8(0x52ff), 0x0d },
++	{ CCI_REG8(0x5300), 0x14 }, { CCI_REG8(0x5301), 0x13 },
++	{ CCI_REG8(0x5302), 0x12 }, { CCI_REG8(0x5303), 0x11 },
++	{ CCI_REG8(0x5304), 0x18 }, { CCI_REG8(0x5305), 0x17 },
++	{ CCI_REG8(0x5306), 0x16 }, { CCI_REG8(0x5307), 0x15 },
++	{ CCI_REG8(0x5308), 0x1c }, { CCI_REG8(0x5309), 0x1b },
++	{ CCI_REG8(0x530a), 0x1a }, { CCI_REG8(0x530b), 0x19 },
++	{ CCI_REG8(0x530c), 0x20 }, { CCI_REG8(0x530d), 0x1f },
++	{ CCI_REG8(0x530e), 0x1e }, { CCI_REG8(0x530f), 0x1d },
++	{ CCI_REG8(0x5310), 0x03 }, { CCI_REG8(0x5311), 0xe8 },
++	{ CCI_REG8(0x5331), 0x0a }, { CCI_REG8(0x5332), 0x43 },
++	{ CCI_REG8(0x5333), 0x45 }, { CCI_REG8(0x5353), 0x09 },
++	{ CCI_REG8(0x5354), 0x00 }, { CCI_REG8(0x5414), 0x03 },
++	{ CCI_REG8(0x54b0), 0x10 }, { CCI_REG8(0x54b3), 0x0e },
++	{ CCI_REG8(0x54b5), 0x02 }, { CCI_REG8(0x54b6), 0x00 },
++	{ CCI_REG8(0x54b7), 0x00 }, { CCI_REG8(0x54b8), 0x00 },
++	{ CCI_REG8(0x54b9), 0x70 }, { CCI_REG8(0x54ba), 0x00 },
++	{ CCI_REG8(0x54bb), 0x10 }, { CCI_REG8(0x54bc), 0x00 },
++	{ CCI_REG8(0x54bd), 0x00 }, { CCI_REG8(0x54d2), 0xff },
++	{ CCI_REG8(0x54d3), 0x1c }, { CCI_REG8(0x5510), 0x03 },
++	{ CCI_REG8(0x5511), 0xe8 }, { CCI_REG8(0x5550), 0x6c },
++	{ CCI_REG8(0x5551), 0x00 }, { CCI_REG8(0x557a), 0x00 },
++	{ CCI_REG8(0x557b), 0x38 }, { CCI_REG8(0x557c), 0x00 },
++	{ CCI_REG8(0x557d), 0x4b }, { CCI_REG8(0x5590), 0x00 },
++	{ CCI_REG8(0x5591), 0x50 }, { CCI_REG8(0x5592), 0x00 },
++	{ CCI_REG8(0x5593), 0x50 }, { CCI_REG8(0x5594), 0x00 },
++	{ CCI_REG8(0x5595), 0x50 }, { CCI_REG8(0x5596), 0x00 },
++	{ CCI_REG8(0x5597), 0x50 }, { CCI_REG8(0x5598), 0x00 },
++	{ CCI_REG8(0x5599), 0x50 }, { CCI_REG8(0x559a), 0x01 },
++	{ CCI_REG8(0x559b), 0x00 }, { CCI_REG8(0x559c), 0x01 },
++	{ CCI_REG8(0x559d), 0x00 }, { CCI_REG8(0x559e), 0x00 },
++	{ CCI_REG8(0x559f), 0x50 }, { CCI_REG8(0x55a0), 0x00 },
++	{ CCI_REG8(0x55a1), 0x50 }, { CCI_REG8(0x55a2), 0x01 },
++	{ CCI_REG8(0x55a3), 0x00 }, { CCI_REG8(0x55a4), 0x01 },
++	{ CCI_REG8(0x55a5), 0x00 }, { CCI_REG8(0x55a6), 0x00 },
++	{ CCI_REG8(0x55a7), 0x50 }, { CCI_REG8(0x55a8), 0x00 },
++	{ CCI_REG8(0x55a9), 0x50 }, { CCI_REG8(0x55aa), 0x00 },
++	{ CCI_REG8(0x55ab), 0x50 }, { CCI_REG8(0x55ac), 0x00 },
++	{ CCI_REG8(0x55ad), 0x50 }, { CCI_REG8(0x55ae), 0x00 },
++	{ CCI_REG8(0x55af), 0x50 }, { CCI_REG8(0x55b0), 0x00 },
++	{ CCI_REG8(0x55b1), 0x50 }, { CCI_REG8(0x55b2), 0x00 },
++	{ CCI_REG8(0x55b3), 0x50 }, { CCI_REG8(0x55b4), 0x00 },
++	{ CCI_REG8(0x55b5), 0x50 }, { CCI_REG8(0x55b6), 0x00 },
++	{ CCI_REG8(0x55b7), 0x50 }, { CCI_REG8(0x55b8), 0x00 },
++	{ CCI_REG8(0x55b9), 0x50 }, { CCI_REG8(0x55ba), 0x01 },
++	{ CCI_REG8(0x55bb), 0x00 }, { CCI_REG8(0x55bc), 0x01 },
++	{ CCI_REG8(0x55bd), 0x00 }, { CCI_REG8(0x55be), 0x00 },
++	{ CCI_REG8(0x55bf), 0x50 }, { CCI_REG8(0x55c0), 0x00 },
++	{ CCI_REG8(0x55c1), 0x50 }, { CCI_REG8(0x55c2), 0x01 },
++	{ CCI_REG8(0x55c3), 0x00 }, { CCI_REG8(0x55c4), 0x01 },
++	{ CCI_REG8(0x55c5), 0x00 }, { CCI_REG8(0x55c6), 0x00 },
++	{ CCI_REG8(0x55c7), 0x50 }, { CCI_REG8(0x55c8), 0x00 },
++	{ CCI_REG8(0x55c9), 0x50 }, { CCI_REG8(0x55ca), 0x00 },
++	{ CCI_REG8(0x55cb), 0x50 }, { CCI_REG8(0x55cc), 0x00 },
++	{ CCI_REG8(0x55cd), 0x50 }, { CCI_REG8(0x55ce), 0x00 },
++	{ CCI_REG8(0x55cf), 0x50 }, { CCI_REG8(0x55f0), 0x04 },
++	{ CCI_REG8(0x55f1), 0x03 }, { CCI_REG8(0x55f2), 0x02 },
++	{ CCI_REG8(0x55f3), 0x01 }, { CCI_REG8(0x55f4), 0x08 },
++	{ CCI_REG8(0x55f5), 0x07 }, { CCI_REG8(0x55f6), 0x06 },
++	{ CCI_REG8(0x55f7), 0x05 }, { CCI_REG8(0x55f8), 0x0c },
++	{ CCI_REG8(0x55f9), 0x0b }, { CCI_REG8(0x55fa), 0x0a },
++	{ CCI_REG8(0x55fb), 0x09 }, { CCI_REG8(0x55fc), 0x10 },
++	{ CCI_REG8(0x55fd), 0x0f }, { CCI_REG8(0x55fe), 0x0e },
++	{ CCI_REG8(0x55ff), 0x0d }, { CCI_REG8(0x5600), 0x14 },
++	{ CCI_REG8(0x5601), 0x13 }, { CCI_REG8(0x5602), 0x12 },
++	{ CCI_REG8(0x5603), 0x11 }, { CCI_REG8(0x5604), 0x18 },
++	{ CCI_REG8(0x5605), 0x17 }, { CCI_REG8(0x5606), 0x16 },
++	{ CCI_REG8(0x5607), 0x15 }, { CCI_REG8(0x5608), 0x1c },
++	{ CCI_REG8(0x5609), 0x1b }, { CCI_REG8(0x560a), 0x1a },
++	{ CCI_REG8(0x560b), 0x19 }, { CCI_REG8(0x560c), 0x20 },
++	{ CCI_REG8(0x560d), 0x1f }, { CCI_REG8(0x560e), 0x1e },
++	{ CCI_REG8(0x560f), 0x1d }, { CCI_REG8(0x5631), 0x02 },
++	{ CCI_REG8(0x5632), 0x42 }, { CCI_REG8(0x5633), 0x24 },
++	{ CCI_REG8(0x5653), 0x09 }, { CCI_REG8(0x5654), 0x00 },
++	{ CCI_REG8(0x5714), 0x03 }, { CCI_REG8(0x57b0), 0x10 },
++	{ CCI_REG8(0x57b3), 0x0e }, { CCI_REG8(0x57b5), 0x02 },
++	{ CCI_REG8(0x57b6), 0x00 }, { CCI_REG8(0x57b7), 0x00 },
++	{ CCI_REG8(0x57b8), 0x00 }, { CCI_REG8(0x57b9), 0x70 },
++	{ CCI_REG8(0x57ba), 0x00 }, { CCI_REG8(0x57bb), 0x10 },
++	{ CCI_REG8(0x57bc), 0x00 }, { CCI_REG8(0x57bd), 0x00 },
++	{ CCI_REG8(0x57d2), 0xff }, { CCI_REG8(0x57d3), 0x1c },
++	{ CCI_REG8(0x5810), 0x03 }, { CCI_REG8(0x5811), 0xe8 },
++	{ CCI_REG8(0x5850), 0x6c }, { CCI_REG8(0x5851), 0x00 },
++	{ CCI_REG8(0x587a), 0x00 }, { CCI_REG8(0x587b), 0x38 },
++	{ CCI_REG8(0x587c), 0x00 }, { CCI_REG8(0x587d), 0x4b },
++	{ CCI_REG8(0x5890), 0x00 }, { CCI_REG8(0x5891), 0x50 },
++	{ CCI_REG8(0x5892), 0x00 }, { CCI_REG8(0x5893), 0x50 },
++	{ CCI_REG8(0x5894), 0x00 }, { CCI_REG8(0x5895), 0x50 },
++	{ CCI_REG8(0x5896), 0x00 }, { CCI_REG8(0x5897), 0x50 },
++	{ CCI_REG8(0x5898), 0x00 }, { CCI_REG8(0x5899), 0x50 },
++	{ CCI_REG8(0x589a), 0x01 }, { CCI_REG8(0x589b), 0x00 },
++	{ CCI_REG8(0x589c), 0x01 }, { CCI_REG8(0x589d), 0x00 },
++	{ CCI_REG8(0x589e), 0x00 }, { CCI_REG8(0x589f), 0x50 },
++	{ CCI_REG8(0x58a0), 0x00 }, { CCI_REG8(0x58a1), 0x50 },
++	{ CCI_REG8(0x58a2), 0x01 }, { CCI_REG8(0x58a3), 0x00 },
++	{ CCI_REG8(0x58a4), 0x01 }, { CCI_REG8(0x58a5), 0x00 },
++	{ CCI_REG8(0x58a6), 0x00 }, { CCI_REG8(0x58a7), 0x50 },
++	{ CCI_REG8(0x58a8), 0x00 }, { CCI_REG8(0x58a9), 0x50 },
++	{ CCI_REG8(0x58aa), 0x00 }, { CCI_REG8(0x58ab), 0x50 },
++	{ CCI_REG8(0x58ac), 0x00 }, { CCI_REG8(0x58ad), 0x50 },
++	{ CCI_REG8(0x58ae), 0x00 }, { CCI_REG8(0x58af), 0x50 },
++	{ CCI_REG8(0x58b0), 0x00 }, { CCI_REG8(0x58b1), 0x50 },
++	{ CCI_REG8(0x58b2), 0x00 }, { CCI_REG8(0x58b3), 0x50 },
++	{ CCI_REG8(0x58b4), 0x00 }, { CCI_REG8(0x58b5), 0x50 },
++	{ CCI_REG8(0x58b6), 0x00 }, { CCI_REG8(0x58b7), 0x50 },
++	{ CCI_REG8(0x58b8), 0x00 }, { CCI_REG8(0x58b9), 0x50 },
++	{ CCI_REG8(0x58ba), 0x01 }, { CCI_REG8(0x58bb), 0x00 },
++	{ CCI_REG8(0x58bc), 0x01 }, { CCI_REG8(0x58bd), 0x00 },
++	{ CCI_REG8(0x58be), 0x00 }, { CCI_REG8(0x58bf), 0x50 },
++	{ CCI_REG8(0x58c0), 0x00 }, { CCI_REG8(0x58c1), 0x50 },
++	{ CCI_REG8(0x58c2), 0x01 }, { CCI_REG8(0x58c3), 0x00 },
++	{ CCI_REG8(0x58c4), 0x01 }, { CCI_REG8(0x58c5), 0x00 },
++	{ CCI_REG8(0x58c6), 0x00 }, { CCI_REG8(0x58c7), 0x50 },
++	{ CCI_REG8(0x58c8), 0x00 }, { CCI_REG8(0x58c9), 0x50 },
++	{ CCI_REG8(0x58ca), 0x00 }, { CCI_REG8(0x58cb), 0x50 },
++	{ CCI_REG8(0x58cc), 0x00 }, { CCI_REG8(0x58cd), 0x50 },
++	{ CCI_REG8(0x58ce), 0x00 }, { CCI_REG8(0x58cf), 0x50 },
++	{ CCI_REG8(0x58f0), 0x04 }, { CCI_REG8(0x58f1), 0x03 },
++	{ CCI_REG8(0x58f2), 0x02 }, { CCI_REG8(0x58f3), 0x01 },
++	{ CCI_REG8(0x58f4), 0x08 }, { CCI_REG8(0x58f5), 0x07 },
++	{ CCI_REG8(0x58f6), 0x06 }, { CCI_REG8(0x58f7), 0x05 },
++	{ CCI_REG8(0x58f8), 0x0c }, { CCI_REG8(0x58f9), 0x0b },
++	{ CCI_REG8(0x58fa), 0x0a }, { CCI_REG8(0x58fb), 0x09 },
++	{ CCI_REG8(0x58fc), 0x10 }, { CCI_REG8(0x58fd), 0x0f },
++	{ CCI_REG8(0x58fe), 0x0e }, { CCI_REG8(0x58ff), 0x0d },
++	{ CCI_REG8(0x5900), 0x14 }, { CCI_REG8(0x5901), 0x13 },
++	{ CCI_REG8(0x5902), 0x12 }, { CCI_REG8(0x5903), 0x11 },
++	{ CCI_REG8(0x5904), 0x18 }, { CCI_REG8(0x5905), 0x17 },
++	{ CCI_REG8(0x5906), 0x16 }, { CCI_REG8(0x5907), 0x15 },
++	{ CCI_REG8(0x5908), 0x1c }, { CCI_REG8(0x5909), 0x1b },
++	{ CCI_REG8(0x590a), 0x1a }, { CCI_REG8(0x590b), 0x19 },
++	{ CCI_REG8(0x590c), 0x20 }, { CCI_REG8(0x590d), 0x1f },
++	{ CCI_REG8(0x590e), 0x1e }, { CCI_REG8(0x590f), 0x1d },
++	{ CCI_REG8(0x5931), 0x02 }, { CCI_REG8(0x5932), 0x42 },
++	{ CCI_REG8(0x5933), 0x24 }, { CCI_REG8(0x5953), 0x09 },
++	{ CCI_REG8(0x5954), 0x00 }, { CCI_REG8(0x5989), 0x84 },
++	{ CCI_REG8(0x59c3), 0x04 }, { CCI_REG8(0x59c4), 0x24 },
++	{ CCI_REG8(0x59c5), 0x40 }, { CCI_REG8(0x59c6), 0x1b },
++	{ CCI_REG8(0x59c7), 0x40 }, { CCI_REG8(0x5a02), 0x0f },
++	{ CCI_REG8(0x5f00), 0x29 }, { CCI_REG8(0x5f2d), 0x28 },
++	{ CCI_REG8(0x5f2e), 0x28 }, { CCI_REG8(0x6801), 0x11 },
++	{ CCI_REG8(0x6802), 0x3f }, { CCI_REG8(0x6803), 0xe7 },
++	{ CCI_REG8(0x6825), 0x0f }, { CCI_REG8(0x6826), 0x20 },
++	{ CCI_REG8(0x6827), 0x00 }, { CCI_REG8(0x6829), 0x16 },
++	{ CCI_REG8(0x682b), 0xb3 }, { CCI_REG8(0x682c), 0x01 },
++	{ CCI_REG8(0x6832), 0xff }, { CCI_REG8(0x6833), 0xff },
++	{ CCI_REG8(0x6898), 0x80 }, { CCI_REG8(0x6899), 0x80 },
++	{ CCI_REG8(0x689b), 0x40 }, { CCI_REG8(0x689c), 0x20 },
++	{ CCI_REG8(0x689d), 0x20 }, { CCI_REG8(0x689e), 0x80 },
++	{ CCI_REG8(0x689f), 0x60 }, { CCI_REG8(0x68a0), 0x40 },
++	{ CCI_REG8(0x68a4), 0x40 }, { CCI_REG8(0x68a5), 0x20 },
++	{ CCI_REG8(0x68a6), 0x00 }, { CCI_REG8(0x68b6), 0x80 },
++	{ CCI_REG8(0x68b7), 0x80 }, { CCI_REG8(0x68b8), 0x80 },
++	{ CCI_REG8(0x68bc), 0x80 }, { CCI_REG8(0x68bd), 0x80 },
++	{ CCI_REG8(0x68be), 0x80 }, { CCI_REG8(0x68bf), 0x40 },
++	{ CCI_REG8(0x68c2), 0x80 }, { CCI_REG8(0x68c3), 0x80 },
++	{ CCI_REG8(0x68c4), 0x60 }, { CCI_REG8(0x68c5), 0x30 },
++	{ CCI_REG8(0x6918), 0x80 }, { CCI_REG8(0x6919), 0x80 },
++	{ CCI_REG8(0x691b), 0x40 }, { CCI_REG8(0x691c), 0x20 },
++	{ CCI_REG8(0x691d), 0x20 }, { CCI_REG8(0x691e), 0x80 },
++	{ CCI_REG8(0x691f), 0x60 }, { CCI_REG8(0x6920), 0x40 },
++	{ CCI_REG8(0x6924), 0x40 }, { CCI_REG8(0x6925), 0x20 },
++	{ CCI_REG8(0x6926), 0x00 }, { CCI_REG8(0x6936), 0x40 },
++	{ CCI_REG8(0x6937), 0x40 }, { CCI_REG8(0x6938), 0x20 },
++	{ CCI_REG8(0x6939), 0x20 }, { CCI_REG8(0x693a), 0x10 },
++	{ CCI_REG8(0x693b), 0x10 }, { CCI_REG8(0x693c), 0x20 },
++	{ CCI_REG8(0x693d), 0x20 }, { CCI_REG8(0x693e), 0x10 },
++	{ CCI_REG8(0x693f), 0x10 }, { CCI_REG8(0x6940), 0x00 },
++	{ CCI_REG8(0x6941), 0x00 }, { CCI_REG8(0x6942), 0x08 },
++	{ CCI_REG8(0x6943), 0x08 }, { CCI_REG8(0x6944), 0x00 },
++	{ CCI_REG8(0x69c2), 0x07 }, { CCI_REG8(0x6a20), 0x01 },
++	{ CCI_REG8(0x6a23), 0x10 }, { CCI_REG8(0x6a26), 0x3d },
++	{ CCI_REG8(0x6a27), 0x3e }, { CCI_REG8(0x6a38), 0x02 },
++	{ CCI_REG8(0x6a39), 0x20 }, { CCI_REG8(0x6a3a), 0x02 },
++	{ CCI_REG8(0x6a3b), 0x84 }, { CCI_REG8(0x6a3e), 0x02 },
++	{ CCI_REG8(0x6a3f), 0x20 }, { CCI_REG8(0x6a47), 0x3b },
++	{ CCI_REG8(0x6a63), 0x04 }, { CCI_REG8(0x6a65), 0x00 },
++	{ CCI_REG8(0x6a67), 0x0f }, { CCI_REG8(0x6b22), 0x07 },
++	{ CCI_REG8(0x6b23), 0xc2 }, { CCI_REG8(0x6b2f), 0x00 },
++	{ CCI_REG8(0x6b60), 0x1f }, { CCI_REG8(0x6bd2), 0x5a },
++	{ CCI_REG8(0x6c20), 0x50 }, { CCI_REG8(0x6c60), 0x50 },
++	{ CCI_REG8(0x6c61), 0x06 }, { CCI_REG8(0x7318), 0x04 },
++	{ CCI_REG8(0x7319), 0x01 }, { CCI_REG8(0x731a), 0x04 },
++	{ CCI_REG8(0x731b), 0x01 }, { CCI_REG8(0x731c), 0x00 },
++	{ CCI_REG8(0x731d), 0x00 }, { CCI_REG8(0x731e), 0x04 },
++	{ CCI_REG8(0x731f), 0x01 }, { CCI_REG8(0x7320), 0x04 },
++	{ CCI_REG8(0x7321), 0x00 }, { CCI_REG8(0x7322), 0x04 },
++	{ CCI_REG8(0x7323), 0x00 }, { CCI_REG8(0x7324), 0x04 },
++	{ CCI_REG8(0x7325), 0x00 }, { CCI_REG8(0x7326), 0x04 },
++	{ CCI_REG8(0x7327), 0x00 }, { CCI_REG8(0x7600), 0x00 },
++	{ CCI_REG8(0x7601), 0x00 }, { CCI_REG8(0x7602), 0x10 },
++	{ CCI_REG8(0x7603), 0x00 }, { CCI_REG8(0x7604), 0x00 },
++	{ CCI_REG8(0x7605), 0x00 }, { CCI_REG8(0x7606), 0x10 },
++	{ CCI_REG8(0x7607), 0x00 }, { CCI_REG8(0x7608), 0x00 },
++	{ CCI_REG8(0x7609), 0x00 }, { CCI_REG8(0x760a), 0x10 },
++	{ CCI_REG8(0x760b), 0x00 }, { CCI_REG8(0x760c), 0x00 },
++	{ CCI_REG8(0x760d), 0x00 }, { CCI_REG8(0x760e), 0x10 },
++	{ CCI_REG8(0x760f), 0x00 }, { CCI_REG8(0x7610), 0x00 },
++	{ CCI_REG8(0x7611), 0x00 }, { CCI_REG8(0x7612), 0x10 },
++	{ CCI_REG8(0x7613), 0x00 }, { CCI_REG8(0x7614), 0x00 },
++	{ CCI_REG8(0x7615), 0x00 }, { CCI_REG8(0x7616), 0x10 },
++	{ CCI_REG8(0x7617), 0x00 }, { CCI_REG8(0x7618), 0x00 },
++	{ CCI_REG8(0x7619), 0x00 }, { CCI_REG8(0x761a), 0x10 },
++	{ CCI_REG8(0x761b), 0x00 }, { CCI_REG8(0x761c), 0x00 },
++	{ CCI_REG8(0x761d), 0x00 }, { CCI_REG8(0x761e), 0x10 },
++	{ CCI_REG8(0x761f), 0x00 }, { CCI_REG8(0x7620), 0x00 },
++	{ CCI_REG8(0x7621), 0x00 }, { CCI_REG8(0x7622), 0x10 },
++	{ CCI_REG8(0x7623), 0x00 }, { CCI_REG8(0x7624), 0x00 },
++	{ CCI_REG8(0x7625), 0x00 }, { CCI_REG8(0x7626), 0x10 },
++	{ CCI_REG8(0x7627), 0x00 }, { CCI_REG8(0x7628), 0x00 },
++	{ CCI_REG8(0x7629), 0x00 }, { CCI_REG8(0x762a), 0x10 },
++	{ CCI_REG8(0x762b), 0x00 }, { CCI_REG8(0x762c), 0x00 },
++	{ CCI_REG8(0x762d), 0x00 }, { CCI_REG8(0x762e), 0x10 },
++	{ CCI_REG8(0x762f), 0x00 }, { CCI_REG8(0x7630), 0x00 },
++	{ CCI_REG8(0x7631), 0x00 }, { CCI_REG8(0x7632), 0x10 },
++	{ CCI_REG8(0x7633), 0x00 }, { CCI_REG8(0x7634), 0x00 },
++	{ CCI_REG8(0x7635), 0x00 }, { CCI_REG8(0x7636), 0x10 },
++	{ CCI_REG8(0x7637), 0x00 }, { CCI_REG8(0x7638), 0x00 },
++	{ CCI_REG8(0x7639), 0x00 }, { CCI_REG8(0x763a), 0x10 },
++	{ CCI_REG8(0x763b), 0x00 }, { CCI_REG8(0x763c), 0x00 },
++	{ CCI_REG8(0x763d), 0x00 }, { CCI_REG8(0x763e), 0x10 },
++	{ CCI_REG8(0x763f), 0x00 }, { CCI_REG8(0x7640), 0x00 },
++	{ CCI_REG8(0x7641), 0x00 }, { CCI_REG8(0x7642), 0x10 },
++	{ CCI_REG8(0x7643), 0x00 }, { CCI_REG8(0x7644), 0x00 },
++	{ CCI_REG8(0x7645), 0x00 }, { CCI_REG8(0x7646), 0x10 },
++	{ CCI_REG8(0x7647), 0x00 }, { CCI_REG8(0x7648), 0x00 },
++	{ CCI_REG8(0x7649), 0x00 }, { CCI_REG8(0x764a), 0x10 },
++	{ CCI_REG8(0x764b), 0x00 }, { CCI_REG8(0x764c), 0x00 },
++	{ CCI_REG8(0x764d), 0x00 }, { CCI_REG8(0x764e), 0x10 },
++	{ CCI_REG8(0x764f), 0x00 }, { CCI_REG8(0x7650), 0x00 },
++	{ CCI_REG8(0x7651), 0x00 }, { CCI_REG8(0x7652), 0x10 },
++	{ CCI_REG8(0x7653), 0x00 }, { CCI_REG8(0x7654), 0x00 },
++	{ CCI_REG8(0x7655), 0x00 }, { CCI_REG8(0x7656), 0x10 },
++	{ CCI_REG8(0x7657), 0x00 }, { CCI_REG8(0x7658), 0x00 },
++	{ CCI_REG8(0x7659), 0x00 }, { CCI_REG8(0x765a), 0x10 },
++	{ CCI_REG8(0x765b), 0x00 }, { CCI_REG8(0x765c), 0x00 },
++	{ CCI_REG8(0x765d), 0x00 }, { CCI_REG8(0x765e), 0x10 },
++	{ CCI_REG8(0x765f), 0x00 }, { CCI_REG8(0x7660), 0x00 },
++	{ CCI_REG8(0x7661), 0x00 }, { CCI_REG8(0x7662), 0x10 },
++	{ CCI_REG8(0x7663), 0x00 }, { CCI_REG8(0x7664), 0x00 },
++	{ CCI_REG8(0x7665), 0x00 }, { CCI_REG8(0x7666), 0x10 },
++	{ CCI_REG8(0x7667), 0x00 }, { CCI_REG8(0x7668), 0x00 },
++	{ CCI_REG8(0x7669), 0x00 }, { CCI_REG8(0x766a), 0x10 },
++	{ CCI_REG8(0x766b), 0x00 }, { CCI_REG8(0x766c), 0x00 },
++	{ CCI_REG8(0x766d), 0x00 }, { CCI_REG8(0x766e), 0x10 },
++	{ CCI_REG8(0x766f), 0x00 }, { CCI_REG8(0x7670), 0x00 },
++	{ CCI_REG8(0x7671), 0x00 }, { CCI_REG8(0x7672), 0x10 },
++	{ CCI_REG8(0x7673), 0x00 }, { CCI_REG8(0x7674), 0x00 },
++	{ CCI_REG8(0x7675), 0x00 }, { CCI_REG8(0x7676), 0x10 },
++	{ CCI_REG8(0x7677), 0x00 }, { CCI_REG8(0x7678), 0x00 },
++	{ CCI_REG8(0x7679), 0x00 }, { CCI_REG8(0x767a), 0x10 },
++	{ CCI_REG8(0x767b), 0x00 }, { CCI_REG8(0x767c), 0x00 },
++	{ CCI_REG8(0x767d), 0x00 }, { CCI_REG8(0x767e), 0x10 },
++	{ CCI_REG8(0x767f), 0x00 }, { CCI_REG8(0x7680), 0x00 },
++	{ CCI_REG8(0x7681), 0x00 }, { CCI_REG8(0x7682), 0x10 },
++	{ CCI_REG8(0x7683), 0x00 }, { CCI_REG8(0x7684), 0x00 },
++	{ CCI_REG8(0x7685), 0x00 }, { CCI_REG8(0x7686), 0x10 },
++	{ CCI_REG8(0x7687), 0x00 }, { CCI_REG8(0x7688), 0x00 },
++	{ CCI_REG8(0x7689), 0x00 }, { CCI_REG8(0x768a), 0x10 },
++	{ CCI_REG8(0x768b), 0x00 }, { CCI_REG8(0x768c), 0x00 },
++	{ CCI_REG8(0x768d), 0x00 }, { CCI_REG8(0x768e), 0x10 },
++	{ CCI_REG8(0x768f), 0x00 }, { CCI_REG8(0x7690), 0x00 },
++	{ CCI_REG8(0x7691), 0x00 }, { CCI_REG8(0x7692), 0x10 },
++	{ CCI_REG8(0x7693), 0x00 }, { CCI_REG8(0x7694), 0x00 },
++	{ CCI_REG8(0x7695), 0x00 }, { CCI_REG8(0x7696), 0x10 },
++	{ CCI_REG8(0x7697), 0x00 }, { CCI_REG8(0x7698), 0x00 },
++	{ CCI_REG8(0x7699), 0x00 }, { CCI_REG8(0x769a), 0x10 },
++	{ CCI_REG8(0x769b), 0x00 }, { CCI_REG8(0x769c), 0x00 },
++	{ CCI_REG8(0x769d), 0x00 }, { CCI_REG8(0x769e), 0x10 },
++	{ CCI_REG8(0x769f), 0x00 }, { CCI_REG8(0x76a0), 0x00 },
++	{ CCI_REG8(0x76a1), 0x00 }, { CCI_REG8(0x76a2), 0x10 },
++	{ CCI_REG8(0x76a3), 0x00 }, { CCI_REG8(0x76a4), 0x00 },
++	{ CCI_REG8(0x76a5), 0x00 }, { CCI_REG8(0x76a6), 0x10 },
++	{ CCI_REG8(0x76a7), 0x00 }, { CCI_REG8(0x76a8), 0x00 },
++	{ CCI_REG8(0x76a9), 0x00 }, { CCI_REG8(0x76aa), 0x10 },
++	{ CCI_REG8(0x76ab), 0x00 }, { CCI_REG8(0x76ac), 0x00 },
++	{ CCI_REG8(0x76ad), 0x00 }, { CCI_REG8(0x76ae), 0x10 },
++	{ CCI_REG8(0x76af), 0x00 }, { CCI_REG8(0x76b0), 0x00 },
++	{ CCI_REG8(0x76b1), 0x00 }, { CCI_REG8(0x76b2), 0x10 },
++	{ CCI_REG8(0x76b3), 0x00 }, { CCI_REG8(0x76b4), 0x00 },
++	{ CCI_REG8(0x76b5), 0x00 }, { CCI_REG8(0x76b6), 0x10 },
++	{ CCI_REG8(0x76b7), 0x00 }, { CCI_REG8(0x76b8), 0x00 },
++	{ CCI_REG8(0x76b9), 0x00 }, { CCI_REG8(0x76ba), 0x10 },
++	{ CCI_REG8(0x76bb), 0x00 }, { CCI_REG8(0x76bc), 0x00 },
++	{ CCI_REG8(0x76bd), 0x00 }, { CCI_REG8(0x76be), 0x10 },
++	{ CCI_REG8(0x76bf), 0x00 }, { CCI_REG8(0x76c0), 0x00 },
++	{ CCI_REG8(0x76c1), 0x00 }, { CCI_REG8(0x76c2), 0x10 },
++	{ CCI_REG8(0x76c3), 0x00 }, { CCI_REG8(0x76c4), 0x00 },
++	{ CCI_REG8(0x76c5), 0x00 }, { CCI_REG8(0x76c6), 0x10 },
++	{ CCI_REG8(0x76c7), 0x00 }, { CCI_REG8(0x76c8), 0x00 },
++	{ CCI_REG8(0x76c9), 0x00 }, { CCI_REG8(0x76ca), 0x10 },
++	{ CCI_REG8(0x76cb), 0x00 }, { CCI_REG8(0x76cc), 0x00 },
++	{ CCI_REG8(0x76cd), 0x00 }, { CCI_REG8(0x76ce), 0x10 },
++	{ CCI_REG8(0x76cf), 0x00 }, { CCI_REG8(0x76d0), 0x00 },
++	{ CCI_REG8(0x76d1), 0x00 }, { CCI_REG8(0x76d2), 0x10 },
++	{ CCI_REG8(0x76d3), 0x00 }, { CCI_REG8(0x76d4), 0x00 },
++	{ CCI_REG8(0x76d5), 0x00 }, { CCI_REG8(0x76d6), 0x10 },
++	{ CCI_REG8(0x76d7), 0x00 }, { CCI_REG8(0x76d8), 0x00 },
++	{ CCI_REG8(0x76d9), 0x00 }, { CCI_REG8(0x76da), 0x10 },
++	{ CCI_REG8(0x76db), 0x00 }, { CCI_REG8(0x76dc), 0x00 },
++	{ CCI_REG8(0x76dd), 0x00 }, { CCI_REG8(0x76de), 0x10 },
++	{ CCI_REG8(0x76df), 0x00 }, { CCI_REG8(0x76e0), 0x00 },
++	{ CCI_REG8(0x76e1), 0x00 }, { CCI_REG8(0x76e2), 0x10 },
++	{ CCI_REG8(0x76e3), 0x00 }, { CCI_REG8(0x76e4), 0x00 },
++	{ CCI_REG8(0x76e5), 0x00 }, { CCI_REG8(0x76e6), 0x10 },
++	{ CCI_REG8(0x76e7), 0x00 }, { CCI_REG8(0x76e8), 0x00 },
++	{ CCI_REG8(0x76e9), 0x00 }, { CCI_REG8(0x76ea), 0x10 },
++	{ CCI_REG8(0x76eb), 0x00 }, { CCI_REG8(0x76ec), 0x00 },
++	{ CCI_REG8(0x76ed), 0x00 }, { CCI_REG8(0x76ee), 0x10 },
++	{ CCI_REG8(0x76ef), 0x00 }, { CCI_REG8(0x76f0), 0x00 },
++	{ CCI_REG8(0x76f1), 0x00 }, { CCI_REG8(0x76f2), 0x10 },
++	{ CCI_REG8(0x76f3), 0x00 }, { CCI_REG8(0x76f4), 0x00 },
++	{ CCI_REG8(0x76f5), 0x00 }, { CCI_REG8(0x76f6), 0x10 },
++	{ CCI_REG8(0x76f7), 0x00 }, { CCI_REG8(0x76f8), 0x00 },
++	{ CCI_REG8(0x76f9), 0x00 }, { CCI_REG8(0x76fa), 0x10 },
++	{ CCI_REG8(0x76fb), 0x00 }, { CCI_REG8(0x76fc), 0x00 },
++	{ CCI_REG8(0x76fd), 0x00 }, { CCI_REG8(0x76fe), 0x10 },
++	{ CCI_REG8(0x76ff), 0x00 }, { CCI_REG8(0x7700), 0x00 },
++	{ CCI_REG8(0x7701), 0x00 }, { CCI_REG8(0x7702), 0x10 },
++	{ CCI_REG8(0x7703), 0x00 }, { CCI_REG8(0x7704), 0x00 },
++	{ CCI_REG8(0x7705), 0x00 }, { CCI_REG8(0x7706), 0x10 },
++	{ CCI_REG8(0x7707), 0x00 }, { CCI_REG8(0x7708), 0x00 },
++	{ CCI_REG8(0x7709), 0x00 }, { CCI_REG8(0x770a), 0x10 },
++	{ CCI_REG8(0x770b), 0x00 }, { CCI_REG8(0x770c), 0x00 },
++	{ CCI_REG8(0x770d), 0x00 }, { CCI_REG8(0x770e), 0x10 },
++	{ CCI_REG8(0x770f), 0x00 }, { CCI_REG8(0x7710), 0x00 },
++	{ CCI_REG8(0x7711), 0x00 }, { CCI_REG8(0x7712), 0x10 },
++	{ CCI_REG8(0x7713), 0x00 }, { CCI_REG8(0x7714), 0x00 },
++	{ CCI_REG8(0x7715), 0x00 }, { CCI_REG8(0x7716), 0x10 },
++	{ CCI_REG8(0x7717), 0x00 }, { CCI_REG8(0x7718), 0x00 },
++	{ CCI_REG8(0x7719), 0x00 }, { CCI_REG8(0x771a), 0x10 },
++	{ CCI_REG8(0x771b), 0x00 }, { CCI_REG8(0x771c), 0x00 },
++	{ CCI_REG8(0x771d), 0x00 }, { CCI_REG8(0x771e), 0x10 },
++	{ CCI_REG8(0x771f), 0x00 }, { CCI_REG8(0x7720), 0x00 },
++	{ CCI_REG8(0x7721), 0x00 }, { CCI_REG8(0x7722), 0x10 },
++	{ CCI_REG8(0x7723), 0x00 }, { CCI_REG8(0x7724), 0x00 },
++	{ CCI_REG8(0x7725), 0x00 }, { CCI_REG8(0x7726), 0x10 },
++	{ CCI_REG8(0x7727), 0x00 }, { CCI_REG8(0x7728), 0x00 },
++	{ CCI_REG8(0x7729), 0x00 }, { CCI_REG8(0x772a), 0x10 },
++	{ CCI_REG8(0x772b), 0x00 }, { CCI_REG8(0x772c), 0x00 },
++	{ CCI_REG8(0x772d), 0x00 }, { CCI_REG8(0x772e), 0x10 },
++	{ CCI_REG8(0x772f), 0x00 }, { CCI_REG8(0x7730), 0x00 },
++	{ CCI_REG8(0x7731), 0x00 }, { CCI_REG8(0x7732), 0x10 },
++	{ CCI_REG8(0x7733), 0x00 }, { CCI_REG8(0x7734), 0x00 },
++	{ CCI_REG8(0x7735), 0x00 }, { CCI_REG8(0x7736), 0x10 },
++	{ CCI_REG8(0x7737), 0x00 }, { CCI_REG8(0x7738), 0x00 },
++	{ CCI_REG8(0x7739), 0x00 }, { CCI_REG8(0x773a), 0x10 },
++	{ CCI_REG8(0x773b), 0x00 }, { CCI_REG8(0x773c), 0x00 },
++	{ CCI_REG8(0x773d), 0x00 }, { CCI_REG8(0x773e), 0x10 },
++	{ CCI_REG8(0x773f), 0x00 }, { CCI_REG8(0x7740), 0x00 },
++	{ CCI_REG8(0x7741), 0x00 }, { CCI_REG8(0x7742), 0x10 },
++	{ CCI_REG8(0x7743), 0x00 }, { CCI_REG8(0x3421), 0x02 },
++	{ CCI_REG8(0x37d0), 0x00 }, { CCI_REG8(0x3632), 0x99 },
++	{ CCI_REG8(0xc518), 0x1f }, { CCI_REG8(0xc519), 0x1f },
++	{ CCI_REG8(0xc51a), 0x1f }, { CCI_REG8(0xc51b), 0x1f },
++	{ CCI_REG8(0xc51c), 0x1f }, { CCI_REG8(0xc51d), 0x1f },
++	{ CCI_REG8(0xc51e), 0x1f }, { CCI_REG8(0xc51f), 0x1f },
++	{ CCI_REG8(0xc520), 0x1f }, { CCI_REG8(0xc521), 0x1f },
++	{ CCI_REG8(0x3616), 0xa0 }, { CCI_REG8(0x3615), 0xc5 },
++	{ CCI_REG8(0xc4c1), 0x02 }, { CCI_REG8(0xc4c2), 0x02 },
++	{ CCI_REG8(0xc4c3), 0x03 }, { CCI_REG8(0xc4c4), 0x03 },
++	{ CCI_REG8(0xc4f6), 0x0a }, { CCI_REG8(0xc4f7), 0x0a },
++	{ CCI_REG8(0xc4f8), 0x0a }, { CCI_REG8(0xc4f9), 0x0a },
++	{ CCI_REG8(0xc4fa), 0x0a }, { CCI_REG8(0xc4c6), 0x0a },
++	{ CCI_REG8(0xc4c7), 0x0a }, { CCI_REG8(0xc4c8), 0x0a },
++	{ CCI_REG8(0xc4c9), 0x0a }, { CCI_REG8(0xc4ca), 0x14 },
++	{ CCI_REG8(0xc4cb), 0x14 }, { CCI_REG8(0xc4cc), 0x14 },
++	{ CCI_REG8(0xc4cd), 0x14 }, { CCI_REG8(0x3b92), 0x05 },
++	{ CCI_REG8(0x3b93), 0x05 }, { CCI_REG8(0x3b94), 0x05 },
++	{ CCI_REG8(0x3b95), 0x05 }, { CCI_REG8(0x3623), 0x10 },
++	{ CCI_REG8(0xc522), 0x18 }, { CCI_REG8(0xc523), 0x12 },
++	{ CCI_REG8(0xc524), 0x0e }, { CCI_REG8(0xc525), 0x0b },
++	{ CCI_REG8(0xc526), 0x18 }, { CCI_REG8(0xc527), 0x12 },
++	{ CCI_REG8(0xc528), 0x0c }, { CCI_REG8(0xc529), 0x08 },
++	{ CCI_REG8(0xc52a), 0x18 }, { CCI_REG8(0xc52b), 0x12 },
++	{ CCI_REG8(0xc52c), 0x0e }, { CCI_REG8(0xc52d), 0x0b },
++	{ CCI_REG8(0xc52e), 0x18 }, { CCI_REG8(0xc52f), 0x12 },
++	{ CCI_REG8(0xc530), 0x0e }, { CCI_REG8(0xc531), 0x0b },
++	{ CCI_REG8(0xc532), 0x18 }, { CCI_REG8(0xc533), 0x12 },
++	{ CCI_REG8(0xc534), 0x0e }, { CCI_REG8(0xc535), 0x0b },
++	{ CCI_REG8(0xc536), 0x18 }, { CCI_REG8(0xc537), 0x12 },
++	{ CCI_REG8(0xc538), 0x0e }, { CCI_REG8(0xc539), 0x0b },
++	{ CCI_REG8(0xc53a), 0x18 }, { CCI_REG8(0xc53b), 0x12 },
++	{ CCI_REG8(0xc53c), 0x0c }, { CCI_REG8(0xc53d), 0x08 },
++	{ CCI_REG8(0xc53e), 0x18 }, { CCI_REG8(0xc53f), 0x12 },
++	{ CCI_REG8(0xc540), 0x0e }, { CCI_REG8(0xc541), 0x0b },
++	{ CCI_REG8(0xc542), 0x18 }, { CCI_REG8(0xc543), 0x12 },
++	{ CCI_REG8(0xc544), 0x0e }, { CCI_REG8(0xc545), 0x0b },
++	{ CCI_REG8(0xc546), 0x18 }, { CCI_REG8(0xc547), 0x12 },
++	{ CCI_REG8(0xc548), 0x0e }, { CCI_REG8(0xc549), 0x0b },
++	{ CCI_REG8(0x3701), 0x18 }, { CCI_REG8(0x3702), 0x38 },
++	{ CCI_REG8(0x3703), 0x72 }, { CCI_REG8(0x3708), 0x26 },
++	{ CCI_REG8(0x3709), 0xe6 }, { CCI_REG8(0x3a1d), 0x18 },
++	{ CCI_REG8(0x3a1e), 0x18 }, { CCI_REG8(0x3a21), 0x18 },
++	{ CCI_REG8(0x3a22), 0x18 }, { CCI_REG8(0x39fb), 0x18 },
++	{ CCI_REG8(0x39fc), 0x18 }, { CCI_REG8(0x39fd), 0x18 },
++	{ CCI_REG8(0x39fe), 0x18 }, { CCI_REG8(0xc44a), 0x08 },
++	{ CCI_REG8(0xc44c), 0x08 }, { CCI_REG8(0xc5e8), 0x0a },
++	{ CCI_REG8(0xc5ea), 0x0a }, { CCI_REG8(0x391d), 0x54 },
++	{ CCI_REG8(0x391e), 0xca }, { CCI_REG8(0x3991), 0x0c },
++	{ CCI_REG8(0x399d), 0x0c }, { CCI_REG8(0x3744), 0x24 },
++	{ CCI_REG8(0x374b), 0x0c }, { CCI_REG8(0x3be7), 0x1e },
++	{ CCI_REG8(0x3be8), 0x26 }, { CCI_REG8(0x3a50), 0x14 },
++	{ CCI_REG8(0x3a54), 0x14 }, { CCI_REG8(0x3add), 0x1f },
++	{ CCI_REG8(0x3adf), 0x24 }, { CCI_REG8(0x3aef), 0x1f },
++	{ CCI_REG8(0x3af0), 0x24 }, { CCI_REG8(0xc57f), 0x30 },
++	{ CCI_REG8(0xc580), 0x30 }, { CCI_REG8(0xc581), 0x30 },
++	{ CCI_REG8(0xc582), 0x30 }, { CCI_REG8(0xc583), 0x30 },
++	{ CCI_REG8(0xc584), 0x30 }, { CCI_REG8(0xc585), 0x30 },
++	{ CCI_REG8(0xc586), 0x30 }, { CCI_REG8(0xc587), 0x30 },
++	{ CCI_REG8(0xc588), 0x30 }, { CCI_REG8(0xc589), 0x30 },
++	{ CCI_REG8(0xc58a), 0x30 }, { CCI_REG8(0xc58b), 0x30 },
++	{ CCI_REG8(0xc58c), 0x30 }, { CCI_REG8(0xc58d), 0x30 },
++	{ CCI_REG8(0xc58e), 0x30 }, { CCI_REG8(0xc58f), 0x30 },
++	{ CCI_REG8(0xc590), 0x30 }, { CCI_REG8(0xc591), 0x30 },
++	{ CCI_REG8(0xc592), 0x30 }, { CCI_REG8(0xc598), 0x30 },
++	{ CCI_REG8(0xc599), 0x30 }, { CCI_REG8(0xc59a), 0x30 },
++	{ CCI_REG8(0xc59b), 0x30 }, { CCI_REG8(0xc59c), 0x30 },
++	{ CCI_REG8(0xc59d), 0x30 }, { CCI_REG8(0xc59e), 0x30 },
++	{ CCI_REG8(0xc59f), 0x30 }, { CCI_REG8(0xc5a0), 0x30 },
++	{ CCI_REG8(0xc5a1), 0x30 }, { CCI_REG8(0xc5a2), 0x30 },
++	{ CCI_REG8(0xc5a3), 0x30 }, { CCI_REG8(0xc5a4), 0x30 },
++	{ CCI_REG8(0xc5a5), 0x30 }, { CCI_REG8(0xc5a6), 0x30 },
++	{ CCI_REG8(0xc5a7), 0x30 }, { CCI_REG8(0xc5a8), 0x30 },
++	{ CCI_REG8(0xc5a9), 0x30 }, { CCI_REG8(0xc5aa), 0x30 },
++	{ CCI_REG8(0xc5ab), 0x30 }, { CCI_REG8(0xc5b1), 0x38 },
++	{ CCI_REG8(0xc5b2), 0x38 }, { CCI_REG8(0xc5b3), 0x38 },
++	{ CCI_REG8(0xc5b4), 0x38 }, { CCI_REG8(0xc5b5), 0x38 },
++	{ CCI_REG8(0xc5b6), 0x38 }, { CCI_REG8(0xc5b7), 0x38 },
++	{ CCI_REG8(0xc5b8), 0x38 }, { CCI_REG8(0xc5b9), 0x38 },
++	{ CCI_REG8(0xc5ba), 0x38 }, { CCI_REG8(0xc5bb), 0x38 },
++	{ CCI_REG8(0xc5bc), 0x38 }, { CCI_REG8(0xc5bd), 0x38 },
++	{ CCI_REG8(0xc5be), 0x38 }, { CCI_REG8(0xc5bf), 0x38 },
++	{ CCI_REG8(0xc5c0), 0x38 }, { CCI_REG8(0xc5c1), 0x38 },
++	{ CCI_REG8(0xc5c2), 0x38 }, { CCI_REG8(0xc5c3), 0x38 },
++	{ CCI_REG8(0xc5c4), 0x38 }, { CCI_REG8(0xc5ca), 0x38 },
++	{ CCI_REG8(0xc5cb), 0x38 }, { CCI_REG8(0xc5cc), 0x38 },
++	{ CCI_REG8(0xc5cd), 0x38 }, { CCI_REG8(0xc5ce), 0x38 },
++	{ CCI_REG8(0xc5cf), 0x38 }, { CCI_REG8(0xc5d0), 0x38 },
++	{ CCI_REG8(0xc5d1), 0x38 }, { CCI_REG8(0xc5d2), 0x38 },
++	{ CCI_REG8(0xc5d3), 0x38 }, { CCI_REG8(0xc5d4), 0x38 },
++	{ CCI_REG8(0xc5d5), 0x38 }, { CCI_REG8(0xc5d6), 0x38 },
++	{ CCI_REG8(0xc5d7), 0x38 }, { CCI_REG8(0xc5d8), 0x38 },
++	{ CCI_REG8(0xc5d9), 0x38 }, { CCI_REG8(0xc5da), 0x38 },
++	{ CCI_REG8(0xc5db), 0x38 }, { CCI_REG8(0xc5dc), 0x38 },
++	{ CCI_REG8(0xc5dd), 0x38 }, { CCI_REG8(0x3a60), 0x68 },
++	{ CCI_REG8(0x3a6f), 0x68 }, { CCI_REG8(0x3a5e), 0xdc },
++	{ CCI_REG8(0x3a6d), 0xdc }, { CCI_REG8(0x3aed), 0x6e },
++	{ CCI_REG8(0x3af1), 0x73 }, { CCI_REG8(0x3992), 0x02 },
++	{ CCI_REG8(0x399e), 0x02 }, { CCI_REG8(0x371d), 0x17 },
++	{ CCI_REG8(0x371f), 0x08 }, { CCI_REG8(0x3721), 0xc9 },
++	{ CCI_REG8(0x401e), 0x00 }, { CCI_REG8(0x401f), 0xf8 },
++	{ CCI_REG8(0x3642), 0x00 }, { CCI_REG8(0x3641), 0x7f },
++	{ CCI_REG8(0x3ac5), 0x0c }, { CCI_REG8(0x3ac6), 0x09 },
++	{ CCI_REG8(0x3ac7), 0x06 }, { CCI_REG8(0x3ac8), 0x02 },
++	{ CCI_REG8(0x3ac9), 0x0c }, { CCI_REG8(0x3aca), 0x09 },
++	{ CCI_REG8(0x3acb), 0x06 }, { CCI_REG8(0x3acc), 0x02 },
++	{ CCI_REG8(0x3acd), 0x0c }, { CCI_REG8(0x3ace), 0x09 },
++	{ CCI_REG8(0x3acf), 0x07 }, { CCI_REG8(0x3ad0), 0x04 },
++	{ CCI_REG8(0x3ad1), 0x0c }, { CCI_REG8(0x3ad2), 0x09 },
++	{ CCI_REG8(0x3ad3), 0x07 }, { CCI_REG8(0x3ad4), 0x04 },
++	{ CCI_REG8(0xc483), 0x0c }, { CCI_REG8(0xc484), 0x0c },
++	{ CCI_REG8(0xc485), 0x0c }, { CCI_REG8(0xc486), 0x0c },
++	{ CCI_REG8(0x3a2f), 0x0c }, { CCI_REG8(0x3a30), 0x09 },
++	{ CCI_REG8(0x3a31), 0x06 }, { CCI_REG8(0x3a32), 0x02 },
++	{ CCI_REG8(0x3a34), 0x0c }, { CCI_REG8(0x3a35), 0x09 },
++	{ CCI_REG8(0x3a36), 0x07 }, { CCI_REG8(0x3a37), 0x04 },
++	{ CCI_REG8(0x3a43), 0x0c }, { CCI_REG8(0x3a44), 0x09 },
++	{ CCI_REG8(0x3a45), 0x06 }, { CCI_REG8(0x3a46), 0x02 },
++	{ CCI_REG8(0x3a48), 0x0c }, { CCI_REG8(0x3a49), 0x09 },
++	{ CCI_REG8(0x3a4a), 0x07 }, { CCI_REG8(0x3a4b), 0x04 },
++	{ CCI_REG8(0xc487), 0x0c }, { CCI_REG8(0xc488), 0x0c },
++	{ CCI_REG8(0xc489), 0x0c }, { CCI_REG8(0xc48a), 0x0c },
++	{ CCI_REG8(0x3645), 0xbd }, { CCI_REG8(0x373f), 0x00 },
++	{ CCI_REG8(0x374f), 0x10 }, { CCI_REG8(0x3743), 0xc6 },
++	{ CCI_REG8(0x3717), 0x82 }, { CCI_REG8(0x3732), 0x07 },
++	{ CCI_REG8(0x3731), 0x16 }, { CCI_REG8(0x3730), 0x16 },
++	{ CCI_REG8(0x3828), 0x07 }, { CCI_REG8(0x3714), 0x68 },
++	{ CCI_REG8(0x371d), 0x02 }, { CCI_REG8(0x371f), 0x02 },
++	{ CCI_REG8(0x37e0), 0x00 }, { CCI_REG8(0x37e1), 0x03 },
++	{ CCI_REG8(0x37e2), 0x07 }, { CCI_REG8(0x3734), 0x3e },
++	{ CCI_REG8(0x3736), 0x02 }, { CCI_REG8(0x37e4), 0x36 },
++	{ CCI_REG8(0x37e9), 0x1c }, { CCI_REG8(0x37ea), 0x01 },
++	{ CCI_REG8(0x37eb), 0x0a }, { CCI_REG8(0x37ec), 0x1c },
++	{ CCI_REG8(0x37ed), 0x01 }, { CCI_REG8(0x37ee), 0x36 },
++	{ CCI_REG8(0x373b), 0x1c }, { CCI_REG8(0x373c), 0x02 },
++	{ CCI_REG8(0x37bb), 0x1c }, { CCI_REG8(0x37bc), 0x02 },
++	{ CCI_REG8(0x37b8), 0x0c }, { CCI_REG8(0x371c), 0x01 },
++	{ CCI_REG8(0x371e), 0x11 }, { CCI_REG8(0x371d), 0x01 },
++	{ CCI_REG8(0x371f), 0x01 }, { CCI_REG8(0x3721), 0x01 },
++	{ CCI_REG8(0x3725), 0x12 }, { CCI_REG8(0x37e3), 0x06 },
++	{ CCI_REG8(0x37dd), 0x86 }, { CCI_REG8(0x37db), 0x0a },
++	{ CCI_REG8(0x37dc), 0x14 }, { CCI_REG8(0x3727), 0x20 },
++	{ CCI_REG8(0x37b2), 0x80 }, { CCI_REG8(0x37da), 0x04 },
++	{ CCI_REG8(0x37df), 0x01 }, { CCI_REG8(0x3731), 0x11 },
++	{ CCI_REG8(0x37dd), 0x86 }, { CCI_REG8(0x37df), 0x01 },
++	{ CCI_REG8(0x37da), 0x03 }, { CCI_REG8(0x37b2), 0x80 },
++	{ CCI_REG8(0x3727), 0x20 }, { CCI_REG8(0x4883), 0x26 },
++	{ CCI_REG8(0x488b), 0x88 }, { CCI_REG8(0x3d85), 0x1f },
++	{ CCI_REG8(0x3d81), 0x01 }, { CCI_REG8(0x3d84), 0x40 },
++	{ CCI_REG8(0x3d88), 0x00 }, { CCI_REG8(0x3d89), 0x00 },
++	{ CCI_REG8(0x3d8a), 0x0b }, { CCI_REG8(0x3d8b), 0xff },
++	{ CCI_REG8(0x4d00), 0x05 }, { CCI_REG8(0x4d01), 0xc4 },
++	{ CCI_REG8(0x4d02), 0xa3 }, { CCI_REG8(0x4d03), 0x8c },
++	{ CCI_REG8(0x4d04), 0xfb }, { CCI_REG8(0x4d05), 0xed },
++	{ CCI_REG8(0x4010), 0x28 }, { CCI_REG8(0x4030), 0x00 },
++	{ CCI_REG8(0x4031), 0x00 }, { CCI_REG8(0x4032), 0x00 },
++	{ CCI_REG8(0x4033), 0x00 }, { CCI_REG8(0x4034), 0x00 },
++	{ CCI_REG8(0x4035), 0x00 }, { CCI_REG8(0x4036), 0x00 },
++	{ CCI_REG8(0x4037), 0x00 }, { CCI_REG8(0x4040), 0x00 },
++	{ CCI_REG8(0x4041), 0x00 }, { CCI_REG8(0x4042), 0x00 },
++	{ CCI_REG8(0x4043), 0x00 }, { CCI_REG8(0x4044), 0x00 },
++	{ CCI_REG8(0x4045), 0x00 }, { CCI_REG8(0x4046), 0x00 },
++	{ CCI_REG8(0x4047), 0x00 }, { CCI_REG8(0x3400), 0x00 },
++	{ CCI_REG8(0x3421), 0x23 }, { CCI_REG8(0x3422), 0xfc },
++	{ CCI_REG8(0x3423), 0x07 }, { CCI_REG8(0x3424), 0x01 },
++	{ CCI_REG8(0x3425), 0x04 }, { CCI_REG8(0x3426), 0x50 },
++	{ CCI_REG8(0x3427), 0x55 }, { CCI_REG8(0x3428), 0x15 },
++	{ CCI_REG8(0x3429), 0x00 }, { CCI_REG8(0x3025), 0x03 },
++	{ CCI_REG8(0x3053), 0x00 }, { CCI_REG8(0x3054), 0x00 },
++	{ CCI_REG8(0x3055), 0x00 }, { CCI_REG8(0x3056), 0x00 },
++	{ CCI_REG8(0x3057), 0x00 }, { CCI_REG8(0x3058), 0x00 },
++	{ CCI_REG8(0x305c), 0x00 }, { CCI_REG8(0x340c), 0x1f },
++	{ CCI_REG8(0x340d), 0x00 }, { CCI_REG8(0x3501), 0x01 },
++	{ CCI_REG8(0x3542), 0x48 }, { CCI_REG8(0x3582), 0x24 },
++	{ CCI_REG8(0x3015), 0xf1 }, { CCI_REG8(0x3018), 0xf2 },
++	{ CCI_REG8(0x301c), 0xf2 }, { CCI_REG8(0x301d), 0xf6 },
++	{ CCI_REG8(0x301e), 0xf1 }, { CCI_REG8(0x0100), 0x01 },
++	{ CCI_REG8(0xfff9), 0x08 }, { CCI_REG8(0x3900), 0xcd },
++	{ CCI_REG8(0x3901), 0xcd }, { CCI_REG8(0x3902), 0xcd },
++	{ CCI_REG8(0x3903), 0xcd }, { CCI_REG8(0x3904), 0xcd },
++	{ CCI_REG8(0x3905), 0xcd }, { CCI_REG8(0x3906), 0xcd },
++	{ CCI_REG8(0x3907), 0xcd }, { CCI_REG8(0x3908), 0xcd },
++	{ CCI_REG8(0x3909), 0xcd }, { CCI_REG8(0x390a), 0xcd },
++	{ CCI_REG8(0x390b), 0xcd }, { CCI_REG8(0x390c), 0xcd },
++	{ CCI_REG8(0x390d), 0xcd }, { CCI_REG8(0x390e), 0xcd },
++	{ CCI_REG8(0x390f), 0xcd }, { CCI_REG8(0x3910), 0xcd },
++	{ CCI_REG8(0x3911), 0xcd }, { CCI_REG8(0x3912), 0xcd },
++	{ CCI_REG8(0x3913), 0xcd }, { CCI_REG8(0x3914), 0xcd },
++	{ CCI_REG8(0x3915), 0xcd }, { CCI_REG8(0x3916), 0xcd },
++	{ CCI_REG8(0x3917), 0xcd }, { CCI_REG8(0x3918), 0xcd },
++	{ CCI_REG8(0x3919), 0xcd }, { CCI_REG8(0x391a), 0xcd },
++	{ CCI_REG8(0x391b), 0xcd }, { CCI_REG8(0x391c), 0xcd },
++	{ CCI_REG8(0x391d), 0xcd }, { CCI_REG8(0x391e), 0xcd },
++	{ CCI_REG8(0x391f), 0xcd }, { CCI_REG8(0x3920), 0xcd },
++	{ CCI_REG8(0x3921), 0xcd }, { CCI_REG8(0x3922), 0xcd },
++	{ CCI_REG8(0x3923), 0xcd }, { CCI_REG8(0x3924), 0xcd },
++	{ CCI_REG8(0x3925), 0xcd }, { CCI_REG8(0x3926), 0xcd },
++	{ CCI_REG8(0x3927), 0xcd }, { CCI_REG8(0x3928), 0xcd },
++	{ CCI_REG8(0x3929), 0xcd }, { CCI_REG8(0x392a), 0xcd },
++	{ CCI_REG8(0x392b), 0xcd }, { CCI_REG8(0x392c), 0xcd },
++	{ CCI_REG8(0x392d), 0xcd }, { CCI_REG8(0x392e), 0xcd },
++	{ CCI_REG8(0x392f), 0xcd }, { CCI_REG8(0x3930), 0xcd },
++	{ CCI_REG8(0x3931), 0xcd }, { CCI_REG8(0x3932), 0xcd },
++	{ CCI_REG8(0x3933), 0xcd }, { CCI_REG8(0x3934), 0xcd },
++	{ CCI_REG8(0x3935), 0xcd }, { CCI_REG8(0x3936), 0xcd },
++	{ CCI_REG8(0x3937), 0xcd }, { CCI_REG8(0x3938), 0xcd },
++	{ CCI_REG8(0x3939), 0xcd }, { CCI_REG8(0x393a), 0xcd },
++	{ CCI_REG8(0x393b), 0xcd }, { CCI_REG8(0x393c), 0xcd },
++	{ CCI_REG8(0x393d), 0xcd }, { CCI_REG8(0x393e), 0xcd },
++	{ CCI_REG8(0x393f), 0xcd }, { CCI_REG8(0x3940), 0xcd },
++	{ CCI_REG8(0x3941), 0xcd }, { CCI_REG8(0x3942), 0xcd },
++	{ CCI_REG8(0x3943), 0xcd }, { CCI_REG8(0x3944), 0xcd },
++	{ CCI_REG8(0x3945), 0xcd }, { CCI_REG8(0x3946), 0xcd },
++	{ CCI_REG8(0x3947), 0xcd }, { CCI_REG8(0x3948), 0xcd },
++	{ CCI_REG8(0x3949), 0xcd }, { CCI_REG8(0x394a), 0xcd },
++	{ CCI_REG8(0x394b), 0xcd }, { CCI_REG8(0x394c), 0xcd },
++	{ CCI_REG8(0x394d), 0xcd }, { CCI_REG8(0x394e), 0xcd },
++	{ CCI_REG8(0x394f), 0xcd }, { CCI_REG8(0x3950), 0xcd },
++	{ CCI_REG8(0x3951), 0xcd }, { CCI_REG8(0x3952), 0xcd },
++	{ CCI_REG8(0x3953), 0xcd }, { CCI_REG8(0x3954), 0xcd },
++	{ CCI_REG8(0x3955), 0xcd }, { CCI_REG8(0x3956), 0xcd },
++	{ CCI_REG8(0x3957), 0xcd }, { CCI_REG8(0x3958), 0xcd },
++	{ CCI_REG8(0x3959), 0xcd }, { CCI_REG8(0x395a), 0xcd },
++	{ CCI_REG8(0x395b), 0xcd }, { CCI_REG8(0x395c), 0xcd },
++	{ CCI_REG8(0x395d), 0xcd }, { CCI_REG8(0x395e), 0xcd },
++	{ CCI_REG8(0x395f), 0xcd }, { CCI_REG8(0x3960), 0xcd },
++	{ CCI_REG8(0x3961), 0xcd }, { CCI_REG8(0x3962), 0xcd },
++	{ CCI_REG8(0x3963), 0xcd }, { CCI_REG8(0x3964), 0xcd },
++	{ CCI_REG8(0x3965), 0xcd }, { CCI_REG8(0x3966), 0xcd },
++	{ CCI_REG8(0x3967), 0xcd }, { CCI_REG8(0x3968), 0xcd },
++	{ CCI_REG8(0x3969), 0xcd }, { CCI_REG8(0x396a), 0xcd },
++	{ CCI_REG8(0x396b), 0xcd }, { CCI_REG8(0x396c), 0xcd },
++	{ CCI_REG8(0x396d), 0xcd }, { CCI_REG8(0x396e), 0xcd },
++	{ CCI_REG8(0x396f), 0xcd }, { CCI_REG8(0x3970), 0xcd },
++	{ CCI_REG8(0x3971), 0xcd }, { CCI_REG8(0x3972), 0xcd },
++	{ CCI_REG8(0x3973), 0xcd }, { CCI_REG8(0x3974), 0xcd },
++	{ CCI_REG8(0x3975), 0xcd }, { CCI_REG8(0x3976), 0xcd },
++	{ CCI_REG8(0x3977), 0xcd }, { CCI_REG8(0x3978), 0xcd },
++	{ CCI_REG8(0x3979), 0xcd }, { CCI_REG8(0x397a), 0xcd },
++	{ CCI_REG8(0x397b), 0xcd }, { CCI_REG8(0x397c), 0xcd },
++	{ CCI_REG8(0x397d), 0xcd }, { CCI_REG8(0x397e), 0xcd },
++	{ CCI_REG8(0x397f), 0xcd }, { CCI_REG8(0x3980), 0xcd },
++	{ CCI_REG8(0x3981), 0xcd }, { CCI_REG8(0x3982), 0xcd },
++	{ CCI_REG8(0x3983), 0xcd }, { CCI_REG8(0x3984), 0xcd },
++	{ CCI_REG8(0x3985), 0xcd }, { CCI_REG8(0x3986), 0xcd },
++	{ CCI_REG8(0x3987), 0xcd }, { CCI_REG8(0x3988), 0xcd },
++	{ CCI_REG8(0x3989), 0xcd }, { CCI_REG8(0x398a), 0xcd },
++	{ CCI_REG8(0x398b), 0xcd }, { CCI_REG8(0x398c), 0xcd },
++	{ CCI_REG8(0x398d), 0xcd }, { CCI_REG8(0x398e), 0xcd },
++	{ CCI_REG8(0x398f), 0xcd }, { CCI_REG8(0x3990), 0xcd },
++	{ CCI_REG8(0x3991), 0xcd }, { CCI_REG8(0x3992), 0xcd },
++	{ CCI_REG8(0x3993), 0xcd }, { CCI_REG8(0x3994), 0xcd },
++	{ CCI_REG8(0x3995), 0xcd }, { CCI_REG8(0x3996), 0xcd },
++	{ CCI_REG8(0x3997), 0xcd }, { CCI_REG8(0x3998), 0xcd },
++	{ CCI_REG8(0x3999), 0xcd }, { CCI_REG8(0x399a), 0xcd },
++	{ CCI_REG8(0x399b), 0xcd }, { CCI_REG8(0x399c), 0xcd },
++	{ CCI_REG8(0x399d), 0xcd }, { CCI_REG8(0x399e), 0xcd },
++	{ CCI_REG8(0x399f), 0xcd }, { CCI_REG8(0x39a0), 0xcd },
++	{ CCI_REG8(0x39a1), 0xcd }, { CCI_REG8(0x39a2), 0xcd },
++	{ CCI_REG8(0x39a3), 0xcd }, { CCI_REG8(0x39a4), 0xcd },
++	{ CCI_REG8(0x39a5), 0xcd }, { CCI_REG8(0x39a6), 0xcd },
++	{ CCI_REG8(0x39a7), 0xcd }, { CCI_REG8(0x39a8), 0xcd },
++	{ CCI_REG8(0x39a9), 0xcd }, { CCI_REG8(0x39aa), 0xcd },
++	{ CCI_REG8(0x39ab), 0xcd }, { CCI_REG8(0x39ac), 0xcd },
++	{ CCI_REG8(0x39ad), 0xcd }, { CCI_REG8(0x39ae), 0xcd },
++	{ CCI_REG8(0x39af), 0xcd }, { CCI_REG8(0x39b0), 0xcd },
++	{ CCI_REG8(0x39b1), 0xcd }, { CCI_REG8(0x39b2), 0xcd },
++	{ CCI_REG8(0x39b3), 0xcd }, { CCI_REG8(0x39b4), 0xcd },
++	{ CCI_REG8(0x39b5), 0xcd }, { CCI_REG8(0x39b6), 0xcd },
++	{ CCI_REG8(0x39b7), 0xcd }, { CCI_REG8(0x39b8), 0xcd },
++	{ CCI_REG8(0x39b9), 0xcd }, { CCI_REG8(0x39ba), 0xcd },
++	{ CCI_REG8(0x39bb), 0xcd }, { CCI_REG8(0x39bc), 0xcd },
++	{ CCI_REG8(0x39bd), 0xcd }, { CCI_REG8(0x39be), 0xcd },
++	{ CCI_REG8(0x39bf), 0xcd }, { CCI_REG8(0x39c0), 0xcd },
++	{ CCI_REG8(0x39c1), 0xcd }, { CCI_REG8(0x39c2), 0xcd },
++	{ CCI_REG8(0x39c3), 0xcd }, { CCI_REG8(0x39c4), 0xcd },
++	{ CCI_REG8(0x39c5), 0xcd }, { CCI_REG8(0x39c6), 0xcd },
++	{ CCI_REG8(0x39c7), 0xcd }, { CCI_REG8(0x39c8), 0xcd },
++	{ CCI_REG8(0x39c9), 0xcd }, { CCI_REG8(0x39ca), 0xcd },
++	{ CCI_REG8(0x39cb), 0xcd }, { CCI_REG8(0x39cc), 0xcd },
++	{ CCI_REG8(0x39cd), 0xcd }, { CCI_REG8(0x39ce), 0xcd },
++	{ CCI_REG8(0x39cf), 0xcd }, { CCI_REG8(0x39d0), 0xcd },
++	{ CCI_REG8(0x39d1), 0xcd }, { CCI_REG8(0x39d2), 0xcd },
++	{ CCI_REG8(0x39d3), 0xcd }, { CCI_REG8(0x39d4), 0xcd },
++	{ CCI_REG8(0x39d5), 0xcd }, { CCI_REG8(0x39d6), 0xcd },
++	{ CCI_REG8(0x39d7), 0xcd }, { CCI_REG8(0x39d8), 0xcd },
++	{ CCI_REG8(0x39d9), 0xcd }, { CCI_REG8(0x39da), 0xcd },
++	{ CCI_REG8(0x39db), 0xcd }, { CCI_REG8(0x39dc), 0xcd },
++	{ CCI_REG8(0x39dd), 0xcd }, { CCI_REG8(0x39de), 0xcd },
++	{ CCI_REG8(0x39df), 0xcd }, { CCI_REG8(0x39e0), 0xcd },
++	{ CCI_REG8(0x39e1), 0x40 }, { CCI_REG8(0x39e2), 0x40 },
++	{ CCI_REG8(0x39e3), 0x40 }, { CCI_REG8(0x39e4), 0x40 },
++	{ CCI_REG8(0x39e5), 0x40 }, { CCI_REG8(0x39e6), 0x40 },
++	{ CCI_REG8(0x39e7), 0x40 }, { CCI_REG8(0x39e8), 0x40 },
++	{ CCI_REG8(0x39e9), 0x40 }, { CCI_REG8(0x39ea), 0x40 },
++	{ CCI_REG8(0x39eb), 0x40 }, { CCI_REG8(0x39ec), 0x40 },
++	{ CCI_REG8(0x39ed), 0x40 }, { CCI_REG8(0x39ee), 0x40 },
++	{ CCI_REG8(0x39ef), 0x40 }, { CCI_REG8(0x39f0), 0x40 },
++	{ CCI_REG8(0x39f1), 0x40 }, { CCI_REG8(0x39f2), 0x40 },
++	{ CCI_REG8(0x39f3), 0x40 }, { CCI_REG8(0x39f4), 0x40 },
++	{ CCI_REG8(0x39f5), 0x40 }, { CCI_REG8(0x39f6), 0x40 },
++	{ CCI_REG8(0x39f7), 0x40 }, { CCI_REG8(0x39f8), 0x40 },
++	{ CCI_REG8(0x39f9), 0x40 }, { CCI_REG8(0x39fa), 0x40 },
++	{ CCI_REG8(0x39fb), 0x40 }, { CCI_REG8(0x39fc), 0x40 },
++	{ CCI_REG8(0x39fd), 0x40 }, { CCI_REG8(0x39fe), 0x40 },
++	{ CCI_REG8(0x39ff), 0x40 }, { CCI_REG8(0x3a00), 0x40 },
++	{ CCI_REG8(0x3a01), 0x40 }, { CCI_REG8(0x3a02), 0x40 },
++	{ CCI_REG8(0x3a03), 0x40 }, { CCI_REG8(0x3a04), 0x40 },
++	{ CCI_REG8(0x3a05), 0x40 }, { CCI_REG8(0x3a06), 0x40 },
++	{ CCI_REG8(0x3a07), 0x40 }, { CCI_REG8(0x3a08), 0x40 },
++	{ CCI_REG8(0x3a09), 0x40 }, { CCI_REG8(0x3a0a), 0x40 },
++	{ CCI_REG8(0x3a0b), 0x40 }, { CCI_REG8(0x3a0c), 0x40 },
++	{ CCI_REG8(0x3a0d), 0x40 }, { CCI_REG8(0x3a0e), 0x40 },
++	{ CCI_REG8(0x3a0f), 0x40 }, { CCI_REG8(0x3a10), 0x40 },
++	{ CCI_REG8(0x3a11), 0x40 }, { CCI_REG8(0x3a12), 0x40 },
++	{ CCI_REG8(0x3a13), 0x40 }, { CCI_REG8(0x3a14), 0x40 },
++	{ CCI_REG8(0x3a15), 0x40 }, { CCI_REG8(0x3a16), 0x40 },
++	{ CCI_REG8(0x3a17), 0x40 }, { CCI_REG8(0x3a18), 0x40 },
++	{ CCI_REG8(0x3a19), 0x40 }, { CCI_REG8(0x3a1a), 0x40 },
++	{ CCI_REG8(0x3a1b), 0x40 }, { CCI_REG8(0x3a1c), 0x40 },
++	{ CCI_REG8(0x3a1d), 0x40 }, { CCI_REG8(0x3a1e), 0x40 },
++	{ CCI_REG8(0x3a1f), 0x40 }, { CCI_REG8(0x3a20), 0x40 },
++	{ CCI_REG8(0x3a21), 0x40 }, { CCI_REG8(0x3a22), 0x40 },
++	{ CCI_REG8(0x3a23), 0x40 }, { CCI_REG8(0x3a24), 0x40 },
++	{ CCI_REG8(0x3a25), 0x40 }, { CCI_REG8(0x3a26), 0x40 },
++	{ CCI_REG8(0x3a27), 0x40 }, { CCI_REG8(0x3a28), 0x40 },
++	{ CCI_REG8(0x3a29), 0x40 }, { CCI_REG8(0x3a2a), 0x40 },
++	{ CCI_REG8(0x3a2b), 0x40 }, { CCI_REG8(0x3a2c), 0x40 },
++	{ CCI_REG8(0x3a2d), 0x40 }, { CCI_REG8(0x3a2e), 0x40 },
++	{ CCI_REG8(0x3a2f), 0x40 }, { CCI_REG8(0x3a30), 0x40 },
++	{ CCI_REG8(0x3a31), 0x40 }, { CCI_REG8(0x3a32), 0x40 },
++	{ CCI_REG8(0x3a33), 0x40 }, { CCI_REG8(0x3a34), 0x40 },
++	{ CCI_REG8(0x3a35), 0x40 }, { CCI_REG8(0x3a36), 0x40 },
++	{ CCI_REG8(0x3a37), 0x40 }, { CCI_REG8(0x3a38), 0x40 },
++	{ CCI_REG8(0x3a39), 0x40 }, { CCI_REG8(0x3a3a), 0x40 },
++	{ CCI_REG8(0x3a3b), 0xcd }, { CCI_REG8(0x3a3c), 0xcd },
++	{ CCI_REG8(0x3a3d), 0xcd }, { CCI_REG8(0x3a3e), 0xcd },
++	{ CCI_REG8(0x3a3f), 0xcd }, { CCI_REG8(0x3a40), 0xcd },
++	{ CCI_REG8(0x3a41), 0xcd }, { CCI_REG8(0x3a42), 0xcd },
++	{ CCI_REG8(0x3a43), 0xcd }, { CCI_REG8(0x3a44), 0xcd },
++	{ CCI_REG8(0x3a45), 0xcd }, { CCI_REG8(0x3a46), 0xcd },
++	{ CCI_REG8(0x3a47), 0xcd }, { CCI_REG8(0x3a48), 0xcd },
++	{ CCI_REG8(0x3a49), 0xcd }, { CCI_REG8(0x3a4a), 0xcd },
++	{ CCI_REG8(0x3a4b), 0xcd }, { CCI_REG8(0x3a4c), 0xcd },
++	{ CCI_REG8(0x3a4d), 0xcd }, { CCI_REG8(0x3a4e), 0xcd },
++	{ CCI_REG8(0x3a4f), 0xcd }, { CCI_REG8(0x3a50), 0xcd },
++	{ CCI_REG8(0x3a51), 0xcd }, { CCI_REG8(0x3a52), 0xcd },
++	{ CCI_REG8(0x3a53), 0xcd }, { CCI_REG8(0x3a54), 0xcd },
++	{ CCI_REG8(0x3a55), 0xcd }, { CCI_REG8(0x3a56), 0xcd },
++	{ CCI_REG8(0x3a57), 0xcd }, { CCI_REG8(0x3a58), 0xcd },
++	{ CCI_REG8(0x3a59), 0xcd }, { CCI_REG8(0x3a5a), 0xcd },
++	{ CCI_REG8(0x3a5b), 0xcd }, { CCI_REG8(0x3a5c), 0xcd },
++	{ CCI_REG8(0x3a5d), 0xcd }, { CCI_REG8(0x3a5e), 0xcd },
++	{ CCI_REG8(0x3a5f), 0xcd }, { CCI_REG8(0x3a60), 0xcd },
++	{ CCI_REG8(0x3a61), 0xcd }, { CCI_REG8(0x3a62), 0xcd },
++	{ CCI_REG8(0x3a63), 0xcd }, { CCI_REG8(0x3a64), 0xcd },
++	{ CCI_REG8(0x3a65), 0xcd }, { CCI_REG8(0x3a66), 0xcd },
++	{ CCI_REG8(0x3a67), 0xcd }, { CCI_REG8(0x3a68), 0xcd },
++	{ CCI_REG8(0x3a69), 0xcd }, { CCI_REG8(0x3a6a), 0xcd },
++	{ CCI_REG8(0x3a6b), 0xcd }, { CCI_REG8(0x3a6c), 0xcd },
++	{ CCI_REG8(0x3a6d), 0xcd }, { CCI_REG8(0x3a6e), 0xcd },
++	{ CCI_REG8(0x3a6f), 0xcd }, { CCI_REG8(0x3a70), 0xcd },
++	{ CCI_REG8(0x3a71), 0xcd }, { CCI_REG8(0x3a72), 0xcd },
++	{ CCI_REG8(0x3a73), 0xcd }, { CCI_REG8(0x3a74), 0xcd },
++	{ CCI_REG8(0x3a75), 0xcd }, { CCI_REG8(0x3a76), 0xcd },
++	{ CCI_REG8(0x3a77), 0xcd }, { CCI_REG8(0x3a78), 0xcd },
++	{ CCI_REG8(0x3a79), 0xcd }, { CCI_REG8(0x3a7a), 0xcd },
++	{ CCI_REG8(0x3a7b), 0xcd }, { CCI_REG8(0x3a7c), 0xcd },
++	{ CCI_REG8(0x3a7d), 0xcd }, { CCI_REG8(0x3a7e), 0xcd },
++	{ CCI_REG8(0x3a7f), 0xcd }, { CCI_REG8(0x3a80), 0xcd },
++	{ CCI_REG8(0x3a81), 0xcd }, { CCI_REG8(0x3a82), 0xcd },
++	{ CCI_REG8(0x3a83), 0xcd }, { CCI_REG8(0x3a84), 0xcd },
++	{ CCI_REG8(0x3a85), 0xcd }, { CCI_REG8(0x3a86), 0xcd },
++	{ CCI_REG8(0x3a87), 0xcd }, { CCI_REG8(0x3a88), 0xcd },
++	{ CCI_REG8(0x3a89), 0xcd }, { CCI_REG8(0x3a8a), 0xcd },
++	{ CCI_REG8(0x3a8b), 0xcd }, { CCI_REG8(0x3a8c), 0xcd },
++	{ CCI_REG8(0x3a8d), 0xcd }, { CCI_REG8(0x3a8e), 0xcd },
++	{ CCI_REG8(0x3a8f), 0xcd }, { CCI_REG8(0x3a90), 0xcd },
++	{ CCI_REG8(0x3a91), 0xcd }, { CCI_REG8(0x3a92), 0xcd },
++	{ CCI_REG8(0x3a93), 0xcd }, { CCI_REG8(0x3a94), 0xcd },
++	{ CCI_REG8(0x3a95), 0x40 }, { CCI_REG8(0x3a96), 0x40 },
++	{ CCI_REG8(0x3a97), 0x40 }, { CCI_REG8(0x3a98), 0x40 },
++	{ CCI_REG8(0x3a99), 0x40 }, { CCI_REG8(0x3a9a), 0x40 },
++	{ CCI_REG8(0x3a9b), 0x40 }, { CCI_REG8(0x3a9c), 0x40 },
++	{ CCI_REG8(0x3a9d), 0x40 }, { CCI_REG8(0x3a9e), 0x40 },
++	{ CCI_REG8(0x3a9f), 0x40 }, { CCI_REG8(0x3aa0), 0x40 },
++	{ CCI_REG8(0x3aa1), 0x40 }, { CCI_REG8(0x3aa2), 0x40 },
++	{ CCI_REG8(0x3aa3), 0x40 }, { CCI_REG8(0x3aa4), 0x40 },
++	{ CCI_REG8(0x3aa5), 0x40 }, { CCI_REG8(0x3aa6), 0x40 },
++	{ CCI_REG8(0x3aa7), 0x40 }, { CCI_REG8(0x3aa8), 0x40 },
++	{ CCI_REG8(0x3aa9), 0x40 }, { CCI_REG8(0x3aaa), 0x40 },
++	{ CCI_REG8(0x3aab), 0x40 }, { CCI_REG8(0x3aac), 0x40 },
++	{ CCI_REG8(0x3aad), 0x40 }, { CCI_REG8(0x3aae), 0x40 },
++	{ CCI_REG8(0x3aaf), 0x40 }, { CCI_REG8(0x3ab0), 0x40 },
++	{ CCI_REG8(0x3ab1), 0x40 }, { CCI_REG8(0x3ab2), 0x40 },
++	{ CCI_REG8(0x3ab3), 0x40 }, { CCI_REG8(0x3ab4), 0x40 },
++	{ CCI_REG8(0x3ab5), 0x40 }, { CCI_REG8(0x3ab6), 0x40 },
++	{ CCI_REG8(0x3ab7), 0x40 }, { CCI_REG8(0x3ab8), 0x40 },
++	{ CCI_REG8(0x3ab9), 0x40 }, { CCI_REG8(0x3aba), 0x40 },
++	{ CCI_REG8(0x3abb), 0x40 }, { CCI_REG8(0x3abc), 0x40 },
++	{ CCI_REG8(0x3abd), 0x40 }, { CCI_REG8(0x3abe), 0x40 },
++	{ CCI_REG8(0x3abf), 0x40 }, { CCI_REG8(0x3ac0), 0x40 },
++	{ CCI_REG8(0x3ac1), 0x40 }, { CCI_REG8(0x3ac2), 0x40 },
++	{ CCI_REG8(0x3ac3), 0x40 }, { CCI_REG8(0x3ac4), 0x40 },
++	{ CCI_REG8(0x3ac5), 0x40 }, { CCI_REG8(0x3ac6), 0x40 },
++	{ CCI_REG8(0x3ac7), 0x40 }, { CCI_REG8(0x3ac8), 0x40 },
++	{ CCI_REG8(0x3ac9), 0x40 }, { CCI_REG8(0x3aca), 0x40 },
++	{ CCI_REG8(0x3acb), 0x40 }, { CCI_REG8(0x3acc), 0x40 },
++	{ CCI_REG8(0x3acd), 0x40 }, { CCI_REG8(0x3ace), 0x40 },
++	{ CCI_REG8(0x3acf), 0x40 }, { CCI_REG8(0x3ad0), 0x40 },
++	{ CCI_REG8(0x3ad1), 0x40 }, { CCI_REG8(0x3ad2), 0x40 },
++	{ CCI_REG8(0x3ad3), 0x40 }, { CCI_REG8(0x3ad4), 0x40 },
++	{ CCI_REG8(0x3ad5), 0x40 }, { CCI_REG8(0x3ad6), 0x40 },
++	{ CCI_REG8(0x3ad7), 0x40 }, { CCI_REG8(0x3ad8), 0x40 },
++	{ CCI_REG8(0x3ad9), 0x40 }, { CCI_REG8(0x3ada), 0x40 },
++	{ CCI_REG8(0x3adb), 0x40 }, { CCI_REG8(0x3adc), 0x40 },
++	{ CCI_REG8(0x3add), 0x40 }, { CCI_REG8(0x3ade), 0x40 },
++	{ CCI_REG8(0x3adf), 0x40 }, { CCI_REG8(0x3ae0), 0x40 },
++	{ CCI_REG8(0x3ae1), 0x40 }, { CCI_REG8(0x3ae2), 0x40 },
++	{ CCI_REG8(0x3ae3), 0x40 }, { CCI_REG8(0x3ae4), 0x40 },
++	{ CCI_REG8(0x3ae5), 0x40 }, { CCI_REG8(0x3ae6), 0x40 },
++	{ CCI_REG8(0x3ae7), 0x40 }, { CCI_REG8(0x3ae8), 0x40 },
++	{ CCI_REG8(0x3ae9), 0x40 }, { CCI_REG8(0x3aea), 0x40 },
++	{ CCI_REG8(0x3aeb), 0x40 }, { CCI_REG8(0x3aec), 0x40 },
++	{ CCI_REG8(0x3aed), 0x40 }, { CCI_REG8(0x3aee), 0x40 },
++	{ CCI_REG8(0x3aef), 0xcd }, { CCI_REG8(0x3af0), 0xcd },
++	{ CCI_REG8(0x3af1), 0xcd }, { CCI_REG8(0x3af2), 0xcd },
++	{ CCI_REG8(0x3af3), 0xcd }, { CCI_REG8(0x3af4), 0xcd },
++	{ CCI_REG8(0x3af5), 0xcd }, { CCI_REG8(0x3af6), 0xcd },
++	{ CCI_REG8(0x3af7), 0xcd }, { CCI_REG8(0x3af8), 0xcd },
++	{ CCI_REG8(0x3af9), 0xcd }, { CCI_REG8(0x3afa), 0xcd },
++	{ CCI_REG8(0x3afb), 0xcd }, { CCI_REG8(0x3afc), 0xcd },
++	{ CCI_REG8(0x3afd), 0xcd }, { CCI_REG8(0x3afe), 0xcd },
++	{ CCI_REG8(0x3aff), 0xcd }, { CCI_REG8(0x3b00), 0xcd },
++	{ CCI_REG8(0x3b01), 0xcd }, { CCI_REG8(0x3b02), 0xcd },
++	{ CCI_REG8(0x3b03), 0xcd }, { CCI_REG8(0x3b04), 0xcd },
++	{ CCI_REG8(0x3b05), 0xcd }, { CCI_REG8(0x3b06), 0xcd },
++	{ CCI_REG8(0x3b07), 0xcd }, { CCI_REG8(0x3b08), 0xcd },
++	{ CCI_REG8(0x3b09), 0xcd }, { CCI_REG8(0x3b0a), 0xcd },
++	{ CCI_REG8(0x3b0b), 0xcd }, { CCI_REG8(0x3b0c), 0xcd },
++	{ CCI_REG8(0x3b0d), 0xcd }, { CCI_REG8(0x3b0e), 0xcd },
++	{ CCI_REG8(0x3b0f), 0xcd }, { CCI_REG8(0x3b10), 0xcd },
++	{ CCI_REG8(0x3b11), 0xcd }, { CCI_REG8(0x3b12), 0xcd },
++	{ CCI_REG8(0x3b13), 0xcd }, { CCI_REG8(0x3b14), 0xcd },
++	{ CCI_REG8(0x3b15), 0xcd }, { CCI_REG8(0x3b16), 0xcd },
++	{ CCI_REG8(0x3b17), 0xcd }, { CCI_REG8(0x3b18), 0xcd },
++	{ CCI_REG8(0x3b19), 0xcd }, { CCI_REG8(0x3b1a), 0xcd },
++	{ CCI_REG8(0x3b1b), 0xcd }, { CCI_REG8(0x3b1c), 0xcd },
++	{ CCI_REG8(0x3b1d), 0xcd }, { CCI_REG8(0x3b1e), 0xcd },
++	{ CCI_REG8(0x3b1f), 0xcd }, { CCI_REG8(0x3b20), 0xcd },
++	{ CCI_REG8(0x3b21), 0xcd }, { CCI_REG8(0x3b22), 0xcd },
++	{ CCI_REG8(0x3b23), 0xcd }, { CCI_REG8(0x3b24), 0xcd },
++	{ CCI_REG8(0x3b25), 0xcd }, { CCI_REG8(0x3b26), 0xcd },
++	{ CCI_REG8(0x3b27), 0xcd }, { CCI_REG8(0x3b28), 0xcd },
++	{ CCI_REG8(0x3b29), 0xcd }, { CCI_REG8(0x3b2a), 0xcd },
++	{ CCI_REG8(0x3b2b), 0xcd }, { CCI_REG8(0x3b2c), 0xcd },
++	{ CCI_REG8(0x3b2d), 0xcd }, { CCI_REG8(0x3b2e), 0xcd },
++	{ CCI_REG8(0x3b2f), 0xcd }, { CCI_REG8(0x3b30), 0xcd },
++	{ CCI_REG8(0x3b31), 0xcd }, { CCI_REG8(0x3b32), 0xcd },
++	{ CCI_REG8(0x3b33), 0xcd }, { CCI_REG8(0x3b34), 0xcd },
++	{ CCI_REG8(0x3b35), 0xcd }, { CCI_REG8(0x3b36), 0xcd },
++	{ CCI_REG8(0x3b37), 0xcd }, { CCI_REG8(0x3b38), 0xcd },
++	{ CCI_REG8(0x3b39), 0xcd }, { CCI_REG8(0x3b3a), 0xcd },
++	{ CCI_REG8(0x3b3b), 0xcd }, { CCI_REG8(0x3b3c), 0xcd },
++	{ CCI_REG8(0x3b3d), 0xcd }, { CCI_REG8(0x3b3e), 0xcd },
++	{ CCI_REG8(0x3b3f), 0xcd }, { CCI_REG8(0x3b40), 0xcd },
++	{ CCI_REG8(0x3b41), 0xcd }, { CCI_REG8(0x3b42), 0xcd },
++	{ CCI_REG8(0x3b43), 0xcd }, { CCI_REG8(0x3b44), 0xcd },
++	{ CCI_REG8(0x3b45), 0xcd }, { CCI_REG8(0x3b46), 0xcd },
++	{ CCI_REG8(0x3b47), 0xcd }, { CCI_REG8(0x3b48), 0xcd },
++	{ CCI_REG8(0x3b49), 0xcd }, { CCI_REG8(0x3b4a), 0xcd },
++	{ CCI_REG8(0x3b4b), 0xcd }, { CCI_REG8(0x3b4c), 0xcd },
++	{ CCI_REG8(0x3b4d), 0xcd }, { CCI_REG8(0x3b4e), 0xcd },
++	{ CCI_REG8(0x3b4f), 0xcd }, { CCI_REG8(0x3b50), 0xcd },
++	{ CCI_REG8(0x3b51), 0xcd }, { CCI_REG8(0x3b52), 0xcd },
++	{ CCI_REG8(0x3b53), 0xcd }, { CCI_REG8(0x3b54), 0xcd },
++	{ CCI_REG8(0x3b55), 0xcd }, { CCI_REG8(0x3b56), 0xcd },
++	{ CCI_REG8(0x3b57), 0xcd }, { CCI_REG8(0x3b58), 0xcd },
++	{ CCI_REG8(0x3b59), 0xcd }, { CCI_REG8(0x3b5a), 0xcd },
++	{ CCI_REG8(0x3b5b), 0xcd }, { CCI_REG8(0x3b5c), 0xcd },
++	{ CCI_REG8(0x3b5d), 0xcd }, { CCI_REG8(0x3b5e), 0xcd },
++	{ CCI_REG8(0x3b5f), 0xcd }, { CCI_REG8(0x3b60), 0xcd },
++	{ CCI_REG8(0x3b61), 0xcd }, { CCI_REG8(0x3b62), 0xcd },
++	{ CCI_REG8(0x3b63), 0xcd }, { CCI_REG8(0x3b64), 0xcd },
++	{ CCI_REG8(0x3b65), 0xcd }, { CCI_REG8(0x3b66), 0xcd },
++	{ CCI_REG8(0x3b67), 0xcd }, { CCI_REG8(0x3b68), 0xcd },
++	{ CCI_REG8(0x3b69), 0xcd }, { CCI_REG8(0x3b6a), 0xcd },
++	{ CCI_REG8(0x3b6b), 0xcd }, { CCI_REG8(0x3b6c), 0xcd },
++	{ CCI_REG8(0x3b6d), 0xcd }, { CCI_REG8(0x3b6e), 0xcd },
++	{ CCI_REG8(0x3b6f), 0xcd }, { CCI_REG8(0x3b70), 0xcd },
++	{ CCI_REG8(0x3b71), 0xcd }, { CCI_REG8(0x3b72), 0xcd },
++	{ CCI_REG8(0x3b73), 0xcd }, { CCI_REG8(0x3b74), 0xcd },
++	{ CCI_REG8(0x3b75), 0xcd }, { CCI_REG8(0x3b76), 0xcd },
++	{ CCI_REG8(0x3b77), 0xcd }, { CCI_REG8(0x3b78), 0xcd },
++	{ CCI_REG8(0x3b79), 0xcd }, { CCI_REG8(0x3b7a), 0xcd },
++	{ CCI_REG8(0x3b7b), 0xcd }, { CCI_REG8(0x3b7c), 0xcd },
++	{ CCI_REG8(0x3b7d), 0xcd }, { CCI_REG8(0x3b7e), 0xcd },
++	{ CCI_REG8(0x3b7f), 0xcd }, { CCI_REG8(0x3b80), 0xcd },
++	{ CCI_REG8(0x3b81), 0xcd }, { CCI_REG8(0x3b82), 0xcd },
++	{ CCI_REG8(0x3b83), 0xcd }, { CCI_REG8(0x3b84), 0xcd },
++	{ CCI_REG8(0x3b85), 0xcd }, { CCI_REG8(0x3b86), 0xcd },
++	{ CCI_REG8(0x3b87), 0xcd }, { CCI_REG8(0x3b88), 0xcd },
++	{ CCI_REG8(0x3b89), 0xcd }, { CCI_REG8(0x3b8a), 0xcd },
++	{ CCI_REG8(0x3b8b), 0xcd }, { CCI_REG8(0x3b8c), 0xcd },
++	{ CCI_REG8(0x3b8d), 0xcd }, { CCI_REG8(0x3b8e), 0xcd },
++	{ CCI_REG8(0x3b8f), 0xcd }, { CCI_REG8(0x3b90), 0xcd },
++	{ CCI_REG8(0x3b91), 0xcd }, { CCI_REG8(0x3b92), 0xcd },
++	{ CCI_REG8(0x3b93), 0xcd }, { CCI_REG8(0x3b94), 0xcd },
++	{ CCI_REG8(0x3b95), 0xcd }, { CCI_REG8(0x3b96), 0xcd },
++	{ CCI_REG8(0x3b97), 0xcd }, { CCI_REG8(0x3b98), 0xcd },
++	{ CCI_REG8(0x3b99), 0xcd }, { CCI_REG8(0x3b9a), 0xcd },
++	{ CCI_REG8(0x3b9b), 0xcd }, { CCI_REG8(0x3b9c), 0xcd },
++	{ CCI_REG8(0x3b9d), 0xcd }, { CCI_REG8(0x3b9e), 0xcd },
++	{ CCI_REG8(0x3b9f), 0xcd }, { CCI_REG8(0x3ba0), 0xcd },
++	{ CCI_REG8(0x3ba1), 0xcd }, { CCI_REG8(0x3ba2), 0xcd },
++	{ CCI_REG8(0x3ba3), 0xcd }, { CCI_REG8(0x3ba4), 0xcd },
++	{ CCI_REG8(0x3ba5), 0xcd }, { CCI_REG8(0x3ba6), 0xcd },
++	{ CCI_REG8(0x3ba7), 0xcd }, { CCI_REG8(0x3ba8), 0xcd },
++	{ CCI_REG8(0x3ba9), 0xcd }, { CCI_REG8(0x3baa), 0xcd },
++	{ CCI_REG8(0x3bab), 0xcd }, { CCI_REG8(0x3bac), 0xcd },
++	{ CCI_REG8(0x3bad), 0xcd }, { CCI_REG8(0x3bae), 0xcd },
++	{ CCI_REG8(0x3baf), 0xcd }, { CCI_REG8(0x3bb0), 0xcd },
++	{ CCI_REG8(0x3bb1), 0xcd }, { CCI_REG8(0x3bb2), 0xcd },
++	{ CCI_REG8(0x3bb3), 0xcd }, { CCI_REG8(0x3bb4), 0xcd },
++	{ CCI_REG8(0x3bb5), 0xcd }, { CCI_REG8(0x3bb6), 0xcd },
++	{ CCI_REG8(0x3bb7), 0xcd }, { CCI_REG8(0x3bb8), 0xcd },
++	{ CCI_REG8(0x3bb9), 0xcd }, { CCI_REG8(0x3bba), 0xcd },
++	{ CCI_REG8(0x3bbb), 0xcd }, { CCI_REG8(0x3bbc), 0xcd },
++	{ CCI_REG8(0x3bbd), 0xcd }, { CCI_REG8(0x3bbe), 0xcd },
++	{ CCI_REG8(0x3bbf), 0xcd }, { CCI_REG8(0x3bc0), 0xcd },
++	{ CCI_REG8(0x3bc1), 0xcd }, { CCI_REG8(0x3bc2), 0xcd },
++	{ CCI_REG8(0x3bc3), 0xcd }, { CCI_REG8(0x3bc4), 0xcd },
++	{ CCI_REG8(0x3bc5), 0xcd }, { CCI_REG8(0x3bc6), 0xcd },
++	{ CCI_REG8(0x3bc7), 0xcd }, { CCI_REG8(0x3bc8), 0xcd },
++	{ CCI_REG8(0x3bc9), 0xcd }, { CCI_REG8(0x3bca), 0xcd },
++	{ CCI_REG8(0x3bcb), 0xcd }, { CCI_REG8(0x3bcc), 0xcd },
++	{ CCI_REG8(0x3bcd), 0xcd }, { CCI_REG8(0x3bce), 0xcd },
++	{ CCI_REG8(0x3bcf), 0xcd }, { CCI_REG8(0x3bd0), 0xcd },
++	{ CCI_REG8(0x3bd1), 0xcd }, { CCI_REG8(0x3bd2), 0xcd },
++	{ CCI_REG8(0x3bd3), 0xcd }, { CCI_REG8(0x3bd4), 0xcd },
++	{ CCI_REG8(0x3bd5), 0xcd }, { CCI_REG8(0x3bd6), 0xcd },
++	{ CCI_REG8(0x3bd7), 0xcd }, { CCI_REG8(0x3bd8), 0xcd },
++	{ CCI_REG8(0x3bd9), 0xcd }, { CCI_REG8(0x3bda), 0xcd },
++	{ CCI_REG8(0x3bdb), 0xcd }, { CCI_REG8(0x3bdc), 0xcd },
++	{ CCI_REG8(0x3bdd), 0xcd }, { CCI_REG8(0x3bde), 0xcd },
++	{ CCI_REG8(0x3bdf), 0xcd }, { CCI_REG8(0x3be0), 0xcd },
++	{ CCI_REG8(0x3be1), 0xcd }, { CCI_REG8(0x3be2), 0xcd },
++	{ CCI_REG8(0x3be3), 0xcd }, { CCI_REG8(0x3be4), 0xcd },
++	{ CCI_REG8(0x3be5), 0xcd }, { CCI_REG8(0x3be6), 0xcd },
++	{ CCI_REG8(0x3be7), 0xcd }, { CCI_REG8(0x3be8), 0xcd },
++	{ CCI_REG8(0x3be9), 0xcd }, { CCI_REG8(0x3bea), 0xcd },
++	{ CCI_REG8(0x3beb), 0xcd }, { CCI_REG8(0x3bec), 0xcd },
++	{ CCI_REG8(0x3bed), 0xcd }, { CCI_REG8(0x3bee), 0xcd },
++	{ CCI_REG8(0x3bef), 0xcd }, { CCI_REG8(0x3bf0), 0xcd },
++	{ CCI_REG8(0x3bf1), 0xcd }, { CCI_REG8(0x3bf2), 0xcd },
++	{ CCI_REG8(0x3bf3), 0xcd }, { CCI_REG8(0x3bf4), 0xcd },
++	{ CCI_REG8(0x3bf5), 0xcd }, { CCI_REG8(0x3bf6), 0xcd },
++	{ CCI_REG8(0x3bf7), 0xcd }, { CCI_REG8(0x3bf8), 0xcd },
++	{ CCI_REG8(0x3bf9), 0xcd }, { CCI_REG8(0x3bfa), 0xcd },
++	{ CCI_REG8(0x3bfb), 0xcd }, { CCI_REG8(0x3bfc), 0xcd },
++	{ CCI_REG8(0x3bfd), 0xcd }, { CCI_REG8(0x3bfe), 0xcd },
++	{ CCI_REG8(0x3bff), 0xcd }, { CCI_REG8(0x3c00), 0xcd },
++	{ CCI_REG8(0x3c01), 0xcd }, { CCI_REG8(0x3c02), 0xcd },
++	{ CCI_REG8(0x3c03), 0xcd }, { CCI_REG8(0x3c04), 0xcd },
++	{ CCI_REG8(0x3c05), 0xcd }, { CCI_REG8(0x3c06), 0xcd },
++	{ CCI_REG8(0x3c07), 0xcd }, { CCI_REG8(0x3c08), 0xcd },
++	{ CCI_REG8(0x3c09), 0xcd }, { CCI_REG8(0x3c0a), 0xcd },
++	{ CCI_REG8(0x3c0b), 0xcd }, { CCI_REG8(0x3c0c), 0xcd },
++	{ CCI_REG8(0x3c0d), 0xcd }, { CCI_REG8(0x3c0e), 0xcd },
++	{ CCI_REG8(0x3c0f), 0xcd }, { CCI_REG8(0x3c10), 0xcd },
++	{ CCI_REG8(0x3c11), 0xcd }, { CCI_REG8(0x3c12), 0xcd },
++	{ CCI_REG8(0x3c13), 0xcd }, { CCI_REG8(0x3c14), 0xcd },
++	{ CCI_REG8(0x3c15), 0xcd }, { CCI_REG8(0x3c16), 0xcd },
++	{ CCI_REG8(0x3c17), 0xcd }, { CCI_REG8(0x3c18), 0xcd },
++	{ CCI_REG8(0x3c19), 0xcd }, { CCI_REG8(0x3c1a), 0xcd },
++	{ CCI_REG8(0x3c1b), 0xcd }, { CCI_REG8(0x3c1c), 0xcd },
++	{ CCI_REG8(0x3c1d), 0xcd }, { CCI_REG8(0x3c1e), 0xcd },
++	{ CCI_REG8(0x3c1f), 0xcd }, { CCI_REG8(0x3c20), 0xcd },
++	{ CCI_REG8(0x3c21), 0xcd }, { CCI_REG8(0x3c22), 0xcd },
++	{ CCI_REG8(0x3c23), 0xcd }, { CCI_REG8(0x3c24), 0xcd },
++	{ CCI_REG8(0x3c25), 0xcd }, { CCI_REG8(0x3c26), 0xcd },
++	{ CCI_REG8(0x3c27), 0xcd }, { CCI_REG8(0x3c28), 0xcd },
++	{ CCI_REG8(0x3c29), 0xcd }, { CCI_REG8(0x3c2a), 0xcd },
++	{ CCI_REG8(0x3c2b), 0xcd }, { CCI_REG8(0x3c2c), 0xcd },
++	{ CCI_REG8(0x3c2d), 0xcd }, { CCI_REG8(0x3c2e), 0xcd },
++	{ CCI_REG8(0x3c2f), 0xcd }, { CCI_REG8(0x3c30), 0xcd },
++	{ CCI_REG8(0x3c31), 0xcd }, { CCI_REG8(0x3c32), 0xcd },
++	{ CCI_REG8(0x3c33), 0xcd }, { CCI_REG8(0x3c34), 0xcd },
++	{ CCI_REG8(0x3c35), 0xcd }, { CCI_REG8(0x3c36), 0xcd },
++	{ CCI_REG8(0x3c37), 0xcd }, { CCI_REG8(0x3c38), 0xcd },
++	{ CCI_REG8(0x3c39), 0xcd }, { CCI_REG8(0x3c3a), 0xcd },
++	{ CCI_REG8(0x3c3b), 0xcd }, { CCI_REG8(0x3c3c), 0xcd },
++	{ CCI_REG8(0x3c3d), 0xcd }, { CCI_REG8(0x3c3e), 0xcd },
++	{ CCI_REG8(0x3c3f), 0xcd }, { CCI_REG8(0x3c40), 0xcd },
++	{ CCI_REG8(0x3c41), 0xcd }, { CCI_REG8(0x3c42), 0xcd },
++	{ CCI_REG8(0x3c43), 0xcd }, { CCI_REG8(0x3c44), 0xcd },
++	{ CCI_REG8(0x3c45), 0xcd }, { CCI_REG8(0x3c46), 0xcd },
++	{ CCI_REG8(0x3c47), 0xcd }, { CCI_REG8(0x3c48), 0xcd },
++	{ CCI_REG8(0x3c49), 0xcd }, { CCI_REG8(0x3c4a), 0xcd },
++	{ CCI_REG8(0x3c4b), 0xcd }, { CCI_REG8(0x3c4c), 0xcd },
++	{ CCI_REG8(0x3c4d), 0xcd }, { CCI_REG8(0x3c4e), 0xcd },
++	{ CCI_REG8(0x3c4f), 0xcd }, { CCI_REG8(0x3c50), 0xcd },
++	{ CCI_REG8(0x3c51), 0xcd }, { CCI_REG8(0x3c52), 0xcd },
++	{ CCI_REG8(0x3c53), 0xcd }, { CCI_REG8(0x3c54), 0xcd },
++	{ CCI_REG8(0x3c55), 0xcd }, { CCI_REG8(0x3c56), 0xcd },
++	{ CCI_REG8(0x3c57), 0xcd }, { CCI_REG8(0x3c58), 0xcd },
++	{ CCI_REG8(0x3c59), 0xcd }, { CCI_REG8(0x3c5a), 0xcd },
++	{ CCI_REG8(0x3c5b), 0xcd }, { CCI_REG8(0x3c5c), 0xcd },
++	{ CCI_REG8(0x3c5d), 0xcd }, { CCI_REG8(0x3c5e), 0xcd },
++	{ CCI_REG8(0x3c5f), 0xcd }, { CCI_REG8(0x3c60), 0xcd },
++	{ CCI_REG8(0x3c61), 0xcd }, { CCI_REG8(0x3c62), 0xcd },
++	{ CCI_REG8(0x3c63), 0xcd }, { CCI_REG8(0x3c64), 0xcd },
++	{ CCI_REG8(0x3c65), 0xcd }, { CCI_REG8(0x3c66), 0xcd },
++	{ CCI_REG8(0x3c67), 0xcd }, { CCI_REG8(0x3c68), 0xcd },
++	{ CCI_REG8(0x3c69), 0xcd }, { CCI_REG8(0x3c6a), 0xcd },
++	{ CCI_REG8(0x3c6b), 0xcd }, { CCI_REG8(0x3c6c), 0xcd },
++	{ CCI_REG8(0x3c6d), 0xcd }, { CCI_REG8(0x3c6e), 0xcd },
++	{ CCI_REG8(0x3c6f), 0xcd }, { CCI_REG8(0x3c70), 0xcd },
++	{ CCI_REG8(0x3c71), 0xcd }, { CCI_REG8(0x3c72), 0xcd },
++	{ CCI_REG8(0x3c73), 0xcd }, { CCI_REG8(0x3c74), 0xcd },
++	{ CCI_REG8(0x3c75), 0xcd }, { CCI_REG8(0x3c76), 0xcd },
++	{ CCI_REG8(0x3c77), 0xcd }, { CCI_REG8(0x3c78), 0xcd },
++	{ CCI_REG8(0x3c79), 0xcd }, { CCI_REG8(0x3c7a), 0xcd },
++	{ CCI_REG8(0x3c7b), 0xcd }, { CCI_REG8(0x3c7c), 0xcd },
++	{ CCI_REG8(0x3c7d), 0xcd }, { CCI_REG8(0x3c7e), 0xcd },
++	{ CCI_REG8(0x3c7f), 0xcd }, { CCI_REG8(0x3c80), 0xcd },
++	{ CCI_REG8(0x3c81), 0xcd }, { CCI_REG8(0x3c82), 0xcd },
++	{ CCI_REG8(0x3c83), 0xcd }, { CCI_REG8(0x3c84), 0xcd },
++	{ CCI_REG8(0x3c85), 0xcd }, { CCI_REG8(0x3c86), 0xcd },
++	{ CCI_REG8(0x3c87), 0xcd }, { CCI_REG8(0x3c88), 0xcd },
++	{ CCI_REG8(0x3c89), 0xcd }, { CCI_REG8(0x3c8a), 0xcd },
++	{ CCI_REG8(0x3c8b), 0xcd }, { CCI_REG8(0x3c8c), 0xcd },
++	{ CCI_REG8(0x3c8d), 0xcd }, { CCI_REG8(0x3c8e), 0xcd },
++	{ CCI_REG8(0x3c8f), 0xcd }, { CCI_REG8(0x3c90), 0xcd },
++	{ CCI_REG8(0x3c91), 0xcd }, { CCI_REG8(0x3c92), 0xcd },
++	{ CCI_REG8(0x3c93), 0xcd }, { CCI_REG8(0x3c94), 0xcd },
++	{ CCI_REG8(0x3c95), 0xcd }, { CCI_REG8(0x3c96), 0xcd },
++	{ CCI_REG8(0x3c97), 0xcd }, { CCI_REG8(0x3c98), 0xcd },
++	{ CCI_REG8(0x3c99), 0xcd }, { CCI_REG8(0x3c9a), 0xcd },
++	{ CCI_REG8(0x3c9b), 0xcd }, { CCI_REG8(0x3c9c), 0xcd },
++	{ CCI_REG8(0x3c9d), 0xcd }, { CCI_REG8(0x3c9e), 0xcd },
++	{ CCI_REG8(0x3c9f), 0xcd }, { CCI_REG8(0x3ca0), 0xcd },
++	{ CCI_REG8(0x3ca1), 0xcd }, { CCI_REG8(0x3ca2), 0xcd },
++	{ CCI_REG8(0x3ca3), 0xcd }, { CCI_REG8(0x3ca4), 0xcd },
++	{ CCI_REG8(0x3ca5), 0xcd }, { CCI_REG8(0x3ca6), 0xcd },
++	{ CCI_REG8(0x3ca7), 0xcd }, { CCI_REG8(0x3ca8), 0xcd },
++	{ CCI_REG8(0x3ca9), 0xcd }, { CCI_REG8(0x3caa), 0xcd },
++	{ CCI_REG8(0x3cab), 0xcd }, { CCI_REG8(0x3cac), 0xcd },
++	{ CCI_REG8(0x3cad), 0xcd }, { CCI_REG8(0x3cae), 0xcd },
++	{ CCI_REG8(0x3caf), 0xcd }, { CCI_REG8(0x3cb0), 0xcd },
++	{ CCI_REG8(0x3cb1), 0x40 }, { CCI_REG8(0x3cb2), 0x40 },
++	{ CCI_REG8(0x3cb3), 0x40 }, { CCI_REG8(0x3cb4), 0x40 },
++	{ CCI_REG8(0x3cb5), 0x40 }, { CCI_REG8(0x3cb6), 0x40 },
++	{ CCI_REG8(0x3cb7), 0x40 }, { CCI_REG8(0x3cb8), 0x40 },
++	{ CCI_REG8(0x3cb9), 0x40 }, { CCI_REG8(0x3cba), 0x40 },
++	{ CCI_REG8(0x3cbb), 0x40 }, { CCI_REG8(0x3cbc), 0x40 },
++	{ CCI_REG8(0x3cbd), 0x40 }, { CCI_REG8(0x3cbe), 0x40 },
++	{ CCI_REG8(0x3cbf), 0x40 }, { CCI_REG8(0x3cc0), 0x40 },
++	{ CCI_REG8(0x3cc1), 0x40 }, { CCI_REG8(0x3cc2), 0x40 },
++	{ CCI_REG8(0x3cc3), 0x40 }, { CCI_REG8(0x3cc4), 0x40 },
++	{ CCI_REG8(0x3cc5), 0x40 }, { CCI_REG8(0x3cc6), 0x40 },
++	{ CCI_REG8(0x3cc7), 0x40 }, { CCI_REG8(0x3cc8), 0x40 },
++	{ CCI_REG8(0x3cc9), 0x40 }, { CCI_REG8(0x3cca), 0x40 },
++	{ CCI_REG8(0x3ccb), 0x40 }, { CCI_REG8(0x3ccc), 0x40 },
++	{ CCI_REG8(0x3ccd), 0x40 }, { CCI_REG8(0x3cce), 0x40 },
++	{ CCI_REG8(0x3ccf), 0x40 }, { CCI_REG8(0x3cd0), 0x40 },
++	{ CCI_REG8(0x3cd1), 0x40 }, { CCI_REG8(0x3cd2), 0x40 },
++	{ CCI_REG8(0x3cd3), 0x40 }, { CCI_REG8(0x3cd4), 0x40 },
++	{ CCI_REG8(0x3cd5), 0x40 }, { CCI_REG8(0x3cd6), 0x40 },
++	{ CCI_REG8(0x3cd7), 0x40 }, { CCI_REG8(0x3cd8), 0x40 },
++	{ CCI_REG8(0x3cd9), 0x40 }, { CCI_REG8(0x3cda), 0x40 },
++	{ CCI_REG8(0x3cdb), 0x40 }, { CCI_REG8(0x3cdc), 0x40 },
++	{ CCI_REG8(0x3cdd), 0x40 }, { CCI_REG8(0x3cde), 0x40 },
++	{ CCI_REG8(0x3cdf), 0x40 }, { CCI_REG8(0x3ce0), 0x40 },
++	{ CCI_REG8(0x3ce1), 0x40 }, { CCI_REG8(0x3ce2), 0x40 },
++	{ CCI_REG8(0x3ce3), 0x40 }, { CCI_REG8(0x3ce4), 0x40 },
++	{ CCI_REG8(0x3ce5), 0x40 }, { CCI_REG8(0x3ce6), 0x40 },
++	{ CCI_REG8(0x3ce7), 0x40 }, { CCI_REG8(0x3ce8), 0x40 },
++	{ CCI_REG8(0x3ce9), 0x40 }, { CCI_REG8(0x3cea), 0x40 },
++	{ CCI_REG8(0x3ceb), 0x40 }, { CCI_REG8(0x3cec), 0x40 },
++	{ CCI_REG8(0x3ced), 0x40 }, { CCI_REG8(0x3cee), 0x40 },
++	{ CCI_REG8(0x3cef), 0x40 }, { CCI_REG8(0x3cf0), 0x40 },
++	{ CCI_REG8(0x3cf1), 0x40 }, { CCI_REG8(0x3cf2), 0x40 },
++	{ CCI_REG8(0x3cf3), 0x40 }, { CCI_REG8(0x3cf4), 0x40 },
++	{ CCI_REG8(0x3cf5), 0x40 }, { CCI_REG8(0x3cf6), 0x40 },
++	{ CCI_REG8(0x3cf7), 0x40 }, { CCI_REG8(0x3cf8), 0x40 },
++	{ CCI_REG8(0x3cf9), 0x40 }, { CCI_REG8(0x3cfa), 0x40 },
++	{ CCI_REG8(0x3cfb), 0x40 }, { CCI_REG8(0x3cfc), 0x40 },
++	{ CCI_REG8(0x3cfd), 0x40 }, { CCI_REG8(0x3cfe), 0x40 },
++	{ CCI_REG8(0x3cff), 0x40 }, { CCI_REG8(0x3d00), 0x40 },
++	{ CCI_REG8(0x3d01), 0x40 }, { CCI_REG8(0x3d02), 0x40 },
++	{ CCI_REG8(0x3d03), 0x40 }, { CCI_REG8(0x3d04), 0x40 },
++	{ CCI_REG8(0x3d05), 0x40 }, { CCI_REG8(0x3d06), 0x40 },
++	{ CCI_REG8(0x3d07), 0x40 }, { CCI_REG8(0x3d08), 0x40 },
++	{ CCI_REG8(0x3d09), 0x40 }, { CCI_REG8(0x3d0a), 0x40 },
++	{ CCI_REG8(0x3d0b), 0xcd }, { CCI_REG8(0x3d0c), 0xcd },
++	{ CCI_REG8(0x3d0d), 0xcd }, { CCI_REG8(0x3d0e), 0xcd },
++	{ CCI_REG8(0x3d0f), 0xcd }, { CCI_REG8(0x3d10), 0xcd },
++	{ CCI_REG8(0x3d11), 0xcd }, { CCI_REG8(0x3d12), 0xcd },
++	{ CCI_REG8(0x3d13), 0xcd }, { CCI_REG8(0x3d14), 0xcd },
++	{ CCI_REG8(0x3d15), 0xcd }, { CCI_REG8(0x3d16), 0xcd },
++	{ CCI_REG8(0x3d17), 0xcd }, { CCI_REG8(0x3d18), 0xcd },
++	{ CCI_REG8(0x3d19), 0xcd }, { CCI_REG8(0x3d1a), 0xcd },
++	{ CCI_REG8(0x3d1b), 0xcd }, { CCI_REG8(0x3d1c), 0xcd },
++	{ CCI_REG8(0x3d1d), 0xcd }, { CCI_REG8(0x3d1e), 0xcd },
++	{ CCI_REG8(0x3d1f), 0xcd }, { CCI_REG8(0x3d20), 0xcd },
++	{ CCI_REG8(0x3d21), 0xcd }, { CCI_REG8(0x3d22), 0xcd },
++	{ CCI_REG8(0x3d23), 0xcd }, { CCI_REG8(0x3d24), 0xcd },
++	{ CCI_REG8(0x3d25), 0xcd }, { CCI_REG8(0x3d26), 0xcd },
++	{ CCI_REG8(0x3d27), 0xcd }, { CCI_REG8(0x3d28), 0xcd },
++	{ CCI_REG8(0x3d29), 0xcd }, { CCI_REG8(0x3d2a), 0xcd },
++	{ CCI_REG8(0x3d2b), 0xcd }, { CCI_REG8(0x3d2c), 0xcd },
++	{ CCI_REG8(0x3d2d), 0xcd }, { CCI_REG8(0x3d2e), 0xcd },
++	{ CCI_REG8(0x3d2f), 0xcd }, { CCI_REG8(0x3d30), 0xcd },
++	{ CCI_REG8(0x3d31), 0xcd }, { CCI_REG8(0x3d32), 0xcd },
++	{ CCI_REG8(0x3d33), 0xcd }, { CCI_REG8(0x3d34), 0xcd },
++	{ CCI_REG8(0x3d35), 0xcd }, { CCI_REG8(0x3d36), 0xcd },
++	{ CCI_REG8(0x3d37), 0xcd }, { CCI_REG8(0x3d38), 0xcd },
++	{ CCI_REG8(0x3d39), 0xcd }, { CCI_REG8(0x3d3a), 0xcd },
++	{ CCI_REG8(0x3d3b), 0xcd }, { CCI_REG8(0x3d3c), 0xcd },
++	{ CCI_REG8(0x3d3d), 0xcd }, { CCI_REG8(0x3d3e), 0xcd },
++	{ CCI_REG8(0x3d3f), 0xcd }, { CCI_REG8(0x3d40), 0xcd },
++	{ CCI_REG8(0x3d41), 0xcd }, { CCI_REG8(0x3d42), 0xcd },
++	{ CCI_REG8(0x3d43), 0xcd }, { CCI_REG8(0x3d44), 0xcd },
++	{ CCI_REG8(0x3d45), 0xcd }, { CCI_REG8(0x3d46), 0xcd },
++	{ CCI_REG8(0x3d47), 0xcd }, { CCI_REG8(0x3d48), 0xcd },
++	{ CCI_REG8(0x3d49), 0xcd }, { CCI_REG8(0x3d4a), 0xcd },
++	{ CCI_REG8(0x3d4b), 0xcd }, { CCI_REG8(0x3d4c), 0xcd },
++	{ CCI_REG8(0x3d4d), 0xcd }, { CCI_REG8(0x3d4e), 0xcd },
++	{ CCI_REG8(0x3d4f), 0xcd }, { CCI_REG8(0x3d50), 0xcd },
++	{ CCI_REG8(0x3d51), 0xcd }, { CCI_REG8(0x3d52), 0xcd },
++	{ CCI_REG8(0x3d53), 0xcd }, { CCI_REG8(0x3d54), 0xcd },
++	{ CCI_REG8(0x3d55), 0xcd }, { CCI_REG8(0x3d56), 0xcd },
++	{ CCI_REG8(0x3d57), 0xcd }, { CCI_REG8(0x3d58), 0xcd },
++	{ CCI_REG8(0x3d59), 0xcd }, { CCI_REG8(0x3d5a), 0xcd },
++	{ CCI_REG8(0x3d5b), 0xcd }, { CCI_REG8(0x3d5c), 0xcd },
++	{ CCI_REG8(0x3d5d), 0xcd }, { CCI_REG8(0x3d5e), 0xcd },
++	{ CCI_REG8(0x3d5f), 0xcd }, { CCI_REG8(0x3d60), 0xcd },
++	{ CCI_REG8(0x3d61), 0xcd }, { CCI_REG8(0x3d62), 0xcd },
++	{ CCI_REG8(0x3d63), 0xcd }, { CCI_REG8(0x3d64), 0xcd },
++	{ CCI_REG8(0x3d65), 0x40 }, { CCI_REG8(0x3d66), 0x40 },
++	{ CCI_REG8(0x3d67), 0x40 }, { CCI_REG8(0x3d68), 0x40 },
++	{ CCI_REG8(0x3d69), 0x40 }, { CCI_REG8(0x3d6a), 0x40 },
++	{ CCI_REG8(0x3d6b), 0x40 }, { CCI_REG8(0x3d6c), 0x40 },
++	{ CCI_REG8(0x3d6d), 0x40 }, { CCI_REG8(0x3d6e), 0x40 },
++	{ CCI_REG8(0x3d6f), 0x40 }, { CCI_REG8(0x3d70), 0x40 },
++	{ CCI_REG8(0x3d71), 0x40 }, { CCI_REG8(0x3d72), 0x40 },
++	{ CCI_REG8(0x3d73), 0x40 }, { CCI_REG8(0x3d74), 0x40 },
++	{ CCI_REG8(0x3d75), 0x40 }, { CCI_REG8(0x3d76), 0x40 },
++	{ CCI_REG8(0x3d77), 0x40 }, { CCI_REG8(0x3d78), 0x40 },
++	{ CCI_REG8(0x3d79), 0x40 }, { CCI_REG8(0x3d7a), 0x40 },
++	{ CCI_REG8(0x3d7b), 0x40 }, { CCI_REG8(0x3d7c), 0x40 },
++	{ CCI_REG8(0x3d7d), 0x40 }, { CCI_REG8(0x3d7e), 0x40 },
++	{ CCI_REG8(0x3d7f), 0x40 }, { CCI_REG8(0x3d80), 0x40 },
++	{ CCI_REG8(0x3d81), 0x40 }, { CCI_REG8(0x3d82), 0x40 },
++	{ CCI_REG8(0x3d83), 0x40 }, { CCI_REG8(0x3d84), 0x40 },
++	{ CCI_REG8(0x3d85), 0x40 }, { CCI_REG8(0x3d86), 0x40 },
++	{ CCI_REG8(0x3d87), 0x40 }, { CCI_REG8(0x3d88), 0x40 },
++	{ CCI_REG8(0x3d89), 0x40 }, { CCI_REG8(0x3d8a), 0x40 },
++	{ CCI_REG8(0x3d8b), 0x40 }, { CCI_REG8(0x3d8c), 0x40 },
++	{ CCI_REG8(0x3d8d), 0x40 }, { CCI_REG8(0x3d8e), 0x40 },
++	{ CCI_REG8(0x3d8f), 0x40 }, { CCI_REG8(0x3d90), 0x40 },
++	{ CCI_REG8(0x3d91), 0x40 }, { CCI_REG8(0x3d92), 0x40 },
++	{ CCI_REG8(0x3d93), 0x40 }, { CCI_REG8(0x3d94), 0x40 },
++	{ CCI_REG8(0x3d95), 0x40 }, { CCI_REG8(0x3d96), 0x40 },
++	{ CCI_REG8(0x3d97), 0x40 }, { CCI_REG8(0x3d98), 0x40 },
++	{ CCI_REG8(0x3d99), 0x40 }, { CCI_REG8(0x3d9a), 0x40 },
++	{ CCI_REG8(0x3d9b), 0x40 }, { CCI_REG8(0x3d9c), 0x40 },
++	{ CCI_REG8(0x3d9d), 0x40 }, { CCI_REG8(0x3d9e), 0x40 },
++	{ CCI_REG8(0x3d9f), 0x40 }, { CCI_REG8(0x3da0), 0x40 },
++	{ CCI_REG8(0x3da1), 0x40 }, { CCI_REG8(0x3da2), 0x40 },
++	{ CCI_REG8(0x3da3), 0x40 }, { CCI_REG8(0x3da4), 0x40 },
++	{ CCI_REG8(0x3da5), 0x40 }, { CCI_REG8(0x3da6), 0x40 },
++	{ CCI_REG8(0x3da7), 0x40 }, { CCI_REG8(0x3da8), 0x40 },
++	{ CCI_REG8(0x3da9), 0x40 }, { CCI_REG8(0x3daa), 0x40 },
++	{ CCI_REG8(0x3dab), 0x40 }, { CCI_REG8(0x3dac), 0x40 },
++	{ CCI_REG8(0x3dad), 0x40 }, { CCI_REG8(0x3dae), 0x40 },
++	{ CCI_REG8(0x3daf), 0x40 }, { CCI_REG8(0x3db0), 0x40 },
++	{ CCI_REG8(0x3db1), 0x40 }, { CCI_REG8(0x3db2), 0x40 },
++	{ CCI_REG8(0x3db3), 0x40 }, { CCI_REG8(0x3db4), 0x40 },
++	{ CCI_REG8(0x3db5), 0x40 }, { CCI_REG8(0x3db6), 0x40 },
++	{ CCI_REG8(0x3db7), 0x40 }, { CCI_REG8(0x3db8), 0x40 },
++	{ CCI_REG8(0x3db9), 0x40 }, { CCI_REG8(0x3dba), 0x40 },
++	{ CCI_REG8(0x3dbb), 0x40 }, { CCI_REG8(0x3dbc), 0x40 },
++	{ CCI_REG8(0x3dbd), 0x40 }, { CCI_REG8(0x3dbe), 0x40 },
++	{ CCI_REG8(0x3dbf), 0xcd }, { CCI_REG8(0x3dc0), 0xcd },
++	{ CCI_REG8(0x3dc1), 0xcd }, { CCI_REG8(0x3dc2), 0xcd },
++	{ CCI_REG8(0x3dc3), 0xcd }, { CCI_REG8(0x3dc4), 0xcd },
++	{ CCI_REG8(0x3dc5), 0xcd }, { CCI_REG8(0x3dc6), 0xcd },
++	{ CCI_REG8(0x3dc7), 0xcd }, { CCI_REG8(0x3dc8), 0xcd },
++	{ CCI_REG8(0x3dc9), 0xcd }, { CCI_REG8(0x3dca), 0xcd },
++	{ CCI_REG8(0x3dcb), 0xcd }, { CCI_REG8(0x3dcc), 0xcd },
++	{ CCI_REG8(0x3dcd), 0xcd }, { CCI_REG8(0x3dce), 0xcd },
++	{ CCI_REG8(0x3dcf), 0xcd }, { CCI_REG8(0x3dd0), 0xcd },
++	{ CCI_REG8(0x3dd1), 0xcd }, { CCI_REG8(0x3dd2), 0xcd },
++	{ CCI_REG8(0x3dd3), 0xcd }, { CCI_REG8(0x3dd4), 0xcd },
++	{ CCI_REG8(0x3dd5), 0xcd }, { CCI_REG8(0x3dd6), 0xcd },
++	{ CCI_REG8(0x3dd7), 0xcd }, { CCI_REG8(0x3dd8), 0xcd },
++	{ CCI_REG8(0x3dd9), 0xcd }, { CCI_REG8(0x3dda), 0xcd },
++	{ CCI_REG8(0x3ddb), 0xcd }, { CCI_REG8(0x3ddc), 0xcd },
++	{ CCI_REG8(0x3ddd), 0xcd }, { CCI_REG8(0x3dde), 0xcd },
++	{ CCI_REG8(0x3ddf), 0xcd }, { CCI_REG8(0x3de0), 0xcd },
++	{ CCI_REG8(0x3de1), 0xcd }, { CCI_REG8(0x3de2), 0xcd },
++	{ CCI_REG8(0x3de3), 0xcd }, { CCI_REG8(0x3de4), 0xcd },
++	{ CCI_REG8(0x3de5), 0xcd }, { CCI_REG8(0x3de6), 0xcd },
++	{ CCI_REG8(0x3de7), 0xcd }, { CCI_REG8(0x3de8), 0xcd },
++	{ CCI_REG8(0x3de9), 0xcd }, { CCI_REG8(0x3dea), 0xcd },
++	{ CCI_REG8(0x3deb), 0xcd }, { CCI_REG8(0x3dec), 0xcd },
++	{ CCI_REG8(0x3ded), 0xcd }, { CCI_REG8(0x3dee), 0xcd },
++	{ CCI_REG8(0x3def), 0xcd }, { CCI_REG8(0x3df0), 0xcd },
++	{ CCI_REG8(0x3df1), 0xcd }, { CCI_REG8(0x3df2), 0xcd },
++	{ CCI_REG8(0x3df3), 0xcd }, { CCI_REG8(0x3df4), 0xcd },
++	{ CCI_REG8(0x3df5), 0xcd }, { CCI_REG8(0x3df6), 0xcd },
++	{ CCI_REG8(0x3df7), 0xcd }, { CCI_REG8(0x3df8), 0xcd },
++	{ CCI_REG8(0x3df9), 0xcd }, { CCI_REG8(0x3dfa), 0xcd },
++	{ CCI_REG8(0x3dfb), 0xcd }, { CCI_REG8(0x3dfc), 0xcd },
++	{ CCI_REG8(0x3dfd), 0xcd }, { CCI_REG8(0x3dfe), 0xcd },
++	{ CCI_REG8(0x3dff), 0xcd }, { CCI_REG8(0x3e00), 0xcd },
++	{ CCI_REG8(0x3e01), 0xcd }, { CCI_REG8(0x3e02), 0xcd },
++	{ CCI_REG8(0x3e03), 0xcd }, { CCI_REG8(0x3e04), 0xcd },
++	{ CCI_REG8(0x3e05), 0xcd }, { CCI_REG8(0x3e06), 0xcd },
++	{ CCI_REG8(0x3e07), 0xcd }, { CCI_REG8(0x3e08), 0xcd },
++	{ CCI_REG8(0x3e09), 0xcd }, { CCI_REG8(0x3e0a), 0xcd },
++	{ CCI_REG8(0x3e0b), 0xcd }, { CCI_REG8(0x3e0c), 0xcd },
++	{ CCI_REG8(0x3e0d), 0xcd }, { CCI_REG8(0x3e0e), 0xcd },
++	{ CCI_REG8(0x3e0f), 0xcd }, { CCI_REG8(0x3e10), 0xcd },
++	{ CCI_REG8(0x3e11), 0xcd }, { CCI_REG8(0x3e12), 0xcd },
++	{ CCI_REG8(0x3e13), 0xcd }, { CCI_REG8(0x3e14), 0xcd },
++	{ CCI_REG8(0x3e15), 0xcd }, { CCI_REG8(0x3e16), 0xcd },
++	{ CCI_REG8(0x3e17), 0xcd }, { CCI_REG8(0x3e18), 0xcd },
++	{ CCI_REG8(0x3e19), 0xcd }, { CCI_REG8(0x3e1a), 0xcd },
++	{ CCI_REG8(0x3e1b), 0xcd }, { CCI_REG8(0x3e1c), 0xcd },
++	{ CCI_REG8(0x3e1d), 0xcd }, { CCI_REG8(0x3e1e), 0xcd },
++	{ CCI_REG8(0x3e1f), 0xcd }, { CCI_REG8(0x3e20), 0xcd },
++	{ CCI_REG8(0x3e21), 0xcd }, { CCI_REG8(0x3e22), 0xcd },
++	{ CCI_REG8(0x3e23), 0xcd }, { CCI_REG8(0x3e24), 0xcd },
++	{ CCI_REG8(0x3e25), 0xcd }, { CCI_REG8(0x3e26), 0xcd },
++	{ CCI_REG8(0x3e27), 0xcd }, { CCI_REG8(0x3e28), 0xcd },
++	{ CCI_REG8(0x3e29), 0xcd }, { CCI_REG8(0x3e2a), 0xcd },
++	{ CCI_REG8(0x3e2b), 0xcd }, { CCI_REG8(0x3e2c), 0xcd },
++	{ CCI_REG8(0x3e2d), 0xcd }, { CCI_REG8(0x3e2e), 0xcd },
++	{ CCI_REG8(0x3e2f), 0xcd }, { CCI_REG8(0x3e30), 0xcd },
++	{ CCI_REG8(0x3e31), 0xcd }, { CCI_REG8(0x3e32), 0xcd },
++	{ CCI_REG8(0x3e33), 0xcd }, { CCI_REG8(0x3e34), 0xcd },
++	{ CCI_REG8(0x3e35), 0xcd }, { CCI_REG8(0x3e36), 0xcd },
++	{ CCI_REG8(0x3e37), 0xcd }, { CCI_REG8(0x3e38), 0xcd },
++	{ CCI_REG8(0x3e39), 0xcd }, { CCI_REG8(0x3e3a), 0xcd },
++	{ CCI_REG8(0x3e3b), 0xcd }, { CCI_REG8(0x3e3c), 0xcd },
++	{ CCI_REG8(0x3e3d), 0xcd }, { CCI_REG8(0x3e3e), 0xcd },
++	{ CCI_REG8(0x3e3f), 0xcd }, { CCI_REG8(0x3e40), 0xcd },
++	{ CCI_REG8(0x3e41), 0xcd }, { CCI_REG8(0x3e42), 0xcd },
++	{ CCI_REG8(0x3e43), 0xcd }, { CCI_REG8(0x3e44), 0xcd },
++	{ CCI_REG8(0x3e45), 0xcd }, { CCI_REG8(0x3e46), 0xcd },
++	{ CCI_REG8(0x3e47), 0xcd }, { CCI_REG8(0x3e48), 0xcd },
++	{ CCI_REG8(0x3e49), 0xcd }, { CCI_REG8(0x3e4a), 0xcd },
++	{ CCI_REG8(0x3e4b), 0xcd }, { CCI_REG8(0x3e4c), 0xcd },
++	{ CCI_REG8(0x3e4d), 0xcd }, { CCI_REG8(0x3e4e), 0xcd },
++	{ CCI_REG8(0x3e4f), 0xcd }, { CCI_REG8(0x3e50), 0xcd },
++	{ CCI_REG8(0x3e51), 0xcd }, { CCI_REG8(0x3e52), 0xcd },
++	{ CCI_REG8(0x3e53), 0xcd }, { CCI_REG8(0x3e54), 0xcd },
++	{ CCI_REG8(0x3e55), 0xcd }, { CCI_REG8(0x3e56), 0xcd },
++	{ CCI_REG8(0x3e57), 0xcd }, { CCI_REG8(0x3e58), 0xcd },
++	{ CCI_REG8(0x3e59), 0xcd }, { CCI_REG8(0x3e5a), 0xcd },
++	{ CCI_REG8(0x3e5b), 0xcd }, { CCI_REG8(0x3e5c), 0xcd },
++	{ CCI_REG8(0x3e5d), 0xcd }, { CCI_REG8(0x3e5e), 0xcd },
++	{ CCI_REG8(0x3e5f), 0xcd }, { CCI_REG8(0x3e60), 0xcd },
++	{ CCI_REG8(0x3e61), 0xcd }, { CCI_REG8(0x3e62), 0xcd },
++	{ CCI_REG8(0x3e63), 0xcd }, { CCI_REG8(0x3e64), 0xcd },
++	{ CCI_REG8(0x3e65), 0xcd }, { CCI_REG8(0x3e66), 0xcd },
++	{ CCI_REG8(0x3e67), 0xcd }, { CCI_REG8(0x3e68), 0xcd },
++	{ CCI_REG8(0x3e69), 0xcd }, { CCI_REG8(0x3e6a), 0xcd },
++	{ CCI_REG8(0x3e6b), 0xcd }, { CCI_REG8(0x3e6c), 0xcd },
++	{ CCI_REG8(0x3e6d), 0xcd }, { CCI_REG8(0x3e6e), 0xcd },
++	{ CCI_REG8(0x3e6f), 0xcd }, { CCI_REG8(0x3e70), 0xcd },
++	{ CCI_REG8(0x3e71), 0xcd }, { CCI_REG8(0x3e72), 0xcd },
++	{ CCI_REG8(0x3e73), 0xcd }, { CCI_REG8(0x3e74), 0xcd },
++	{ CCI_REG8(0x3e75), 0xcd }, { CCI_REG8(0x3e76), 0xcd },
++	{ CCI_REG8(0x3e77), 0xcd }, { CCI_REG8(0x3e78), 0xcd },
++	{ CCI_REG8(0x3e79), 0xcd }, { CCI_REG8(0x3e7a), 0xcd },
++	{ CCI_REG8(0x3e7b), 0xcd }, { CCI_REG8(0x3e7c), 0xcd },
++	{ CCI_REG8(0x3e7d), 0xcd }, { CCI_REG8(0x3e7e), 0xcd },
++	{ CCI_REG8(0x3e7f), 0xcd }, { CCI_REG8(0x3e80), 0xcd },
++	{ CCI_REG8(0x3e81), 0xcd }, { CCI_REG8(0x3e82), 0xcd },
++	{ CCI_REG8(0x3e83), 0xcd }, { CCI_REG8(0x3e84), 0xcd },
++	{ CCI_REG8(0x3e85), 0xcd }, { CCI_REG8(0x3e86), 0xcd },
++	{ CCI_REG8(0x3e87), 0xcd }, { CCI_REG8(0x3e88), 0xcd },
++	{ CCI_REG8(0x3e89), 0xcd }, { CCI_REG8(0x3e8a), 0xcd },
++	{ CCI_REG8(0x3e8b), 0xcd }, { CCI_REG8(0x3e8c), 0xcd },
++	{ CCI_REG8(0x3e8d), 0xcd }, { CCI_REG8(0x3e8e), 0xcd },
++	{ CCI_REG8(0x3e8f), 0xcd }, { CCI_REG8(0x3e90), 0xcd },
++	{ CCI_REG8(0x3e91), 0xcd }, { CCI_REG8(0x3e92), 0xcd },
++	{ CCI_REG8(0x3e93), 0xcd }, { CCI_REG8(0x3e94), 0xcd },
++	{ CCI_REG8(0x3e95), 0xcd }, { CCI_REG8(0x3e96), 0xcd },
++	{ CCI_REG8(0x3e97), 0xcd }, { CCI_REG8(0x3e98), 0xcd },
++	{ CCI_REG8(0x3e99), 0xcd }, { CCI_REG8(0x3e9a), 0xcd },
++	{ CCI_REG8(0x3e9b), 0xcd }, { CCI_REG8(0x3e9c), 0xcd },
++	{ CCI_REG8(0x3e9d), 0xcd }, { CCI_REG8(0x3e9e), 0xcd },
++	{ CCI_REG8(0x3e9f), 0xcd }, { CCI_REG8(0xfff9), 0x06 },
++	{ CCI_REG8(0xc03f), 0x01 }, { CCI_REG8(0xc03e), 0x08 },
++	{ CCI_REG8(0xc02c), 0xff }, { CCI_REG8(0xc005), 0x06 },
++	{ CCI_REG8(0xc006), 0x30 }, { CCI_REG8(0xc007), 0xc0 },
++	{ CCI_REG8(0xc027), 0x01 }, { CCI_REG8(0x30c0), 0x05 },
++	{ CCI_REG8(0x30c1), 0x9f }, { CCI_REG8(0x30c2), 0x06 },
++	{ CCI_REG8(0x30c3), 0x5f }, { CCI_REG8(0x30c4), 0x80 },
++	{ CCI_REG8(0x30c5), 0x08 }, { CCI_REG8(0x30c6), 0x39 },
++	{ CCI_REG8(0x30c7), 0x00 }, { CCI_REG8(0xc046), 0x20 },
++	{ CCI_REG8(0xc043), 0x01 }, { CCI_REG8(0xc04b), 0x01 },
++	{ CCI_REG8(0x0102), 0x01 }, { CCI_REG8(0x0100), 0x00 },
++	{ CCI_REG8(0x0102), 0x00 }, { CCI_REG8(0x3015), 0xf0 },
++	{ CCI_REG8(0x3018), 0xf0 }, { CCI_REG8(0x301c), 0xf0 },
++	{ CCI_REG8(0x301d), 0xf6 }, { CCI_REG8(0x301e), 0xf1 }
++};
++
++static const struct cci_reg_sequence ov64a40_9248x6944[] = {
++	{ CCI_REG8(0x0305), 0x98 }, { CCI_REG8(0x0306), 0x04 },
++	{ CCI_REG8(0x0307), 0x01 }, { CCI_REG8(0x4837), 0x1a },
++	{ CCI_REG8(0x4888), 0x10 }, { CCI_REG8(0x4860), 0x00 },
++	{ CCI_REG8(0x4850), 0x43 }, { CCI_REG8(0x480C), 0x92 },
++	{ CCI_REG8(0x5001), 0x21 }
++};
++
++static const struct cci_reg_sequence ov64a40_8000x6000[] = {
++	{ CCI_REG8(0x0305), 0x98 }, { CCI_REG8(0x0306), 0x04 },
++	{ CCI_REG8(0x0307), 0x01 }, { CCI_REG8(0x4837), 0x1a },
++	{ CCI_REG8(0x4888), 0x10 }, { CCI_REG8(0x4860), 0x00 },
++	{ CCI_REG8(0x4850), 0x43 }, { CCI_REG8(0x480C), 0x92 },
++	{ CCI_REG8(0x5001), 0x21 }
++};
++
++static const struct cci_reg_sequence ov64a40_4624_3472[] = {
++	{ CCI_REG8(0x034b), 0x02 }, { CCI_REG8(0x3504), 0x08 },
++	{ CCI_REG8(0x360d), 0x82 }, { CCI_REG8(0x368a), 0x2e },
++	{ CCI_REG8(0x3712), 0x50 }, { CCI_REG8(0x3822), 0x00 },
++	{ CCI_REG8(0x3827), 0x40 }, { CCI_REG8(0x383d), 0x08 },
++	{ CCI_REG8(0x383f), 0x00 }, { CCI_REG8(0x384c), 0x02 },
++	{ CCI_REG8(0x384d), 0xba }, { CCI_REG8(0x3852), 0x00 },
++	{ CCI_REG8(0x3856), 0x08 }, { CCI_REG8(0x3857), 0x08 },
++	{ CCI_REG8(0x3858), 0x10 }, { CCI_REG8(0x3859), 0x10 },
++	{ CCI_REG8(0x4016), 0x0f }, { CCI_REG8(0x4018), 0x03 },
++	{ CCI_REG8(0x4504), 0x1e }, { CCI_REG8(0x4523), 0x41 },
++	{ CCI_REG8(0x45c0), 0x01 }, { CCI_REG8(0x4641), 0x12 },
++	{ CCI_REG8(0x4643), 0x0c }, { CCI_REG8(0x4915), 0x02 },
++	{ CCI_REG8(0x4916), 0x1d }, { CCI_REG8(0x4a15), 0x02 },
++	{ CCI_REG8(0x4a16), 0x1d }, { CCI_REG8(0x3703), 0x72 },
++	{ CCI_REG8(0x3709), 0xe6 }, { CCI_REG8(0x3a60), 0x68 },
++	{ CCI_REG8(0x3a6f), 0x68 }, { CCI_REG8(0x3a5e), 0xdc },
++	{ CCI_REG8(0x3a6d), 0xdc }, { CCI_REG8(0x3721), 0xc9 },
++	{ CCI_REG8(0x5250), 0x06 }, { CCI_REG8(0x527a), 0x00 },
++	{ CCI_REG8(0x527b), 0x65 }, { CCI_REG8(0x527c), 0x00 },
++	{ CCI_REG8(0x527d), 0x82 }, { CCI_REG8(0x5280), 0x24 },
++	{ CCI_REG8(0x5281), 0x40 }, { CCI_REG8(0x5282), 0x1b },
++	{ CCI_REG8(0x5283), 0x40 }, { CCI_REG8(0x5284), 0x24 },
++	{ CCI_REG8(0x5285), 0x40 }, { CCI_REG8(0x5286), 0x1b },
++	{ CCI_REG8(0x5287), 0x40 }, { CCI_REG8(0x5200), 0x24 },
++	{ CCI_REG8(0x5201), 0x40 }, { CCI_REG8(0x5202), 0x1b },
++	{ CCI_REG8(0x5203), 0x40 }, { CCI_REG8(0x481b), 0x35 },
++	{ CCI_REG8(0x4862), 0x25 }, { CCI_REG8(0x3400), 0x00 },
++	{ CCI_REG8(0x3421), 0x23 }, { CCI_REG8(0x3422), 0xfc },
++	{ CCI_REG8(0x3423), 0x07 }, { CCI_REG8(0x3424), 0x01 },
++	{ CCI_REG8(0x3425), 0x04 }, { CCI_REG8(0x3426), 0x50 },
++	{ CCI_REG8(0x3427), 0x55 }, { CCI_REG8(0x3428), 0x15 },
++	{ CCI_REG8(0x3429), 0x00 }, { CCI_REG8(0x3025), 0x03 },
++	{ CCI_REG8(0x5250), 0x06 }, { CCI_REG8(0x0305), 0x98 },
++	{ CCI_REG8(0x0306), 0x04 }, { CCI_REG8(0x0307), 0x01 },
++	{ CCI_REG8(0x4837), 0x1a }, { CCI_REG8(0x4888), 0x10 },
++	{ CCI_REG8(0x4860), 0x00 }, { CCI_REG8(0x4850), 0x43 },
++	{ CCI_REG8(0x480C), 0x92 }, { CCI_REG8(0x5001), 0x21 }
++};
++
++static const struct cci_reg_sequence ov64a40_3840x2160[] = {
++	{ CCI_REG8(0x034a), 0x05 }, { CCI_REG8(0x034b), 0x05 },
++	{ CCI_REG8(0x3504), 0x08 }, { CCI_REG8(0x360d), 0x82 },
++	{ CCI_REG8(0x368a), 0x2e }, { CCI_REG8(0x3712), 0x50 },
++	{ CCI_REG8(0x3822), 0x00 }, { CCI_REG8(0x3827), 0x40 },
++	{ CCI_REG8(0x383d), 0x08 }, { CCI_REG8(0x383f), 0x00 },
++	{ CCI_REG8(0x384c), 0x02 }, { CCI_REG8(0x384d), 0xba },
++	{ CCI_REG8(0x3852), 0x00 }, { CCI_REG8(0x3856), 0x08 },
++	{ CCI_REG8(0x3857), 0x08 }, { CCI_REG8(0x3858), 0x10 },
++	{ CCI_REG8(0x3859), 0x10 }, { CCI_REG8(0x4016), 0x0f },
++	{ CCI_REG8(0x4018), 0x03 }, { CCI_REG8(0x4504), 0x1e },
++	{ CCI_REG8(0x4523), 0x41 }, { CCI_REG8(0x45c0), 0x01 },
++	{ CCI_REG8(0x4641), 0x12 }, { CCI_REG8(0x4643), 0x0c },
++	{ CCI_REG8(0x4915), 0x02 }, { CCI_REG8(0x4916), 0x1d },
++	{ CCI_REG8(0x4a15), 0x02 }, { CCI_REG8(0x4a16), 0x1d },
++	{ CCI_REG8(0x3703), 0x72 }, { CCI_REG8(0x3709), 0xe6 },
++	{ CCI_REG8(0x3a60), 0x68 }, { CCI_REG8(0x3a6f), 0x68 },
++	{ CCI_REG8(0x3a5e), 0xdc }, { CCI_REG8(0x3a6d), 0xdc },
++	{ CCI_REG8(0x3721), 0xc9 }, { CCI_REG8(0x5250), 0x06 },
++	{ CCI_REG8(0x527a), 0x00 }, { CCI_REG8(0x527b), 0x65 },
++	{ CCI_REG8(0x527c), 0x00 }, { CCI_REG8(0x527d), 0x82 },
++	{ CCI_REG8(0x5280), 0x24 }, { CCI_REG8(0x5281), 0x40 },
++	{ CCI_REG8(0x5282), 0x1b }, { CCI_REG8(0x5283), 0x40 },
++	{ CCI_REG8(0x5284), 0x24 }, { CCI_REG8(0x5285), 0x40 },
++	{ CCI_REG8(0x5286), 0x1b }, { CCI_REG8(0x5287), 0x40 },
++	{ CCI_REG8(0x5200), 0x24 }, { CCI_REG8(0x5201), 0x40 },
++	{ CCI_REG8(0x5202), 0x1b }, { CCI_REG8(0x5203), 0x40 },
++	{ CCI_REG8(0x481b), 0x35 }, { CCI_REG8(0x4862), 0x25 },
++	{ CCI_REG8(0x3400), 0x00 }, { CCI_REG8(0x3421), 0x23 },
++	{ CCI_REG8(0x3422), 0xfc }, { CCI_REG8(0x3423), 0x07 },
++	{ CCI_REG8(0x3424), 0x01 }, { CCI_REG8(0x3425), 0x04 },
++	{ CCI_REG8(0x3426), 0x50 }, { CCI_REG8(0x3427), 0x55 },
++	{ CCI_REG8(0x3428), 0x15 }, { CCI_REG8(0x3429), 0x00 },
++	{ CCI_REG8(0x3025), 0x03 }, { CCI_REG8(0x5250), 0x06 },
++	{ CCI_REG8(0x0305), 0x98 }, { CCI_REG8(0x0306), 0x04 },
++	{ CCI_REG8(0x0345), 0x90 }, { CCI_REG8(0x0307), 0x01 },
++	{ CCI_REG8(0x4837), 0x1a }, { CCI_REG8(0x4888), 0x10 },
++	{ CCI_REG8(0x4860), 0x00 }, { CCI_REG8(0x4850), 0x43 },
++	{ CCI_REG8(0x480C), 0x92 }, { CCI_REG8(0x5001), 0x21 },
++	{ CCI_REG8(0x5000), 0x01 }
++};
++
++static const struct cci_reg_sequence ov64a40_2312_1736[] = {
++	{ CCI_REG8(0x034b), 0x02 }, { CCI_REG8(0x3504), 0x08 },
++	{ CCI_REG8(0x360d), 0x82 }, { CCI_REG8(0x368a), 0x2e },
++	{ CCI_REG8(0x3712), 0x00 }, { CCI_REG8(0x3822), 0x08 },
++	{ CCI_REG8(0x3827), 0x40 }, { CCI_REG8(0x383d), 0x04 },
++	{ CCI_REG8(0x383f), 0x00 }, { CCI_REG8(0x384c), 0x01 },
++	{ CCI_REG8(0x384d), 0x12 }, { CCI_REG8(0x3852), 0x00 },
++	{ CCI_REG8(0x3856), 0x04 }, { CCI_REG8(0x3857), 0x04 },
++	{ CCI_REG8(0x3858), 0x08 }, { CCI_REG8(0x3859), 0x08 },
++	{ CCI_REG8(0x4016), 0x07 }, { CCI_REG8(0x4018), 0x01 },
++	{ CCI_REG8(0x4504), 0x00 }, { CCI_REG8(0x4523), 0x00 },
++	{ CCI_REG8(0x45c0), 0x01 }, { CCI_REG8(0x4641), 0x24 },
++	{ CCI_REG8(0x4643), 0x0c }, { CCI_REG8(0x4837), 0x0b },
++	{ CCI_REG8(0x4915), 0x02 }, { CCI_REG8(0x4916), 0x1d },
++	{ CCI_REG8(0x4a15), 0x02 }, { CCI_REG8(0x4a16), 0x1d },
++	{ CCI_REG8(0x5000), 0x55 }, { CCI_REG8(0x5001), 0x00 },
++	{ CCI_REG8(0x5002), 0x35 }, { CCI_REG8(0x5004), 0xc0 },
++	{ CCI_REG8(0x5068), 0x02 }, { CCI_REG8(0x3703), 0x6a },
++	{ CCI_REG8(0x3709), 0xa3 }, { CCI_REG8(0x3a60), 0x60 },
++	{ CCI_REG8(0x3a6f), 0x60 }, { CCI_REG8(0x3a5e), 0x99 },
++	{ CCI_REG8(0x3a6d), 0x99 }, { CCI_REG8(0x3721), 0xc1 },
++	{ CCI_REG8(0x5250), 0x06 }, { CCI_REG8(0x527a), 0x00 },
++	{ CCI_REG8(0x527b), 0x65 }, { CCI_REG8(0x527c), 0x00 },
++	{ CCI_REG8(0x527d), 0x82 }, { CCI_REG8(0x5280), 0x24 },
++	{ CCI_REG8(0x5281), 0x40 }, { CCI_REG8(0x5282), 0x1b },
++	{ CCI_REG8(0x5283), 0x40 }, { CCI_REG8(0x5284), 0x24 },
++	{ CCI_REG8(0x5285), 0x40 }, { CCI_REG8(0x5286), 0x1b },
++	{ CCI_REG8(0x5287), 0x40 }, { CCI_REG8(0x5200), 0x24 },
++	{ CCI_REG8(0x5201), 0x40 }, { CCI_REG8(0x5202), 0x1b },
++	{ CCI_REG8(0x5203), 0x40 }, { CCI_REG8(0x3684), 0x05 },
++	{ CCI_REG8(0x481b), 0x20 }, { CCI_REG8(0x51b0), 0x38 },
++	{ CCI_REG8(0x51b3), 0x0e }, { CCI_REG8(0x51b5), 0x04 },
++	{ CCI_REG8(0x51b6), 0x00 }, { CCI_REG8(0x51b7), 0x00 },
++	{ CCI_REG8(0x51b9), 0x70 }, { CCI_REG8(0x51bb), 0x10 },
++	{ CCI_REG8(0x51bc), 0x00 }, { CCI_REG8(0x51bd), 0x00 },
++	{ CCI_REG8(0x51b0), 0x38 }, { CCI_REG8(0x54b0), 0x38 },
++	{ CCI_REG8(0x54b3), 0x0e }, { CCI_REG8(0x54b5), 0x04 },
++	{ CCI_REG8(0x54b6), 0x00 }, { CCI_REG8(0x54b7), 0x00 },
++	{ CCI_REG8(0x54b9), 0x70 }, { CCI_REG8(0x54bb), 0x10 },
++	{ CCI_REG8(0x54bc), 0x00 }, { CCI_REG8(0x54bd), 0x00 },
++	{ CCI_REG8(0x57b0), 0x38 }, { CCI_REG8(0x57b3), 0x0e },
++	{ CCI_REG8(0x57b5), 0x04 }, { CCI_REG8(0x57b6), 0x00 },
++	{ CCI_REG8(0x57b7), 0x00 }, { CCI_REG8(0x57b9), 0x70 },
++	{ CCI_REG8(0x57bb), 0x10 }, { CCI_REG8(0x57bc), 0x00 },
++	{ CCI_REG8(0x57bd), 0x00 }, { CCI_REG8(0x0305), 0x98 },
++	{ CCI_REG8(0x0306), 0x04 }, { CCI_REG8(0x0307), 0x01 },
++	{ CCI_REG8(0x4837), 0x1a }, { CCI_REG8(0x4888), 0x10 },
++	{ CCI_REG8(0x4860), 0x00 }, { CCI_REG8(0x4850), 0x43 },
++	{ CCI_REG8(0x480C), 0x92 }
++};
++
++static const struct cci_reg_sequence ov64a40_1920x1080[] = {
++	{ CCI_REG8(0x034b), 0x02 }, { CCI_REG8(0x3504), 0x08 },
++	{ CCI_REG8(0x360d), 0x82 }, { CCI_REG8(0x368a), 0x2e },
++	{ CCI_REG8(0x3712), 0x00 }, { CCI_REG8(0x3822), 0x08 },
++	{ CCI_REG8(0x3827), 0x40 }, { CCI_REG8(0x383d), 0x04 },
++	{ CCI_REG8(0x383f), 0x00 }, { CCI_REG8(0x384c), 0x01 },
++	{ CCI_REG8(0x384d), 0x12 }, { CCI_REG8(0x3852), 0x00 },
++	{ CCI_REG8(0x3856), 0x04 }, { CCI_REG8(0x3857), 0x04 },
++	{ CCI_REG8(0x3858), 0x08 }, { CCI_REG8(0x3859), 0x08 },
++	{ CCI_REG8(0x4016), 0x07 }, { CCI_REG8(0x4018), 0x01 },
++	{ CCI_REG8(0x4504), 0x00 }, { CCI_REG8(0x4523), 0x00 },
++	{ CCI_REG8(0x45c0), 0x01 }, { CCI_REG8(0x4641), 0x24 },
++	{ CCI_REG8(0x4643), 0x0c }, { CCI_REG8(0x4837), 0x0b },
++	{ CCI_REG8(0x4915), 0x02 }, { CCI_REG8(0x4916), 0x1d },
++	{ CCI_REG8(0x4a15), 0x02 }, { CCI_REG8(0x4a16), 0x1d },
++	{ CCI_REG8(0x5000), 0x55 }, { CCI_REG8(0x5001), 0x00 },
++	{ CCI_REG8(0x5002), 0x35 }, { CCI_REG8(0x5004), 0xc0 },
++	{ CCI_REG8(0x5068), 0x02 }, { CCI_REG8(0x3703), 0x6a },
++	{ CCI_REG8(0x3709), 0xa3 }, { CCI_REG8(0x3a60), 0x60 },
++	{ CCI_REG8(0x3a6f), 0x60 }, { CCI_REG8(0x3a5e), 0x99 },
++	{ CCI_REG8(0x3a6d), 0x99 }, { CCI_REG8(0x3721), 0xc1 },
++	{ CCI_REG8(0x5250), 0x06 }, { CCI_REG8(0x527a), 0x00 },
++	{ CCI_REG8(0x527b), 0x65 }, { CCI_REG8(0x527c), 0x00 },
++	{ CCI_REG8(0x527d), 0x82 }, { CCI_REG8(0x5280), 0x24 },
++	{ CCI_REG8(0x5281), 0x40 }, { CCI_REG8(0x5282), 0x1b },
++	{ CCI_REG8(0x5283), 0x40 }, { CCI_REG8(0x5284), 0x24 },
++	{ CCI_REG8(0x5285), 0x40 }, { CCI_REG8(0x5286), 0x1b },
++	{ CCI_REG8(0x5287), 0x40 }, { CCI_REG8(0x5200), 0x24 },
++	{ CCI_REG8(0x5201), 0x40 }, { CCI_REG8(0x5202), 0x1b },
++	{ CCI_REG8(0x5203), 0x40 }, { CCI_REG8(0x3684), 0x05 },
++	{ CCI_REG8(0x481b), 0x20 }, { CCI_REG8(0x51b0), 0x38 },
++	{ CCI_REG8(0x51b3), 0x0e }, { CCI_REG8(0x51b5), 0x04 },
++	{ CCI_REG8(0x51b6), 0x00 }, { CCI_REG8(0x51b7), 0x00 },
++	{ CCI_REG8(0x51b9), 0x70 }, { CCI_REG8(0x51bb), 0x10 },
++	{ CCI_REG8(0x51bc), 0x00 }, { CCI_REG8(0x51bd), 0x00 },
++	{ CCI_REG8(0x51b0), 0x38 }, { CCI_REG8(0x54b0), 0x38 },
++	{ CCI_REG8(0x54b3), 0x0e }, { CCI_REG8(0x54b5), 0x04 },
++	{ CCI_REG8(0x54b6), 0x00 }, { CCI_REG8(0x54b7), 0x00 },
++	{ CCI_REG8(0x54b9), 0x70 }, { CCI_REG8(0x54bb), 0x10 },
++	{ CCI_REG8(0x54bc), 0x00 }, { CCI_REG8(0x54bd), 0x00 },
++	{ CCI_REG8(0x57b0), 0x38 }, { CCI_REG8(0x57b3), 0x0e },
++	{ CCI_REG8(0x57b5), 0x04 }, { CCI_REG8(0x57b6), 0x00 },
++	{ CCI_REG8(0x57b7), 0x00 }, { CCI_REG8(0x57b9), 0x70 },
++	{ CCI_REG8(0x57bb), 0x10 }, { CCI_REG8(0x57bc), 0x00 },
++	{ CCI_REG8(0x57bd), 0x00 }, { CCI_REG8(0x0305), 0x98 },
++	{ CCI_REG8(0x0306), 0x04 }, { CCI_REG8(0x0307), 0x01 },
++	{ CCI_REG8(0x4837), 0x1a }, { CCI_REG8(0x4888), 0x10 },
++	{ CCI_REG8(0x4860), 0x00 }, { CCI_REG8(0x4850), 0x43 },
++	{ CCI_REG8(0x480C), 0x92 }
++};
++
++/* 456MHz MIPI link frequency with 24MHz input clock. */
++static const struct cci_reg_sequence ov64a40_pll_config[] = {
++	{ OV64A40_PLL1_PRE_DIV0, 0x88 },
++	{ OV64A40_PLL1_PRE_DIV, 0x02 },
++	{ OV64A40_PLL1_MULTIPLIER, 0x0098 },
++	{ OV64A40_PLL1_M_DIV, 0x01 },
++	{ OV64A40_PLL2_SEL_BAK_SA1, 0x00 },
++	{ OV64A40_PLL2_PRE_DIV, 0x12 },
++	{ OV64A40_PLL2_MULTIPLIER, 0x0190 },
++	{ OV64A40_PLL2_PRE_DIV0, 0xd7 },
++	{ OV64A40_PLL2_DIVSP, 0x00 },
++	{ OV64A40_PLL2_DIVDAC, 0x00 },
++	{ OV64A40_PLL2_DACPREDIV, 0x00 }
++};
++
++struct ov64a40_reglist {
++	unsigned int num_regs;
++	const struct cci_reg_sequence *regvals;
++};
++
++struct ov64a40_subsampling {
++	unsigned int x_odd_inc;
++	unsigned int x_even_inc;
++	unsigned int y_odd_inc;
++	unsigned int y_even_inc;
++	bool vbin;
++	bool hbin;
++};
++
++static struct ov64a40_mode {
++	unsigned int width;
++	unsigned int height;
++	struct ov64a40_timings {
++		unsigned int vts;
++		unsigned int ppl;
++	} timings_default[OV64A40_NUM_LINK_FREQ];
++	const struct ov64a40_reglist reglist;
++	struct v4l2_rect analogue_crop;
++	struct v4l2_rect digital_crop;
++	struct ov64a40_subsampling subsampling;
++} ov64a40_modes[] = {
++	/* Full resolution */
++	{
++		.width = 9248,
++		.height = 6944,
++		.timings_default = {
++			/* 2.6 FPS */
++			[OV64A40_LINK_FREQ_456M_ID] = {
++				.vts = 7072,
++				.ppl = 4072,
++			},
++			/* 2 FPS */
++			[OV64A40_LINK_FREQ_360M_ID] = {
++				.vts = 7072,
++				.ppl = 5248,
++			},
++		},
++		.reglist = {
++			.num_regs = ARRAY_SIZE(ov64a40_9248x6944),
++			.regvals = ov64a40_9248x6944,
++		},
++		.analogue_crop = {
++			.left = 0,
++			.top = 0,
++			.width = 9279,
++			.height = 6975,
++		},
++		.digital_crop = {
++			.left = 17,
++			.top = 16,
++			.width = 9248,
++			.height = 6944,
++		},
++		.subsampling = {
++			.x_odd_inc = 1,
++			.x_even_inc = 1,
++			.y_odd_inc = 1,
++			.y_even_inc = 1,
++			.vbin = false,
++			.hbin = false,
++		},
++	},
++	/* Analogue crop + digital crop */
++	{
++		.width = 8000,
++		.height = 6000,
++		.timings_default = {
++			/* 3.0 FPS */
++			[OV64A40_LINK_FREQ_456M_ID] = {
++				.vts = 6400,
++				.ppl = 3848,
++			},
++			/* 2.5 FPS */
++			[OV64A40_LINK_FREQ_360M_ID] = {
++				.vts = 6304,
++				.ppl = 4736,
++			},
++		},
++		.reglist = {
++			.num_regs = ARRAY_SIZE(ov64a40_8000x6000),
++			.regvals = ov64a40_8000x6000,
++		},
++		.analogue_crop = {
++			.left = 624,
++			.top = 472,
++			.width = 8047,
++			.height = 6031,
++		},
++		.digital_crop = {
++			.left = 17,
++			.top = 16,
++			.width = 8000,
++			.height = 6000,
++		},
++		.subsampling = {
++			.x_odd_inc = 1,
++			.x_even_inc = 1,
++			.y_odd_inc = 1,
++			.y_even_inc = 1,
++			.vbin = false,
++			.hbin = false,
++		},
++	},
++	/* 2x2 downscaled */
++	{
++		.width = 4624,
++		.height = 3472,
++		.timings_default = {
++			/* 10 FPS */
++			[OV64A40_LINK_FREQ_456M_ID] = {
++				.vts = 3533,
++				.ppl = 2112,
++			},
++			/* 7 FPS */
++			[OV64A40_LINK_FREQ_360M_ID] = {
++				.vts = 3939,
++				.ppl = 2720,
++			},
++		},
++		.reglist = {
++			.num_regs = ARRAY_SIZE(ov64a40_4624_3472),
++			.regvals = ov64a40_4624_3472,
++		},
++		.analogue_crop = {
++			.left = 0,
++			.top = 0,
++			.width = 9279,
++			.height = 6975,
++		},
++		.digital_crop = {
++			.left = 9,
++			.top = 8,
++			.width = 4624,
++			.height = 3472,
++		},
++		.subsampling = {
++			.x_odd_inc = 3,
++			.x_even_inc = 1,
++			.y_odd_inc = 1,
++			.y_even_inc = 1,
++			.vbin = true,
++			.hbin = false,
++		},
++	},
++	/* Analogue crop + 2x2 downscale + digital crop */
++	{
++		.width = 3840,
++		.height = 2160,
++		.timings_default = {
++			/* 20 FPS */
++			[OV64A40_LINK_FREQ_456M_ID] = {
++				.vts = 2218,
++				.ppl = 1690,
++			},
++			/* 15 FPS */
++			[OV64A40_LINK_FREQ_360M_ID] = {
++				.vts = 2270,
++				.ppl = 2202,
++			},
++		},
++		.reglist = {
++			.num_regs = ARRAY_SIZE(ov64a40_3840x2160),
++			.regvals = ov64a40_3840x2160,
++		},
++		.analogue_crop = {
++			.left = 784,
++			.top = 1312,
++			.width = 7711,
++			.height = 4351,
++		},
++		.digital_crop = {
++			.left = 9,
++			.top = 8,
++			.width = 3840,
++			.height = 2160,
++		},
++		.subsampling = {
++			.x_odd_inc = 3,
++			.x_even_inc = 1,
++			.y_odd_inc = 1,
++			.y_even_inc = 1,
++			.vbin = true,
++			.hbin = false,
++		},
++	},
++	/* 4x4 downscaled */
++	{
++		.width = 2312,
++		.height = 1736,
++		.timings_default = {
++			/* 30 FPS */
++			[OV64A40_LINK_FREQ_456M_ID] = {
++				.vts = 1998,
++				.ppl = 1248,
++			},
++			/* 25 FPS */
++			[OV64A40_LINK_FREQ_360M_ID] = {
++				.vts = 1994,
++				.ppl = 1504,
++			},
++		},
++		.reglist = {
++			.num_regs = ARRAY_SIZE(ov64a40_2312_1736),
++			.regvals = ov64a40_2312_1736,
++		},
++		.analogue_crop = {
++			.left = 0,
++			.top = 0,
++			.width = 9279,
++			.height = 6975,
++		},
++		.digital_crop = {
++			.left = 5,
++			.top = 4,
++			.width = 2312,
++			.height = 1736,
++		},
++		.subsampling = {
++			.x_odd_inc = 3,
++			.x_even_inc = 1,
++			.y_odd_inc = 3,
++			.y_even_inc = 1,
++			.vbin = true,
++			.hbin = true,
++		},
++	},
++	/* Analogue crop + 4x4 downscale + digital crop */
++	{
++		.width = 1920,
++		.height = 1080,
++		.timings_default = {
++			/* 60 FPS */
++			[OV64A40_LINK_FREQ_456M_ID] = {
++				.vts = 1397,
++				.ppl = 880,
++			},
++			/* 45 FPS */
++			[OV64A40_LINK_FREQ_360M_ID] = {
++				.vts = 1216,
++				.ppl = 1360,
++			},
++		},
++		.reglist = {
++			.num_regs = ARRAY_SIZE(ov64a40_1920x1080),
++			.regvals = ov64a40_1920x1080,
++		},
++		.analogue_crop = {
++			.left = 784,
++			.top = 1312,
++			.width = 7711,
++			.height = 4351,
++		},
++		.digital_crop = {
++			.left = 7,
++			.top = 6,
++			.width = 1920,
++			.height = 1080,
++		},
++		.subsampling = {
++			.x_odd_inc = 3,
++			.x_even_inc = 1,
++			.y_odd_inc = 3,
++			.y_even_inc = 1,
++			.vbin = true,
++			.hbin = true,
++		},
++	},
++};
++
++struct ov64a40 {
++	struct device *dev;
++
++	struct v4l2_subdev sd;
++	struct media_pad pad;
++
++	struct regmap *cci;
++
++	struct ov64a40_mode *mode;
++
++	struct clk *xclk;
++
++	struct gpio_desc *reset_gpio;
++	struct regulator_bulk_data supplies[ARRAY_SIZE(ov64a40_supply_names)];
++
++	s64 *link_frequencies;
++	unsigned int num_link_frequencies;
++
++	struct v4l2_ctrl_handler ctrl_handler;
++	struct v4l2_ctrl *exposure;
++	struct v4l2_ctrl *link_freq;
++	struct v4l2_ctrl *vblank;
++	struct v4l2_ctrl *hblank;
++	struct v4l2_ctrl *vflip;
++	struct v4l2_ctrl *hflip;
++};
++
++static inline struct ov64a40 *sd_to_ov64a40(struct v4l2_subdev *sd)
++{
++	return container_of(sd, struct ov64a40, sd);
++}
++
++static const struct ov64a40_timings *
++ov64a40_get_timings(struct ov64a40 *ov64a40, unsigned int link_freq_index)
++{
++	s64 link_freq = ov64a40->link_frequencies[link_freq_index];
++	unsigned int timings_index = link_freq == OV64A40_LINK_FREQ_360M
++				   ? OV64A40_LINK_FREQ_360M_ID
++				   : OV64A40_LINK_FREQ_456M_ID;
++
++	return &ov64a40->mode->timings_default[timings_index];
++}
++
++static int ov64a40_program_geometry(struct ov64a40 *ov64a40)
++{
++	struct ov64a40_mode *mode = ov64a40->mode;
++	struct v4l2_rect *anacrop = &mode->analogue_crop;
++	struct v4l2_rect *digicrop = &mode->digital_crop;
++	const struct ov64a40_timings *timings;
++	int ret = 0;
++
++	/* Analogue crop. */
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL0,
++		  anacrop->left, &ret);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL2,
++		  anacrop->top, &ret);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL4,
++		  anacrop->width + anacrop->left, &ret);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL6,
++		  anacrop->height + anacrop->top, &ret);
++
++	/* ISP windowing. */
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL10,
++		  digicrop->left, &ret);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL12,
++		  digicrop->top, &ret);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL8,
++		  digicrop->width, &ret);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRLA,
++		  digicrop->height, &ret);
++
++	/* Total timings. */
++	timings = ov64a40_get_timings(ov64a40, ov64a40->link_freq->cur.val);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRLC, timings->ppl, &ret);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRLE, timings->vts, &ret);
++
++	return ret;
++}
++
++static int ov64a40_program_subsampling(struct ov64a40 *ov64a40)
++{
++	struct ov64a40_subsampling *subsampling = &ov64a40->mode->subsampling;
++	int ret = 0;
++
++	/* Skipping configuration */
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL14,
++		  OV64A40_SKIPPING_CONFIG(subsampling->x_odd_inc,
++					  subsampling->x_even_inc), &ret);
++	cci_write(ov64a40->cci, OV64A40_REG_TIMING_CTRL15,
++		  OV64A40_SKIPPING_CONFIG(subsampling->y_odd_inc,
++					  subsampling->y_even_inc), &ret);
++
++	/* Binning configuration */
++	cci_update_bits(ov64a40->cci, OV64A40_REG_TIMING_CTRL_20,
++			OV64A40_TIMING_CTRL_20_VBIN,
++			subsampling->vbin ? OV64A40_TIMING_CTRL_20_VBIN : 0,
++			&ret);
++	cci_update_bits(ov64a40->cci, OV64A40_REG_TIMING_CTRL_21,
++			OV64A40_TIMING_CTRL_21_HBIN_CONF,
++			subsampling->hbin ?
++			OV64A40_TIMING_CTRL_21_HBIN_CONF : 0, &ret);
++
++	return ret;
++}
++
++static int ov64a40_start_streaming(struct ov64a40 *ov64a40,
++				   struct v4l2_subdev_state *state)
++{
++	const struct ov64a40_reglist *reglist = &ov64a40->mode->reglist;
++	const struct ov64a40_timings *timings;
++	unsigned long delay;
++	int ret;
++
++	ret = pm_runtime_resume_and_get(ov64a40->dev);
++	if (ret < 0)
++		return ret;
++
++	ret = cci_multi_reg_write(ov64a40->cci, ov64a40_init,
++				  ARRAY_SIZE(ov64a40_init), NULL);
++	if (ret)
++		goto error_power_off;
++
++	ret = cci_multi_reg_write(ov64a40->cci, reglist->regvals,
++				  reglist->num_regs, NULL);
++	if (ret)
++		goto error_power_off;
++
++	ret = ov64a40_program_geometry(ov64a40);
++	if (ret)
++		goto error_power_off;
++
++	ret = ov64a40_program_subsampling(ov64a40);
++	if (ret)
++		goto error_power_off;
++
++	ret =  __v4l2_ctrl_handler_setup(&ov64a40->ctrl_handler);
++	if (ret)
++		goto error_power_off;
++
++	ret = cci_write(ov64a40->cci, OV64A40_REG_SMIA,
++			OV64A40_REG_SMIA_STREAMING, NULL);
++	if (ret)
++		goto error_power_off;
++
++	/* Link frequency and flips cannot change while streaming. */
++	__v4l2_ctrl_grab(ov64a40->link_freq, true);
++	__v4l2_ctrl_grab(ov64a40->vflip, true);
++	__v4l2_ctrl_grab(ov64a40->hflip, true);
++
++	/* delay: max(4096 xclk pulses, 150usec) + exposure time */
++	timings = ov64a40_get_timings(ov64a40, ov64a40->link_freq->cur.val);
++	delay = DIV_ROUND_UP(4096, OV64A40_XCLK_FREQ / 1000 / 1000);
++	delay = max(delay, 150ul);
++
++	/* The sensor has an internal x4 multiplier on the line length. */
++	delay += DIV_ROUND_UP(timings->ppl * 4 * ov64a40->exposure->cur.val,
++			      OV64A40_PIXEL_RATE / 1000 / 1000);
++	fsleep(delay);
++
++	return 0;
++
++error_power_off:
++	pm_runtime_mark_last_busy(ov64a40->dev);
++	pm_runtime_put_autosuspend(ov64a40->dev);
++
++	return ret;
++}
++
++static int ov64a40_stop_streaming(struct ov64a40 *ov64a40,
++				  struct v4l2_subdev_state *state)
++{
++	cci_update_bits(ov64a40->cci, OV64A40_REG_SMIA, BIT(0), 0, NULL);
++	pm_runtime_mark_last_busy(ov64a40->dev);
++	pm_runtime_put_autosuspend(ov64a40->dev);
++
++	__v4l2_ctrl_grab(ov64a40->link_freq, false);
++	__v4l2_ctrl_grab(ov64a40->vflip, false);
++	__v4l2_ctrl_grab(ov64a40->hflip, false);
++
++	return 0;
++}
++
++static int ov64a40_set_stream(struct v4l2_subdev *sd, int enable)
++{
++	struct ov64a40 *ov64a40 = sd_to_ov64a40(sd);
++	struct v4l2_subdev_state *state;
++	int ret;
++
++	state = v4l2_subdev_lock_and_get_active_state(sd);
++	if (enable)
++		ret = ov64a40_start_streaming(ov64a40, state);
++	else
++		ret = ov64a40_stop_streaming(ov64a40, state);
++	v4l2_subdev_unlock_state(state);
++
++	return ret;
++}
++
++static const struct v4l2_subdev_video_ops ov64a40_video_ops = {
++	.s_stream = ov64a40_set_stream,
++};
++
++static u32 ov64a40_mbus_code(struct ov64a40 *ov64a40)
++{
++	unsigned int index = ov64a40->hflip->val << 1 | ov64a40->vflip->val;
++
++	return ov64a40_mbus_codes[index];
++}
++
++static void ov64a40_update_pad_fmt(struct ov64a40 *ov64a40,
++				   struct ov64a40_mode *mode,
++				   struct v4l2_mbus_framefmt *fmt)
++{
++	fmt->code = ov64a40_mbus_code(ov64a40);
++	fmt->width = mode->width;
++	fmt->height = mode->height;
++	fmt->field = V4L2_FIELD_NONE;
++	fmt->colorspace = V4L2_COLORSPACE_RAW;
++	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
++	fmt->xfer_func = V4L2_XFER_FUNC_NONE;
++	fmt->ycbcr_enc = V4L2_YCBCR_ENC_601;
++}
++
++static int ov64a40_init_cfg(struct v4l2_subdev *sd,
++			    struct v4l2_subdev_state *state)
++{
++	struct ov64a40 *ov64a40 = sd_to_ov64a40(sd);
++	struct v4l2_mbus_framefmt *format;
++	struct v4l2_rect *crop;
++
++	format = v4l2_subdev_get_pad_format(sd, state, 0);
++	ov64a40_update_pad_fmt(ov64a40, &ov64a40_modes[0], format);
++
++	crop = v4l2_subdev_get_pad_crop(sd, state, 0);
++	crop->top = OV64A40_PIXEL_ARRAY_TOP;
++	crop->left = OV64A40_PIXEL_ARRAY_LEFT;
++	crop->width = OV64A40_PIXEL_ARRAY_WIDTH;
++	crop->height = OV64A40_PIXEL_ARRAY_HEIGHT;
++
++	return 0;
++}
++
++static int ov64a40_enum_mbus_code(struct v4l2_subdev *sd,
++				  struct v4l2_subdev_state *sd_state,
++				  struct v4l2_subdev_mbus_code_enum *code)
++{
++	struct ov64a40 *ov64a40 = sd_to_ov64a40(sd);
++
++	if (code->index)
++		return -EINVAL;
++
++	code->code = ov64a40_mbus_code(ov64a40);
++
++	return 0;
++}
++
++static int ov64a40_enum_frame_size(struct v4l2_subdev *sd,
++				   struct v4l2_subdev_state *sd_state,
++				   struct v4l2_subdev_frame_size_enum *fse)
++{
++	struct ov64a40 *ov64a40 = sd_to_ov64a40(sd);
++	struct ov64a40_mode *mode;
++	u32 code;
++
++	if (fse->index >= ARRAY_SIZE(ov64a40_modes))
++		return -EINVAL;
++
++	code = ov64a40_mbus_code(ov64a40);
++	if (fse->code != code)
++		return -EINVAL;
++
++	mode = &ov64a40_modes[fse->index];
++	fse->min_width = mode->width;
++	fse->max_width = mode->width;
++	fse->min_height = mode->height;
++	fse->max_height = mode->height;
++
++	return 0;
++}
++
++static int ov64a40_get_selection(struct v4l2_subdev *sd,
++				 struct v4l2_subdev_state *sd_state,
++				 struct v4l2_subdev_selection *sel)
++{
++	switch (sel->target) {
++	case V4L2_SEL_TGT_CROP:
++		sel->r = *v4l2_subdev_get_pad_crop(sd, sd_state, 0);
++
++		return 0;
++
++	case V4L2_SEL_TGT_NATIVE_SIZE:
++		sel->r.top = 0;
++		sel->r.left = 0;
++		sel->r.width = OV64A40_NATIVE_WIDTH;
++		sel->r.height = OV64A40_NATIVE_HEIGHT;
++
++		return 0;
++
++	case V4L2_SEL_TGT_CROP_DEFAULT:
++	case V4L2_SEL_TGT_CROP_BOUNDS:
++		sel->r.top = OV64A40_PIXEL_ARRAY_TOP;
++		sel->r.left = OV64A40_PIXEL_ARRAY_LEFT;
++		sel->r.width = OV64A40_PIXEL_ARRAY_WIDTH;
++		sel->r.height = OV64A40_PIXEL_ARRAY_HEIGHT;
++
++		return 0;
++	}
++
++	return -EINVAL;
++}
++
++static int ov64a40_set_format(struct v4l2_subdev *sd,
++			      struct v4l2_subdev_state *sd_state,
++			      struct v4l2_subdev_format *fmt)
++{
++	struct ov64a40 *ov64a40 = sd_to_ov64a40(sd);
++	struct v4l2_mbus_framefmt *format;
++	struct ov64a40_mode *mode;
++
++	mode = v4l2_find_nearest_size(ov64a40_modes,
++				      ARRAY_SIZE(ov64a40_modes),
++				      width, height,
++				      fmt->format.width, fmt->format.height);
++
++	ov64a40_update_pad_fmt(ov64a40, mode, &fmt->format);
++
++	format = v4l2_subdev_get_pad_format(sd, sd_state, 0);
++	if (ov64a40->mode == mode && format->code == fmt->format.code)
++		return 0;
++
++	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
++		const struct ov64a40_timings *timings;
++		int vblank_max, vblank_def;
++		int hblank_val;
++		int exp_max;
++
++		ov64a40->mode = mode;
++		*v4l2_subdev_get_pad_crop(sd, sd_state, 0) = mode->analogue_crop;
++
++		/* Update control limits according to the new mode. */
++		timings = ov64a40_get_timings(ov64a40,
++					      ov64a40->link_freq->cur.val);
++		vblank_max = OV64A40_VTS_MAX - mode->height;
++		vblank_def = timings->vts - mode->height;
++		__v4l2_ctrl_modify_range(ov64a40->vblank, OV64A40_VBLANK_MIN,
++					 vblank_max, 1, vblank_def);
++		__v4l2_ctrl_s_ctrl(ov64a40->vblank, vblank_def);
++
++		exp_max = timings->vts - OV64A40_EXPOSURE_MARGIN;
++		__v4l2_ctrl_modify_range(ov64a40->exposure,
++					 OV64A40_EXPOSURE_MIN, exp_max,
++					 1, OV64A40_EXPOSURE_MIN);
++
++		hblank_val = timings->ppl * 4 - mode->width;
++		__v4l2_ctrl_modify_range(ov64a40->hblank,
++					 hblank_val, hblank_val, 1, hblank_val);
++	}
++
++	*format = fmt->format;
++
++	return 0;
++}
++
++static const struct v4l2_subdev_pad_ops ov64a40_pad_ops = {
++	.init_cfg = ov64a40_init_cfg,
++	.enum_mbus_code = ov64a40_enum_mbus_code,
++	.enum_frame_size = ov64a40_enum_frame_size,
++	.get_fmt = v4l2_subdev_get_fmt,
++	.set_fmt = ov64a40_set_format,
++	.get_selection = ov64a40_get_selection,
++};
++
++static const struct v4l2_subdev_core_ops ov64a40_core_ops = {
++	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
++	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
++};
++
++static const struct v4l2_subdev_ops ov64a40_subdev_ops = {
++	.core = &ov64a40_core_ops,
++	.video = &ov64a40_video_ops,
++	.pad = &ov64a40_pad_ops,
++};
++
++static int ov64a40_power_on(struct device *dev)
++{
++	struct v4l2_subdev *sd = dev_get_drvdata(dev);
++	struct ov64a40 *ov64a40 = sd_to_ov64a40(sd);
++	int ret;
++
++	ret = clk_prepare_enable(ov64a40->xclk);
++	if (ret)
++		return ret;
++
++	ret = regulator_bulk_enable(ARRAY_SIZE(ov64a40_supply_names),
++				    ov64a40->supplies);
++	if (ret) {
++		clk_disable_unprepare(ov64a40->xclk);
++		dev_err(dev, "Failed to enable regulators: %d\n", ret);
++		return ret;
++	}
++
++	gpiod_set_value_cansleep(ov64a40->reset_gpio, 0);
++
++	fsleep(5000);
++
++	return 0;
++}
++
++static int ov64a40_power_off(struct device *dev)
++{
++	struct v4l2_subdev *sd = dev_get_drvdata(dev);
++	struct ov64a40 *ov64a40 = sd_to_ov64a40(sd);
++
++	gpiod_set_value_cansleep(ov64a40->reset_gpio, 1);
++	regulator_bulk_disable(ARRAY_SIZE(ov64a40_supply_names),
++			       ov64a40->supplies);
++	clk_disable_unprepare(ov64a40->xclk);
++
++	return 0;
++}
++
++static int ov64a40_link_freq_config(struct ov64a40 *ov64a40, int link_freq_id)
++{
++	s64 link_frequency;
++	int ret = 0;
++
++	/* Default 456MHz with 24MHz input clock. */
++	cci_multi_reg_write(ov64a40->cci, ov64a40_pll_config,
++			    ARRAY_SIZE(ov64a40_pll_config), &ret);
++
++	/* Decrease the PLL1 multiplier to obtain 360MHz mipi link frequency. */
++	link_frequency = ov64a40->link_frequencies[link_freq_id];
++	if (link_frequency == OV64A40_LINK_FREQ_360M)
++		cci_write(ov64a40->cci, OV64A40_PLL1_MULTIPLIER, 0x0078, &ret);
++
++	return ret;
++}
++
++static int ov64a40_set_ctrl(struct v4l2_ctrl *ctrl)
++{
++	struct ov64a40 *ov64a40 = container_of(ctrl->handler, struct ov64a40,
++					       ctrl_handler);
++	int pm_status;
++	int ret = 0;
++
++	if (ctrl->id == V4L2_CID_VBLANK) {
++		int exp_max = ov64a40->mode->height + ctrl->val
++			    - OV64A40_EXPOSURE_MARGIN;
++		int exp_val = min(ov64a40->exposure->cur.val, exp_max);
++
++		__v4l2_ctrl_modify_range(ov64a40->exposure,
++					 ov64a40->exposure->minimum,
++					 exp_max, 1, exp_val);
++	}
++
++	pm_status = pm_runtime_get_if_active(ov64a40->dev, true);
++	if (!pm_status)
++		return 0;
++
++	switch (ctrl->id) {
++	case V4L2_CID_EXPOSURE:
++		ret = cci_write(ov64a40->cci, OV64A40_REG_MEC_LONG_EXPO,
++				ctrl->val, NULL);
++		break;
++	case V4L2_CID_ANALOGUE_GAIN:
++		ret = cci_write(ov64a40->cci, OV64A40_REG_MEC_LONG_GAIN,
++				ctrl->val << 1, NULL);
++		break;
++	case V4L2_CID_VBLANK: {
++		int vts = ctrl->val + ov64a40->mode->height;
++
++		cci_write(ov64a40->cci, OV64A40_REG_TIMINGS_VTS_LOW, vts, &ret);
++		cci_write(ov64a40->cci, OV64A40_REG_TIMINGS_VTS_MID,
++			  (vts >> 8), &ret);
++		cci_write(ov64a40->cci, OV64A40_REG_TIMINGS_VTS_HIGH,
++			  (vts >> 16), &ret);
++		break;
++	}
++	case V4L2_CID_VFLIP:
++		ret = cci_update_bits(ov64a40->cci, OV64A40_REG_TIMING_CTRL_20,
++				      OV64A40_TIMING_CTRL_20_VFLIP,
++				      ctrl->val << 2,
++				      NULL);
++		break;
++	case V4L2_CID_HFLIP:
++		ret = cci_update_bits(ov64a40->cci, OV64A40_REG_TIMING_CTRL_21,
++				      OV64A40_TIMING_CTRL_21_HFLIP,
++				      ctrl->val ? 0
++						: OV64A40_TIMING_CTRL_21_HFLIP,
++				      NULL);
++		break;
++	case V4L2_CID_TEST_PATTERN:
++		ret = cci_write(ov64a40->cci, OV64A40_REG_TEST_PATTERN,
++				ov64a40_test_pattern_val[ctrl->val], NULL);
++		break;
++	case V4L2_CID_LINK_FREQ:
++		ret = ov64a40_link_freq_config(ov64a40, ctrl->val);
++		break;
++	default:
++		dev_err(ov64a40->dev, "Unhandled control: %#x\n", ctrl->id);
++		ret = -EINVAL;
++		break;
++	}
++
++	if (pm_status > 0) {
++		pm_runtime_mark_last_busy(ov64a40->dev);
++		pm_runtime_put_autosuspend(ov64a40->dev);
++	}
++
++	return ret;
++}
++
++static const struct v4l2_ctrl_ops ov64a40_ctrl_ops = {
++	.s_ctrl = ov64a40_set_ctrl,
++};
++
++static int ov64a40_init_controls(struct ov64a40 *ov64a40)
++{
++	int exp_max, hblank_val, vblank_max, vblank_def;
++	struct v4l2_ctrl_handler *hdlr = &ov64a40->ctrl_handler;
++	struct v4l2_fwnode_device_properties props;
++	const struct ov64a40_timings *timings;
++	int ret;
++
++	ret = v4l2_ctrl_handler_init(hdlr, 11);
++	if (ret)
++		return ret;
++
++	v4l2_ctrl_new_std(hdlr, &ov64a40_ctrl_ops, V4L2_CID_PIXEL_RATE,
++			  OV64A40_PIXEL_RATE, OV64A40_PIXEL_RATE,  1,
++			  OV64A40_PIXEL_RATE);
++
++	ov64a40->link_freq =
++		v4l2_ctrl_new_int_menu(hdlr, &ov64a40_ctrl_ops,
++				       V4L2_CID_LINK_FREQ,
++				       ov64a40->num_link_frequencies - 1,
++				       0, ov64a40->link_frequencies);
++
++	v4l2_ctrl_new_std_menu_items(hdlr, &ov64a40_ctrl_ops,
++				     V4L2_CID_TEST_PATTERN,
++				     ARRAY_SIZE(ov64a40_test_pattern_menu) - 1,
++				     0, 0, ov64a40_test_pattern_menu);
++
++	timings = ov64a40_get_timings(ov64a40, 0);
++	exp_max = timings->vts - OV64A40_EXPOSURE_MARGIN;
++	ov64a40->exposure = v4l2_ctrl_new_std(hdlr, &ov64a40_ctrl_ops,
++					      V4L2_CID_EXPOSURE,
++					      OV64A40_EXPOSURE_MIN, exp_max, 1,
++					      OV64A40_EXPOSURE_MIN);
++
++	hblank_val = timings->ppl * 4 - ov64a40->mode->width;
++	ov64a40->hblank = v4l2_ctrl_new_std(hdlr, &ov64a40_ctrl_ops,
++					    V4L2_CID_HBLANK, hblank_val,
++					    hblank_val, 1, hblank_val);
++	if (ov64a40->hblank)
++		ov64a40->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
++
++	vblank_def = timings->vts - ov64a40->mode->height;
++	vblank_max = OV64A40_VTS_MAX - ov64a40->mode->height;
++	ov64a40->vblank = v4l2_ctrl_new_std(hdlr, &ov64a40_ctrl_ops,
++					    V4L2_CID_VBLANK, OV64A40_VBLANK_MIN,
++					    vblank_max, 1, vblank_def);
++
++	v4l2_ctrl_new_std(hdlr, &ov64a40_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
++			  OV64A40_ANA_GAIN_MIN, OV64A40_ANA_GAIN_MAX, 1,
++			  OV64A40_ANA_GAIN_DEFAULT);
++
++	ov64a40->hflip = v4l2_ctrl_new_std(hdlr, &ov64a40_ctrl_ops,
++					   V4L2_CID_HFLIP, 0, 1, 1, 0);
++	if (ov64a40->hflip)
++		ov64a40->hflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;
++
++	ov64a40->vflip = v4l2_ctrl_new_std(hdlr, &ov64a40_ctrl_ops,
++					   V4L2_CID_VFLIP, 0, 1, 1, 0);
++	if (ov64a40->vflip)
++		ov64a40->vflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;
++
++	if (hdlr->error) {
++		ret = hdlr->error;
++		dev_err(ov64a40->dev, "control init failed: %d\n", ret);
++		goto error_free_hdlr;
++	}
++
++	ret = v4l2_fwnode_device_parse(ov64a40->dev, &props);
++	if (ret)
++		goto error_free_hdlr;
++
++	ret = v4l2_ctrl_new_fwnode_properties(hdlr, &ov64a40_ctrl_ops,
++					      &props);
++	if (ret)
++		goto error_free_hdlr;
++
++	ov64a40->sd.ctrl_handler = hdlr;
++
++	return 0;
++
++error_free_hdlr:
++	v4l2_ctrl_handler_free(hdlr);
++	return ret;
++}
++
++static int ov64a40_identify(struct ov64a40 *ov64a40)
++{
++	int ret;
++	u64 id;
++
++	ret = cci_read(ov64a40->cci, OV64A40_REG_CHIP_ID, &id, NULL);
++	if (ret) {
++		dev_err(ov64a40->dev, "Failed to read chip id: %d\n", ret);
++		return ret;
++	}
++
++	if (id != OV64A40_CHIP_ID) {
++		dev_err(ov64a40->dev, "chip id mismatch: %#llx\n", id);
++		return -ENODEV;
++	}
++
++	dev_dbg(ov64a40->dev, "OV64A40 chip identified: %#llx\n", id);
++
++	return 0;
++}
++
++static int ov64a40_parse_dt(struct ov64a40 *ov64a40)
++{
++	struct v4l2_fwnode_endpoint v4l2_fwnode = {
++		.bus_type = V4L2_MBUS_CSI2_DPHY
++	};
++	struct fwnode_handle *endpoint;
++	int ret = -EINVAL;
++	unsigned int i;
++
++	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(ov64a40->dev),
++						  NULL);
++	if (!endpoint) {
++		dev_err(ov64a40->dev, "Failed to find endpoint\n");
++		return -EINVAL;
++	}
++
++	if (v4l2_fwnode_endpoint_alloc_parse(endpoint, &v4l2_fwnode)) {
++		dev_err(ov64a40->dev, "Failed to parse endpoint\n");
++		goto error_put_fwnode;
++
++	}
++
++	if (v4l2_fwnode.bus.mipi_csi2.num_data_lanes != 2) {
++		dev_err(ov64a40->dev, "Unsupported number of data lanes: %u\n",
++			v4l2_fwnode.bus.mipi_csi2.num_data_lanes);
++		goto error_free_fwnode;
++	}
++
++	if (!v4l2_fwnode.nr_of_link_frequencies) {
++		dev_warn(ov64a40->dev, "no link frequencies defined\n");
++		goto error_free_fwnode;
++	}
++
++	if (v4l2_fwnode.nr_of_link_frequencies > 2) {
++		dev_warn(ov64a40->dev,
++			 "Unsupported number of link frequencies\n");
++		goto error_free_fwnode;
++	}
++
++	ov64a40->link_frequencies =
++		devm_kcalloc(ov64a40->dev, v4l2_fwnode.nr_of_link_frequencies,
++			     sizeof(v4l2_fwnode.link_frequencies[0]),
++			     GFP_KERNEL);
++	if (!ov64a40->link_frequencies)  {
++		ret = -ENOMEM;
++		goto error_free_fwnode;
++	}
++	ov64a40->num_link_frequencies = v4l2_fwnode.nr_of_link_frequencies;
++
++	for (i = 0; i < v4l2_fwnode.nr_of_link_frequencies; ++i) {
++		if (v4l2_fwnode.link_frequencies[i] != OV64A40_LINK_FREQ_360M &&
++		    v4l2_fwnode.link_frequencies[i] != OV64A40_LINK_FREQ_456M) {
++			dev_err(ov64a40->dev,
++				"Unsupported link frequency %lld\n",
++				v4l2_fwnode.link_frequencies[i]);
++			goto error_free_fwnode;
++		}
++
++		ov64a40->link_frequencies[i] = v4l2_fwnode.link_frequencies[i];
++	}
++
++	v4l2_fwnode_endpoint_free(&v4l2_fwnode);
++
++	/* Register the subdev on the endpoint, so don't put it yet. */
++	ov64a40->sd.fwnode = endpoint;
++
++	return 0;
++
++error_free_fwnode:
++	v4l2_fwnode_endpoint_free(&v4l2_fwnode);
++error_put_fwnode:
++	fwnode_handle_put(endpoint);
++	return ret;
++}
++
++static int ov64a40_get_regulators(struct ov64a40 *ov64a40)
++{
++	struct i2c_client *client = v4l2_get_subdevdata(&ov64a40->sd);
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(ov64a40_supply_names); i++)
++		ov64a40->supplies[i].supply = ov64a40_supply_names[i];
++
++	return devm_regulator_bulk_get(&client->dev,
++				       ARRAY_SIZE(ov64a40_supply_names),
++				       ov64a40->supplies);
++}
++
++static int ov64a40_probe(struct i2c_client *client)
++{
++	struct ov64a40 *ov64a40;
++	u32 xclk_freq;
++	int ret;
++
++	ov64a40 = devm_kzalloc(&client->dev, sizeof(*ov64a40), GFP_KERNEL);
++	if (!ov64a40)
++		return -ENOMEM;
++
++	ov64a40->dev = &client->dev;
++	v4l2_i2c_subdev_init(&ov64a40->sd, client, &ov64a40_subdev_ops);
++
++	ov64a40->cci = devm_cci_regmap_init_i2c(client, 16);
++	if (IS_ERR(ov64a40->cci)) {
++		dev_err(&client->dev, "Failed to initialize CCI\n");
++		return PTR_ERR(ov64a40->cci);
++	}
++
++	ov64a40->xclk = devm_clk_get(&client->dev, NULL);
++	if (!ov64a40->xclk)
++		return dev_err_probe(&client->dev, PTR_ERR(ov64a40->xclk),
++				     "Failed to get clock\n");
++
++	xclk_freq = clk_get_rate(ov64a40->xclk);
++	if (xclk_freq != OV64A40_XCLK_FREQ) {
++		dev_err(&client->dev, "Unsupported xclk frequency %u\n",
++			xclk_freq);
++		return -EINVAL;
++	}
++
++	ret = ov64a40_get_regulators(ov64a40);
++	if (ret)
++		return ret;
++
++	ov64a40->reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",
++						      GPIOD_OUT_LOW);
++	if (IS_ERR(ov64a40->reset_gpio))
++		return dev_err_probe(&client->dev, PTR_ERR(ov64a40->reset_gpio),
++				     "Failed to get reset gpio\n");
++
++	ret = ov64a40_parse_dt(ov64a40);
++	if (ret)
++		return ret;
++
++	ret = ov64a40_power_on(&client->dev);
++	if (ret)
++		goto error_put_fwnode;
++
++	ret = ov64a40_identify(ov64a40);
++	if (ret)
++		goto error_poweroff;
++
++	ov64a40->mode = &ov64a40_modes[0];
++
++	pm_runtime_set_active(&client->dev);
++	pm_runtime_get_noresume(&client->dev);
++	pm_runtime_enable(&client->dev);
++	pm_runtime_set_autosuspend_delay(&client->dev, 1000);
++	pm_runtime_use_autosuspend(&client->dev);
++
++	ret = ov64a40_init_controls(ov64a40);
++	if (ret)
++		goto error_poweroff;
++
++	/* Initialize subdev */
++	ov64a40->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE
++			  | V4L2_SUBDEV_FL_HAS_EVENTS;
++	ov64a40->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
++
++	ov64a40->pad.flags = MEDIA_PAD_FL_SOURCE;
++	ret = media_entity_pads_init(&ov64a40->sd.entity, 1, &ov64a40->pad);
++	if (ret) {
++		dev_err(&client->dev, "failed to init entity pads: %d\n", ret);
++		goto error_handler_free;
++	}
++
++	ov64a40->sd.state_lock = ov64a40->ctrl_handler.lock;
++	ret = v4l2_subdev_init_finalize(&ov64a40->sd);
++	if (ret < 0) {
++		dev_err(&client->dev, "subdev init error: %d\n", ret);
++		goto error_media_entity;
++	}
++
++	ret = v4l2_async_register_subdev_sensor(&ov64a40->sd);
++	if (ret < 0) {
++		dev_err(&client->dev,
++			"failed to register sensor sub-device: %d\n", ret);
++		goto error_subdev_cleanup;
++	}
++
++	pm_runtime_mark_last_busy(&client->dev);
++	pm_runtime_put_autosuspend(&client->dev);
++
++	return 0;
++
++error_subdev_cleanup:
++	v4l2_subdev_cleanup(&ov64a40->sd);
++error_media_entity:
++	media_entity_cleanup(&ov64a40->sd.entity);
++error_handler_free:
++	v4l2_ctrl_handler_free(ov64a40->sd.ctrl_handler);
++error_poweroff:
++	ov64a40_power_off(&client->dev);
++	pm_runtime_set_suspended(&client->dev);
++error_put_fwnode:
++	fwnode_handle_put(ov64a40->sd.fwnode);
++
++	return ret;
++}
++
++static void ov64a40_remove(struct i2c_client *client)
++{
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++	struct ov64a40 *ov64a40 = sd_to_ov64a40(sd);
++
++	v4l2_async_unregister_subdev(sd);
++	fwnode_handle_put(ov64a40->sd.fwnode);
++	v4l2_subdev_cleanup(sd);
++	media_entity_cleanup(&sd->entity);
++	v4l2_ctrl_handler_free(sd->ctrl_handler);
++
++	pm_runtime_disable(&client->dev);
++	if (!pm_runtime_status_suspended(&client->dev))
++		ov64a40_power_off(&client->dev);
++	pm_runtime_set_suspended(&client->dev);
++}
++
++static const struct of_device_id ov64a40_of_ids[] = {
++	{ .compatible = "ovti,ov64a40" },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, ov64a40_of_ids);
++
++static const struct dev_pm_ops ov64a40_pm_ops = {
++	SET_RUNTIME_PM_OPS(ov64a40_power_off, ov64a40_power_on, NULL)
++};
++
++static struct i2c_driver ov64a40_i2c_driver = {
++	.driver	= {
++		.name = "ov64a40",
++		.of_match_table	= ov64a40_of_ids,
++		.pm = &ov64a40_pm_ops,
++	},
++	.probe_new = ov64a40_probe,
++	.remove	= ov64a40_remove,
++};
++
++module_i2c_driver(ov64a40_i2c_driver);
++
++MODULE_AUTHOR("Jacopo Mondi <jacopo.mondi@ideasonboard.com>");
++MODULE_DESCRIPTION("OmniVision OV64A40 sensor driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/bcm27xx/patches-6.1/950-1196-media-i2c-Add-ROHM-BU64754-Camera-Autofocus-Actuator.patch b/target/linux/bcm27xx/patches-6.1/950-1196-media-i2c-Add-ROHM-BU64754-Camera-Autofocus-Actuator.patch
new file mode 100644
index 0000000000..a50617ee56
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1196-media-i2c-Add-ROHM-BU64754-Camera-Autofocus-Actuator.patch
@@ -0,0 +1,368 @@
+From 97ec6aeb265df0bfe7193f00c249b38873fb0fb7 Mon Sep 17 00:00:00 2001
+From: Kieran Bingham <kieran.bingham@ideasonboard.com>
+Date: Wed, 13 Sep 2023 17:53:54 +0100
+Subject: [PATCH] media: i2c: Add ROHM BU64754 Camera Autofocus Actuator
+
+Add support for the ROHM BU64754 Motor Driver for Camera Autofocus. A
+V4L2 Subdevice is registered and provides a single
+V4L2_CID_FOCUS_ABSOLUTE control.
+
+Signed-off-by: Kieran Bingham <kieran.bingham@ideasonboard.com>
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+---
+ drivers/media/i2c/Kconfig   |  13 ++
+ drivers/media/i2c/Makefile  |   1 +
+ drivers/media/i2c/bu64754.c | 315 ++++++++++++++++++++++++++++++++++++
+ 3 files changed, 329 insertions(+)
+ create mode 100644 drivers/media/i2c/bu64754.c
+
+--- a/drivers/media/i2c/Kconfig
++++ b/drivers/media/i2c/Kconfig
+@@ -917,6 +917,19 @@ config VIDEO_AK7375
+ 	  capability. This is designed for linear control of
+ 	  voice coil motors, controlled via I2C serial interface.
+ 
++config VIDEO_BU64754
++	tristate "BU64754 Motor Driver for Camera Autofocus"
++	depends on I2C && VIDEO_DEV
++	select MEDIA_CONTROLLER
++	select VIDEO_V4L2_SUBDEV_API
++	select V4L2_ASYNC
++	select V4L2_CCI_I2C
++	help
++	  This is a driver for the BU64754 Motor Driver for Camera
++	  Autofocus. The BU64754GWZ is an actuator driver IC which
++	  can be controlled the actuator position precisely using
++	  with internal Hall Sensor.
++
+ config VIDEO_DW9714
+ 	tristate "DW9714 lens voice coil support"
+ 	depends on I2C && VIDEO_DEV
+--- a/drivers/media/i2c/Makefile
++++ b/drivers/media/i2c/Makefile
+@@ -26,6 +26,7 @@ obj-$(CONFIG_VIDEO_ARDUCAM_PIVARIETY) +=
+ obj-$(CONFIG_VIDEO_BT819) += bt819.o
+ obj-$(CONFIG_VIDEO_BT856) += bt856.o
+ obj-$(CONFIG_VIDEO_BT866) += bt866.o
++obj-$(CONFIG_VIDEO_BU64754) += bu64754.o
+ obj-$(CONFIG_VIDEO_CCS) += ccs/
+ obj-$(CONFIG_VIDEO_CCS_PLL) += ccs-pll.o
+ obj-$(CONFIG_VIDEO_CS3308) += cs3308.o
+--- /dev/null
++++ b/drivers/media/i2c/bu64754.c
+@@ -0,0 +1,315 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * The BU64754GWZ is an actuator driver IC which can control the
++ * actuator position precisely using an internal Hall Sensor.
++ */
++
++#include <linux/delay.h>
++#include <linux/i2c.h>
++#include <linux/module.h>
++#include <linux/pm_runtime.h>
++#include <linux/regulator/consumer.h>
++
++#include <media/v4l2-cci.h>
++#include <media/v4l2-ctrls.h>
++#include <media/v4l2-device.h>
++
++#define BU64754_REG_ACTIVE	CCI_REG16(0x07)
++#define BU64754_ACTIVE_MODE	0x8080
++
++#define BU64754_REG_SERVE	CCI_REG16(0xd9)
++#define BU64754_SERVE_ON	0x0404
++
++#define BU64754_REG_POSITION	CCI_REG16(0x45)
++#define BU64753_POSITION_MAX	1023 /* 0x3ff */
++#define BU64753_POSITION_STEPS	1
++
++#define BU64754_POWER_ON_DELAY	800 /* uS : t1, t3 */
++
++struct bu64754 {
++	struct device *dev;
++
++	struct v4l2_ctrl_handler ctrls_vcm;
++	struct v4l2_subdev sd;
++	struct regmap *cci;
++
++	u16 current_val;
++	struct regulator *vdd;
++	struct notifier_block notifier;
++};
++
++static inline struct bu64754 *sd_to_bu64754(struct v4l2_subdev *subdev)
++{
++	return container_of(subdev, struct bu64754, sd);
++}
++
++static int bu64754_set(struct bu64754 *bu64754, u16 position)
++{
++	int ret;
++
++	position &= 0x3ff; /* BU64753_POSITION_MAX */
++	ret = cci_write(bu64754->cci, BU64754_REG_POSITION, position, NULL);
++	if (ret) {
++		dev_err(bu64754->dev, "Set position failed ret=%d\n", ret);
++		return ret;
++	}
++
++	return 0;
++}
++
++static int bu64754_active(struct bu64754 *bu64754)
++{
++	int ret;
++
++	/* Power on */
++	ret = cci_write(bu64754->cci, BU64754_REG_ACTIVE, BU64754_ACTIVE_MODE, NULL);
++	if (ret < 0) {
++		dev_err(bu64754->dev, "Failed to set active mode ret = %d\n",
++			ret);
++		return ret;
++	}
++
++	/* Serve on */
++	ret = cci_write(bu64754->cci, BU64754_REG_SERVE, BU64754_SERVE_ON, NULL);
++	if (ret < 0) {
++		dev_err(bu64754->dev, "Failed to enable serve ret = %d\n",
++			ret);
++		return ret;
++	}
++
++	return bu64754_set(bu64754, bu64754->current_val);
++}
++
++static int bu64754_standby(struct bu64754 *bu64754)
++{
++	int ret;
++
++	ret = cci_write(bu64754->cci, BU64754_REG_ACTIVE, 0, NULL);
++	if (ret < 0)
++		dev_err(bu64754->dev, "Failed to enter standby mode ret = %d\n",
++			ret);
++
++	return ret;
++}
++
++static int bu64754_regulator_event(struct notifier_block *nb,
++				   unsigned long action, void *data)
++{
++	struct bu64754 *bu64754 = container_of(nb, struct bu64754, notifier);
++
++	if (action & REGULATOR_EVENT_ENABLE) {
++		/*
++		 * Initialisation delay between VDD low->high and availability
++		 * i2c operation.
++		 */
++		usleep_range(BU64754_POWER_ON_DELAY,
++			     BU64754_POWER_ON_DELAY + 100);
++
++		bu64754_active(bu64754);
++	} else if (action & REGULATOR_EVENT_PRE_DISABLE) {
++		bu64754_standby(bu64754);
++	}
++
++	return 0;
++}
++
++static int bu64754_set_ctrl(struct v4l2_ctrl *ctrl)
++{
++	struct bu64754 *bu64754 = container_of(ctrl->handler,
++		struct bu64754, ctrls_vcm);
++
++	if (ctrl->id == V4L2_CID_FOCUS_ABSOLUTE) {
++		bu64754->current_val = ctrl->val;
++		return bu64754_set(bu64754, ctrl->val);
++	}
++
++	return -EINVAL;
++}
++
++static const struct v4l2_ctrl_ops bu64754_vcm_ctrl_ops = {
++	.s_ctrl = bu64754_set_ctrl,
++};
++
++static int bu64754_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
++{
++	return pm_runtime_resume_and_get(sd->dev);
++}
++
++static int bu64754_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
++{
++	pm_runtime_put(sd->dev);
++	return 0;
++}
++
++static const struct v4l2_subdev_internal_ops bu64754_int_ops = {
++	.open = bu64754_open,
++	.close = bu64754_close,
++};
++
++static const struct v4l2_subdev_ops bu64754_ops = { };
++
++static void bu64754_subdev_cleanup(struct bu64754 *bu64754)
++{
++	v4l2_async_unregister_subdev(&bu64754->sd);
++	v4l2_ctrl_handler_free(&bu64754->ctrls_vcm);
++	media_entity_cleanup(&bu64754->sd.entity);
++}
++
++static int bu64754_init_controls(struct bu64754 *bu64754)
++{
++	struct v4l2_ctrl_handler *hdl = &bu64754->ctrls_vcm;
++	const struct v4l2_ctrl_ops *ops = &bu64754_vcm_ctrl_ops;
++
++	v4l2_ctrl_handler_init(hdl, 1);
++
++	v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FOCUS_ABSOLUTE,
++			  0, BU64753_POSITION_MAX, BU64753_POSITION_STEPS,
++			  0);
++
++	bu64754->current_val = 0;
++
++	bu64754->sd.ctrl_handler = hdl;
++	if (hdl->error) {
++		dev_err(bu64754->dev, "%s fail error: 0x%x\n",
++			__func__, hdl->error);
++		return hdl->error;
++	}
++
++	return 0;
++}
++
++static int bu64754_probe(struct i2c_client *client)
++{
++	struct bu64754 *bu64754;
++	int ret;
++
++	bu64754 = devm_kzalloc(&client->dev, sizeof(*bu64754), GFP_KERNEL);
++	if (!bu64754)
++		return -ENOMEM;
++
++	bu64754->dev = &client->dev;
++
++	bu64754->cci = devm_cci_regmap_init_i2c(client, 8);
++	if (IS_ERR(bu64754->cci)) {
++		dev_err(bu64754->dev, "Failed to initialize CCI\n");
++		return PTR_ERR(bu64754->cci);
++	}
++
++	bu64754->vdd = devm_regulator_get_optional(&client->dev, "vdd");
++	if (IS_ERR(bu64754->vdd)) {
++		if (PTR_ERR(bu64754->vdd) != -ENODEV)
++			return PTR_ERR(bu64754->vdd);
++
++		bu64754->vdd = NULL;
++	} else {
++		bu64754->notifier.notifier_call = bu64754_regulator_event;
++
++		ret = regulator_register_notifier(bu64754->vdd,
++						  &bu64754->notifier);
++		if (ret) {
++			dev_err(bu64754->dev,
++				"could not register regulator notifier\n");
++			return ret;
++		}
++	}
++
++	v4l2_i2c_subdev_init(&bu64754->sd, client, &bu64754_ops);
++	bu64754->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
++	bu64754->sd.internal_ops = &bu64754_int_ops;
++	bu64754->sd.entity.function = MEDIA_ENT_F_LENS;
++
++	ret = bu64754_init_controls(bu64754);
++	if (ret)
++		goto err_cleanup;
++
++	ret = media_entity_pads_init(&bu64754->sd.entity, 0, NULL);
++	if (ret < 0)
++		goto err_cleanup;
++
++	bu64754->sd.entity.function = MEDIA_ENT_F_LENS;
++
++	ret = v4l2_async_register_subdev(&bu64754->sd);
++	if (ret < 0)
++		goto err_cleanup;
++
++	if (!bu64754->vdd)
++		pm_runtime_set_active(&client->dev);
++
++	pm_runtime_enable(&client->dev);
++	pm_runtime_idle(&client->dev);
++
++	return 0;
++
++err_cleanup:
++	v4l2_ctrl_handler_free(&bu64754->ctrls_vcm);
++	media_entity_cleanup(&bu64754->sd.entity);
++
++	return ret;
++}
++
++static void bu64754_remove(struct i2c_client *client)
++{
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++	struct bu64754 *bu64754 = sd_to_bu64754(sd);
++
++	if (bu64754->vdd)
++		regulator_unregister_notifier(bu64754->vdd,
++					      &bu64754->notifier);
++
++	pm_runtime_disable(&client->dev);
++
++	bu64754_subdev_cleanup(bu64754);
++}
++
++static int __maybe_unused bu64754_vcm_suspend(struct device *dev)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++	struct bu64754 *bu64754 = sd_to_bu64754(sd);
++
++	if (bu64754->vdd)
++		return regulator_disable(bu64754->vdd);
++
++	return bu64754_standby(bu64754);
++}
++
++static int  __maybe_unused bu64754_vcm_resume(struct device *dev)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	struct v4l2_subdev *sd = i2c_get_clientdata(client);
++	struct bu64754 *bu64754 = sd_to_bu64754(sd);
++
++	if (bu64754->vdd)
++		return regulator_enable(bu64754->vdd);
++
++	return bu64754_active(bu64754);
++}
++
++static const struct of_device_id bu64754_of_table[] = {
++	{ .compatible = "rohm,bu64754", },
++	{ /* sentinel */ }
++};
++
++MODULE_DEVICE_TABLE(of, bu64754_of_table);
++
++static const struct dev_pm_ops bu64754_pm_ops = {
++	SET_SYSTEM_SLEEP_PM_OPS(bu64754_vcm_suspend, bu64754_vcm_resume)
++	SET_RUNTIME_PM_OPS(bu64754_vcm_suspend, bu64754_vcm_resume, NULL)
++};
++
++static struct i2c_driver bu64754_i2c_driver = {
++	.driver = {
++		.name = "bu64754",
++		.pm = &bu64754_pm_ops,
++		.of_match_table = bu64754_of_table,
++	},
++	.probe_new = bu64754_probe,
++	.remove = bu64754_remove,
++};
++
++module_i2c_driver(bu64754_i2c_driver);
++
++MODULE_AUTHOR("Kieran Bingham");
++MODULE_DESCRIPTION("BU64754 VCM driver");
++MODULE_LICENSE("GPL");
++
diff --git a/target/linux/bcm27xx/patches-6.1/950-1197-overlays-Add-overlay-for-the-OV64A40-Arducam-Camera-.patch b/target/linux/bcm27xx/patches-6.1/950-1197-overlays-Add-overlay-for-the-OV64A40-Arducam-Camera-.patch
new file mode 100644
index 0000000000..d3ee0dc68e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1197-overlays-Add-overlay-for-the-OV64A40-Arducam-Camera-.patch
@@ -0,0 +1,426 @@
+From 7f67a45ee7c008c3d8e45fde6fa9c4287fb3bc9e Mon Sep 17 00:00:00 2001
+From: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+Date: Thu, 20 Jul 2023 13:18:34 +0200
+Subject: [PATCH] overlays: Add overlay for the OV64A40 Arducam Camera Module
+
+Arducam have integrated an Omnivision OV64A40 with a ROHM BU64754 VCM
+with a Raspberry Pi compatible cable pinout.
+
+Provide an overlay to support the module.
+
+Also add support to the camera mux overlays.
+
+Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
+Signed-off-by: Kieran Bingham <kieran.bingham@ideasonboard.com>
+---
+ arch/arm/boot/dts/overlays/Makefile           |  1 +
+ arch/arm/boot/dts/overlays/README             | 25 +++++
+ .../dts/overlays/camera-mux-2port-overlay.dts | 32 +++++++
+ .../dts/overlays/camera-mux-4port-overlay.dts | 64 +++++++++++++
+ .../arm/boot/dts/overlays/ov64a40-overlay.dts | 91 +++++++++++++++++++
+ arch/arm/boot/dts/overlays/ov64a40.dtsi       | 34 +++++++
+ 6 files changed, 247 insertions(+)
+ create mode 100644 arch/arm/boot/dts/overlays/ov64a40-overlay.dts
+ create mode 100644 arch/arm/boot/dts/overlays/ov64a40.dtsi
+
+--- a/arch/arm/boot/dts/overlays/Makefile
++++ b/arch/arm/boot/dts/overlays/Makefile
+@@ -175,6 +175,7 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
+ 	mz61581.dtbo \
+ 	ov2311.dtbo \
+ 	ov5647.dtbo \
++	ov64a40.dtbo \
+ 	ov7251.dtbo \
+ 	ov9281.dtbo \
+ 	papirus.dtbo \
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -817,6 +817,7 @@ Params: cam0-arducam-64mp       Select A
+         cam0-imx708             Select IMX708 for camera on port 0
+         cam0-ov2311             Select OV2311 for camera on port 0
+         cam0-ov5647             Select OV5647 for camera on port 0
++        cam0-ov64a40            Select OV64A40 for camera on port 0
+         cam0-ov7251             Select OV7251 for camera on port 0
+         cam0-ov9281             Select OV9281 for camera on port 0
+         cam0-imx290-clk-freq    Set clock frequency for an IMX290 on port 0
+@@ -829,6 +830,7 @@ Params: cam0-arducam-64mp       Select A
+         cam1-imx708             Select IMX708 for camera on port 1
+         cam1-ov2311             Select OV2311 for camera on port 1
+         cam1-ov5647             Select OV5647 for camera on port 1
++        cam1-ov64a40            Select OV64A40 for camera on port 1
+         cam1-ov7251             Select OV7251 for camera on port 1
+         cam1-ov9281             Select OV9281 for camera on port 1
+         cam1-imx290-clk-freq    Set clock frequency for an IMX290 on port 1
+@@ -850,6 +852,7 @@ Params: cam0-arducam-64mp       Select A
+         cam0-imx708             Select IMX708 for camera on port 0
+         cam0-ov2311             Select OV2311 for camera on port 0
+         cam0-ov5647             Select OV5647 for camera on port 0
++        cam0-ov64a40            Select OV64A40 for camera on port 0
+         cam0-ov7251             Select OV7251 for camera on port 0
+         cam0-ov9281             Select OV9281 for camera on port 0
+         cam0-imx290-clk-freq    Set clock frequency for an IMX290 on port 0
+@@ -862,6 +865,7 @@ Params: cam0-arducam-64mp       Select A
+         cam1-imx708             Select IMX708 for camera on port 1
+         cam1-ov2311             Select OV2311 for camera on port 1
+         cam1-ov5647             Select OV5647 for camera on port 1
++        cam1-ov64a40            Select OV64A40 for camera on port 1
+         cam1-ov7251             Select OV7251 for camera on port 1
+         cam1-ov9281             Select OV9281 for camera on port 1
+         cam1-imx290-clk-freq    Set clock frequency for an IMX290 on port 1
+@@ -874,6 +878,7 @@ Params: cam0-arducam-64mp       Select A
+         cam2-imx708             Select IMX708 for camera on port 2
+         cam2-ov2311             Select OV2311 for camera on port 2
+         cam2-ov5647             Select OV5647 for camera on port 2
++        cam2-ov64a40            Select OV64A40 for camera on port 2
+         cam2-ov7251             Select OV7251 for camera on port 2
+         cam2-ov9281             Select OV9281 for camera on port 2
+         cam2-imx290-clk-freq    Set clock frequency for an IMX290 on port 2
+@@ -886,6 +891,7 @@ Params: cam0-arducam-64mp       Select A
+         cam3-imx708             Select IMX708 for camera on port 3
+         cam3-ov2311             Select OV2311 for camera on port 3
+         cam3-ov5647             Select OV5647 for camera on port 3
++        cam3-ov64a40            Select OV64A40 for camera on port 3
+         cam3-ov7251             Select OV7251 for camera on port 3
+         cam3-ov9281             Select OV9281 for camera on port 3
+         cam3-imx290-clk-freq    Set clock frequency for an IMX290 on port 3
+@@ -3222,6 +3228,25 @@ Params: rotation                Mounting
+         vcm                     Configure a VCM focus drive on the sensor.
+ 
+ 
++Name:   ov64a40
++Info:   Arducam OV64A40 camera module.
++        Uses Unicam 1, which is the standard camera connector on most Pi
++        variants.
++Load:   dtoverlay=ov64a40,<param>=<val>
++Params: rotation                Mounting rotation of the camera sensor (0 or
++                                180, default 0)
++        orientation             Sensor orientation (0 = front, 1 = rear,
++                                2 = external, default external)
++        media-controller        Configure use of Media Controller API for
++                                configuring the sensor (default on)
++        cam0                    Adopt the default configuration for CAM0 on a
++                                Compute Module (CSI0, i2c_vc, and cam0_reg).
++        vcm                     Select lens driver state. Default is enabled,
++                                but vcm=off will disable.
++        link-frequency          Allowable link frequency values to use in Hz:
++                                456000000 (default), 360000000
++
++
+ Name:   ov7251
+ Info:   Omnivision OV7251 camera module.
+         Uses Unicam 1, which is the standard camera connector on most Pi
+--- a/arch/arm/boot/dts/overlays/camera-mux-2port-overlay.dts
++++ b/arch/arm/boot/dts/overlays/camera-mux-2port-overlay.dts
+@@ -189,6 +189,16 @@
+ 					#undef cam_node
+ 					#undef cam_endpoint
+ 					#undef cam1_clk
++
++					#define cam_node ov64a40_0
++					#define cam_endpoint ov64a40_0_ep
++					#define vcm_node ov64a40_0_vcm
++					#define cam1_clk clk_24mhz
++					#include "ov64a40.dtsi"
++					#undef cam_node
++					#undef cam_endpoint
++					#undef vcm_node
++					#undef cam1_clk
+ 				};
+ 
+ 				i2c@1 {
+@@ -289,6 +299,16 @@
+ 					#undef cam_node
+ 					#undef cam_endpoint
+ 					#undef cam1_clk
++
++					#define cam_node ov64a40_1
++					#define cam_endpoint ov64a40_1_ep
++					#define vcm_node ov64a40_1_vcm
++					#define cam1_clk clk_24mhz
++					#include "ov64a40.dtsi"
++					#undef cam_node
++					#undef cam_endpoint
++					#undef vcm_node
++					#undef cam1_clk
+ 				};
+ 			};
+ 		};
+@@ -450,6 +470,12 @@
+ 		cam0-ov2311 = <&mux_in0>, "remote-endpoint:0=",<&ov2311_0_ep>,
+ 			      <&ov2311_0_ep>, "remote-endpoint:0=",<&mux_in0>,
+ 			      <&ov2311_0>, "status=okay";
++		cam0-ov64a40 = <&mux_in0>, "remote-endpoint:0=",<&ov64a40_0_ep>,
++			      <&ov64a40_0_ep>, "remote-endpoint:0=",<&mux_in0>,
++			      <&mux_in0>, "clock-noncontinuous?",
++			      <&ov64a40_0>, "status=okay",
++			      <&ov64a40_0_vcm>, "status=okay",
++			      <&ov64a40_0>,"lens-focus:0=", <&ov64a40_0_vcm>;
+ 
+ 		cam1-arducam-64mp = <&mux_in1>, "remote-endpoint:0=",<&arducam_64mp_1_ep>,
+ 				    <&arducam_64mp_1_ep>, "remote-endpoint:0=",<&mux_in1>,
+@@ -496,6 +522,12 @@
+ 		cam1-ov2311 = <&mux_in1>, "remote-endpoint:0=",<&ov2311_1_ep>,
+ 			      <&ov2311_1_ep>, "remote-endpoint:0=",<&mux_in1>,
+ 			      <&ov2311_1>, "status=okay";
++		cam1-ov64a40 = <&mux_in1>, "remote-endpoint:0=",<&ov64a40_1_ep>,
++			      <&ov64a40_1_ep>, "remote-endpoint:0=",<&mux_in1>,
++			      <&mux_in1>, "clock-noncontinuous?",
++			      <&ov64a40_1>, "status=okay",
++			      <&ov64a40_1_vcm>, "status=okay",
++			      <&ov64a40_1>,"lens-focus:0=", <&ov64a40_1_vcm>;
+ 
+ 		cam0-imx290-clk-freq = <&clk_imx290>,"clock-frequency:0",
+ 				       <&imx290_0>,"clock-frequency:0";
+--- a/arch/arm/boot/dts/overlays/camera-mux-4port-overlay.dts
++++ b/arch/arm/boot/dts/overlays/camera-mux-4port-overlay.dts
+@@ -247,6 +247,16 @@
+ 					#undef cam_node
+ 					#undef cam_endpoint
+ 					#undef cam1_clk
++
++					#define cam_node ov64a40_0
++					#define cam_endpoint ov64a40_0_ep
++					#define vcm_node ov64a40_0_vcm
++					#define cam1_clk clk_24mhz
++					#include "ov64a40.dtsi"
++					#undef cam_node
++					#undef cam_endpoint
++					#undef vcm_node
++					#undef cam1_clk
+ 				};
+ 
+ 				i2c@1 {
+@@ -347,6 +357,16 @@
+ 					#undef cam_node
+ 					#undef cam_endpoint
+ 					#undef cam1_clk
++
++					#define cam_node ov64a40_1
++					#define cam_endpoint ov64a40_1_ep
++					#define vcm_node ov64a40_1_vcm
++					#define cam1_clk clk_24mhz
++					#include "ov64a40.dtsi"
++					#undef cam_node
++					#undef cam_endpoint
++					#undef vcm_node
++					#undef cam1_clk
+ 				};
+ 
+ 				i2c@2 {
+@@ -447,6 +467,16 @@
+ 					#undef cam_node
+ 					#undef cam_endpoint
+ 					#undef cam1_clk
++
++					#define cam_node ov64a40_2
++					#define cam_endpoint ov64a40_2_ep
++					#define vcm_node ov64a40_2_vcm
++					#define cam1_clk clk_24mhz
++					#include "ov64a40.dtsi"
++					#undef cam_node
++					#undef cam_endpoint
++					#undef vcm_node
++					#undef cam1_clk
+ 				};
+ 
+ 				i2c@3 {
+@@ -547,6 +577,16 @@
+ 					#undef cam_node
+ 					#undef cam_endpoint
+ 					#undef cam1_clk
++
++					#define cam_node ov64a40_3
++					#define cam_endpoint ov64a40_3_ep
++					#define vcm_node ov64a40_3_vcm
++					#define cam1_clk clk_24mhz
++					#include "ov64a40.dtsi"
++					#undef cam_node
++					#undef cam_endpoint
++					#undef vcm_node
++					#undef cam1_clk
+ 				};
+ 			};
+ 		};
+@@ -725,6 +765,12 @@
+ 		cam0-ov2311 = <&mux_in0>, "remote-endpoint:0=",<&ov2311_0_ep>,
+ 			      <&ov2311_0_ep>, "remote-endpoint:0=",<&mux_in0>,
+ 			      <&ov2311_0>, "status=okay";
++		cam0-ov64a40 = <&mux_in0>, "remote-endpoint:0=",<&ov64a40_0_ep>,
++			      <&ov64a40_0_ep>, "remote-endpoint:0=",<&mux_in0>,
++			      <&mux_in0>, "clock-noncontinuous?",
++			      <&ov64a40_0>, "status=okay",
++			      <&ov64a40_0_vcm>, "status=okay",
++			      <&ov64a40_0>,"lens-focus:0=", <&ov64a40_0_vcm>;
+ 
+ 		cam1-arducam-64mp = <&mux_in1>, "remote-endpoint:0=",<&arducam_64mp_1_ep>,
+ 				    <&arducam_64mp_1_ep>, "remote-endpoint:0=",<&mux_in1>,
+@@ -771,6 +817,12 @@
+ 		cam1-ov2311 = <&mux_in1>, "remote-endpoint:0=",<&ov2311_1_ep>,
+ 			      <&ov2311_1_ep>, "remote-endpoint:0=",<&mux_in1>,
+ 			      <&ov2311_1>, "status=okay";
++		cam1-ov64a40 = <&mux_in1>, "remote-endpoint:0=",<&ov64a40_1_ep>,
++			      <&ov64a40_1_ep>, "remote-endpoint:0=",<&mux_in1>,
++			      <&mux_in1>, "clock-noncontinuous?",
++			      <&ov64a40_1>, "status=okay",
++			      <&ov64a40_1_vcm>, "status=okay",
++			      <&ov64a40_1>,"lens-focus:0=", <&ov64a40_1_vcm>;
+ 
+ 		cam2-arducam-64mp = <&mux_in2>, "remote-endpoint:0=",<&arducam_64mp_2_ep>,
+ 				    <&arducam_64mp_2_ep>, "remote-endpoint:0=",<&mux_in2>,
+@@ -817,6 +869,12 @@
+ 		cam2-ov2311 = <&mux_in2>, "remote-endpoint:0=",<&ov2311_2_ep>,
+ 			      <&ov2311_2_ep>, "remote-endpoint:0=",<&mux_in2>,
+ 			      <&ov2311_2>, "status=okay";
++		cam2-ov64a40 = <&mux_in2>, "remote-endpoint:0=",<&ov64a40_2_ep>,
++			      <&ov64a40_2_ep>, "remote-endpoint:0=",<&mux_in2>,
++			      <&mux_in2>, "clock-noncontinuous?",
++			      <&ov64a40_2>, "status=okay",
++			      <&ov64a40_2_vcm>, "status=okay",
++			      <&ov64a40_2>,"lens-focus:0=", <&ov64a40_2_vcm>;
+ 
+ 		cam3-arducam-64mp = <&mux_in3>, "remote-endpoint:0=",<&arducam_64mp_3_ep>,
+ 				    <&arducam_64mp_3_ep>, "remote-endpoint:0=",<&mux_in3>,
+@@ -863,6 +921,12 @@
+ 		cam3-ov2311 = <&mux_in3>, "remote-endpoint:0=",<&ov2311_3_ep>,
+ 			      <&ov2311_3_ep>, "remote-endpoint:0=",<&mux_in3>,
+ 			      <&ov2311_3>, "status=okay";
++		cam3-ov64a40 = <&mux_in3>, "remote-endpoint:0=",<&ov64a40_3_ep>,
++			      <&ov64a40_3_ep>, "remote-endpoint:0=",<&mux_in3>,
++			      <&mux_in3>, "clock-noncontinuous?",
++			      <&ov64a40_3>, "status=okay",
++			      <&ov64a40_3_vcm>, "status=okay",
++			      <&ov64a40_3>,"lens-focus:0=", <&ov64a40_3_vcm>;
+ 
+ 		cam0-imx290-clk-freq = <&clk_imx290>,"clock-frequency:0",
+ 				       <&imx290_0>,"clock-frequency:0";
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/ov64a40-overlay.dts
+@@ -0,0 +1,91 @@
++// SPDX-License-Identifier: GPL-2.0-only
++// Definitions for OV64A40 camera module on VC I2C bus
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2835";
++
++	i2c_frag: fragment@0 {
++		target = <&i2c_csi_dsi>;
++		__overlay__ {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "okay";
++
++			#include "ov64a40.dtsi"
++		};
++	};
++
++	csi_frag: fragment@1 {
++		target = <&csi1>;
++		csi: __overlay__ {
++			status = "okay";
++			brcm,media-controller;
++
++			port{
++				csi_ep: endpoint{
++					remote-endpoint = <&cam_endpoint>;
++					clock-lanes = <0>;
++					data-lanes = <1 2>;
++				};
++			};
++		};
++	};
++
++	fragment@2 {
++		target = <&i2c0if>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	clk_frag: fragment@3 {
++		target = <&cam1_clk>;
++		__overlay__ {
++			clock-frequency = <24000000>;
++			status = "okay";
++		};
++	};
++
++	fragment@4 {
++		target = <&i2c0mux>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@5 {
++		target = <&cam_node>;
++		__overlay__ {
++			lens-focus = <&vcm_node>;
++		};
++	};
++
++	__overrides__ {
++		rotation = <&cam_node>,"rotation:0";
++		orientation = <&cam_node>,"orientation:0";
++		media-controller = <&csi>,"brcm,media-controller?";
++		cam0 = <&i2c_frag>, "target:0=",<&i2c_csi_dsi0>,
++		       <&csi_frag>, "target:0=",<&csi0>,
++		       <&clk_frag>, "target:0=",<&cam0_clk>,
++		       <&cam_node>, "clocks:0=",<&cam0_clk>,
++		       <&cam_node>, "avdd-supply:0=",<&cam0_reg>,
++		       <&vcm_node>, "vdd-supply:0=",<&cam0_reg>;
++		vcm = <&vcm_node>, "status",
++		      <0>, "=5";
++		link-frequency = <&cam_endpoint>,"link-frequencies#0";
++	};
++};
++
++&cam_node {
++	status = "okay";
++};
++
++&cam_endpoint {
++	remote-endpoint = <&csi_ep>;
++};
++
++&vcm_node {
++	status = "okay";
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/ov64a40.dtsi
+@@ -0,0 +1,34 @@
++// Fragment that configures an OV64A40
++
++cam_node: ov64a40@36 {
++	compatible = "ovti,ov64a40";
++	reg = <0x36>;
++	status = "disabled";
++
++	clocks = <&cam1_clk>;
++	clock-names = "xclk";
++
++	avdd-supply = <&cam1_reg>;	/* 2.8v */
++	dovdd-supply = <&cam_dummy_reg>;/* 1.8v */
++	dvdd-supply = <&cam_dummy_reg>;	/* 1.1v */
++
++	rotation = <180>;
++	orientation = <2>;
++
++	port {
++		cam_endpoint: endpoint {
++			bus-type = <4>;
++			clock-lanes = <0>;
++			data-lanes = <1 2>;
++			link-frequencies =
++				/bits/ 64 <456000000>;
++		};
++	};
++};
++
++vcm_node: bu64754@76 {
++	compatible = "rohm,bu64754";
++	reg = <0x76>;
++	status = "disabled";
++	vdd-supply = <&cam1_reg>;
++};
diff --git a/target/linux/bcm27xx/patches-6.1/950-1199-media-rp1-cfe-Fix-verbose-debug-print.patch b/target/linux/bcm27xx/patches-6.1/950-1199-media-rp1-cfe-Fix-verbose-debug-print.patch
new file mode 100644
index 0000000000..8ff96cc568
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1199-media-rp1-cfe-Fix-verbose-debug-print.patch
@@ -0,0 +1,26 @@
+From 8ef68aadaa3aa29bc2661ab44db4ddc50e77cef5 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Wed, 4 Oct 2023 11:25:16 +0300
+Subject: [PATCH] media: rp1: cfe: Fix verbose debug print
+
+Switch a debug print from cfe_dbg() to cfe_dbg_verbose() as it will be
+printed often while streaming.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -975,8 +975,8 @@ static void cfe_buffer_queue(struct vb2_
+ 
+ 	if (!cfe->job_queued && cfe->job_ready &&
+ 	    test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING)) {
+-		cfe_dbg("Preparing job immediately for channel %u\n",
+-			node->id);
++		cfe_dbg_verbose("Preparing job immediately for channel %u\n",
++				node->id);
+ 		cfe_prepare_next_job(cfe);
+ 	}
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1200-media-rp1-cfe-Expose-find_format_by_pix.patch b/target/linux/bcm27xx/patches-6.1/950-1200-media-rp1-cfe-Expose-find_format_by_pix.patch
new file mode 100644
index 0000000000..f263648af2
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1200-media-rp1-cfe-Expose-find_format_by_pix.patch
@@ -0,0 +1,33 @@
+From d978e784f433346d3676b5de805b3cea36b835c4 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 29 Sep 2023 16:23:58 +0300
+Subject: [PATCH] media: rp1: cfe: Expose find_format_by_pix()
+
+Make find_format_by_pix() accessible to other files in the driver.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.c | 2 +-
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe.h | 1 +
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -461,7 +461,7 @@ const struct cfe_fmt *find_format_by_cod
+ 	return NULL;
+ }
+ 
+-static const struct cfe_fmt *find_format_by_pix(u32 pixelformat)
++const struct cfe_fmt *find_format_by_pix(u32 pixelformat)
+ {
+ 	unsigned int i;
+ 
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.h
+@@ -36,5 +36,6 @@ extern const struct v4l2_mbus_framefmt c
+ extern const struct v4l2_mbus_framefmt cfe_default_meta_format;
+ 
+ const struct cfe_fmt *find_format_by_code(u32 code);
++const struct cfe_fmt *find_format_by_pix(u32 pixelformat);
+ 
+ #endif
diff --git a/target/linux/bcm27xx/patches-6.1/950-1201-media-rp1-cfe-Add-missing-remaps.patch b/target/linux/bcm27xx/patches-6.1/950-1201-media-rp1-cfe-Add-missing-remaps.patch
new file mode 100644
index 0000000000..d6dadb6f27
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1201-media-rp1-cfe-Add-missing-remaps.patch
@@ -0,0 +1,43 @@
+From cbed711f05a228d0f8f54b1b01f43d4d6489eccc Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 29 Sep 2023 16:24:14 +0300
+Subject: [PATCH] media: rp1: cfe: Add missing remaps
+
+8-bit bayer formats are missing remap definitions. Add them.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
+@@ -85,24 +85,28 @@ static const struct cfe_fmt formats[] =
+ 		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+ 		.depth = 8,
+ 		.csi_dt = 0x2a,
++		.remap = { V4L2_PIX_FMT_SBGGR16, V4L2_PIX_FMT_PISP_COMP1_BGGR },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_SGBRG8,
+ 		.code = MEDIA_BUS_FMT_SGBRG8_1X8,
+ 		.depth = 8,
+ 		.csi_dt = 0x2a,
++		.remap = { V4L2_PIX_FMT_SGBRG16, V4L2_PIX_FMT_PISP_COMP1_GBRG },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_SGRBG8,
+ 		.code = MEDIA_BUS_FMT_SGRBG8_1X8,
+ 		.depth = 8,
+ 		.csi_dt = 0x2a,
++		.remap = { V4L2_PIX_FMT_SGRBG16, V4L2_PIX_FMT_PISP_COMP1_GRBG },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_SRGGB8,
+ 		.code = MEDIA_BUS_FMT_SRGGB8_1X8,
+ 		.depth = 8,
+ 		.csi_dt = 0x2a,
++		.remap = { V4L2_PIX_FMT_SRGGB16, V4L2_PIX_FMT_PISP_COMP1_RGGB },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_SBGGR10P,
diff --git a/target/linux/bcm27xx/patches-6.1/950-1202-media-rp1-cfe-Add-missing-compressed-remaps.patch b/target/linux/bcm27xx/patches-6.1/950-1202-media-rp1-cfe-Add-missing-compressed-remaps.patch
new file mode 100644
index 0000000000..92d7db369c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1202-media-rp1-cfe-Add-missing-compressed-remaps.patch
@@ -0,0 +1,43 @@
+From 93c40564b94367c6ce072d66479af58afa3f08e0 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 29 Sep 2023 17:14:31 +0300
+Subject: [PATCH] media: rp1: cfe: Add missing compressed remaps
+
+16-bit bayer formats are missing compressed remap definitions. Add them.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe_fmts.h
+@@ -197,24 +197,28 @@ static const struct cfe_fmt formats[] =
+ 		.code = MEDIA_BUS_FMT_SBGGR16_1X16,
+ 		.depth = 16,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
++		.remap = { V4L2_PIX_FMT_SBGGR16, V4L2_PIX_FMT_PISP_COMP1_BGGR },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_SGBRG16,
+ 		.code = MEDIA_BUS_FMT_SGBRG16_1X16,
+ 		.depth = 16,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
++		.remap = { V4L2_PIX_FMT_SGBRG16, V4L2_PIX_FMT_PISP_COMP1_GBRG },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_SGRBG16,
+ 		.code = MEDIA_BUS_FMT_SGRBG16_1X16,
+ 		.depth = 16,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
++		.remap = { V4L2_PIX_FMT_SGRBG16, V4L2_PIX_FMT_PISP_COMP1_GRBG },
+ 	},
+ 	{
+ 		.fourcc = V4L2_PIX_FMT_SRGGB16,
+ 		.code = MEDIA_BUS_FMT_SRGGB16_1X16,
+ 		.depth = 16,
+ 		.flags = CFE_FORMAT_FLAG_FE_OUT,
++		.remap = { V4L2_PIX_FMT_SRGGB16, V4L2_PIX_FMT_PISP_COMP1_RGGB },
+ 	},
+ 	/* PiSP Compressed Mode 1 */
+ 	{
diff --git a/target/linux/bcm27xx/patches-6.1/950-1203-media-rp1-cfe-Add-cfe_find_16bit_code-and-cfe_find_c.patch b/target/linux/bcm27xx/patches-6.1/950-1203-media-rp1-cfe-Add-cfe_find_16bit_code-and-cfe_find_c.patch
new file mode 100644
index 0000000000..42c3b6f42b
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1203-media-rp1-cfe-Add-cfe_find_16bit_code-and-cfe_find_c.patch
@@ -0,0 +1,74 @@
+From 2e0e1d7b493dffe7baa763d499e51ba42f0bad19 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 29 Sep 2023 17:14:11 +0300
+Subject: [PATCH] media: rp1: cfe: Add cfe_find_16bit_code() and
+ cfe_find_compressed_code()
+
+Add helper functions which, given an mbus code, return the 16-bit
+remapped mbus code or the compressed mbus code.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 40 +++++++++++++++++++
+ .../media/platform/raspberrypi/rp1_cfe/cfe.h  |  2 +
+ 2 files changed, 42 insertions(+)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -473,6 +473,46 @@ const struct cfe_fmt *find_format_by_pix
+ 	return NULL;
+ }
+ 
++/*
++ * Given the mbus code, find the 16 bit remapped code. Returns 0 if no remap
++ * possible.
++ */
++u32 cfe_find_16bit_code(u32 code)
++{
++	const struct cfe_fmt *cfe_fmt;
++
++	cfe_fmt = find_format_by_code(code);
++
++	if (!cfe_fmt || !cfe_fmt->remap[CFE_REMAP_16BIT])
++		return 0;
++
++	cfe_fmt = find_format_by_pix(cfe_fmt->remap[CFE_REMAP_16BIT]);
++	if (!cfe_fmt)
++		return 0;
++
++	return cfe_fmt->code;
++}
++
++/*
++ * Given the mbus code, find the 8 bit compressed code. Returns 0 if no remap
++ * possible.
++ */
++u32 cfe_find_compressed_code(u32 code)
++{
++	const struct cfe_fmt *cfe_fmt;
++
++	cfe_fmt = find_format_by_code(code);
++
++	if (!cfe_fmt || !cfe_fmt->remap[CFE_REMAP_COMPRESSED])
++		return 0;
++
++	cfe_fmt = find_format_by_pix(cfe_fmt->remap[CFE_REMAP_COMPRESSED]);
++	if (!cfe_fmt)
++		return 0;
++
++	return cfe_fmt->code;
++}
++
+ static int cfe_calc_format_size_bpl(struct cfe_device *cfe,
+ 				    const struct cfe_fmt *fmt,
+ 				    struct v4l2_format *f)
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.h
+@@ -37,5 +37,7 @@ extern const struct v4l2_mbus_framefmt c
+ 
+ const struct cfe_fmt *find_format_by_code(u32 code);
+ const struct cfe_fmt *find_format_by_pix(u32 pixelformat);
++u32 cfe_find_16bit_code(u32 code);
++u32 cfe_find_compressed_code(u32 code);
+ 
+ #endif
diff --git a/target/linux/bcm27xx/patches-6.1/950-1204-media-rp1-csi2-Fix-csi2_pad_set_fmt.patch b/target/linux/bcm27xx/patches-6.1/950-1204-media-rp1-csi2-Fix-csi2_pad_set_fmt.patch
new file mode 100644
index 0000000000..d9b8d264d3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1204-media-rp1-csi2-Fix-csi2_pad_set_fmt.patch
@@ -0,0 +1,95 @@
+From eaa8a0ae14a1ca797c1896e9dafbefa1fa51a617 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 29 Sep 2023 16:25:10 +0300
+Subject: [PATCH] media: rp1: csi2: Fix csi2_pad_set_fmt()
+
+The CSI-2 subdev's set_fmt currently allows setting the source and sink
+pad formats quite freely. This is not right, as the CSI-2 block can only
+do one of the following when processing the stream: 1) pass through as
+is, 2) expand to 16-bits, 3) compress.
+
+The csi2_pad_set_fmt() should take this into account, and only allow
+changing the source side mbus code, compared to the sink side format.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/csi2.c | 61 +++++++++++++++----
+ 1 file changed, 48 insertions(+), 13 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -438,25 +438,60 @@ static int csi2_pad_set_fmt(struct v4l2_
+ 			    struct v4l2_subdev_state *state,
+ 			    struct v4l2_subdev_format *format)
+ {
+-	struct v4l2_mbus_framefmt *fmt;
+-	const struct cfe_fmt *cfe_fmt;
+-
+-	/* TODO: format validation */
++	if (format->pad < CSI2_NUM_CHANNELS) {
++		/*
++		 * Store the sink pad format and propagate it to the source pad.
++		 */
++
++		struct v4l2_mbus_framefmt *fmt;
++
++		fmt = v4l2_subdev_get_pad_format(sd, state, format->pad);
++		if (!fmt)
++			return -EINVAL;
+ 
+-	cfe_fmt = find_format_by_code(format->format.code);
+-	if (!cfe_fmt)
+-		cfe_fmt = find_format_by_code(MEDIA_BUS_FMT_SBGGR10_1X10);
++		*fmt = format->format;
+ 
+-	format->format.code = cfe_fmt->code;
++		fmt = v4l2_subdev_get_pad_format(sd, state,
++			format->pad + CSI2_NUM_CHANNELS);
++		if (!fmt)
++			return -EINVAL;
+ 
+-	fmt = v4l2_subdev_get_pad_format(sd, state, format->pad);
+-	*fmt = format->format;
++		format->format.field = V4L2_FIELD_NONE;
+ 
+-	if (format->pad < CSI2_NUM_CHANNELS) {
+-		/* Propagate to the source pad */
+-		fmt = v4l2_subdev_get_pad_format(sd, state,
+-						 format->pad + CSI2_NUM_CHANNELS);
+ 		*fmt = format->format;
++	} else {
++		/*
++		 * Only allow changing the source pad mbus code.
++		 */
++
++		struct v4l2_mbus_framefmt *sink_fmt, *source_fmt;
++		u32 sink_code;
++		u32 code;
++
++		sink_fmt = v4l2_subdev_get_pad_format(sd, state,
++			format->pad - CSI2_NUM_CHANNELS);
++		if (!sink_fmt)
++			return -EINVAL;
++
++		source_fmt = v4l2_subdev_get_pad_format(sd, state, format->pad);
++		if (!source_fmt)
++			return -EINVAL;
++
++		sink_code = sink_fmt->code;
++		code = format->format.code;
++
++		/*
++		 * If the source code from the user does not match the code in
++		 * the sink pad, check that the source code matches either the
++		 * 16-bit version or the compressed version of the sink code.
++		 */
++
++		if (code != sink_code &&
++		    (code == cfe_find_16bit_code(sink_code) ||
++		     code == cfe_find_compressed_code(sink_code)))
++			source_fmt->code = code;
++
++		format->format.code = source_fmt->code;
+ 	}
+ 
+ 	return 0;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1205-media-rp1-fe-Fix-pisp_fe_pad_set_fmt.patch b/target/linux/bcm27xx/patches-6.1/950-1205-media-rp1-fe-Fix-pisp_fe_pad_set_fmt.patch
new file mode 100644
index 0000000000..202fe2946d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1205-media-rp1-fe-Fix-pisp_fe_pad_set_fmt.patch
@@ -0,0 +1,104 @@
+From 214e8134842a338215831f2efa6d730f413c5ec4 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 29 Sep 2023 17:15:20 +0300
+Subject: [PATCH] media: rp1: fe: Fix pisp_fe_pad_set_fmt()
+
+pisp_fe_pad_set_fmt() allows setting the pad formats quite freely. This
+is not correct, and the function should only allow formats as supported
+by the hardware. Fix this by:
+
+Allow no format changes for FE_CONFIG_PAD and FE_STATS_PAD. They should
+always be the hardcoded initial ones.
+
+Allow setting FE_STREAM_PAD freely (but the mbus code must be
+supported), and propagate the format to the FE_OUTPUT0_PAD and
+FE_OUTPUT1_PAD pads.
+
+Allow changing the mbus code for FE_OUTPUT0_PAD and FE_OUTPUT1_PAD pads
+only if the mbus code is the compressed version of the sink side code.
+
+TODO: FE supports scaling and cropping. This should be represented here
+too?
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../platform/raspberrypi/rp1_cfe/pisp_fe.c    | 59 +++++++++++++++----
+ 1 file changed, 48 insertions(+), 11 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+@@ -433,26 +433,63 @@ static int pisp_fe_pad_set_fmt(struct v4
+ 
+ 	switch (format->pad) {
+ 	case FE_STREAM_PAD:
+-	case FE_OUTPUT0_PAD:
+-	case FE_OUTPUT1_PAD:
+ 		cfe_fmt = find_format_by_code(format->format.code);
+ 		if (!cfe_fmt || !(cfe_fmt->flags & CFE_FORMAT_FLAG_FE_OUT))
+ 			cfe_fmt = find_format_by_code(MEDIA_BUS_FMT_SRGGB16_1X16);
+ 
+ 		format->format.code = cfe_fmt->code;
++		format->format.field = V4L2_FIELD_NONE;
+ 
+-		break;
++		fmt = v4l2_subdev_get_pad_format(sd, state, FE_STREAM_PAD);
++		*fmt = format->format;
+ 
+-	case FE_STATS_PAD:
+-	case FE_CONFIG_PAD:
+-		format->format.code = MEDIA_BUS_FMT_FIXED;
+-		break;
+-	}
++		fmt = v4l2_subdev_get_pad_format(sd, state, FE_OUTPUT0_PAD);
++		*fmt = format->format;
++
++		fmt = v4l2_subdev_get_pad_format(sd, state, FE_OUTPUT1_PAD);
++		*fmt = format->format;
++
++		return 0;
+ 
+-	fmt = v4l2_subdev_get_pad_format(sd, state, format->pad);
+-	*fmt = format->format;
++	case FE_OUTPUT0_PAD:
++	case FE_OUTPUT1_PAD: {
++		/*
++		 * TODO: we should allow scaling and cropping by allowing the
++		 * user to set the size here.
++		 */
++		struct v4l2_mbus_framefmt *sink_fmt, *source_fmt;
++		u32 sink_code;
++		u32 code;
++
++		sink_fmt = v4l2_subdev_get_pad_format(sd, state, FE_STREAM_PAD);
++		if (!sink_fmt)
++			return -EINVAL;
++
++		source_fmt = v4l2_subdev_get_pad_format(sd, state, format->pad);
++		if (!source_fmt)
++			return -EINVAL;
++
++		sink_code = sink_fmt->code;
++		code = format->format.code;
++
++		/*
++		 * If the source code from the user does not match the code in
++		 * the sink pad, check that the source code matches the
++		 * compressed version of the sink code.
++		 */
++
++		if (code != sink_code &&
++		    code == cfe_find_compressed_code(sink_code))
++			source_fmt->code = code;
++
++		return 0;
++	}
+ 
+-	return 0;
++	case FE_CONFIG_PAD:
++	case FE_STATS_PAD:
++	default:
++		return v4l2_subdev_get_fmt(sd, state, format);
++	}
+ }
+ 
+ static int pisp_fe_link_validate(struct v4l2_subdev *sd,
diff --git a/target/linux/bcm27xx/patches-6.1/950-1206-media-rp1-csi2-Use-get_frame_desc-to-get-CSI-2-VC-an.patch b/target/linux/bcm27xx/patches-6.1/950-1206-media-rp1-csi2-Use-get_frame_desc-to-get-CSI-2-VC-an.patch
new file mode 100644
index 0000000000..bd5789a1b3
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1206-media-rp1-csi2-Use-get_frame_desc-to-get-CSI-2-VC-an.patch
@@ -0,0 +1,146 @@
+From 425a6b752c38b50c97220db37a67b18b281f56e5 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Thu, 21 Sep 2023 15:28:20 +0300
+Subject: [PATCH] media: rp1: csi2: Use get_frame_desc to get CSI-2 VC and DT
+
+Use get_frame_desc pad op for asking the CSI-2 VC and DT from the source
+device driver, instead of hardcoding to VC 0, and getting the DT from a
+formats table. To keep backward compatibility with sources that do not
+implement get_frame_desc, implement a fallback mechanism that always
+uses VC 0, and gets the DT from the formats table, based on the CSI2's
+sink pad's format.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  |  4 +-
+ .../media/platform/raspberrypi/rp1_cfe/csi2.c | 75 ++++++++++++++++++-
+ .../media/platform/raspberrypi/rp1_cfe/csi2.h |  2 +-
+ 3 files changed, 77 insertions(+), 4 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -838,7 +838,7 @@ static void cfe_start_channel(struct cfe
+ 		 * this is handled by the CSI2 AUTO_ARM mode.
+ 		 */
+ 		csi2_start_channel(&cfe->csi2, cfe->fe_csi2_channel,
+-				   fmt->csi_dt, CSI2_MODE_FE_STREAMING,
++				   CSI2_MODE_FE_STREAMING,
+ 				   true, false, width, height);
+ 		csi2_set_buffer(&cfe->csi2, cfe->fe_csi2_channel, 0, 0, -1);
+ 		pisp_fe_start(&cfe->fe);
+@@ -872,7 +872,7 @@ static void cfe_start_channel(struct cfe
+ 			}
+ 		}
+ 		/* Unconditionally start this CSI2 channel. */
+-		csi2_start_channel(&cfe->csi2, node->id, fmt->csi_dt,
++		csi2_start_channel(&cfe->csi2, node->id,
+ 				   mode,
+ 				   /* Auto arm */
+ 				   false,
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -324,12 +324,84 @@ void csi2_set_compression(struct csi2_de
+ 	csi2_reg_write(csi2, CSI2_CH_COMP_CTRL(channel), compression);
+ }
+ 
++static int csi2_get_vc_dt_fallback(struct csi2_device *csi2,
++				   unsigned int channel, u8 *vc, u8 *dt)
++{
++	struct v4l2_subdev *sd = &csi2->sd;
++	struct v4l2_subdev_state *state;
++	struct v4l2_mbus_framefmt *fmt;
++	const struct cfe_fmt *cfe_fmt;
++
++	state = v4l2_subdev_get_locked_active_state(sd);
++
++	/* Without Streams API, the channel number matches the sink pad */
++	fmt = v4l2_subdev_get_pad_format(sd, state, channel);
++	if (!fmt)
++		return -EINVAL;
++
++	cfe_fmt = find_format_by_code(fmt->code);
++	if (!cfe_fmt)
++		return -EINVAL;
++
++	*vc = 0;
++	*dt = cfe_fmt->csi_dt;
++
++	return 0;
++}
++
++static int csi2_get_vc_dt(struct csi2_device *csi2, unsigned int channel,
++			  u8 *vc, u8 *dt)
++{
++	struct v4l2_mbus_frame_desc remote_desc;
++	const struct media_pad *remote_pad;
++	struct v4l2_subdev *source_sd;
++	int ret;
++
++	/* Without Streams API, the channel number matches the sink pad */
++	remote_pad = media_pad_remote_pad_first(&csi2->pad[channel]);
++	if (!remote_pad)
++		return -EPIPE;
++
++	source_sd = media_entity_to_v4l2_subdev(remote_pad->entity);
++
++	ret = v4l2_subdev_call(source_sd, pad, get_frame_desc,
++			       remote_pad->index, &remote_desc);
++	if (ret == -ENOIOCTLCMD) {
++		csi2_dbg("source does not support get_frame_desc, use fallback\n");
++		return csi2_get_vc_dt_fallback(csi2, channel, vc, dt);
++	} else if (ret) {
++		csi2_err("Failed to get frame descriptor\n");
++		return ret;
++	}
++
++	if (remote_desc.type != V4L2_MBUS_FRAME_DESC_TYPE_CSI2) {
++		csi2_err("Frame descriptor does not describe CSI-2 link");
++		return -EINVAL;
++	}
++
++	if (remote_desc.num_entries != 1) {
++		csi2_err("Frame descriptor does not have a single entry");
++		return -EINVAL;
++	}
++
++	*vc = remote_desc.entry[0].bus.csi2.vc;
++	*dt = remote_desc.entry[0].bus.csi2.dt;
++
++	return 0;
++}
++
+ void csi2_start_channel(struct csi2_device *csi2, unsigned int channel,
+-			u16 dt, enum csi2_mode mode, bool auto_arm,
++			enum csi2_mode mode, bool auto_arm,
+ 			bool pack_bytes, unsigned int width,
+ 			unsigned int height)
+ {
+ 	u32 ctrl;
++	int ret;
++	u8 vc, dt;
++
++	ret = csi2_get_vc_dt(csi2, channel, &vc, &dt);
++	if (ret)
++		return;
+ 
+ 	csi2_dbg("%s [%u]\n", __func__, channel);
+ 
+@@ -369,6 +441,7 @@ void csi2_start_channel(struct csi2_devi
+ 		csi2_reg_write(csi2, CSI2_CH_FRAME_SIZE(channel), 0);
+ 	}
+ 
++	set_field(&ctrl, vc, VC_MASK);
+ 	set_field(&ctrl, dt, DT_MASK);
+ 	csi2_reg_write(csi2, CSI2_CH_CTRL(channel), ctrl);
+ 	csi2->num_lines[channel] = height;
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
+@@ -79,7 +79,7 @@ void csi2_set_compression(struct csi2_de
+ 			  enum csi2_compression_mode mode, unsigned int shift,
+ 			  unsigned int offset);
+ void csi2_start_channel(struct csi2_device *csi2, unsigned int channel,
+-			u16 dt, enum csi2_mode mode, bool auto_arm,
++			enum csi2_mode mode, bool auto_arm,
+ 			bool pack_bytes, unsigned int width,
+ 			unsigned int height);
+ void csi2_stop_channel(struct csi2_device *csi2, unsigned int channel);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1207-media-rp1-cfe-Add-is_image_node.patch b/target/linux/bcm27xx/patches-6.1/950-1207-media-rp1-cfe-Add-is_image_node.patch
new file mode 100644
index 0000000000..ad589d79cf
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1207-media-rp1-cfe-Add-is_image_node.patch
@@ -0,0 +1,91 @@
+From 2b6570e66f2769110311593f52f88dba3271a278 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Fri, 22 Sep 2023 13:47:10 +0300
+Subject: [PATCH] media: rp1: cfe: Add is_image_node()
+
+The hardware supports streaming from memory (in addition to streaming
+from the CSI-2 RX), but the driver does not support this at the moment.
+
+There are multiple places in the driver which uses
+is_image_output_node(), even if the "output" part is not relevant. Thus,
+in a minor preparation for the possible support for streaming from
+memory, and to make it more obvious that the pieces of code are not
+about the "output", add is_image_node() which will return true for both
+input and output video nodes.
+
+While at it, reformat also the metadata related macros to fit inside 80
+columns.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 28 +++++++++++--------
+ 1 file changed, 17 insertions(+), 11 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -199,13 +199,20 @@ static const struct node_description nod
+ 
+ #define is_fe_node(node) (((node)->id) >= FE_OUT0)
+ #define is_csi2_node(node) (!is_fe_node(node))
+-#define is_image_output_node(node)                                               \
++
++#define is_image_output_node(node) \
+ 	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+-#define is_meta_output_node(node)                                                \
++#define is_image_input_node(node) \
++	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
++#define is_image_node(node) \
++	(is_image_output_node(node) || is_image_input_node(node))
++
++#define is_meta_output_node(node) \
+ 	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_META_CAPTURE)
+-#define is_meta_input_node(node)                                                 \
++#define is_meta_input_node(node) \
+ 	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_META_OUTPUT)
+-#define is_meta_node(node) (is_meta_output_node(node) || is_meta_input_node(node))
++#define is_meta_node(node) \
++	(is_meta_output_node(node) || is_meta_input_node(node))
+ 
+ /* To track state across all nodes. */
+ #define NUM_STATES		5
+@@ -426,7 +433,7 @@ static int format_show(struct seq_file *
+ 		seq_printf(s, "\nNode %u (%s) state: 0x%lx\n", i,
+ 			   node_desc[i].name, state);
+ 
+-		if (is_image_output_node(node))
++		if (is_image_node(node))
+ 			seq_printf(s, "format: " V4L2_FOURCC_CONV " 0x%x\n"
+ 				      "resolution: %ux%u\nbpl: %u\nsize: %u\n",
+ 				   V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.pix.pixelformat),
+@@ -940,9 +947,8 @@ static int cfe_queue_setup(struct vb2_qu
+ {
+ 	struct cfe_node *node = vb2_get_drv_priv(vq);
+ 	struct cfe_device *cfe = node->cfe;
+-	unsigned int size = is_image_output_node(node) ?
+-					  node->fmt.fmt.pix.sizeimage :
+-					  node->fmt.fmt.meta.buffersize;
++	unsigned int size = is_image_node(node) ? node->fmt.fmt.pix.sizeimage :
++						  node->fmt.fmt.meta.buffersize;
+ 
+ 	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
+ 
+@@ -973,8 +979,8 @@ static int cfe_buffer_prepare(struct vb2
+ 	cfe_dbg_verbose("%s: [%s] buffer:%p\n", __func__,
+ 			node_desc[node->id].name, vb);
+ 
+-	size = is_image_output_node(node) ? node->fmt.fmt.pix.sizeimage :
+-					    node->fmt.fmt.meta.buffersize;
++	size = is_image_node(node) ? node->fmt.fmt.pix.sizeimage :
++				     node->fmt.fmt.meta.buffersize;
+ 	if (vb2_plane_size(vb, 0) < size) {
+ 		cfe_err("data will not fit into plane (%lu < %lu)\n",
+ 			vb2_plane_size(vb, 0), size);
+@@ -1757,7 +1763,7 @@ static int cfe_register_node(struct cfe_
+ 	node->cfe = cfe;
+ 	node->id = id;
+ 
+-	if (is_image_output_node(node)) {
++	if (is_image_node(node)) {
+ 		fmt = find_format_by_code(cfe_default_format.code);
+ 		if (!fmt) {
+ 			cfe_err("Failed to find format code\n");
diff --git a/target/linux/bcm27xx/patches-6.1/950-1208-media-rp1-cfe-Dual-purpose-video-nodes.patch b/target/linux/bcm27xx/patches-6.1/950-1208-media-rp1-cfe-Dual-purpose-video-nodes.patch
new file mode 100644
index 0000000000..f68aa3975d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1208-media-rp1-cfe-Dual-purpose-video-nodes.patch
@@ -0,0 +1,621 @@
+From c54b8d2fc79c684deacc81a94f6baa1cb56c62be Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Wed, 27 Sep 2023 17:18:09 +0300
+Subject: [PATCH] media: rp1: cfe: Dual purpose video nodes
+
+The RP1 CSI-2 DMA can capture both video and metadata just fine, but at
+the moment the video nodes are only set to support either video or
+metadata.
+
+Make the changes to support both video and metadata. This mostly means
+tracking both video format and metadata format separately for each video
+node, and using vb2_queue_change_type() to change the vb2 queue type
+when needed.
+
+Briefly, this means that the user can get/set both video and meta
+formats to a single video node. The vb2 queue buffer type will be
+changed when the user calls REQBUFS or CREATE_BUFS ioctls. This buffer
+type will be then used as the "mode" for the video node when the user
+starts the streaming, and based on that either the video or the meta
+format will be used.
+
+A bunch of macros are added (node_supports_xxx()), which tell if a node
+can support a particular mode, whereas the existing macros
+(is_xxx_node()) will tell if the node is currently in a particular mode.
+Note that the latter will only work correctly between the start of the
+streaming and the end of the streaming, and thus should be only used in
+those code paths.
+
+However, as the userspace (libcamera) does not support dual purpose
+video nodes, for the time being let's keep the second video node as
+V4L2_CAP_META_CAPTURE only to keep the userspace working.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 271 ++++++++++++------
+ 1 file changed, 182 insertions(+), 89 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -116,7 +116,7 @@ const struct v4l2_mbus_framefmt cfe_defa
+ enum node_ids {
+ 	/* CSI2 HW output nodes first. */
+ 	CSI2_CH0,
+-	CSI2_CH1_EMBEDDED,
++	CSI2_CH1,
+ 	CSI2_CH2,
+ 	CSI2_CH3,
+ 	/* FE only nodes from here on. */
+@@ -130,8 +130,7 @@ enum node_ids {
+ struct node_description {
+ 	unsigned int id;
+ 	const char *name;
+-	enum v4l2_buf_type buf_type;
+-	unsigned int cap;
++	unsigned int caps;
+ 	unsigned int pad_flags;
+ 	unsigned int link_pad;
+ };
+@@ -140,58 +139,55 @@ struct node_description {
+ static const struct node_description node_desc[NUM_NODES] = {
+ 	[CSI2_CH0] = {
+ 		.name = "csi2_ch0",
+-		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+-		.cap = V4L2_CAP_VIDEO_CAPTURE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_META_CAPTURE,
+ 		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
+ 		.link_pad = CSI2_NUM_CHANNELS + 0
+ 	},
+-	/* This node is assigned for the embedded data channel! */
+-	[CSI2_CH1_EMBEDDED] = {
++	/*
++	 * TODO: This node should be named "csi2_ch1" and the caps should be set
++	 * to both video and meta capture. However, to keep compatibility with
++	 * the current libcamera, keep the name as "embedded" and support
++	 * only meta capture.
++	 */
++	[CSI2_CH1] = {
+ 		.name = "embedded",
+-		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+-		.cap = V4L2_CAP_META_CAPTURE,
++		.caps = V4L2_CAP_META_CAPTURE,
+ 		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
+ 		.link_pad = CSI2_NUM_CHANNELS + 1
+ 	},
+ 	[CSI2_CH2] = {
+ 		.name = "csi2_ch2",
+-		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+-		.cap = V4L2_CAP_META_CAPTURE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_META_CAPTURE,
+ 		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
+ 		.link_pad = CSI2_NUM_CHANNELS + 2
+ 	},
+ 	[CSI2_CH3] = {
+ 		.name = "csi2_ch3",
+-		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+-		.cap = V4L2_CAP_META_CAPTURE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_META_CAPTURE,
+ 		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
+ 		.link_pad = CSI2_NUM_CHANNELS + 3
+ 	},
+ 	[FE_OUT0] = {
+ 		.name = "fe_image0",
+-		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+-		.cap = V4L2_CAP_VIDEO_CAPTURE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE,
+ 		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
+ 		.link_pad = FE_OUTPUT0_PAD
+ 	},
+ 	[FE_OUT1] = {
+ 		.name = "fe_image1",
+-		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+-		.cap = V4L2_CAP_VIDEO_CAPTURE,
++		.caps = V4L2_CAP_VIDEO_CAPTURE,
+ 		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
+ 		.link_pad = FE_OUTPUT1_PAD
+ 	},
+ 	[FE_STATS] = {
+ 		.name = "fe_stats",
+-		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+-		.cap = V4L2_CAP_META_CAPTURE,
++		.caps = V4L2_CAP_META_CAPTURE,
+ 		.pad_flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT,
+ 		.link_pad = FE_STATS_PAD
+ 	},
+ 	[FE_CONFIG] = {
+ 		.name = "fe_config",
+-		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+-		.cap = V4L2_CAP_META_OUTPUT,
++		.caps = V4L2_CAP_META_OUTPUT,
+ 		.pad_flags = MEDIA_PAD_FL_SOURCE | MEDIA_PAD_FL_MUST_CONNECT,
+ 		.link_pad = FE_CONFIG_PAD
+ 	},
+@@ -200,17 +196,29 @@ static const struct node_description nod
+ #define is_fe_node(node) (((node)->id) >= FE_OUT0)
+ #define is_csi2_node(node) (!is_fe_node(node))
+ 
++#define node_supports_image_output(node) \
++	(!!(node_desc[(node)->id].caps & V4L2_CAP_VIDEO_CAPTURE))
++#define node_supports_meta_output(node) \
++	(!!(node_desc[(node)->id].caps & V4L2_CAP_META_CAPTURE))
++#define node_supports_image_input(node) \
++	(!!(node_desc[(node)->id].caps & V4L2_CAP_VIDEO_OUTPUT))
++#define node_supports_meta_input(node) \
++	(!!(node_desc[(node)->id].caps & V4L2_CAP_META_OUTPUT))
++#define node_supports_image(node) \
++	(node_supports_image_output(node) || node_supports_image_input(node))
++#define node_supports_meta(node) \
++	(node_supports_meta_output(node) || node_supports_meta_input(node))
++
+ #define is_image_output_node(node) \
+-	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
++	((node)->buffer_queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+ #define is_image_input_node(node) \
+-	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
++	((node)->buffer_queue.type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+ #define is_image_node(node) \
+ 	(is_image_output_node(node) || is_image_input_node(node))
+-
+ #define is_meta_output_node(node) \
+-	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_META_CAPTURE)
++	((node)->buffer_queue.type == V4L2_BUF_TYPE_META_CAPTURE)
+ #define is_meta_input_node(node) \
+-	(node_desc[(node)->id].buf_type == V4L2_BUF_TYPE_META_OUTPUT)
++	((node)->buffer_queue.type == V4L2_BUF_TYPE_META_OUTPUT)
+ #define is_meta_node(node) \
+ 	(is_meta_output_node(node) || is_meta_input_node(node))
+ 
+@@ -250,7 +258,9 @@ struct cfe_node {
+ 	/* Pointer pointing to next v4l2_buffer */
+ 	struct cfe_buffer *next_frm;
+ 	/* Used to store current pixel format */
+-	struct v4l2_format fmt;
++	struct v4l2_format vid_fmt;
++	/* Used to store current meta format */
++	struct v4l2_format meta_fmt;
+ 	/* Buffer queue used in video-buf */
+ 	struct vb2_queue buffer_queue;
+ 	/* Queue of filled frames */
+@@ -433,20 +443,21 @@ static int format_show(struct seq_file *
+ 		seq_printf(s, "\nNode %u (%s) state: 0x%lx\n", i,
+ 			   node_desc[i].name, state);
+ 
+-		if (is_image_node(node))
++		if (node_supports_image(node))
+ 			seq_printf(s, "format: " V4L2_FOURCC_CONV " 0x%x\n"
+ 				      "resolution: %ux%u\nbpl: %u\nsize: %u\n",
+-				   V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.pix.pixelformat),
+-				   node->fmt.fmt.pix.pixelformat,
+-				   node->fmt.fmt.pix.width,
+-				   node->fmt.fmt.pix.height,
+-				   node->fmt.fmt.pix.bytesperline,
+-				   node->fmt.fmt.pix.sizeimage);
+-		else
++				   V4L2_FOURCC_CONV_ARGS(node->vid_fmt.fmt.pix.pixelformat),
++				   node->vid_fmt.fmt.pix.pixelformat,
++				   node->vid_fmt.fmt.pix.width,
++				   node->vid_fmt.fmt.pix.height,
++				   node->vid_fmt.fmt.pix.bytesperline,
++				   node->vid_fmt.fmt.pix.sizeimage);
++
++		if (node_supports_meta(node))
+ 			seq_printf(s, "format: " V4L2_FOURCC_CONV " 0x%x\nsize: %u\n",
+-				   V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.meta.dataformat),
+-				   node->fmt.fmt.meta.dataformat,
+-				   node->fmt.fmt.meta.buffersize);
++				   V4L2_FOURCC_CONV_ARGS(node->meta_fmt.fmt.meta.dataformat),
++				   node->meta_fmt.fmt.meta.dataformat,
++				   node->meta_fmt.fmt.meta.buffersize);
+ 	}
+ 
+ 	return 0;
+@@ -571,11 +582,11 @@ static void cfe_schedule_next_csi2_job(s
+ 				node_desc[node->id].name, &buf->vb.vb2_buf);
+ 
+ 		if (is_meta_node(node)) {
+-			size = node->fmt.fmt.meta.buffersize;
++			size = node->meta_fmt.fmt.meta.buffersize;
+ 			stride = 0;
+ 		} else {
+-			size = node->fmt.fmt.pix.sizeimage;
+-			stride = node->fmt.fmt.pix.bytesperline;
++			size = node->vid_fmt.fmt.pix.sizeimage;
++			stride = node->vid_fmt.fmt.pix.bytesperline;
+ 		}
+ 
+ 		addr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+@@ -867,10 +878,10 @@ static void cfe_start_channel(struct cfe
+ 			width = source_fmt->width;
+ 			height = source_fmt->height;
+ 
+-			if (node->fmt.fmt.pix.pixelformat ==
++			if (node->vid_fmt.fmt.pix.pixelformat ==
+ 					fmt->remap[CFE_REMAP_16BIT])
+ 				mode = CSI2_MODE_REMAP;
+-			else if (node->fmt.fmt.pix.pixelformat ==
++			else if (node->vid_fmt.fmt.pix.pixelformat ==
+ 					fmt->remap[CFE_REMAP_COMPRESSED]) {
+ 				mode = CSI2_MODE_COMPRESSED;
+ 				csi2_set_compression(&cfe->csi2, node->id,
+@@ -884,7 +895,7 @@ static void cfe_start_channel(struct cfe
+ 				   /* Auto arm */
+ 				   false,
+ 				   /* Pack bytes */
+-				   node->id == CSI2_CH1_EMBEDDED ? true : false,
++				   is_meta_node(node) ? true : false,
+ 				   width, height);
+ 	}
+ 
+@@ -947,10 +958,11 @@ static int cfe_queue_setup(struct vb2_qu
+ {
+ 	struct cfe_node *node = vb2_get_drv_priv(vq);
+ 	struct cfe_device *cfe = node->cfe;
+-	unsigned int size = is_image_node(node) ? node->fmt.fmt.pix.sizeimage :
+-						  node->fmt.fmt.meta.buffersize;
++	unsigned int size = is_image_node(node) ? node->vid_fmt.fmt.pix.sizeimage :
++						  node->meta_fmt.fmt.meta.buffersize;
+ 
+-	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++	cfe_dbg("%s: [%s] type:%u\n", __func__, node_desc[node->id].name,
++		node->buffer_queue.type);
+ 
+ 	if (vq->num_buffers + *nbuffers < 3)
+ 		*nbuffers = 3 - vq->num_buffers;
+@@ -979,8 +991,8 @@ static int cfe_buffer_prepare(struct vb2
+ 	cfe_dbg_verbose("%s: [%s] buffer:%p\n", __func__,
+ 			node_desc[node->id].name, vb);
+ 
+-	size = is_image_node(node) ? node->fmt.fmt.pix.sizeimage :
+-				     node->fmt.fmt.meta.buffersize;
++	size = is_image_node(node) ? node->vid_fmt.fmt.pix.sizeimage :
++				     node->meta_fmt.fmt.meta.buffersize;
+ 	if (vb2_plane_size(vb, 0) < size) {
+ 		cfe_err("data will not fit into plane (%lu < %lu)\n",
+ 			vb2_plane_size(vb, 0), size);
+@@ -995,8 +1007,8 @@ static int cfe_buffer_prepare(struct vb2
+ 
+ 		memcpy(&b->config, addr, sizeof(struct pisp_fe_config));
+ 		return pisp_fe_validate_config(&cfe->fe, &b->config,
+-					       &cfe->node[FE_OUT0].fmt,
+-					       &cfe->node[FE_OUT1].fmt);
++					       &cfe->node[FE_OUT0].vid_fmt,
++					       &cfe->node[FE_OUT1].vid_fmt);
+ 	}
+ 
+ 	return 0;
+@@ -1256,7 +1268,7 @@ static int cfe_enum_fmt_vid_cap(struct f
+ 	struct cfe_device *cfe = node->cfe;
+ 	unsigned int i, j;
+ 
+-	if (!is_image_output_node(node))
++	if (!node_supports_image_output(node))
+ 		return -EINVAL;
+ 
+ 	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
+@@ -1292,10 +1304,10 @@ static int cfe_g_fmt(struct file *file,
+ 
+ 	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
+ 
+-	if (f->type != node->buffer_queue.type)
++	if (!node_supports_image(node))
+ 		return -EINVAL;
+ 
+-	*f = node->fmt;
++	*f = node->vid_fmt;
+ 
+ 	return 0;
+ }
+@@ -1310,7 +1322,7 @@ static int try_fmt_vid_cap(struct cfe_no
+ 		f->fmt.pix.width, f->fmt.pix.height,
+ 		V4L2_FOURCC_CONV_ARGS(f->fmt.pix.pixelformat));
+ 
+-	if (!is_image_output_node(node))
++	if (!node_supports_image_output(node))
+ 		return -EINVAL;
+ 
+ 	/*
+@@ -1351,11 +1363,11 @@ static int cfe_s_fmt_vid_cap(struct file
+ 	if (ret)
+ 		return ret;
+ 
+-	node->fmt = *f;
++	node->vid_fmt = *f;
+ 
+ 	cfe_dbg("%s: Set %ux%u, V4L2 pix " V4L2_FOURCC_CONV "\n", __func__,
+-		node->fmt.fmt.pix.width, node->fmt.fmt.pix.height,
+-		V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.pix.pixelformat));
++		node->vid_fmt.fmt.pix.width, node->vid_fmt.fmt.pix.height,
++		V4L2_FOURCC_CONV_ARGS(node->vid_fmt.fmt.pix.pixelformat));
+ 
+ 	return 0;
+ }
+@@ -1379,11 +1391,11 @@ static int cfe_enum_fmt_meta(struct file
+ 
+ 	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
+ 
+-	if (!is_meta_node(node) || f->index != 0)
++	if (!node_supports_meta(node) || f->index != 0)
+ 		return -EINVAL;
+ 
+ 	switch (node->id) {
+-	case CSI2_CH1_EMBEDDED:
++	case CSI2_CH0...CSI2_CH3:
+ 		f->pixelformat = V4L2_META_FMT_SENSOR_DATA;
+ 		return 0;
+ 	case FE_STATS:
+@@ -1399,8 +1411,11 @@ static int cfe_enum_fmt_meta(struct file
+ 
+ static int try_fmt_meta(struct cfe_node *node, struct v4l2_format *f)
+ {
++	if (!node_supports_meta(node))
++		return -EINVAL;
++
+ 	switch (node->id) {
+-	case CSI2_CH1_EMBEDDED:
++	case CSI2_CH0...CSI2_CH3:
+ 		f->fmt.meta.dataformat = V4L2_META_FMT_SENSOR_DATA;
+ 		if (!f->fmt.meta.buffersize)
+ 			f->fmt.meta.buffersize = DEFAULT_EMBEDDED_SIZE;
+@@ -1422,6 +1437,21 @@ static int try_fmt_meta(struct cfe_node
+ 	return -EINVAL;
+ }
+ 
++static int cfe_g_fmt_meta(struct file *file, void *priv, struct v4l2_format *f)
++{
++	struct cfe_node *node = video_drvdata(file);
++	struct cfe_device *cfe = node->cfe;
++
++	cfe_dbg("%s: [%s]\n", __func__, node_desc[node->id].name);
++
++	if (!node_supports_meta(node))
++		return -EINVAL;
++
++	*f = node->meta_fmt;
++
++	return 0;
++}
++
+ static int cfe_s_fmt_meta(struct file *file, void *priv, struct v4l2_format *f)
+ {
+ 	struct cfe_node *node = video_drvdata(file);
+@@ -1434,17 +1464,17 @@ static int cfe_s_fmt_meta(struct file *f
+ 	if (vb2_is_busy(q))
+ 		return -EBUSY;
+ 
+-	if (f->type != node->buffer_queue.type)
++	if (!node_supports_meta(node))
+ 		return -EINVAL;
+ 
+ 	ret = try_fmt_meta(node, f);
+ 	if (ret)
+ 		return ret;
+ 
+-	node->fmt = *f;
++	node->meta_fmt = *f;
+ 
+ 	cfe_dbg("%s: Set " V4L2_FOURCC_CONV "\n", __func__,
+-		V4L2_FOURCC_CONV_ARGS(node->fmt.fmt.meta.dataformat));
++		V4L2_FOURCC_CONV_ARGS(node->meta_fmt.fmt.meta.dataformat));
+ 
+ 	return 0;
+ }
+@@ -1491,6 +1521,52 @@ static int cfe_enum_framesizes(struct fi
+ 	return 0;
+ }
+ 
++static int cfe_vb2_ioctl_reqbufs(struct file *file, void *priv,
++				 struct v4l2_requestbuffers *p)
++{
++	struct video_device *vdev = video_devdata(file);
++	struct cfe_node *node = video_get_drvdata(vdev);
++	struct cfe_device *cfe = node->cfe;
++	int ret;
++
++	cfe_dbg("%s: [%s] type:%u\n", __func__, node_desc[node->id].name,
++		p->type);
++
++	if (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
++	    p->type != V4L2_BUF_TYPE_META_CAPTURE &&
++	    p->type != V4L2_BUF_TYPE_META_OUTPUT)
++		return -EINVAL;
++
++	ret = vb2_queue_change_type(vdev->queue, p->type);
++	if (ret)
++		return ret;
++
++	return vb2_ioctl_reqbufs(file, priv, p);
++}
++
++static int cfe_vb2_ioctl_create_bufs(struct file *file, void *priv,
++				     struct v4l2_create_buffers *p)
++{
++	struct video_device *vdev = video_devdata(file);
++	struct cfe_node *node = video_get_drvdata(vdev);
++	struct cfe_device *cfe = node->cfe;
++	int ret;
++
++	cfe_dbg("%s: [%s] type:%u\n", __func__, node_desc[node->id].name,
++		p->format.type);
++
++	if (p->format.type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
++	    p->format.type != V4L2_BUF_TYPE_META_CAPTURE &&
++	    p->format.type != V4L2_BUF_TYPE_META_OUTPUT)
++		return -EINVAL;
++
++	ret = vb2_queue_change_type(vdev->queue, p->format.type);
++	if (ret)
++		return ret;
++
++	return vb2_ioctl_create_bufs(file, priv, p);
++}
++
+ static int cfe_subscribe_event(struct v4l2_fh *fh,
+ 			       const struct v4l2_event_subscription *sub)
+ {
+@@ -1498,12 +1574,13 @@ static int cfe_subscribe_event(struct v4
+ 
+ 	switch (sub->type) {
+ 	case V4L2_EVENT_FRAME_SYNC:
+-		if (!is_image_output_node(node))
++		if (!node_supports_image_output(node))
+ 			break;
+ 
+ 		return v4l2_event_subscribe(fh, sub, 2, NULL);
+ 	case V4L2_EVENT_SOURCE_CHANGE:
+-		if (is_meta_input_node(node))
++		if (!node_supports_image_output(node) &&
++		    !node_supports_meta_output(node))
+ 			break;
+ 
+ 		return v4l2_event_subscribe(fh, sub, 4, NULL);
+@@ -1520,19 +1597,19 @@ static const struct v4l2_ioctl_ops cfe_i
+ 	.vidioc_try_fmt_vid_cap = cfe_try_fmt_vid_cap,
+ 
+ 	.vidioc_enum_fmt_meta_cap = cfe_enum_fmt_meta,
+-	.vidioc_g_fmt_meta_cap = cfe_g_fmt,
++	.vidioc_g_fmt_meta_cap = cfe_g_fmt_meta,
+ 	.vidioc_s_fmt_meta_cap = cfe_s_fmt_meta,
+ 	.vidioc_try_fmt_meta_cap = cfe_try_fmt_meta,
+ 
+ 	.vidioc_enum_fmt_meta_out = cfe_enum_fmt_meta,
+-	.vidioc_g_fmt_meta_out = cfe_g_fmt,
++	.vidioc_g_fmt_meta_out = cfe_g_fmt_meta,
+ 	.vidioc_s_fmt_meta_out = cfe_s_fmt_meta,
+ 	.vidioc_try_fmt_meta_out = cfe_try_fmt_meta,
+ 
+ 	.vidioc_enum_framesizes = cfe_enum_framesizes,
+ 
+-	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+-	.vidioc_create_bufs = vb2_ioctl_create_bufs,
++	.vidioc_reqbufs = cfe_vb2_ioctl_reqbufs,
++	.vidioc_create_bufs = cfe_vb2_ioctl_create_bufs,
+ 	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+ 	.vidioc_querybuf = vb2_ioctl_querybuf,
+ 	.vidioc_qbuf = vb2_ioctl_qbuf,
+@@ -1610,7 +1687,7 @@ static int cfe_video_link_validate(struc
+ 	}
+ 
+ 	if (is_image_output_node(node)) {
+-		struct v4l2_pix_format *pix_fmt = &node->fmt.fmt.pix;
++		struct v4l2_pix_format *pix_fmt = &node->vid_fmt.fmt.pix;
+ 		const struct cfe_fmt *fmt = NULL;
+ 		unsigned int i;
+ 
+@@ -1636,8 +1713,8 @@ static int cfe_video_link_validate(struc
+ 			ret = -EINVAL;
+ 			goto out;
+ 		}
+-	} else if (node->id == CSI2_CH1_EMBEDDED) {
+-		struct v4l2_meta_format *meta_fmt = &node->fmt.fmt.meta;
++	} else if (is_csi2_node(node) && is_meta_output_node(node)) {
++		struct v4l2_meta_format *meta_fmt = &node->meta_fmt.fmt.meta;
+ 
+ 		if (source_fmt->width * source_fmt->height !=
+ 							meta_fmt->buffersize ||
+@@ -1698,15 +1775,17 @@ static int cfe_video_link_notify(struct
+ 
+ 	if (link->source->entity != csi2)
+ 		return 0;
+-	if (link->sink->index != 0)
++	if (link->sink->entity != fe)
+ 		return 0;
+-	if (link->source->index == node_desc[CSI2_CH1_EMBEDDED].link_pad)
++	if (link->sink->index != 0)
+ 		return 0;
+ 
+ 	cfe->fe_csi2_channel = -1;
+-	if (link->sink->entity == fe && (link->flags & MEDIA_LNK_FL_ENABLED)) {
++	if (link->flags & MEDIA_LNK_FL_ENABLED) {
+ 		if (link->source->index == node_desc[CSI2_CH0].link_pad)
+ 			cfe->fe_csi2_channel = CSI2_CH0;
++		else if (link->source->index == node_desc[CSI2_CH1].link_pad)
++			cfe->fe_csi2_channel = CSI2_CH1;
+ 		else if (link->source->index == node_desc[CSI2_CH2].link_pad)
+ 			cfe->fe_csi2_channel = CSI2_CH2;
+ 		else if (link->source->index == node_desc[CSI2_CH3].link_pad)
+@@ -1763,30 +1842,42 @@ static int cfe_register_node(struct cfe_
+ 	node->cfe = cfe;
+ 	node->id = id;
+ 
+-	if (is_image_node(node)) {
++	if (node_supports_image(node)) {
++		if (node_supports_image_output(node))
++			node->vid_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
++		else
++			node->vid_fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
++
+ 		fmt = find_format_by_code(cfe_default_format.code);
+ 		if (!fmt) {
+ 			cfe_err("Failed to find format code\n");
+ 			return -EINVAL;
+ 		}
+ 
+-		node->fmt.fmt.pix.pixelformat = fmt->fourcc;
+-		v4l2_fill_pix_format(&node->fmt.fmt.pix, &cfe_default_format);
++		node->vid_fmt.fmt.pix.pixelformat = fmt->fourcc;
++		v4l2_fill_pix_format(&node->vid_fmt.fmt.pix, &cfe_default_format);
+ 
+-		ret = try_fmt_vid_cap(node, &node->fmt);
++		ret = try_fmt_vid_cap(node, &node->vid_fmt);
+ 		if (ret)
+ 			return ret;
+-	} else {
+-		ret = try_fmt_meta(node, &node->fmt);
++	}
++
++	if (node_supports_meta(node)) {
++		if (node_supports_meta_output(node))
++			node->meta_fmt.type = V4L2_BUF_TYPE_META_CAPTURE;
++		else
++			node->meta_fmt.type = V4L2_BUF_TYPE_META_OUTPUT;
++
++		ret = try_fmt_meta(node, &node->meta_fmt);
+ 		if (ret)
+ 			return ret;
+ 	}
+-	node->fmt.type = node_desc[id].buf_type;
+ 
+ 	mutex_init(&node->lock);
+ 
+ 	q = &node->buffer_queue;
+-	q->type = node_desc[id].buf_type;
++	q->type = node_supports_image(node) ? node->vid_fmt.type :
++					      node->meta_fmt.type;
+ 	q->io_modes = VB2_MMAP | VB2_DMABUF;
+ 	q->drv_priv = node;
+ 	q->ops = &cfe_video_qops;
+@@ -1812,11 +1903,13 @@ static int cfe_register_node(struct cfe_
+ 	vdev->ioctl_ops = &cfe_ioctl_ops;
+ 	vdev->entity.ops = &cfe_media_entity_ops;
+ 	vdev->v4l2_dev = &cfe->v4l2_dev;
+-	vdev->vfl_dir = (is_image_output_node(node) || is_meta_output_node(node))
+-				? VFL_DIR_RX : VFL_DIR_TX;
++	vdev->vfl_dir = (node_supports_image_output(node) ||
++			 node_supports_meta_output(node)) ?
++				VFL_DIR_RX :
++				VFL_DIR_TX;
+ 	vdev->queue = q;
+ 	vdev->lock = &node->lock;
+-	vdev->device_caps = node_desc[id].cap;
++	vdev->device_caps = node_desc[id].caps;
+ 	vdev->device_caps |= V4L2_CAP_STREAMING | V4L2_CAP_IO_MC;
+ 
+ 	/* Define the device names */
+@@ -1829,7 +1922,7 @@ static int cfe_register_node(struct cfe_
+ 	node->pad.flags = node_desc[id].pad_flags;
+ 	media_entity_pads_init(&vdev->entity, 1, &node->pad);
+ 
+-	if (is_meta_node(node)) {
++	if (!node_supports_image(node)) {
+ 		v4l2_disable_ioctl(&node->video_dev,
+ 				   VIDIOC_ENUM_FRAMEINTERVALS);
+ 		v4l2_disable_ioctl(&node->video_dev,
+@@ -1907,7 +2000,7 @@ static int cfe_link_node_pads(struct cfe
+ 		if (ret)
+ 			return ret;
+ 
+-		if (node->id != CSI2_CH1_EMBEDDED) {
++		if (node_supports_image(node)) {
+ 			/* CSI2 channel # -> FE Input */
+ 			ret = media_create_pad_link(&cfe->csi2.sd.entity,
+ 						    node_desc[i].link_pad,
diff --git a/target/linux/bcm27xx/patches-6.1/950-1209-media-rp1-Drop-LE-handling.patch b/target/linux/bcm27xx/patches-6.1/950-1209-media-rp1-Drop-LE-handling.patch
new file mode 100644
index 0000000000..1d6e396f1c
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1209-media-rp1-Drop-LE-handling.patch
@@ -0,0 +1,127 @@
+From dad296088dffbaf55c1e61cbdc3f7cb1eb504ca6 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Tue, 16 May 2023 15:51:54 +0300
+Subject: [PATCH] media: rp1: Drop LE handling
+
+The driver registers for line-end interrupts, but never uses them. This
+just causes extra interrupt load, with more complexity in the driver.
+
+Drop the LE handling. It can easily be added back if later needed.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  |  6 ++--
+ .../media/platform/raspberrypi/rp1_cfe/csi2.c | 28 ++++---------------
+ .../media/platform/raspberrypi/rp1_cfe/csi2.h |  2 +-
+ 3 files changed, 10 insertions(+), 26 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -734,13 +734,13 @@ static irqreturn_t cfe_isr(int irq, void
+ {
+ 	struct cfe_device *cfe = dev;
+ 	unsigned int i;
+-	bool sof[NUM_NODES] = {0}, eof[NUM_NODES] = {0}, lci[NUM_NODES] = {0};
++	bool sof[NUM_NODES] = {0}, eof[NUM_NODES] = {0};
+ 	u32 sts;
+ 
+ 	sts = cfg_reg_read(cfe, MIPICFG_INTS);
+ 
+ 	if (sts & MIPICFG_INT_CSI_DMA)
+-		csi2_isr(&cfe->csi2, sof, eof, lci);
++		csi2_isr(&cfe->csi2, sof, eof);
+ 
+ 	if (sts & MIPICFG_INT_PISP_FE)
+ 		pisp_fe_isr(&cfe->fe, sof + CSI2_NUM_CHANNELS,
+@@ -757,7 +757,7 @@ static irqreturn_t cfe_isr(int irq, void
+ 		 * generate interrupts even though the node is not streaming.
+ 		 */
+ 		if (!check_state(cfe, NODE_STREAMING, i) ||
+-		    !(sof[i] || eof[i] || lci[i]))
++		    !(sof[i] || eof[i]))
+ 			continue;
+ 
+ 		/*
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -258,7 +258,7 @@ static void csi2_isr_handle_errors(struc
+ 	spin_unlock(&csi2->errors_lock);
+ }
+ 
+-void csi2_isr(struct csi2_device *csi2, bool *sof, bool *eof, bool *lci)
++void csi2_isr(struct csi2_device *csi2, bool *sof, bool *eof)
+ {
+ 	unsigned int i;
+ 	u32 status;
+@@ -290,7 +290,6 @@ void csi2_isr(struct csi2_device *csi2,
+ 
+ 		sof[i] = !!(status & IRQ_FS(i));
+ 		eof[i] = !!(status & IRQ_FE_ACK(i));
+-		lci[i] = !!(status & IRQ_LE_ACK(i));
+ 	}
+ 
+ 	if (csi2_track_errors)
+@@ -405,16 +404,12 @@ void csi2_start_channel(struct csi2_devi
+ 
+ 	csi2_dbg("%s [%u]\n", __func__, channel);
+ 
+-	/*
+-	 * Disable the channel, but ensure N != 0!  Otherwise we end up with a
+-	 * spurious LE + LE_ACK interrupt when re-enabling the channel.
+-	 */
+-	csi2_reg_write(csi2, CSI2_CH_CTRL(channel), 0x100 << __ffs(LC_MASK));
++	csi2_reg_write(csi2, CSI2_CH_CTRL(channel), 0);
+ 	csi2_reg_write(csi2, CSI2_CH_DEBUG(channel), 0);
+ 	csi2_reg_write(csi2, CSI2_STATUS, IRQ_CH_MASK(channel));
+ 
+-	/* Enable channel and FS/FE/LE interrupts. */
+-	ctrl = DMA_EN | IRQ_EN_FS | IRQ_EN_FE_ACK | IRQ_EN_LE_ACK | PACK_LINE;
++	/* Enable channel and FS/FE interrupts. */
++	ctrl = DMA_EN | IRQ_EN_FS | IRQ_EN_FE_ACK | PACK_LINE;
+ 	/* PACK_BYTES ensures no striding for embedded data. */
+ 	if (pack_bytes)
+ 		ctrl |= PACK_BYTES;
+@@ -423,21 +418,11 @@ void csi2_start_channel(struct csi2_devi
+ 		ctrl |= AUTO_ARM;
+ 
+ 	if (width && height) {
+-		int line_int_freq = height >> 2;
+-
+-		line_int_freq = min(max(0x80, line_int_freq), 0x3ff);
+-		set_field(&ctrl, line_int_freq, LC_MASK);
+ 		set_field(&ctrl, mode, CH_MODE_MASK);
+ 		csi2_reg_write(csi2, CSI2_CH_FRAME_SIZE(channel),
+ 			       (height << 16) | width);
+ 	} else {
+-		/*
+-		 * Do not disable line interrupts for the embedded data channel,
+-		 * set it to the maximum value.  This avoids spamming the ISR
+-		 * with spurious line interrupts.
+-		 */
+-		set_field(&ctrl, 0x3ff, LC_MASK);
+-		set_field(&ctrl, 0x00, CH_MODE_MASK);
++		set_field(&ctrl, 0x0, CH_MODE_MASK);
+ 		csi2_reg_write(csi2, CSI2_CH_FRAME_SIZE(channel), 0);
+ 	}
+ 
+@@ -452,8 +437,7 @@ void csi2_stop_channel(struct csi2_devic
+ 	csi2_dbg("%s [%u]\n", __func__, channel);
+ 
+ 	/* Channel disable.  Use FORCE to allow stopping mid-frame. */
+-	csi2_reg_write(csi2, CSI2_CH_CTRL(channel),
+-		       (0x100 << __ffs(LC_MASK)) | FORCE);
++	csi2_reg_write(csi2, CSI2_CH_CTRL(channel), FORCE);
+ 	/* Latch the above change by writing to the ADDR0 register. */
+ 	csi2_reg_write(csi2, CSI2_CH_ADDR0(channel), 0);
+ 	/* Write this again, the HW needs it! */
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.h
+@@ -71,7 +71,7 @@ struct csi2_device {
+ 	u32 discards_dt_table[DISCARDS_TABLE_NUM_ENTRIES];
+ };
+ 
+-void csi2_isr(struct csi2_device *csi2, bool *sof, bool *eof, bool *lci);
++void csi2_isr(struct csi2_device *csi2, bool *sof, bool *eof);
+ void csi2_set_buffer(struct csi2_device *csi2, unsigned int channel,
+ 		     dma_addr_t dmaaddr, unsigned int stride,
+ 		     unsigned int size);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1210-media-rp1-csi2-Use-standard-link_validate.patch b/target/linux/bcm27xx/patches-6.1/950-1210-media-rp1-csi2-Use-standard-link_validate.patch
new file mode 100644
index 0000000000..a3836150dc
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1210-media-rp1-csi2-Use-standard-link_validate.patch
@@ -0,0 +1,75 @@
+From b6316a8450d3cb99b7599175d59b1b7f710770f5 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Tue, 3 Oct 2023 13:59:02 +0300
+Subject: [PATCH] media: rp1: csi2: Use standard link_validate
+
+The current csi2_link_validate() skips some important checks. Let's
+rather use the standard v4l2_subdev_link_validate_default() as the
+link_validate hook.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/csi2.c | 41 +------------------
+ 1 file changed, 1 insertion(+), 40 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/csi2.c
+@@ -462,11 +462,6 @@ void csi2_close_rx(struct csi2_device *c
+ 	csi2_reg_write(csi2, CSI2_IRQ_MASK, 0);
+ }
+ 
+-static struct csi2_device *to_csi2_device(struct v4l2_subdev *subdev)
+-{
+-	return container_of(subdev, struct csi2_device, sd);
+-}
+-
+ static int csi2_init_cfg(struct v4l2_subdev *sd,
+ 			 struct v4l2_subdev_state *state)
+ {
+@@ -554,45 +549,11 @@ static int csi2_pad_set_fmt(struct v4l2_
+ 	return 0;
+ }
+ 
+-static int csi2_link_validate(struct v4l2_subdev *sd, struct media_link *link,
+-			      struct v4l2_subdev_format *source_fmt,
+-			      struct v4l2_subdev_format *sink_fmt)
+-{
+-	struct csi2_device *csi2 = to_csi2_device(sd);
+-
+-	csi2_dbg("%s: link \"%s\":%u -> \"%s\":%u\n", __func__,
+-		 link->source->entity->name, link->source->index,
+-		 link->sink->entity->name, link->sink->index);
+-
+-	if ((link->source->entity == &csi2->sd.entity &&
+-	     link->source->index == 1) ||
+-	    (link->sink->entity == &csi2->sd.entity &&
+-	     link->sink->index == 1)) {
+-		csi2_dbg("Ignore metadata pad for now\n");
+-		return 0;
+-	}
+-
+-	/* The width, height and code must match. */
+-	if (source_fmt->format.width != sink_fmt->format.width ||
+-	    source_fmt->format.width != sink_fmt->format.width ||
+-	    source_fmt->format.code != sink_fmt->format.code) {
+-		csi2_err("%s: format does not match (source %ux%u 0x%x, sink %ux%u 0x%x)\n",
+-			 __func__,
+-			 source_fmt->format.width, source_fmt->format.height,
+-			 source_fmt->format.code,
+-			 sink_fmt->format.width, sink_fmt->format.height,
+-			 sink_fmt->format.code);
+-		return -EPIPE;
+-	}
+-
+-	return 0;
+-}
+-
+ static const struct v4l2_subdev_pad_ops csi2_subdev_pad_ops = {
+ 	.init_cfg = csi2_init_cfg,
+ 	.get_fmt = v4l2_subdev_get_fmt,
+ 	.set_fmt = csi2_pad_set_fmt,
+-	.link_validate = csi2_link_validate,
++	.link_validate = v4l2_subdev_link_validate_default,
+ };
+ 
+ static const struct media_entity_operations csi2_entity_ops = {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1211-media-rp1-fe-Use-standard-link_validate.patch b/target/linux/bcm27xx/patches-6.1/950-1211-media-rp1-fe-Use-standard-link_validate.patch
new file mode 100644
index 0000000000..d36ea5bd52
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1211-media-rp1-fe-Use-standard-link_validate.patch
@@ -0,0 +1,70 @@
+From 0eeb351222adbc5b534c86f7815ee787babc3485 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Tue, 3 Oct 2023 14:34:43 +0300
+Subject: [PATCH] media: rp1: fe: Use standard link_validate
+
+The current pisp_fe_link_validate() skips some important checks. Let's
+rather use the standard v4l2_subdev_link_validate_default() as the
+link_validate hook.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../platform/raspberrypi/rp1_cfe/pisp_fe.c    | 36 +------------------
+ 1 file changed, 1 insertion(+), 35 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe.c
+@@ -388,11 +388,6 @@ void pisp_fe_stop(struct pisp_fe_device
+ 	pisp_fe_reg_write(fe, FE_INT_STATUS, ~0);
+ }
+ 
+-static struct pisp_fe_device *to_pisp_fe_device(struct v4l2_subdev *subdev)
+-{
+-	return container_of(subdev, struct pisp_fe_device, sd);
+-}
+-
+ static int pisp_fe_init_cfg(struct v4l2_subdev *sd,
+ 			    struct v4l2_subdev_state *state)
+ {
+@@ -492,40 +487,11 @@ static int pisp_fe_pad_set_fmt(struct v4
+ 	}
+ }
+ 
+-static int pisp_fe_link_validate(struct v4l2_subdev *sd,
+-				 struct media_link *link,
+-				 struct v4l2_subdev_format *source_fmt,
+-				 struct v4l2_subdev_format *sink_fmt)
+-{
+-	struct pisp_fe_device *fe = to_pisp_fe_device(sd);
+-
+-	pisp_fe_dbg("%s: link \"%s\":%u -> \"%s\":%u\n", __func__,
+-		    link->source->entity->name, link->source->index,
+-		    link->sink->entity->name, link->sink->index);
+-
+-	/* The width, height and code must match. */
+-	if (source_fmt->format.width != sink_fmt->format.width ||
+-	    source_fmt->format.width != sink_fmt->format.width ||
+-	    source_fmt->format.code != sink_fmt->format.code) {
+-		pisp_fe_err("%s: format does not match (source %ux%u 0x%x, sink %ux%u 0x%x)\n",
+-			    __func__,
+-			     source_fmt->format.width,
+-			     source_fmt->format.height,
+-			     source_fmt->format.code,
+-			     sink_fmt->format.width,
+-			     sink_fmt->format.height,
+-			     sink_fmt->format.code);
+-		return -EPIPE;
+-	}
+-
+-	return 0;
+-}
+-
+ static const struct v4l2_subdev_pad_ops pisp_fe_subdev_pad_ops = {
+ 	.init_cfg = pisp_fe_init_cfg,
+ 	.get_fmt = v4l2_subdev_get_fmt,
+ 	.set_fmt = pisp_fe_pad_set_fmt,
+-	.link_validate = pisp_fe_link_validate,
++	.link_validate = v4l2_subdev_link_validate_default,
+ };
+ 
+ static const struct media_entity_operations pisp_fe_entity_ops = {
diff --git a/target/linux/bcm27xx/patches-6.1/950-1212-media-rp1-cfe-Improve-link-validation-for-metadata.patch b/target/linux/bcm27xx/patches-6.1/950-1212-media-rp1-cfe-Improve-link-validation-for-metadata.patch
new file mode 100644
index 0000000000..d85a90aac1
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1212-media-rp1-cfe-Improve-link-validation-for-metadata.patch
@@ -0,0 +1,61 @@
+From e0f52ccfe1e383622fb30708acd38921e84fbff4 Mon Sep 17 00:00:00 2001
+From: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+Date: Tue, 3 Oct 2023 14:29:44 +0300
+Subject: [PATCH] media: rp1: cfe: Improve link validation for metadata
+
+Improve the link validation for metadata by:
+- Allowing capture buffers that are larger than the incoming frame
+  (instead of requiring exact match).
+
+- Instead of assuming that a metadata unit ("pixel") is 8 bits, use
+  find_format_by_code() to get the format and use the bit depth from
+  there. E.g. bit depth for RAW10 metadata will be 10 bits, when we
+  move to the upstream metadata formats.
+
+Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 32 +++++++++++++------
+ 1 file changed, 22 insertions(+), 10 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -1715,17 +1715,29 @@ static int cfe_video_link_validate(struc
+ 		}
+ 	} else if (is_csi2_node(node) && is_meta_output_node(node)) {
+ 		struct v4l2_meta_format *meta_fmt = &node->meta_fmt.fmt.meta;
++		const struct cfe_fmt *fmt;
++		u32 source_size;
+ 
+-		if (source_fmt->width * source_fmt->height !=
+-							meta_fmt->buffersize ||
+-		    source_fmt->code != MEDIA_BUS_FMT_SENSOR_DATA) {
+-			cfe_err("WARNING: Wrong metadata width/height/code %ux%u %08x (remote pad set to %ux%u %08x)\n",
+-				meta_fmt->buffersize, 1,
+-				MEDIA_BUS_FMT_SENSOR_DATA,
+-				source_fmt->width,
+-				source_fmt->height,
+-				source_fmt->code);
+-			/* TODO: this should throw an error eventually */
++		fmt = find_format_by_code(source_fmt->code);
++		if (!fmt || fmt->fourcc != meta_fmt->dataformat) {
++			cfe_err("Metadata format mismatch!\n");
++			ret = -EINVAL;
++			goto out;
++		}
++
++		source_size = DIV_ROUND_UP(source_fmt->width * source_fmt->height * fmt->depth, 8);
++
++		if (source_fmt->code != MEDIA_BUS_FMT_SENSOR_DATA) {
++			cfe_err("Bad metadata mbus format\n");
++			ret = -EINVAL;
++			goto out;
++		}
++
++		if (source_size > meta_fmt->buffersize) {
++			cfe_err("Metadata buffer too small: %u < %u\n",
++				meta_fmt->buffersize, source_size);
++			ret = -EINVAL;
++			goto out;
+ 		}
+ 	}
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1214-drivers-pinctrl-bcm-Kconfig-Fix-BCM2712-help.patch b/target/linux/bcm27xx/patches-6.1/950-1214-drivers-pinctrl-bcm-Kconfig-Fix-BCM2712-help.patch
new file mode 100644
index 0000000000..c3e4140fa2
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1214-drivers-pinctrl-bcm-Kconfig-Fix-BCM2712-help.patch
@@ -0,0 +1,24 @@
+From 046d03c87ecce5db074eae6ffa2d5298c5f7d5a7 Mon Sep 17 00:00:00 2001
+From: Leon Anavi <leon.anavi@konsulko.com>
+Date: Tue, 12 Dec 2023 13:53:37 +0200
+Subject: [PATCH] drivers/pinctrl/bcm/Kconfig: Fix BCM2712 help
+
+Replace "Broadcom BCM2835 GPIO" with "Broadcom BCM2712 PINCONF"
+in the help message. This work was sponsored by GOVCERT.LU.
+
+Signed-off-by: Leon Anavi <leon.anavi@konsulko.com>
+---
+ drivers/pinctrl/bcm/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/pinctrl/bcm/Kconfig
++++ b/drivers/pinctrl/bcm/Kconfig
+@@ -10,7 +10,7 @@ config PINCTRL_BCM2712
+ 	select PINCONF
+ 	select GENERIC_PINCONF
+ 	help
+-	   Say Y here to enable the Broadcom BCM2835 GPIO driver.
++	   Say Y here to enable the Broadcom BCM2712 PINCONF driver.
+ 
+ config PINCTRL_BCM281XX
+ 	bool "Broadcom BCM281xx pinctrl driver"
diff --git a/target/linux/bcm27xx/patches-6.1/950-1216-drivers-gpu-drm-panel-fix-waveshare-panel-software-r.patch b/target/linux/bcm27xx/patches-6.1/950-1216-drivers-gpu-drm-panel-fix-waveshare-panel-software-r.patch
new file mode 100644
index 0000000000..aeb63589fc
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1216-drivers-gpu-drm-panel-fix-waveshare-panel-software-r.patch
@@ -0,0 +1,41 @@
+From a6872b25f18fe46ef9979f9d4a3635a9c3966afd Mon Sep 17 00:00:00 2001
+From: eng33 <eng33@waveshare.com>
+Date: Mon, 11 Dec 2023 15:06:45 +0800
+Subject: [PATCH] drivers/gpu/drm/panel:fix waveshare panel software
+ restart/shutdown display is abnormal Fixed the screen stays white when the
+ user restarts or shuts down
+
+Signed-off-by: eng33 <eng33@waveshare.com>
+---
+ drivers/gpu/drm/panel/panel-waveshare-dsi.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/gpu/drm/panel/panel-waveshare-dsi.c
++++ b/drivers/gpu/drm/panel/panel-waveshare-dsi.c
+@@ -362,9 +362,18 @@ static void ws_panel_remove(struct i2c_c
+ {
+ 	struct ws_panel *ts = i2c_get_clientdata(i2c);
+ 
++	ws_panel_disable(&ts->base);
++
+ 	drm_panel_remove(&ts->base);
+ }
+ 
++static void ws_panel_shutdown(struct i2c_client *i2c)
++{
++	struct ws_panel *ts = i2c_get_clientdata(i2c);
++
++	ws_panel_disable(&ts->base);
++}
++
+ static const struct of_device_id ws_panel_of_ids[] = {
+ 	{
+ 		.compatible = "waveshare,2.8inch-panel",
+@@ -403,6 +412,7 @@ static struct i2c_driver ws_panel_driver
+ 	},
+ 	.probe = ws_panel_probe,
+ 	.remove = ws_panel_remove,
++	.shutdown = ws_panel_shutdown,
+ };
+ module_i2c_driver(ws_panel_driver);
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1217-firmware-psci-Pass-given-partition-number-through.patch b/target/linux/bcm27xx/patches-6.1/950-1217-firmware-psci-Pass-given-partition-number-through.patch
new file mode 100644
index 0000000000..7feeb224d1
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1217-firmware-psci-Pass-given-partition-number-through.patch
@@ -0,0 +1,33 @@
+From 6988ae7c909dc342322a82daaa3a95b78d038305 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 11 Dec 2023 16:58:07 +0000
+Subject: [PATCH] firmware/psci: Pass given partition number through
+
+Pi 5 uses BL31 as its armstub file, so the reset goes via PSCI. Parse
+any "reboot" parameter as a partition number to reboot into.
+N.B. This code path is only used if reboot mode has been set to warm
+or soft.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/firmware/psci/psci.c | 9 ++++++++-
+ 1 file changed, 8 insertions(+), 1 deletion(-)
+
+--- a/drivers/firmware/psci/psci.c
++++ b/drivers/firmware/psci/psci.c
+@@ -314,7 +314,14 @@ static int psci_sys_reset(struct notifie
+ 		 * reset_type[30:0] = 0 (SYSTEM_WARM_RESET)
+ 		 * cookie = 0 (ignored by the implementation)
+ 		 */
+-		invoke_psci_fn(PSCI_FN_NATIVE(1_1, SYSTEM_RESET2), 0, 0, 0);
++		// Allow extra arguments separated by spaces after
++		// the partition number.
++		unsigned long val;
++		u8 partition = 0;
++
++		if (data && sscanf(data, "%lu", &val) == 1 && val < 63)
++			partition = val;
++		invoke_psci_fn(PSCI_FN_NATIVE(1_1, SYSTEM_RESET2), 0, partition, 0);
+ 	} else {
+ 		invoke_psci_fn(PSCI_0_2_FN_SYSTEM_RESET, 0, 0, 0);
+ 	}
diff --git a/target/linux/bcm27xx/patches-6.1/950-1218-dts-bcm2712-rpi-5-b-Enable-warm-reboot-mode.patch b/target/linux/bcm27xx/patches-6.1/950-1218-dts-bcm2712-rpi-5-b-Enable-warm-reboot-mode.patch
new file mode 100644
index 0000000000..8bcf587e6d
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1218-dts-bcm2712-rpi-5-b-Enable-warm-reboot-mode.patch
@@ -0,0 +1,23 @@
+From 5d87d7f91cb4f1d0f391f6fe9dd0524b363b78e3 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 11 Dec 2023 17:00:56 +0000
+Subject: [PATCH] dts: bcm2712-rpi-5-b: Enable warm reboot mode
+
+Switch to warm reboot mode so that the partition number is preserved.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -428,7 +428,7 @@ dpi_16bit_gpio2:        &rp1_dpi_16bit_g
+ 
+ / {
+ 	chosen: chosen {
+-		bootargs = "coherent_pool=1M 8250.nr_uarts=1 pci=pcie_bus_safe snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1";
++		bootargs = "reboot=w coherent_pool=1M 8250.nr_uarts=1 pci=pcie_bus_safe snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1";
+ 		stdout-path = "serial10:115200n8";
+ 	};
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1222-drivers-media-i2c-imx296-imx477-Configure-tigger_mod.patch b/target/linux/bcm27xx/patches-6.1/950-1222-drivers-media-i2c-imx296-imx477-Configure-tigger_mod.patch
new file mode 100644
index 0000000000..be1eb5611e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1222-drivers-media-i2c-imx296-imx477-Configure-tigger_mod.patch
@@ -0,0 +1,85 @@
+From 083f39e40d980b47ab12b451d40b9f935bb22a5b Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Wed, 6 Dec 2023 14:27:57 +0000
+Subject: [PATCH] drivers: media: i2c: imx296,imx477: Configure tigger_mode
+ every time
+
+Don't assume the camera has been reset each time we start streaming,
+but always write registers relating to trigger_mode, even in mode 0.
+
+IMX477: Stop driving XVS on stop streaming, to avoid spurious pulses.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ drivers/media/i2c/imx296.c |  9 +++++----
+ drivers/media/i2c/imx477.c | 29 ++++++++++++++---------------
+ 2 files changed, 19 insertions(+), 19 deletions(-)
+
+--- a/drivers/media/i2c/imx296.c
++++ b/drivers/media/i2c/imx296.c
+@@ -650,10 +650,11 @@ static int imx296_stream_on(struct imx29
+ 	imx296_write(sensor, IMX296_CTRL00, 0, &ret);
+ 	usleep_range(2000, 5000);
+ 
+-	if (trigger_mode == 1) {
+-		imx296_write(sensor, IMX296_CTRL0B, IMX296_CTRL0B_TRIGEN, &ret);
+-		imx296_write(sensor, IMX296_LOWLAGTRG,  IMX296_LOWLAGTRG_FAST, &ret);
+-	}
++	/* external trigger mode: 0=normal, 1=triggered */
++	imx296_write(sensor, IMX296_CTRL0B,
++		     (trigger_mode == 1) ? IMX296_CTRL0B_TRIGEN : 0, &ret);
++	imx296_write(sensor, IMX296_LOWLAGTRG,
++		     (trigger_mode == 1) ? IMX296_LOWLAGTRG_FAST : 0, &ret);
+ 
+ 	imx296_write(sensor, IMX296_CTRL0A, 0, &ret);
+ 
+--- a/drivers/media/i2c/imx477.c
++++ b/drivers/media/i2c/imx477.c
+@@ -1742,26 +1742,21 @@ static int imx477_start_streaming(struct
+ 	imx477_write_reg(imx477, 0x0b05, IMX477_REG_VALUE_08BIT, !!dpc_enable);
+ 	imx477_write_reg(imx477, 0x0b06, IMX477_REG_VALUE_08BIT, !!dpc_enable);
+ 
+-	/* Set vsync trigger mode */
+-	if (trigger_mode != 0) {
+-		/* trigger_mode == 1 for source, 2 for sink */
+-		const u32 val = (trigger_mode == 1) ? 1 : 0;
+-
+-		imx477_write_reg(imx477, IMX477_REG_MC_MODE,
+-				 IMX477_REG_VALUE_08BIT, 1);
+-		imx477_write_reg(imx477, IMX477_REG_MS_SEL,
+-				 IMX477_REG_VALUE_08BIT, val);
+-		imx477_write_reg(imx477, IMX477_REG_XVS_IO_CTRL,
+-				 IMX477_REG_VALUE_08BIT, val);
+-		imx477_write_reg(imx477, IMX477_REG_EXTOUT_EN,
+-				 IMX477_REG_VALUE_08BIT, val);
+-	}
+-
+ 	/* Apply customized values from user */
+ 	ret =  __v4l2_ctrl_handler_setup(imx477->sd.ctrl_handler);
+ 	if (ret)
+ 		return ret;
+ 
++	/* Set vsync trigger mode: 0=standalone, 1=source, 2=sink */
++	imx477_write_reg(imx477, IMX477_REG_MC_MODE,
++			 IMX477_REG_VALUE_08BIT, (trigger_mode > 0) ? 1 : 0);
++	imx477_write_reg(imx477, IMX477_REG_MS_SEL,
++			 IMX477_REG_VALUE_08BIT, (trigger_mode <= 1) ? 1 : 0);
++	imx477_write_reg(imx477, IMX477_REG_XVS_IO_CTRL,
++			 IMX477_REG_VALUE_08BIT, (trigger_mode == 1) ? 1 : 0);
++	imx477_write_reg(imx477, IMX477_REG_EXTOUT_EN,
++			 IMX477_REG_VALUE_08BIT, (trigger_mode == 1) ? 1 : 0);
++
+ 	/* set stream on register */
+ 	return imx477_write_reg(imx477, IMX477_REG_MODE_SELECT,
+ 				IMX477_REG_VALUE_08BIT, IMX477_MODE_STREAMING);
+@@ -1778,6 +1773,10 @@ static void imx477_stop_streaming(struct
+ 			       IMX477_REG_VALUE_08BIT, IMX477_MODE_STANDBY);
+ 	if (ret)
+ 		dev_err(&client->dev, "%s failed to set stream\n", __func__);
++
++	/* Stop driving XVS out (there is still a weak pull-up) */
++	imx477_write_reg(imx477, IMX477_REG_EXTOUT_EN,
++			 IMX477_REG_VALUE_08BIT, 0);
+ }
+ 
+ static int imx477_set_stream(struct v4l2_subdev *sd, int enable)
diff --git a/target/linux/bcm27xx/patches-6.1/950-1223-overlays-Add-always-on-parameter-to-imx477-and-imx29.patch b/target/linux/bcm27xx/patches-6.1/950-1223-overlays-Add-always-on-parameter-to-imx477-and-imx29.patch
new file mode 100644
index 0000000000..d705df6f40
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1223-overlays-Add-always-on-parameter-to-imx477-and-imx29.patch
@@ -0,0 +1,99 @@
+From 3ed57f25f3074f6abfe570fc11aa7d370fdc499a Mon Sep 17 00:00:00 2001
+From: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+Date: Wed, 6 Dec 2023 14:38:03 +0000
+Subject: [PATCH] overlays: Add "always-on" parameter to imx477 and imx296
+
+Leave the camera's power supplies up, to prevent the camera
+clamping its 1.8V digital I/Os to ground. This may be useful
+when synchronizing multiple camera systems using XVS or XTRIG.
+
+Signed-off-by: Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>
+---
+ arch/arm/boot/dts/overlays/README                  | 6 ++++++
+ arch/arm/boot/dts/overlays/imx296-overlay.dts      | 9 +++++++++
+ arch/arm/boot/dts/overlays/imx477_378-overlay.dtsi | 9 +++++++++
+ 3 files changed, 24 insertions(+)
+
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -2520,6 +2520,8 @@ Params: rotation                Mounting
+         clock-frequency         Sets the clock frequency to match that used on
+                                 the board, which should be one of 54000000
+                                 (the default), 37125000 or 74250000.
++        always-on               Leave the regulator powered up, to stop the
++                                camera clamping I/Os such as XTRIG to 0V.
+ 
+ 
+ Name:   imx327
+@@ -2558,6 +2560,8 @@ Params: rotation                Mounting
+                                 configuring the sensor (default on)
+         cam0                    Adopt the default configuration for CAM0 on a
+                                 Compute Module (CSI0, i2c_vc, and cam0_reg).
++        always-on               Leave the regulator powered up, to stop the
++                                camera clamping I/Os such as XVS to 0V.
+ 
+ 
+ Name:   imx462
+@@ -2596,6 +2600,8 @@ Params: rotation                Mounting
+                                 configuring the sensor (default on)
+         cam0                    Adopt the default configuration for CAM0 on a
+                                 Compute Module (CSI0, i2c_vc, and cam0_reg).
++        always-on               Leave the regulator powered up, to stop the
++                                camera clamping I/Os such as XVS to 0V.
+ 
+ 
+ Name:   imx519
+--- a/arch/arm/boot/dts/overlays/imx296-overlay.dts
++++ b/arch/arm/boot/dts/overlays/imx296-overlay.dts
+@@ -37,6 +37,13 @@
+ 		};
+ 	};
+ 
++	reg_alwayson_frag: fragment@99 {
++		target = <&cam1_reg>;
++		__dormant__ {
++			regulator-always-on;
++		};
++	};
++
+ 	i2c_frag: fragment@100 {
+ 		target = <&i2c_csi_dsi>;
+ 		__overlay__ {
+@@ -98,8 +105,10 @@
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&reg_frag>, "target:0=",<&cam0_reg>,
++		       <&reg_alwayson_frag>, "target:0=",<&cam0_reg>,
+ 		       <&imx296>, "clocks:0=",<&cam0_clk>,
+ 		       <&imx296>, "avdd-supply:0=",<&cam0_reg>;
+ 		clock-frequency = <&clk_over>, "clock-frequency:0";
++		always-on = <0>, "+99";
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/imx477_378-overlay.dtsi
++++ b/arch/arm/boot/dts/overlays/imx477_378-overlay.dtsi
+@@ -33,6 +33,13 @@
+ 		};
+ 	};
+ 
++	reg_alwayson_frag: fragment@99 {
++		target = <&cam1_reg>;
++		__dormant__ {
++			regulator-always-on;
++		};
++	};
++
+ 	i2c_frag: fragment@100 {
+ 		target = <&i2c_csi_dsi>;
+ 		__overlay__ {
+@@ -69,8 +76,10 @@
+ 		       <&csi_frag>, "target:0=",<&csi0>,
+ 		       <&clk_frag>, "target:0=",<&cam0_clk>,
+ 		       <&reg_frag>, "target:0=",<&cam0_reg>,
++		       <&reg_alwayson_frag>, "target:0=",<&cam0_reg>,
+ 		       <&cam_node>, "clocks:0=",<&cam0_clk>,
+ 		       <&cam_node>, "VANA-supply:0=",<&cam0_reg>;
++		always-on = <0>, "+99";
+ 	};
+ };
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1224-input-edt-ft5x06-Correct-prefix-length-in-snprintf.patch b/target/linux/bcm27xx/patches-6.1/950-1224-input-edt-ft5x06-Correct-prefix-length-in-snprintf.patch
new file mode 100644
index 0000000000..6fb8fc0b95
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1224-input-edt-ft5x06-Correct-prefix-length-in-snprintf.patch
@@ -0,0 +1,29 @@
+From e0ecfaf1abfd5ef63ceec7606352020a80a2742b Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Mon, 18 Dec 2023 11:49:36 +0000
+Subject: [PATCH] input: edt-ft5x06: Correct prefix length in snprintf
+
+snprintf takes the length of the array that we can print into,
+and has to fit the NULL terminator in there too.
+Printing the prefix is generally "12-3456 " which is 8 desired
+characters (the length of EDT_NAME_PREFIX_LEN) and the NULL.
+The space is therefore being truncated to fit the NULL in.
+
+Increase the length snprintf is allowed to use.
+
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/input/touchscreen/edt-ft5x06.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/input/touchscreen/edt-ft5x06.c
++++ b/drivers/input/touchscreen/edt-ft5x06.c
+@@ -966,7 +966,7 @@ static int edt_ft5x06_ts_identify(struct
+ 	char *model_name = tsdata->name;
+ 	char *fw_version = tsdata->fw_version;
+ 
+-	snprintf(model_name, EDT_NAME_PREFIX_LEN, "%s ", dev_name(&client->dev));
++	snprintf(model_name, EDT_NAME_PREFIX_LEN + 1, "%s ", dev_name(&client->dev));
+ 	model_name += strlen(model_name);
+ 
+ 	/* see what we find if we assume it is a M06 *
diff --git a/target/linux/bcm27xx/patches-6.1/950-1225-ARM-dts-bcm2712-rpi-5-b-Allow-RTC-to-be-disabled.patch b/target/linux/bcm27xx/patches-6.1/950-1225-ARM-dts-bcm2712-rpi-5-b-Allow-RTC-to-be-disabled.patch
new file mode 100644
index 0000000000..5a3e6df555
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1225-ARM-dts-bcm2712-rpi-5-b-Allow-RTC-to-be-disabled.patch
@@ -0,0 +1,38 @@
+From da5fd98469edd797ed77d9a8690a608c6b54f9e6 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 19 Dec 2023 14:55:21 +0000
+Subject: [PATCH] ARM: dts: bcm2712-rpi-5-b: Allow RTC to be disabled
+
+Add a dtparam "rtc", so that "dtparam=rtc=off" can be used to disable
+the Pi 5's onboard RTC.
+
+See: https://forums.raspberrypi.com/viewtopic.php?t=361813
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 1 +
+ arch/arm/boot/dts/overlays/README     | 3 +++
+ 2 files changed, 4 insertions(+)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -819,6 +819,7 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		pciex1_tperst_clk_ms = <&pciex1>, "brcm,tperst-clk-ms:0";
+ 		pcie_tperst_clk_ms = <&pciex1>, "brcm,tperst-clk-ms:0";
+ 		random = <&random>, "status";
++		rtc = <&rpi_rtc>, "status";
+ 		rtc_bbat_vchg = <&rpi_rtc>, "trickle-charge-microvolt:0";
+ 		spi = <&spi0>, "status";
+ 		suspend = <&pwr_key>, "linux,code:0=205";
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -307,6 +307,9 @@ Params:
+         random                  Set to "on" to enable the hardware random
+                                 number generator (default "on")
+ 
++        rtc                     Set to "off" to disable the onboard Real Time
++                                Clock (2712 only, default "on")
++
+         rtc_bbat_vchg           Set the RTC backup battery charging voltage in
+                                 microvolts. If set to 0 or not specified, the
+                                 trickle charger is disabled.
diff --git a/target/linux/bcm27xx/patches-6.1/950-1226-i2c-designware-Look-for-CNT-values-in-DT.patch b/target/linux/bcm27xx/patches-6.1/950-1226-i2c-designware-Look-for-CNT-values-in-DT.patch
new file mode 100644
index 0000000000..ccba16ad8e
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1226-i2c-designware-Look-for-CNT-values-in-DT.patch
@@ -0,0 +1,57 @@
+From 0a09088e24c013ef608b1bb79501ef890cefc767 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 19 Dec 2023 11:16:25 +0000
+Subject: [PATCH] i2c: designware: Look for *CNT values in DT
+
+The i2c-designware driver supports reading precise timing values from
+ACPI, but the Device Tree support relies on a combination of standard
+rise and fall times and hard-coded minimum timings. The result of this
+is that it is difficult to get optimum timings, particularly given that
+the values are bus speed-specific and only one set can be stored in
+DT at a time.
+
+Add support for initialisation from DT that is similar to that for
+ACPI.
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/i2c/busses/i2c-designware-platdrv.c | 18 ++++++++++++++++++
+ 1 file changed, 18 insertions(+)
+
+--- a/drivers/i2c/busses/i2c-designware-platdrv.c
++++ b/drivers/i2c/busses/i2c-designware-platdrv.c
+@@ -132,9 +132,18 @@ static int mscc_twi_set_sda_hold_time(st
+ 	return 0;
+ }
+ 
++static void dw_i2c_read_of_cnt(struct device_node *np, const char *name, u16 *pval)
++{
++	u32 val;
++
++	if (!of_property_read_u32(np, name, &val))
++		*pval = (u16)val;
++}
++
+ static int dw_i2c_of_configure(struct platform_device *pdev)
+ {
+ 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
++	struct device_node *np = pdev->dev.of_node;
+ 
+ 	switch (dev->flags & MODEL_MASK) {
+ 	case MODEL_MSCC_OCELOT:
+@@ -146,6 +155,15 @@ static int dw_i2c_of_configure(struct pl
+ 		break;
+ 	}
+ 
++	dw_i2c_read_of_cnt(np, "snps,ss_hcnt", &dev->ss_hcnt);
++	dw_i2c_read_of_cnt(np, "snps,ss_lcnt", &dev->ss_lcnt);
++	dw_i2c_read_of_cnt(np, "snps,fs_hcnt", &dev->fs_hcnt);
++	dw_i2c_read_of_cnt(np, "snps,fs_lcnt", &dev->fs_lcnt);
++	dw_i2c_read_of_cnt(np, "snps,fp_hcnt", &dev->fp_hcnt);
++	dw_i2c_read_of_cnt(np, "snps,fp_lcnt", &dev->fp_lcnt);
++	dw_i2c_read_of_cnt(np, "snps,hs_hcnt", &dev->hs_hcnt);
++	dw_i2c_read_of_cnt(np, "snps,hs_lcnt", &dev->hs_lcnt);
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1227-dts-rp1-Add-I2C-timings.patch b/target/linux/bcm27xx/patches-6.1/950-1227-dts-rp1-Add-I2C-timings.patch
new file mode 100644
index 0000000000..892f31ec9f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1227-dts-rp1-Add-I2C-timings.patch
@@ -0,0 +1,103 @@
+From 660d569b1a623e4b64350e608bbf8bc2cc6332e9 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Tue, 19 Dec 2023 11:27:20 +0000
+Subject: [PATCH] dts: rp1: Add I2C timings
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/rp1.dtsi | 42 ++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 42 insertions(+)
+
+--- a/arch/arm/boot/dts/rp1.dtsi
++++ b/arch/arm/boot/dts/rp1.dtsi
+@@ -305,6 +305,12 @@
+ 			compatible = "snps,designware-i2c";
+ 			interrupts = <RP1_INT_I2C0 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			snps,ss_hcnt = <978>;
++			snps,ss_lcnt = <990>;
++			snps,fs_hcnt = <200>;
++			snps,fs_lcnt = <268>;
++			snps,fp_hcnt = <60>;
++			snps,fp_lcnt = <107>;
+ 			status = "disabled";
+ 		};
+ 
+@@ -313,6 +319,12 @@
+ 			compatible = "snps,designware-i2c";
+ 			interrupts = <RP1_INT_I2C1 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			snps,ss_hcnt = <978>;
++			snps,ss_lcnt = <990>;
++			snps,fs_hcnt = <200>;
++			snps,fs_lcnt = <268>;
++			snps,fp_hcnt = <60>;
++			snps,fp_lcnt = <107>;
+ 			status = "disabled";
+ 		};
+ 
+@@ -321,6 +333,12 @@
+ 			compatible = "snps,designware-i2c";
+ 			interrupts = <RP1_INT_I2C2 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			snps,ss_hcnt = <978>;
++			snps,ss_lcnt = <990>;
++			snps,fs_hcnt = <200>;
++			snps,fs_lcnt = <268>;
++			snps,fp_hcnt = <60>;
++			snps,fp_lcnt = <107>;
+ 			status = "disabled";
+ 		};
+ 
+@@ -329,6 +347,12 @@
+ 			compatible = "snps,designware-i2c";
+ 			interrupts = <RP1_INT_I2C3 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			snps,ss_hcnt = <978>;
++			snps,ss_lcnt = <990>;
++			snps,fs_hcnt = <200>;
++			snps,fs_lcnt = <268>;
++			snps,fp_hcnt = <60>;
++			snps,fp_lcnt = <107>;
+ 			status = "disabled";
+ 		};
+ 
+@@ -337,6 +361,12 @@
+ 			compatible = "snps,designware-i2c";
+ 			interrupts = <RP1_INT_I2C4 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			snps,ss_hcnt = <978>;
++			snps,ss_lcnt = <990>;
++			snps,fs_hcnt = <200>;
++			snps,fs_lcnt = <268>;
++			snps,fp_hcnt = <60>;
++			snps,fp_lcnt = <107>;
+ 			status = "disabled";
+ 		};
+ 
+@@ -345,6 +375,12 @@
+ 			compatible = "snps,designware-i2c";
+ 			interrupts = <RP1_INT_I2C5 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			snps,ss_hcnt = <978>;
++			snps,ss_lcnt = <990>;
++			snps,fs_hcnt = <200>;
++			snps,fs_lcnt = <268>;
++			snps,fp_hcnt = <60>;
++			snps,fp_lcnt = <107>;
+ 			status = "disabled";
+ 		};
+ 
+@@ -353,6 +389,12 @@
+ 			compatible = "snps,designware-i2c";
+ 			interrupts = <RP1_INT_I2C6 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&rp1_clocks RP1_CLK_SYS>;
++			snps,ss_hcnt = <978>;
++			snps,ss_lcnt = <990>;
++			snps,fs_hcnt = <200>;
++			snps,fs_lcnt = <268>;
++			snps,fp_hcnt = <60>;
++			snps,fp_lcnt = <107>;
+ 			status = "disabled";
+ 		};
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1228-drivers-media-pisp_be-pisp_fe-Update-UAPI-header-lic.patch b/target/linux/bcm27xx/patches-6.1/950-1228-drivers-media-pisp_be-pisp_fe-Update-UAPI-header-lic.patch
new file mode 100644
index 0000000000..fc77e4d1cf
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1228-drivers-media-pisp_be-pisp_fe-Update-UAPI-header-lic.patch
@@ -0,0 +1,58 @@
+From 74c6c159c2b499bdf3c39961bd40eb9243624226 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Wed, 29 Nov 2023 13:09:05 +0000
+Subject: [PATCH] drivers: media: pisp_be: pisp_fe: Update UAPI header licenses
+
+Update the license tags on the pisp UAPI header files with the
+"Linux-syscall-note" clause.  Also replace the "GPL-2.0" tag with the
+preferred "GPL-2.0-only" tag.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ drivers/media/platform/raspberrypi/pisp_be/pisp_be_config.h  | 2 +-
+ drivers/media/platform/raspberrypi/rp1_cfe/pisp_common.h     | 2 +-
+ drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe_config.h  | 2 +-
+ drivers/media/platform/raspberrypi/rp1_cfe/pisp_statistics.h | 2 +-
+ drivers/media/platform/raspberrypi/rp1_cfe/pisp_types.h      | 2 +-
+ 5 files changed, 5 insertions(+), 5 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/pisp_be/pisp_be_config.h
++++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be_config.h
+@@ -1,4 +1,4 @@
+-/* SPDX-License-Identifier: GPL-2.0-only */
++/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+ /*
+  * PiSP Back End configuration definitions.
+  *
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_common.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_common.h
+@@ -1,4 +1,4 @@
+-/* SPDX-License-Identifier: GPL-2.0 */
++/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+ /*
+  * RP1 PiSP common definitions.
+  *
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe_config.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_fe_config.h
+@@ -1,4 +1,4 @@
+-/* SPDX-License-Identifier: GPL-2.0 */
++/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+ /*
+  * RP1 PiSP Front End Driver Configuration structures
+  *
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_statistics.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_statistics.h
+@@ -1,4 +1,4 @@
+-/* SPDX-License-Identifier: GPL-2.0 */
++/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+ /*
+  * RP1 PiSP Front End statistics definitions
+  *
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/pisp_types.h
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/pisp_types.h
+@@ -1,4 +1,4 @@
+-/* SPDX-License-Identifier: GPL-2.0 */
++/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+ /*
+  * RP1 PiSP Front End image definitions.
+  *
diff --git a/target/linux/bcm27xx/patches-6.1/950-1229-drivers-media-cfe-Add-more-robust-ISR-handlers.patch b/target/linux/bcm27xx/patches-6.1/950-1229-drivers-media-cfe-Add-more-robust-ISR-handlers.patch
new file mode 100644
index 0000000000..b79cad417f
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1229-drivers-media-cfe-Add-more-robust-ISR-handlers.patch
@@ -0,0 +1,207 @@
+From 6fb7a0b4c1dd6cf5b12ec2b2c197dcf8e58cd2b9 Mon Sep 17 00:00:00 2001
+From: Naushir Patuck <naush@raspberrypi.com>
+Date: Mon, 18 Dec 2023 09:52:45 +0000
+Subject: [PATCH] drivers: media: cfe: Add more robust ISR handlers
+
+Update the ISR logic to be more robust to sensors in problematic states
+where interrupts may start arriving overlapped and/or missing.
+
+1) Test for cur_frame in the FE handler, and if present, dequeue it in
+an error state so that it does not get orphaned.
+
+2) Move the sequence counter and timestamp variables to the node
+structures.  This allows the ISR to track channels running ahead when
+interrupts arrive unordered.
+
+3) Add a test to ensure we don't have a spurios (but harmlesS) call to
+the FE handler in some circumstances.
+
+Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
+---
+ .../media/platform/raspberrypi/rp1_cfe/cfe.c  | 92 ++++++++++---------
+ 1 file changed, 49 insertions(+), 43 deletions(-)
+
+--- a/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
++++ b/drivers/media/platform/raspberrypi/rp1_cfe/cfe.c
+@@ -272,6 +272,8 @@ struct cfe_node {
+ 	/* Pointer to the parent handle */
+ 	struct cfe_device *cfe;
+ 	struct media_pad pad;
++	unsigned int fs_count;
++	u64 ts;
+ };
+ 
+ struct cfe_device {
+@@ -311,9 +313,6 @@ struct cfe_device {
+ 	struct pisp_fe_device fe;
+ 
+ 	int fe_csi2_channel;
+-
+-	unsigned int sequence;
+-	u64 ts;
+ };
+ 
+ static inline bool is_fe_enabled(struct cfe_device *cfe)
+@@ -393,17 +392,6 @@ static bool test_all_nodes(struct cfe_de
+ 	return true;
+ }
+ 
+-static void clear_all_nodes(struct cfe_device *cfe, unsigned long precond,
+-			    unsigned long state)
+-{
+-	unsigned int i;
+-
+-	for (i = 0; i < NUM_NODES; i++) {
+-		if (check_state(cfe, precond, i))
+-			clear_state(cfe, state, i);
+-	}
+-}
+-
+ static int mipi_cfg_regs_show(struct seq_file *s, void *data)
+ {
+ 	struct cfe_device *cfe = s->private;
+@@ -656,22 +644,22 @@ static void cfe_prepare_next_job(struct
+ }
+ 
+ static void cfe_process_buffer_complete(struct cfe_node *node,
+-					unsigned int sequence)
++					enum vb2_buffer_state state)
+ {
+ 	struct cfe_device *cfe = node->cfe;
+ 
+ 	cfe_dbg_verbose("%s: [%s] buffer:%p\n", __func__,
+ 			node_desc[node->id].name, &node->cur_frm->vb.vb2_buf);
+ 
+-	node->cur_frm->vb.sequence = sequence;
+-	vb2_buffer_done(&node->cur_frm->vb.vb2_buf, VB2_BUF_STATE_DONE);
++	node->cur_frm->vb.sequence = node->fs_count - 1;
++	vb2_buffer_done(&node->cur_frm->vb.vb2_buf, state);
+ }
+ 
+ static void cfe_queue_event_sof(struct cfe_node *node)
+ {
+ 	struct v4l2_event event = {
+ 		.type = V4L2_EVENT_FRAME_SYNC,
+-		.u.frame_sync.frame_sequence = node->cfe->sequence,
++		.u.frame_sync.frame_sequence = node->fs_count - 1,
+ 	};
+ 
+ 	v4l2_event_queue(&node->video_dev, &event);
+@@ -680,28 +668,53 @@ static void cfe_queue_event_sof(struct c
+ static void cfe_sof_isr_handler(struct cfe_node *node)
+ {
+ 	struct cfe_device *cfe = node->cfe;
++	bool matching_fs = true;
++	unsigned int i;
+ 
+ 	cfe_dbg_verbose("%s: [%s] seq %u\n", __func__, node_desc[node->id].name,
+-			cfe->sequence);
+-
+-	node->cur_frm = node->next_frm;
+-	node->next_frm = NULL;
++			node->fs_count);
+ 
+ 	/*
+-	 * If this is the first node to see a frame start,  sample the
+-	 * timestamp to use for all frames across all channels.
++	 * If the sensor is producing unexpected frame event ordering over a
++	 * sustained period of time, guard against the possibility of coming
++	 * here and orphaning the cur_frm if it's not been dequeued already.
++	 * Unfortunately, there is not enough hardware state to tell if this
++	 * may have occurred.
+ 	 */
+-	if (!test_any_node(cfe, NODE_STREAMING | FS_INT))
+-		cfe->ts = ktime_get_ns();
++	if (WARN(node->cur_frm, "%s: [%s] Orphanded frame at seq %u\n",
++		 __func__, node_desc[node->id].name, node->fs_count))
++		cfe_process_buffer_complete(node, VB2_BUF_STATE_ERROR);
+ 
+-	set_state(cfe, FS_INT, node->id);
++	node->cur_frm = node->next_frm;
++	node->next_frm = NULL;
++	node->fs_count++;
+ 
+-	/* If all nodes have seen a frame start, we can queue another job. */
+-	if (test_all_nodes(cfe, NODE_STREAMING, FS_INT))
++	node->ts = ktime_get_ns();
++	for (i = 0; i < NUM_NODES; i++) {
++		if (!check_state(cfe, NODE_STREAMING, i) || i == node->id)
++			continue;
++		/*
++		 * This checks if any other node has seen a FS. If yes, use the
++		 * same timestamp, eventually across all node buffers.
++		 */
++		if (cfe->node[i].fs_count >= node->fs_count)
++			node->ts = cfe->node[i].ts;
++		/*
++		 * This checks if all other node have seen a matching FS. If
++		 * yes, we can flag another job to be queued.
++		 */
++		if (matching_fs && cfe->node[i].fs_count != node->fs_count)
++			matching_fs = false;
++	}
++
++	if (matching_fs)
+ 		cfe->job_queued = false;
+ 
+ 	if (node->cur_frm)
+-		node->cur_frm->vb.vb2_buf.timestamp = cfe->ts;
++		node->cur_frm->vb.vb2_buf.timestamp = node->ts;
++
++	set_state(cfe, FS_INT, node->id);
++	clear_state(cfe, FE_INT, node->id);
+ 
+ 	if (is_image_output_node(node))
+ 		cfe_queue_event_sof(node);
+@@ -712,22 +725,14 @@ static void cfe_eof_isr_handler(struct c
+ 	struct cfe_device *cfe = node->cfe;
+ 
+ 	cfe_dbg_verbose("%s: [%s] seq %u\n", __func__, node_desc[node->id].name,
+-			cfe->sequence);
++			node->fs_count - 1);
+ 
+ 	if (node->cur_frm)
+-		cfe_process_buffer_complete(node, cfe->sequence);
++		cfe_process_buffer_complete(node, VB2_BUF_STATE_DONE);
+ 
+ 	node->cur_frm = NULL;
+ 	set_state(cfe, FE_INT, node->id);
+-
+-	/*
+-	 * If all nodes have seen a frame end, we can increment
+-	 * the sequence counter now.
+-	 */
+-	if (test_all_nodes(cfe, NODE_STREAMING, FE_INT)) {
+-		cfe->sequence++;
+-		clear_all_nodes(cfe, NODE_STREAMING, FE_INT | FS_INT);
+-	}
++	clear_state(cfe, FS_INT, node->id);
+ }
+ 
+ static irqreturn_t cfe_isr(int irq, void *dev)
+@@ -794,7 +799,8 @@ static irqreturn_t cfe_isr(int irq, void
+ 			 * frame first before the FS handler for the current
+ 			 * frame.
+ 			 */
+-			if (check_state(cfe, FS_INT, node->id)) {
++			if (check_state(cfe, FS_INT, node->id) &&
++			    !check_state(cfe, FE_INT, node->id)) {
+ 				cfe_dbg("%s: [%s] Handling missing previous FE interrupt\n",
+ 					__func__, node_desc[node->id].name);
+ 				cfe_eof_isr_handler(node);
+@@ -1131,6 +1137,7 @@ static int cfe_start_streaming(struct vb
+ 
+ 	clear_state(cfe, FS_INT | FE_INT, node->id);
+ 	set_state(cfe, NODE_STREAMING, node->id);
++	node->fs_count = 0;
+ 	cfe_start_channel(node);
+ 
+ 	if (!test_all_nodes(cfe, NODE_ENABLED, NODE_STREAMING)) {
+@@ -1166,7 +1173,6 @@ static int cfe_start_streaming(struct vb
+ 	csi2_open_rx(&cfe->csi2);
+ 
+ 	cfe_dbg("Starting sensor streaming\n");
+-	cfe->sequence = 0;
+ 	ret = v4l2_subdev_call(cfe->sensor, video, s_stream, 1);
+ 	if (ret < 0) {
+ 		cfe_err("stream on failed in subdev\n");
diff --git a/target/linux/bcm27xx/patches-6.1/950-1231-ASoC-dwc-Defer-bclk_ratio-handling-to-hw_params.patch b/target/linux/bcm27xx/patches-6.1/950-1231-ASoC-dwc-Defer-bclk_ratio-handling-to-hw_params.patch
new file mode 100644
index 0000000000..c187507545
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1231-ASoC-dwc-Defer-bclk_ratio-handling-to-hw_params.patch
@@ -0,0 +1,89 @@
+From dfc04900c40eb14f9364d56e96db2cc3340a1f21 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Wed, 3 Jan 2024 14:43:43 +0000
+Subject: [PATCH] ASoC: dwc: Defer bclk_ratio handling to hw_params
+
+bclk_ratio is only a factor in clock producer mode, and needs to
+override the default value of num_channels * sample_size.
+Move the bclk_ratio handling into the hw_params method, only latching
+the value in set_bclk_ratio, to address both of those matters.
+
+See: https://github.com/raspberrypi/linux/issues/5817
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ sound/soc/dwc/dwc-i2s.c | 38 +++++++++++++++++++++-----------------
+ sound/soc/dwc/local.h   |  1 +
+ 2 files changed, 22 insertions(+), 17 deletions(-)
+
+--- a/sound/soc/dwc/dwc-i2s.c
++++ b/sound/soc/dwc/dwc-i2s.c
+@@ -263,6 +263,25 @@ static int dw_i2s_hw_params(struct snd_p
+ 		return -EINVAL;
+ 	}
+ 
++	if ((dev->capability & DW_I2S_MASTER) && dev->bclk_ratio) {
++		switch (dev->bclk_ratio) {
++		case 32:
++			dev->ccr = 0x00;
++			break;
++
++		case 48:
++			dev->ccr = 0x08;
++			break;
++
++		case 64:
++			dev->ccr = 0x10;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++
+ 	config->chan_nr = params_channels(params);
+ 
+ 	switch (config->chan_nr) {
+@@ -436,23 +455,7 @@ static int dw_i2s_set_bclk_ratio(struct
+ 
+ 	dev_dbg(dev->dev, "%s(%d)\n", __func__, ratio);
+ 
+-	switch (ratio) {
+-	case 32:
+-		dev->ccr = 0x00;
+-		break;
+-
+-	case 48:
+-		dev->ccr = 0x08;
+-		break;
+-
+-	case 64:
+-		dev->ccr = 0x10;
+-		break;
+-	default:
+-		return -EINVAL;
+-	}
+-
+-	i2s_write_reg(dev->i2s_base, CCR, dev->ccr);
++	dev->bclk_ratio = ratio;
+ 
+ 	return 0;
+ }
+@@ -746,6 +749,7 @@ static int dw_i2s_probe(struct platform_
+ 		}
+ 	}
+ 
++	dev->bclk_ratio = 0;
+ 	dev->i2s_reg_comp1 = I2S_COMP_PARAM_1;
+ 	dev->i2s_reg_comp2 = I2S_COMP_PARAM_2;
+ 	if (pdata) {
+--- a/sound/soc/dwc/local.h
++++ b/sound/soc/dwc/local.h
+@@ -107,6 +107,7 @@ struct dw_i2s_dev {
+ 	unsigned int quirks;
+ 	unsigned int i2s_reg_comp1;
+ 	unsigned int i2s_reg_comp2;
++	unsigned int bclk_ratio;
+ 	struct device *dev;
+ 	u32 ccr;
+ 	u32 xfer_resolution;
diff --git a/target/linux/bcm27xx/patches-6.1/950-1232-drm-vc4-Fix-reading-of-frame-count-on-GEN5-Pi4.patch b/target/linux/bcm27xx/patches-6.1/950-1232-drm-vc4-Fix-reading-of-frame-count-on-GEN5-Pi4.patch
new file mode 100644
index 0000000000..4374e24244
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1232-drm-vc4-Fix-reading-of-frame-count-on-GEN5-Pi4.patch
@@ -0,0 +1,79 @@
+From d5066442e39dd9bf4ba6431ffb3f99e3d5085d3f Mon Sep 17 00:00:00 2001
+From: Dave Stevenson <dave.stevenson@raspberrypi.com>
+Date: Thu, 4 Jan 2024 12:02:43 +0000
+Subject: [PATCH] drm/vc4: Fix reading of frame count on GEN5 / Pi4
+
+The frame count values moved within registers DISPSTAT1 and
+DISPSTAT2 with GEN5, so update the accessor function to
+accommodate that.
+
+Fixes: b51cd7ad143d ("drm/vc4: hvs: Fix frame count register readout")
+Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
+---
+ drivers/gpu/drm/vc4/vc4_hvs.c  | 23 +++++++++++++++++++++--
+ drivers/gpu/drm/vc4/vc4_regs.h |  6 ++++++
+ 2 files changed, 27 insertions(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_hvs.c
++++ b/drivers/gpu/drm/vc4/vc4_hvs.c
+@@ -823,10 +823,28 @@ u8 vc4_hvs_get_fifo_frame_count(struct v
+ 	if (!drm_dev_enter(drm, &idx))
+ 		return 0;
+ 
+-	if (vc4->gen >= VC4_GEN_6) {
++	switch (vc4->gen) {
++	case VC4_GEN_6:
+ 		field = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_STATUS(fifo)),
+ 				      SCALER6_DISPX_STATUS_FRCNT);
+-	} else {
++		break;
++	case VC4_GEN_5:
++		switch (fifo) {
++		case 0:
++			field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),
++					      SCALER5_DISPSTAT1_FRCNT0);
++			break;
++		case 1:
++			field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),
++					      SCALER5_DISPSTAT1_FRCNT1);
++			break;
++		case 2:
++			field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT2),
++					      SCALER5_DISPSTAT2_FRCNT2);
++			break;
++		}
++		break;
++	case VC4_GEN_4:
+ 		switch (fifo) {
+ 		case 0:
+ 			field = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTAT1),
+@@ -841,6 +859,7 @@ u8 vc4_hvs_get_fifo_frame_count(struct v
+ 					      SCALER_DISPSTAT2_FRCNT2);
+ 			break;
+ 		}
++		break;
+ 	}
+ 
+ 	drm_dev_exit(idx);
+--- a/drivers/gpu/drm/vc4/vc4_regs.h
++++ b/drivers/gpu/drm/vc4/vc4_regs.h
+@@ -424,6 +424,10 @@
+ # define SCALER_DISPSTAT1_FRCNT0_SHIFT		18
+ # define SCALER_DISPSTAT1_FRCNT1_MASK		VC4_MASK(17, 12)
+ # define SCALER_DISPSTAT1_FRCNT1_SHIFT		12
++# define SCALER5_DISPSTAT1_FRCNT0_MASK		VC4_MASK(25, 20)
++# define SCALER5_DISPSTAT1_FRCNT0_SHIFT		20
++# define SCALER5_DISPSTAT1_FRCNT1_MASK		VC4_MASK(19, 14)
++# define SCALER5_DISPSTAT1_FRCNT1_SHIFT		14
+ 
+ #define SCALER_DISPSTATX(x)			(SCALER_DISPSTAT0 +        \
+ 						 (x) * (SCALER_DISPSTAT1 - \
+@@ -442,6 +446,8 @@
+ #define SCALER_DISPSTAT2                        0x00000068
+ # define SCALER_DISPSTAT2_FRCNT2_MASK		VC4_MASK(17, 12)
+ # define SCALER_DISPSTAT2_FRCNT2_SHIFT		12
++# define SCALER5_DISPSTAT2_FRCNT2_MASK		VC4_MASK(19, 14)
++# define SCALER5_DISPSTAT2_FRCNT2_SHIFT		14
+ 
+ #define SCALER_DISPBASE2                        0x0000006c
+ #define SCALER_DISPALPHA2                       0x00000070
diff --git a/target/linux/bcm27xx/patches-6.1/950-1233-ARM-dts-bcm2712-rpi-5-b-Add-eth_ledx-parameters.patch b/target/linux/bcm27xx/patches-6.1/950-1233-ARM-dts-bcm2712-rpi-5-b-Add-eth_ledx-parameters.patch
new file mode 100644
index 0000000000..f0c6efa362
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1233-ARM-dts-bcm2712-rpi-5-b-Add-eth_ledx-parameters.patch
@@ -0,0 +1,56 @@
+From eeb5969ae34df16024f39a77496a44ae94bfab13 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 4 Jan 2024 13:56:39 +0000
+Subject: [PATCH] ARM: dts: bcm2712-rpi-5-b: Add eth_ledx parameters
+
+Include the dtparams controlling the Ethernet jack LEDs, as used on
+other Pis.
+
+See: https://github.com/raspberrypi/linux/issues/5825
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 2 ++
+ arch/arm/boot/dts/overlays/README     | 6 +++---
+ 2 files changed, 5 insertions(+), 3 deletions(-)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -830,6 +830,8 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		act_led_trigger = <&act_led>, "linux,default-trigger";
+ 		pwr_led_activelow = <&pwr_led>, "gpios:8";
+ 		pwr_led_trigger = <&pwr_led>, "linux,default-trigger";
++		eth_led0 = <&phy1>,"led-modes:0";
++		eth_led1 = <&phy1>,"led-modes:4";
+ 		drm_fb0_rp1_dsi0 = <&aliases>, "drm-fb0=",&dsi0;
+ 		drm_fb0_rp1_dsi1 = <&aliases>, "drm-fb0=",&dsi1;
+ 		drm_fb0_rp1_dpi = <&aliases>, "drm-fb0=",&dpi;
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -207,7 +207,7 @@ Params:
+                                 0 means never downshift (default 2). Pi3B+ only.
+ 
+         eth_led0                Set mode of LED0 - amber on Pi3B+ (default "1"),
+-                                green on Pi4 (default "0").
++                                green on Pi4/5 (default "0").
+                                 The legal values are:
+ 
+                                 Pi3B+
+@@ -217,7 +217,7 @@ Params:
+                                 4=link100/1000/activity  5=link10/1000/activity
+                                 6=link10/100/activity    14=off    15=on
+ 
+-                                Pi4
++                                Pi4/5
+ 
+                                 0=Speed/Activity         1=Speed
+                                 2=Flash activity         3=FDX
+@@ -226,7 +226,7 @@ Params:
+                                 8=Link                   9=Activity
+ 
+         eth_led1                Set mode of LED1 - green on Pi3B+ (default "6"),
+-                                amber on Pi4 (default "8"). See eth_led0 for
++                                amber on Pi4/5 (default "8"). See eth_led0 for
+                                 legal values.
+ 
+         eth_max_speed           Set the maximum speed a link is allowed
diff --git a/target/linux/bcm27xx/patches-6.1/950-1234-ARM-dts-bcm2712-rpi-5-b-Add-fan-speed-dtparams.patch b/target/linux/bcm27xx/patches-6.1/950-1234-ARM-dts-bcm2712-rpi-5-b-Add-fan-speed-dtparams.patch
new file mode 100644
index 0000000000..da2345fdf7
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1234-ARM-dts-bcm2712-rpi-5-b-Add-fan-speed-dtparams.patch
@@ -0,0 +1,71 @@
+From 2c085a1ff40521ab89d8f1894757aa83b59b4607 Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Thu, 4 Jan 2024 12:09:10 +0000
+Subject: [PATCH] ARM: dts: bcm2712-rpi-5-b: Add fan speed dtparams
+
+Add dtparams for adjusting the Pi 5 cooling fan speeds and temperature
+thresholds.
+
+See: https://github.com/raspberrypi/linux/issues/5820
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ arch/arm/boot/dts/bcm2712-rpi-5-b.dts | 13 +++++++++++++
+ arch/arm/boot/dts/overlays/README     | 25 +++++++++++++++++++++++++
+ 2 files changed, 38 insertions(+)
+
+--- a/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
++++ b/arch/arm/boot/dts/bcm2712-rpi-5-b.dts
+@@ -844,5 +844,18 @@ spi10_cs_pins: &spi10_cs_gpio1 {};
+ 		drm_fb2_rp1_dsi1 = <&aliases>, "drm-fb2=",&dsi1;
+ 		drm_fb2_rp1_dpi = <&aliases>, "drm-fb2=",&dpi;
+ 		drm_fb2_vc4 = <&aliases>, "drm-fb2=",&vc4;
++
++		fan_temp0 = <&cpu_tepid>,"temperature:0";
++		fan_temp1 = <&cpu_warm>,"temperature:0";
++		fan_temp2 = <&cpu_hot>,"temperature:0";
++		fan_temp3 = <&cpu_vhot>,"temperature:0";
++		fan_temp0_hyst = <&cpu_tepid>,"hysteresis:0";
++		fan_temp1_hyst = <&cpu_warm>,"hysteresis:0";
++		fan_temp2_hyst = <&cpu_hot>,"hysteresis:0";
++		fan_temp3_hyst = <&cpu_vhot>,"hysteresis:0";
++		fan_temp0_speed = <&fan>, "cooling-levels:4";
++		fan_temp1_speed = <&fan>, "cooling-levels:8";
++		fan_temp2_speed = <&fan>, "cooling-levels:12";
++		fan_temp3_speed = <&fan>, "cooling-levels:16";
+ 	};
+ };
+--- a/arch/arm/boot/dts/overlays/README
++++ b/arch/arm/boot/dts/overlays/README
+@@ -233,6 +233,31 @@ Params:
+                                 to negotiate. Legal values are 10, 100 and
+                                 1000 (default 1000). Pi3B+ only.
+ 
++        fan_temp0               Temperature threshold (in millicelcius) for
++                                1st cooling level (default 50000). Pi5 only.
++        fan_temp0_hyst          Temperature hysteresis (in millicelcius) for
++                                1st cooling level (default 5000). Pi5 only.
++        fan_temp0_speed         Fan PWM setting for 1st cooling level (0-255,
++                                default 75). Pi5 only.
++        fan_temp1               Temperature threshold (in millicelcius) for
++                                2nd cooling level (default 60000). Pi5 only.
++        fan_temp1_hyst          Temperature hysteresis (in millicelcius) for
++                                2nd cooling level (default 5000). Pi5 only.
++        fan_temp1_speed         Fan PWM setting for 2nd cooling level (0-255,
++                                default 125). Pi5 only.
++        fan_temp2               Temperature threshold (in millicelcius) for
++                                3rd cooling level (default 67500). Pi5 only.
++        fan_temp2_hyst          Temperature hysteresis (in millicelcius) for
++                                3rd cooling level (default 5000). Pi5 only.
++        fan_temp2_speed         Fan PWM setting for 3rd cooling level (0-255,
++                                default 175). Pi5 only.
++        fan_temp3               Temperature threshold (in millicelcius) for
++                                4th cooling level (default 75000). Pi5 only.
++        fan_temp3_hyst          Temperature hysteresis (in millicelcius) for
++                                4th cooling level (default 5000). Pi5 only.
++        fan_temp3_speed         Fan PWM setting for 4th cooling level (0-255,
++                                default 250). Pi5 only.
++
+         hdmi                    Set to "off" to disable the HDMI interface
+                                 (default "on")
+ 
diff --git a/target/linux/bcm27xx/patches-6.1/950-1235-drm-vc4-don-t-check-if-plane-state-fb-state-fb.patch b/target/linux/bcm27xx/patches-6.1/950-1235-drm-vc4-don-t-check-if-plane-state-fb-state-fb.patch
new file mode 100644
index 0000000000..7c7c05c5ef
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1235-drm-vc4-don-t-check-if-plane-state-fb-state-fb.patch
@@ -0,0 +1,93 @@
+From 146bbf9627f6c37816939de29538ec8ee9a7be1a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Ma=C3=ADra=20Canal?= <mcanal@igalia.com>
+Date: Fri, 5 Jan 2024 15:07:34 -0300
+Subject: [PATCH] drm/vc4: don't check if plane->state->fb == state->fb
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Currently, when using non-blocking commits, we can see the following
+kernel warning:
+
+[  110.908514] ------------[ cut here ]------------
+[  110.908529] refcount_t: underflow; use-after-free.
+[  110.908620] WARNING: CPU: 0 PID: 1866 at lib/refcount.c:87 refcount_dec_not_one+0xb8/0xc0
+[  110.908664] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device cmac algif_hash aes_arm64 aes_generic algif_skcipher af_alg bnep hid_logitech_hidpp vc4 brcmfmac hci_uart btbcm brcmutil bluetooth snd_soc_hdmi_codec cfg80211 cec drm_display_helper drm_dma_helper drm_kms_helper snd_soc_core snd_compress snd_pcm_dmaengine fb_sys_fops sysimgblt syscopyarea sysfillrect raspberrypi_hwmon ecdh_generic ecc rfkill libaes i2c_bcm2835 binfmt_misc joydev snd_bcm2835(C) bcm2835_codec(C) bcm2835_isp(C) v4l2_mem2mem videobuf2_dma_contig snd_pcm bcm2835_v4l2(C) raspberrypi_gpiomem bcm2835_mmal_vchiq(C) videobuf2_v4l2 snd_timer videobuf2_vmalloc videobuf2_memops videobuf2_common snd videodev vc_sm_cma(C) mc hid_logitech_dj uio_pdrv_genirq uio i2c_dev drm fuse dm_mod drm_panel_orientation_quirks backlight ip_tables x_tables ipv6
+[  110.909086] CPU: 0 PID: 1866 Comm: kodi.bin Tainted: G         C         6.1.66-v8+ #32
+[  110.909104] Hardware name: Raspberry Pi 3 Model B Rev 1.2 (DT)
+[  110.909114] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
+[  110.909132] pc : refcount_dec_not_one+0xb8/0xc0
+[  110.909152] lr : refcount_dec_not_one+0xb4/0xc0
+[  110.909170] sp : ffffffc00913b9c0
+[  110.909177] x29: ffffffc00913b9c0 x28: 000000556969bbb0 x27: 000000556990df60
+[  110.909205] x26: 0000000000000002 x25: 0000000000000004 x24: ffffff8004448480
+[  110.909230] x23: ffffff800570b500 x22: ffffff802e03a7bc x21: ffffffecfca68c78
+[  110.909257] x20: ffffff8002b42000 x19: ffffff802e03a600 x18: 0000000000000000
+[  110.909283] x17: 0000000000000011 x16: ffffffffffffffff x15: 0000000000000004
+[  110.909308] x14: 0000000000000fff x13: ffffffed577e47e0 x12: 0000000000000003
+[  110.909333] x11: 0000000000000000 x10: 0000000000000027 x9 : c912d0d083728c00
+[  110.909359] x8 : c912d0d083728c00 x7 : 65646e75203a745f x6 : 746e756f63666572
+[  110.909384] x5 : ffffffed579f62ee x4 : ffffffed579eb01e x3 : 0000000000000000
+[  110.909409] x2 : 0000000000000000 x1 : ffffffc00913b750 x0 : 0000000000000001
+[  110.909434] Call trace:
+[  110.909441]  refcount_dec_not_one+0xb8/0xc0
+[  110.909461]  vc4_bo_dec_usecnt+0x4c/0x1b0 [vc4]
+[  110.909903]  vc4_cleanup_fb+0x44/0x50 [vc4]
+[  110.910315]  drm_atomic_helper_cleanup_planes+0x88/0xa4 [drm_kms_helper]
+[  110.910669]  vc4_atomic_commit_tail+0x390/0x9dc [vc4]
+[  110.911079]  commit_tail+0xb0/0x164 [drm_kms_helper]
+[  110.911397]  drm_atomic_helper_commit+0x1d0/0x1f0 [drm_kms_helper]
+[  110.911716]  drm_atomic_commit+0xb0/0xdc [drm]
+[  110.912569]  drm_mode_atomic_ioctl+0x348/0x4b8 [drm]
+[  110.913330]  drm_ioctl_kernel+0xec/0x15c [drm]
+[  110.914091]  drm_ioctl+0x24c/0x3b0 [drm]
+[  110.914850]  __arm64_sys_ioctl+0x9c/0xd4
+[  110.914873]  invoke_syscall+0x4c/0x114
+[  110.914897]  el0_svc_common+0xd0/0x118
+[  110.914917]  do_el0_svc+0x38/0xd0
+[  110.914936]  el0_svc+0x30/0x8c
+[  110.914958]  el0t_64_sync_handler+0x84/0xf0
+[  110.914979]  el0t_64_sync+0x18c/0x190
+[  110.914996] ---[ end trace 0000000000000000 ]---
+
+This happens because, although `prepare_fb` and `cleanup_fb` are
+perfectly balanced, we cannot guarantee consistency in the check
+plane->state->fb == state->fb. This means that sometimes we can increase
+the refcount in `prepare_fb` and don't decrease it in `cleanup_fb`. The
+opposite can also be true.
+
+In fact, the struct drm_plane .state shouldn't be accessed directly
+but instead, the `drm_atomic_get_new_plane_state()` helper function should
+be used. So, we could stick to this check, but using
+`drm_atomic_get_new_plane_state()`. But actually, this check is not really
+needed. We can increase and decrease the refcount symmetrically without
+problems.
+
+This is going to make the code more simple and consistent.
+
+Signed-off-by: Mara Canal <mcanal@igalia.com>
+---
+ drivers/gpu/drm/vc4/vc4_plane.c | 5 +----
+ 1 file changed, 1 insertion(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/vc4/vc4_plane.c
++++ b/drivers/gpu/drm/vc4/vc4_plane.c
+@@ -2225,9 +2225,6 @@ static int vc4_prepare_fb(struct drm_pla
+ 
+ 	drm_gem_plane_helper_prepare_fb(plane, state);
+ 
+-	if (plane->state->fb == state->fb)
+-		return 0;
+-
+ 	return vc4_bo_inc_usecnt(bo);
+ }
+ 
+@@ -2236,7 +2233,7 @@ static void vc4_cleanup_fb(struct drm_pl
+ {
+ 	struct vc4_bo *bo;
+ 
+-	if (plane->state->fb == state->fb || !state->fb)
++	if (!state->fb)
+ 		return;
+ 
+ 	bo = to_vc4_bo(&drm_fb_dma_get_gem_obj(state->fb, 0)->base);
diff --git a/target/linux/bcm27xx/patches-6.1/950-1236-spi-bcm2835-Support-spi0-0cs-and-SPI_NO_CS-mode.patch b/target/linux/bcm27xx/patches-6.1/950-1236-spi-bcm2835-Support-spi0-0cs-and-SPI_NO_CS-mode.patch
new file mode 100644
index 0000000000..6039363a40
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1236-spi-bcm2835-Support-spi0-0cs-and-SPI_NO_CS-mode.patch
@@ -0,0 +1,42 @@
+From 5d9075ed7e73dc6ccebf78710c78f39ddc2dd78e Mon Sep 17 00:00:00 2001
+From: Phil Elwell <phil@raspberrypi.com>
+Date: Mon, 8 Jan 2024 11:42:57 +0000
+Subject: [PATCH] spi: bcm2835: Support spi0-0cs and SPI_NO_CS mode
+
+The forced conversion of native CS lines into software CS lines is done
+whether or not the controller has been given any CS lines to use. This
+breaks the use of the spi0-0cs overlay to prevent SPI from claiming any
+CS lines, particularly with spidev which doesn't pass in the SPI_NO_CS
+flag at creation.
+
+Use the presence of an empty cs-gpios property as an indication that no
+CS lines should be used, bypassing the native CS conversion code.
+
+See: https://github.com/raspberrypi/linux/issues/5835
+
+Signed-off-by: Phil Elwell <phil@raspberrypi.com>
+---
+ drivers/spi/spi-bcm2835.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/spi/spi-bcm2835.c
++++ b/drivers/spi/spi-bcm2835.c
+@@ -1222,6 +1222,7 @@ static int bcm2835_spi_setup(struct spi_
+ 	struct bcm2835_spi *bs = spi_controller_get_devdata(ctlr);
+ 	struct bcm2835_spidev *slv = spi_get_ctldata(spi);
+ 	struct gpio_chip *chip;
++	int len;
+ 	int ret;
+ 	u32 cs;
+ 
+@@ -1287,6 +1288,10 @@ static int bcm2835_spi_setup(struct spi_
+ 		goto err_cleanup;
+ 	}
+ 
++	/* Skip forced CS conversion if controller has an empty cs-gpios property */
++	if (of_find_property(ctlr->dev.of_node, "cs-gpios", &len) && len == 0)
++		return 0;
++
+ 	/*
+ 	 * Translate native CS to GPIO
+ 	 *
diff --git a/target/linux/bcm27xx/patches-6.1/950-1237-drivers-media-imx519-Add-V4L2_CID_LINK_FREQ-control.patch b/target/linux/bcm27xx/patches-6.1/950-1237-drivers-media-imx519-Add-V4L2_CID_LINK_FREQ-control.patch
new file mode 100644
index 0000000000..889ddd77dc
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1237-drivers-media-imx519-Add-V4L2_CID_LINK_FREQ-control.patch
@@ -0,0 +1,51 @@
+From 55ed8cded4af6530276b26f567601bed868ae8f5 Mon Sep 17 00:00:00 2001
+From: Lee Jackson <lee.jackson@arducam.com>
+Date: Wed, 10 Jan 2024 08:52:54 +0800
+Subject: [PATCH] drivers: media: imx519: Add V4L2_CID_LINK_FREQ control
+
+Add V4L2_CID_LINK_FREQ as a read-only control with a value of 408 Mhz.
+This will be used by the CFE driver to corretly setup the DPHY timing
+parameters in the CSI-2 block.
+
+Signed-off-by: Lee Jackson <lee.jackson@arducam.com>
+---
+ drivers/media/i2c/imx519.c | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+--- a/drivers/media/i2c/imx519.c
++++ b/drivers/media/i2c/imx519.c
+@@ -145,6 +145,10 @@ struct imx519_mode {
+ 	struct imx519_reg_list reg_list;
+ };
+ 
++static const s64 imx519_link_freq_menu[] = {
++	IMX519_DEFAULT_LINK_FREQ,
++};
++
+ static const struct imx519_reg mode_common_regs[] = {
+ 	{0x0100, 0x00},
+ 	{0x0136, 0x18},
+@@ -1819,6 +1823,7 @@ static int imx519_init_controls(struct i
+ 	struct v4l2_ctrl_handler *ctrl_hdlr;
+ 	struct i2c_client *client = v4l2_get_subdevdata(&imx519->sd);
+ 	struct v4l2_fwnode_device_properties props;
++	struct v4l2_ctrl *link_freq;
+ 	unsigned int i;
+ 	int ret;
+ 
+@@ -1837,6 +1842,15 @@ static int imx519_init_controls(struct i
+ 					       IMX519_PIXEL_RATE, 1,
+ 					       IMX519_PIXEL_RATE);
+ 
++	/* LINK_FREQ is also read only */
++	link_freq =
++		v4l2_ctrl_new_int_menu(ctrl_hdlr, &imx519_ctrl_ops,
++				       V4L2_CID_LINK_FREQ,
++				       ARRAY_SIZE(imx519_link_freq_menu) - 1, 0,
++				       imx519_link_freq_menu);
++	if (link_freq)
++		link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
++
+ 	/*
+ 	 * Create the controls here, but mode specific limits are setup
+ 	 * in the imx519_set_framing_limits() call below.
diff --git a/target/linux/bcm27xx/patches-6.1/950-1238-drivers-media-arducam_64mp-Add-V4L2_CID_LINK_FREQ-co.patch b/target/linux/bcm27xx/patches-6.1/950-1238-drivers-media-arducam_64mp-Add-V4L2_CID_LINK_FREQ-co.patch
new file mode 100644
index 0000000000..df353ffc31
--- /dev/null
+++ b/target/linux/bcm27xx/patches-6.1/950-1238-drivers-media-arducam_64mp-Add-V4L2_CID_LINK_FREQ-co.patch
@@ -0,0 +1,56 @@
+From 5e339e1502c9be0f624398cf774e5880a6d1a677 Mon Sep 17 00:00:00 2001
+From: Lee Jackson <lee.jackson@arducam.com>
+Date: Wed, 10 Jan 2024 09:06:16 +0800
+Subject: [PATCH] drivers: media: arducam_64mp: Add V4L2_CID_LINK_FREQ control
+
+Add V4L2_CID_LINK_FREQ as a read-only control with a value of 456 Mhz.
+This will be used by the CFE driver to corretly setup the DPHY timing
+parameters in the CSI-2 block.
+
+Signed-off-by: Lee Jackson <lee.jackson@arducam.com>
+---
+ drivers/media/i2c/arducam_64mp.c | 16 ++++++++++++++++
+ 1 file changed, 16 insertions(+)
+
+--- a/drivers/media/i2c/arducam_64mp.c
++++ b/drivers/media/i2c/arducam_64mp.c
+@@ -143,6 +143,10 @@ struct arducam_64mp_mode {
+ 	struct arducam_64mp_reg_list reg_list;
+ };
+ 
++static const s64 arducam_64mp_link_freq_menu[] = {
++	ARDUCAM_64MP_DEFAULT_LINK_FREQ,
++};
++
+ static const struct arducam_64mp_reg mode_common_regs[] = {
+ 	{0x0100, 0x00},
+ 	{0x0136, 0x18},
+@@ -2272,9 +2276,11 @@ static int arducam_64mp_init_controls(st
+ 	struct v4l2_ctrl_handler *ctrl_hdlr;
+ 	struct i2c_client *client = v4l2_get_subdevdata(&arducam_64mp->sd);
+ 	struct v4l2_fwnode_device_properties props;
++	struct v4l2_ctrl *link_freq;
+ 	unsigned int i;
+ 	int ret;
+ 	u8 test_pattern_max;
++	u8 link_freq_max;
+ 
+ 	ctrl_hdlr = &arducam_64mp->ctrl_handler;
+ 	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 16);
+@@ -2292,6 +2298,16 @@ static int arducam_64mp_init_controls(st
+ 						     ARDUCAM_64MP_PIXEL_RATE, 1,
+ 						     ARDUCAM_64MP_PIXEL_RATE);
+ 
++	/* LINK_FREQ is also read only */
++	link_freq_max = ARRAY_SIZE(arducam_64mp_link_freq_menu) - 1;
++	link_freq =
++		v4l2_ctrl_new_int_menu(ctrl_hdlr, &arducam_64mp_ctrl_ops,
++				       V4L2_CID_LINK_FREQ,
++				       link_freq_max, 0,
++				       arducam_64mp_link_freq_menu);
++	if (link_freq)
++		link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
++
+ 	/*
+ 	 * Create the controls here, but mode specific limits are setup
+ 	 * in the arducam_64mp_set_framing_limits() call below.
diff --git a/target/linux/bcm27xx/patches-6.1/960-hwrng-iproc-set-quality-to-1000.patch b/target/linux/bcm27xx/patches-6.1/960-hwrng-iproc-set-quality-to-1000.patch
index c1b4879a7c..cabe36ba71 100644
--- a/target/linux/bcm27xx/patches-6.1/960-hwrng-iproc-set-quality-to-1000.patch
+++ b/target/linux/bcm27xx/patches-6.1/960-hwrng-iproc-set-quality-to-1000.patch
@@ -15,7 +15,7 @@ Signed-off-by: lvaro Fernndez Rojas <noltari@gmail.com>
 
 --- a/drivers/char/hw_random/iproc-rng200.c
 +++ b/drivers/char/hw_random/iproc-rng200.c
-@@ -252,6 +252,7 @@ static int iproc_rng200_probe(struct pla
+@@ -253,6 +253,7 @@ static int iproc_rng200_probe(struct pla
  
  	priv->rng.name = pdev->name;
  	priv->rng.cleanup = iproc_rng200_cleanup;
-- 
2.40.1


From f757c9296a4ec4f61a09927e2520d0e8bc9bcd28 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Mon, 25 Dec 2023 00:21:48 -0500
Subject: [PATCH 16/24] kernel: add new kernel config symbols

New kernel kernel config symbols found on BCM2712.

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 target/linux/generic/config-6.1 | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/target/linux/generic/config-6.1 b/target/linux/generic/config-6.1
index d11c946dbc..c6301662f7 100644
--- a/target/linux/generic/config-6.1
+++ b/target/linux/generic/config-6.1
@@ -605,6 +605,7 @@ CONFIG_BASE_SMALL=0
 # CONFIG_BAYCOM_SER_FDX is not set
 # CONFIG_BAYCOM_SER_HDX is not set
 # CONFIG_BCACHE is not set
+# CONFIG_BCM2712_MIP is not set
 # CONFIG_BCM47XX is not set
 # CONFIG_BCM54140_PHY is not set
 # CONFIG_BCM63XX is not set
@@ -1036,6 +1037,8 @@ CONFIG_CMDLINE=""
 # CONFIG_COMMON_CLK_PWM is not set
 # CONFIG_COMMON_CLK_PXA is not set
 # CONFIG_COMMON_CLK_QCOM is not set
+# CONFIG_COMMON_CLK_RP1 is not set
+# CONFIG_COMMON_CLK_RP1_SDIO  is not set
 # CONFIG_COMMON_CLK_RS9_PCIE is not set
 # CONFIG_COMMON_CLK_SI514 is not set
 # CONFIG_COMMON_CLK_SI5341 is not set
@@ -1725,6 +1728,9 @@ CONFIG_DQL=y
 # CONFIG_DRM_RCAR_USE_LVDS is not set
 # CONFIG_DRM_RCAR_USE_MIPI_DSI is not set
 # CONFIG_DRM_ROCKCHIP is not set
+# CONFIG_DRM_RP1_DPI is not set
+# CONFIG_DRM_RP1_DSI is not set
+# CONFIG_DRM_RP1_VEC is not set
 # CONFIG_DRM_SII902X is not set
 # CONFIG_DRM_SII9234 is not set
 # CONFIG_DRM_SIL_SII8620 is not set
@@ -2083,6 +2089,7 @@ CONFIG_FB_NOTIFY=y
 # CONFIG_FB_PXA is not set
 # CONFIG_FB_RADEON is not set
 # CONFIG_FB_RIVA is not set
+# CONFIG_FB_RPISENSE is not set
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_S3 is not set
 # CONFIG_FB_SAVAGE is not set
@@ -2283,6 +2290,7 @@ CONFIG_GPIOLIB_FASTPATH_LIMIT=512
 # CONFIG_GPIO_AMDPT is not set
 # CONFIG_GPIO_AMD_FCH is not set
 # CONFIG_GPIO_BCM_KONA is not set
+# CONFIG_GPIO_BRCMSTB is not set
 # CONFIG_GPIO_BT8XX is not set
 # CONFIG_GPIO_CADENCE is not set
 # CONFIG_GPIO_CASCADE is not set
@@ -2853,6 +2861,7 @@ CONFIG_INPUT_MISC=y
 # CONFIG_INPUT_POWERMATE is not set
 # CONFIG_INPUT_PWM_BEEPER is not set
 # CONFIG_INPUT_PWM_VIBRA is not set
+# CONFIG_INPUT_RASPBERRYPI_BUTTON is not set
 # CONFIG_INPUT_REGULATOR_HAPTIC is not set
 # CONFIG_INPUT_SOC_BUTTON_ARRAY is not set
 # CONFIG_INPUT_SPARSEKMAP is not set
@@ -3609,6 +3618,7 @@ CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
 # CONFIG_MFD_PM8921_CORE is not set
 # CONFIG_MFD_PM8XXX is not set
 # CONFIG_MFD_QCOM_PM8008 is not set
+# CONFIG_MFD_RASPBERRYPI_POE_HAT is not set
 # CONFIG_MFD_RC5T583 is not set
 # CONFIG_MFD_RDC321X is not set
 # CONFIG_MFD_RETU is not set
@@ -3618,6 +3628,8 @@ CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
 # CONFIG_MFD_ROHM_BD71828 is not set
 # CONFIG_MFD_ROHM_BD718XX is not set
 # CONFIG_MFD_ROHM_BD957XMUF is not set
+# CONFIG_MFD_RP1 is not set
+# CONFIG_MFD_RPISENSE_CORE is not set
 # CONFIG_MFD_RSMU_I2C is not set
 # CONFIG_MFD_RSMU_SPI is not set
 # CONFIG_MFD_RT4831 is not set
@@ -4839,6 +4851,7 @@ CONFIG_PCI_SYSCALL=y
 # CONFIG_PHYLIB is not set
 # CONFIG_PHYLIB_LEDS is not set
 # CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_PHY_BRCM_USB is not set
 # CONFIG_PHY_CADENCE_DP is not set
 # CONFIG_PHY_CADENCE_DPHY is not set
 # CONFIG_PHY_CADENCE_DPHY_RX is not set
@@ -4875,6 +4888,7 @@ CONFIG_PINCONF=y
 # CONFIG_PINCTRL is not set
 # CONFIG_PINCTRL_AMD is not set
 # CONFIG_PINCTRL_AXP209 is not set
+# CONFIG_PINCTRL_BCM2712 is not set
 # CONFIG_PINCTRL_CEDARFORK is not set
 # CONFIG_PINCTRL_CY8C95X0 is not set
 # CONFIG_PINCTRL_EXYNOS is not set
@@ -4895,6 +4909,7 @@ CONFIG_PINCONF=y
 # CONFIG_PINCTRL_MTK_V2 is not set
 # CONFIG_PINCTRL_OCELOT is not set
 # CONFIG_PINCTRL_PISTACHIO is not set
+# CONFIG_PINCTRL_RP1 is not set
 # CONFIG_PINCTRL_SC7280 is not set
 # CONFIG_PINCTRL_SC8180X is not set
 # CONFIG_PINCTRL_SDX55 is not set
@@ -5053,6 +5068,7 @@ CONFIG_PSTORE_DEFAULT_KMSG_BYTES=10240
 # CONFIG_PWM_MEDIATEK is not set
 # CONFIG_PWM_PCA9685 is not set
 # CONFIG_PWM_RASPBERRYPI_POE is not set
+# CONFIG_PWM_RP1 is not set
 # CONFIG_PWM_XILINX is not set
 CONFIG_PWRSEQ_EMMC=y
 # CONFIG_PWRSEQ_SD8787 is not set
@@ -5127,6 +5143,7 @@ CONFIG_RANDOM_TRUST_CPU=y
 # CONFIG_RANDSTRUCT_NONE is not set
 # CONFIG_RAPIDIO is not set
 # CONFIG_RAS is not set
+# CONFIG_RASPBERRYPI_GPIOMEM is not set
 # CONFIG_RBTREE_TEST is not set
 # CONFIG_RCU_BOOST is not set
 CONFIG_RCU_CPU_STALL_TIMEOUT=60
@@ -5251,6 +5268,7 @@ CONFIG_REISERFS_FS_XATTR=y
 # CONFIG_RENESAS_PHY is not set
 # CONFIG_RESET_ATH79 is not set
 # CONFIG_RESET_BERLIN is not set
+# CONFIG_RESET_BRCMSTB is not set
 # CONFIG_RESET_BRCMSTB_RESCAL is not set
 # CONFIG_RESET_CONTROLLER is not set
 # CONFIG_RESET_IMX7 is not set
@@ -5779,6 +5797,7 @@ CONFIG_SELECT_MEMORY_MODEL=y
 # CONFIG_SENSORS_Q54SJ108A2 is not set
 # CONFIG_SENSORS_RM3100_I2C is not set
 # CONFIG_SENSORS_RM3100_SPI is not set
+# CONFIG_SENSORS_RP1_ADC is not set
 # CONFIG_SENSORS_SBRMI is not set
 # CONFIG_SENSORS_SBTSI is not set
 # CONFIG_SENSORS_SCH5627 is not set
@@ -6593,6 +6612,7 @@ CONFIG_STDBINUTILS=y
 # CONFIG_STMMAC_PCI is not set
 # CONFIG_STMMAC_PLATFORM is not set
 # CONFIG_STMMAC_SELFTESTS is not set
+# CONFIG_STMPE_ADC is not set
 # CONFIG_STM_DUMMY is not set
 # CONFIG_STM_SOURCE_CONSOLE is not set
 CONFIG_STP=y
@@ -7510,6 +7530,7 @@ CONFIG_VHOST_MENU=y
 # CONFIG_VIDEO_BT848 is not set
 # CONFIG_VIDEO_BT856 is not set
 # CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_BU64754 is not set
 # CONFIG_VIDEO_CADENCE is not set
 # CONFIG_VIDEO_CADENCE_CSI2RX is not set
 # CONFIG_VIDEO_CADENCE_CSI2TX is not set
@@ -7603,6 +7624,7 @@ CONFIG_VHOST_MENU=y
 # CONFIG_VIDEO_OV5675 is not set
 # CONFIG_VIDEO_OV5693 is not set
 # CONFIG_VIDEO_OV5695 is not set
+# CONFIG_VIDEO_OV64A40 is not set
 # CONFIG_VIDEO_OV6650 is not set
 # CONFIG_VIDEO_OV7251 is not set
 # CONFIG_VIDEO_OV7640 is not set
-- 
2.40.1


From 3f7f52250e604b50f73356851a18b688dac28e67 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Tue, 21 Nov 2023 16:34:28 -0500
Subject: [PATCH 17/24] bcm27xx: refresh config

Refresh kernel 6.1 config

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 target/linux/bcm27xx/bcm2708/config-6.1 | 11 ++++++-----
 target/linux/bcm27xx/bcm2709/config-6.1 |  6 +-----
 target/linux/bcm27xx/bcm2710/config-6.1 |  9 +--------
 target/linux/bcm27xx/bcm2711/config-6.1 |  9 +--------
 4 files changed, 9 insertions(+), 26 deletions(-)

diff --git a/target/linux/bcm27xx/bcm2708/config-6.1 b/target/linux/bcm27xx/bcm2708/config-6.1
index c5d604e6bc..27ed7e5b3a 100644
--- a/target/linux/bcm27xx/bcm2708/config-6.1
+++ b/target/linux/bcm27xx/bcm2708/config-6.1
@@ -30,7 +30,6 @@ CONFIG_ARM_UNWIND=y
 CONFIG_AUTO_ZRELADDR=y
 CONFIG_BCM2708_VCMEM=y
 # CONFIG_BCM2711_THERMAL is not set
-CONFIG_BCM2835_DEVGPIOMEM=y
 CONFIG_BCM2835_FAST_MEMCPY=y
 CONFIG_BCM2835_MBOX=y
 CONFIG_BCM2835_POWER=y
@@ -50,6 +49,7 @@ CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_MQ_PCI=y
 CONFIG_BLK_PM=y
 CONFIG_BRCMSTB_L2_IRQ=y
 CONFIG_BRCM_CHAR_DRIVERS=y
@@ -151,7 +151,6 @@ CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_IMAGEBLIT=y
 CONFIG_FB_CMDLINE=y
-# CONFIG_FB_RPISENSE is not set
 CONFIG_FB_SIMPLE=y
 CONFIG_FIQ=y
 CONFIG_FIXED_PHY=y
@@ -239,8 +238,6 @@ CONFIG_MDIO_DEVRES=y
 CONFIG_MEMFD_CREATE=y
 CONFIG_MEMORY_ISOLATION=y
 CONFIG_MFD_CORE=y
-# CONFIG_MFD_RASPBERRYPI_POE_HAT is not set
-# CONFIG_MFD_RPISENSE_CORE is not set
 CONFIG_MFD_SYSCON=y
 CONFIG_MIGHT_HAVE_CACHE_L2X0=y
 CONFIG_MIGRATION=y
@@ -253,6 +250,7 @@ CONFIG_MMC_BCM2835_SDHOST=y
 CONFIG_MMC_BLOCK=y
 CONFIG_MMC_BLOCK_MINORS=32
 CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PCI is not set
 CONFIG_MMC_SDHCI_PLTFM=y
 CONFIG_MODULES_USE_ELF_REL=y
 # CONFIG_MTD is not set
@@ -284,6 +282,9 @@ CONFIG_PAGE_OFFSET=0xC0000000
 CONFIG_PAGE_POOL=y
 CONFIG_PAGE_SIZE_LESS_THAN_256KB=y
 CONFIG_PAGE_SIZE_LESS_THAN_64KB=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
 CONFIG_PERF_USE_VMALLOC=y
 CONFIG_PGTABLE_LEVELS=2
 CONFIG_PHYLIB=y
@@ -296,7 +297,6 @@ CONFIG_PM_GENERIC_DOMAINS_OF=y
 CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
 CONFIG_PM_OPP=y
 CONFIG_PM_SLEEP=y
-# CONFIG_PM_USERSPACE_AUTOSLEEP is not set
 CONFIG_POWER_SUPPLY=y
 CONFIG_PREEMPT_NONE_BUILD=y
 CONFIG_PRINTK_TIME=y
@@ -306,6 +306,7 @@ CONFIG_PWM_BCM2835=y
 CONFIG_PWM_SYSFS=y
 CONFIG_RANDSTRUCT_NONE=y
 CONFIG_RASPBERRYPI_FIRMWARE=y
+CONFIG_RASPBERRYPI_GPIOMEM=y
 CONFIG_RASPBERRYPI_POWER=y
 CONFIG_RATIONAL=y
 # CONFIG_RAVE_SP_CORE is not set
diff --git a/target/linux/bcm27xx/bcm2709/config-6.1 b/target/linux/bcm27xx/bcm2709/config-6.1
index ec2e7f3fa6..371d0d9288 100644
--- a/target/linux/bcm27xx/bcm2709/config-6.1
+++ b/target/linux/bcm27xx/bcm2709/config-6.1
@@ -39,7 +39,6 @@ CONFIG_ASSOCIATIVE_ARRAY=y
 CONFIG_AUTO_ZRELADDR=y
 CONFIG_BCM2708_VCMEM=y
 CONFIG_BCM2711_THERMAL=y
-CONFIG_BCM2835_DEVGPIOMEM=y
 CONFIG_BCM2835_MBOX=y
 CONFIG_BCM2835_POWER=y
 # CONFIG_BCM2835_SMI is not set
@@ -186,7 +185,6 @@ CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_IMAGEBLIT=y
 CONFIG_FB_CMDLINE=y
-# CONFIG_FB_RPISENSE is not set
 CONFIG_FB_SIMPLE=y
 CONFIG_FIQ=y
 CONFIG_FIXED_PHY=y
@@ -297,8 +295,6 @@ CONFIG_MDIO_DEVRES=y
 CONFIG_MEMFD_CREATE=y
 CONFIG_MEMORY_ISOLATION=y
 CONFIG_MFD_CORE=y
-# CONFIG_MFD_RASPBERRYPI_POE_HAT is not set
-# CONFIG_MFD_RPISENSE_CORE is not set
 CONFIG_MFD_SYSCON=y
 CONFIG_MICROCHIP_PHY=y
 CONFIG_MIGHT_HAVE_CACHE_L2X0=y
@@ -374,7 +370,6 @@ CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
 CONFIG_PM_OPP=y
 CONFIG_PM_SLEEP=y
 CONFIG_PM_SLEEP_SMP=y
-# CONFIG_PM_USERSPACE_AUTOSLEEP is not set
 CONFIG_POWER_SUPPLY=y
 CONFIG_PPS=y
 CONFIG_PREEMPT_NONE_BUILD=y
@@ -387,6 +382,7 @@ CONFIG_PWM_SYSFS=y
 CONFIG_RANDSTRUCT_NONE=y
 CONFIG_RAS=y
 CONFIG_RASPBERRYPI_FIRMWARE=y
+CONFIG_RASPBERRYPI_GPIOMEM=y
 CONFIG_RASPBERRYPI_POWER=y
 CONFIG_RATIONAL=y
 # CONFIG_RAVE_SP_CORE is not set
diff --git a/target/linux/bcm27xx/bcm2710/config-6.1 b/target/linux/bcm27xx/bcm2710/config-6.1
index b0abd49c7f..26307750ce 100644
--- a/target/linux/bcm27xx/bcm2710/config-6.1
+++ b/target/linux/bcm27xx/bcm2710/config-6.1
@@ -60,7 +60,6 @@ CONFIG_ASSOCIATIVE_ARRAY=y
 CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
 CONFIG_BCM2708_VCMEM=y
 # CONFIG_BCM2711_THERMAL is not set
-CONFIG_BCM2835_DEVGPIOMEM=y
 CONFIG_BCM2835_MBOX=y
 CONFIG_BCM2835_POWER=y
 # CONFIG_BCM2835_SMI is not set
@@ -152,7 +151,6 @@ CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC=y
 CONFIG_CRYPTO_LIB_SHA1=y
 CONFIG_CRYPTO_LIB_SHA256=y
 CONFIG_CRYPTO_LIB_UTILS=y
-# CONFIG_CRYPTO_POLYVAL_ARM64_CE is not set
 CONFIG_CRYPTO_RNG=y
 CONFIG_CRYPTO_RNG2=y
 CONFIG_CRYPTO_RNG_DEFAULT=y
@@ -161,8 +159,6 @@ CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_SHA256_ARM64=y
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_SHA512_ARM64=y
-# CONFIG_CRYPTO_SM4_ARM64_CE_BLK is not set
-# CONFIG_CRYPTO_SM4_ARM64_NEON_BLK is not set
 CONFIG_CRYPTO_XTS=y
 CONFIG_DCACHE_WORD_ACCESS=y
 CONFIG_DEBUG_BUGVERBOSE=y
@@ -195,7 +191,6 @@ CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_IMAGEBLIT=y
 CONFIG_FB_CMDLINE=y
-# CONFIG_FB_RPISENSE is not set
 CONFIG_FB_SIMPLE=y
 CONFIG_FIXED_PHY=y
 CONFIG_FIX_EARLYCON_MEM=y
@@ -299,8 +294,6 @@ CONFIG_MDIO_DEVRES=y
 CONFIG_MEMFD_CREATE=y
 CONFIG_MEMORY_ISOLATION=y
 CONFIG_MFD_CORE=y
-# CONFIG_MFD_RASPBERRYPI_POE_HAT is not set
-# CONFIG_MFD_RPISENSE_CORE is not set
 CONFIG_MFD_SYSCON=y
 CONFIG_MICROCHIP_PHY=y
 CONFIG_MIGRATION=y
@@ -368,7 +361,6 @@ CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
 CONFIG_PM_OPP=y
 CONFIG_PM_SLEEP=y
 CONFIG_PM_SLEEP_SMP=y
-# CONFIG_PM_USERSPACE_AUTOSLEEP is not set
 CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y
 CONFIG_POWER_RESET=y
 CONFIG_POWER_SUPPLY=y
@@ -382,6 +374,7 @@ CONFIG_QUEUED_RWLOCKS=y
 CONFIG_QUEUED_SPINLOCKS=y
 CONFIG_RANDSTRUCT_NONE=y
 CONFIG_RASPBERRYPI_FIRMWARE=y
+CONFIG_RASPBERRYPI_GPIOMEM=y
 CONFIG_RASPBERRYPI_POWER=y
 CONFIG_RATIONAL=y
 # CONFIG_RAVE_SP_CORE is not set
diff --git a/target/linux/bcm27xx/bcm2711/config-6.1 b/target/linux/bcm27xx/bcm2711/config-6.1
index 205e91a8b9..5b74886561 100644
--- a/target/linux/bcm27xx/bcm2711/config-6.1
+++ b/target/linux/bcm27xx/bcm2711/config-6.1
@@ -54,7 +54,6 @@ CONFIG_ASSOCIATIVE_ARRAY=y
 CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
 CONFIG_BCM2708_VCMEM=y
 CONFIG_BCM2711_THERMAL=y
-CONFIG_BCM2835_DEVGPIOMEM=y
 CONFIG_BCM2835_MBOX=y
 CONFIG_BCM2835_POWER=y
 # CONFIG_BCM2835_SMI is not set
@@ -150,7 +149,6 @@ CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC=y
 CONFIG_CRYPTO_LIB_SHA1=y
 CONFIG_CRYPTO_LIB_SHA256=y
 CONFIG_CRYPTO_LIB_UTILS=y
-# CONFIG_CRYPTO_POLYVAL_ARM64_CE is not set
 CONFIG_CRYPTO_RNG=y
 CONFIG_CRYPTO_RNG2=y
 CONFIG_CRYPTO_RNG_DEFAULT=y
@@ -159,8 +157,6 @@ CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_SHA256_ARM64=y
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_SHA512_ARM64=y
-# CONFIG_CRYPTO_SM4_ARM64_CE_BLK is not set
-# CONFIG_CRYPTO_SM4_ARM64_NEON_BLK is not set
 CONFIG_CRYPTO_XTS=y
 CONFIG_DCACHE_WORD_ACCESS=y
 CONFIG_DEBUG_BUGVERBOSE=y
@@ -194,7 +190,6 @@ CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_IMAGEBLIT=y
 CONFIG_FB_CMDLINE=y
-# CONFIG_FB_RPISENSE is not set
 CONFIG_FB_SIMPLE=y
 CONFIG_FIXED_PHY=y
 CONFIG_FIX_EARLYCON_MEM=y
@@ -300,8 +295,6 @@ CONFIG_MDIO_DEVRES=y
 CONFIG_MEMFD_CREATE=y
 CONFIG_MEMORY_ISOLATION=y
 CONFIG_MFD_CORE=y
-# CONFIG_MFD_RASPBERRYPI_POE_HAT is not set
-# CONFIG_MFD_RPISENSE_CORE is not set
 CONFIG_MFD_SYSCON=y
 CONFIG_MIGRATION=y
 CONFIG_MMC=y
@@ -372,7 +365,6 @@ CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
 CONFIG_PM_OPP=y
 CONFIG_PM_SLEEP=y
 CONFIG_PM_SLEEP_SMP=y
-# CONFIG_PM_USERSPACE_AUTOSLEEP is not set
 CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y
 CONFIG_POWER_RESET=y
 CONFIG_POWER_SUPPLY=y
@@ -389,6 +381,7 @@ CONFIG_QUEUED_SPINLOCKS=y
 CONFIG_RANDSTRUCT_NONE=y
 CONFIG_RAS=y
 CONFIG_RASPBERRYPI_FIRMWARE=y
+CONFIG_RASPBERRYPI_GPIOMEM=y
 CONFIG_RASPBERRYPI_POWER=y
 CONFIG_RATIONAL=y
 # CONFIG_RAVE_SP_CORE is not set
-- 
2.40.1


From 9da1db949095911c4d2b3490ad794124dbde5be4 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Sat, 30 Dec 2023 12:27:26 -0500
Subject: [PATCH 18/24] linux-firmware: update rpi4/5 wifi firmware

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 package/firmware/linux-firmware/broadcom.mk   |  34 ++++++
 ...cmfmac43455-sdio.raspberrypi,5-model-b.txt |  98 ++++++++++++++++++
 ...cyfmac43455-sdio.raspberrypi,5-model-b.bin | Bin 0 -> 548728 bytes
 ...io.raspberrypi,5-model-b.clm_blob.clm_blob | Bin 0 -> 2676 bytes
 target/linux/bcm27xx/image/Makefile           |   3 +-
 5 files changed, 133 insertions(+), 2 deletions(-)
 create mode 100755 package/firmware/linux-firmware/src/brcmfmac43455-sdio.raspberrypi,5-model-b.txt
 create mode 100644 package/firmware/linux-firmware/src/cyfmac43455-sdio.raspberrypi,5-model-b.bin
 create mode 100644 package/firmware/linux-firmware/src/cyfmac43455-sdio.raspberrypi,5-model-b.clm_blob.clm_blob

diff --git a/package/firmware/linux-firmware/broadcom.mk b/package/firmware/linux-firmware/broadcom.mk
index 4f64b423eb..ff18d8d568 100644
--- a/package/firmware/linux-firmware/broadcom.mk
+++ b/package/firmware/linux-firmware/broadcom.mk
@@ -149,6 +149,40 @@ define Package/brcmfmac-nvram-43455-sdio/install
 endef
 $(eval $(call BuildPackage,brcmfmac-nvram-43455-sdio))
 
+# brcmfmac-firmware-43455-sdio-raspberrypi,4-model-b
+
+Package/brcmfmac-firmware-43455-rpi-4-sdio = $(call Package/firmware-default,Broadcom RPi 4 firmware)
+define Package/brcmfmac-firmware-43455-rpi-4-sdio/install
+	$(INSTALL_DIR) $(1)/lib/firmware/brcm
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/cyfmac43455-sdio.raspberrypi,5-model-b.bin \
+		$(1)/lib/firmware/brcm/brcmfmac43455-sdio.raspberrypi,4-model-b.bin
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/cyfmac43455-sdio.raspberrypi,5-model-b.clm_blob.clm_blob \
+		$(1)/lib/firmware/brcm/brcmfmac43455-sdio.raspberrypi,4-model-b.clm_blob
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/brcmfmac43455-sdio.raspberrypi,5-model-b.txt \
+		$(1)/lib/firmware/brcm/brcmfmac43455-sdio.raspberrypi,4-model-b.txt
+endef
+$(eval $(call BuildPackage,brcmfmac-firmware-43455-rpi-4-sdio))
+
+# brcmfmac-firmware-43455-sdio-raspberrypi,5-model-b
+
+Package/brcmfmac-firmware-43455-rpi-5-sdio = $(call Package/firmware-default,Broadcom RPi 5 firmware)
+define Package/brcmfmac-firmware-43455-rpi-5-sdio/install
+	$(INSTALL_DIR) $(1)/lib/firmware/brcm
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/cyfmac43455-sdio.raspberrypi,5-model-b.bin \
+		$(1)/lib/firmware/brcm/brcmfmac43455-sdio.raspberrypi,5-model-b.bin
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/cyfmac43455-sdio.raspberrypi,5-model-b.clm_blob.clm_blob \
+		$(1)/lib/firmware/brcm/brcmfmac43455-sdio.raspberrypi,5-model-b.clm_blob
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/brcmfmac43455-sdio.raspberrypi,5-model-b.txt \
+		$(1)/lib/firmware/brcm/brcmfmac43455-sdio.raspberrypi,5-model-b.txt
+endef
+$(eval $(call BuildPackage,brcmfmac-firmware-43455-rpi-5-sdio))
+
 Package/brcmfmac-nvram-4356-sdio = $(call Package/firmware-default,Broadcom BCM4356 SDIO NVRAM)
 define Package/brcmfmac-nvram-4356-sdio/install
 	$(INSTALL_DIR) $(1)/lib/firmware/brcm
diff --git a/package/firmware/linux-firmware/src/brcmfmac43455-sdio.raspberrypi,5-model-b.txt b/package/firmware/linux-firmware/src/brcmfmac43455-sdio.raspberrypi,5-model-b.txt
new file mode 100755
index 0000000000..4b311bb15e
--- /dev/null
+++ b/package/firmware/linux-firmware/src/brcmfmac43455-sdio.raspberrypi,5-model-b.txt
@@ -0,0 +1,98 @@
+# Cloned from bcm94345wlpagb_p2xx.txt
+NVRAMRev=$Rev: 498373 $
+sromrev=11
+vendid=0x14e4
+devid=0x43ab
+manfid=0x2d0
+prodid=0x06e4
+#macaddr=00:90:4c:c5:12:38
+macaddr=b8:27:eb:74:f2:6c
+nocrc=1
+boardtype=0x6e4
+boardrev=0x1304
+
+#XTAL 37.4MHz
+xtalfreq=37400
+
+btc_mode=1
+#------------------------------------------------------
+#boardflags: 5GHz eTR switch by default
+#            2.4GHz eTR switch by default
+#            bit1 for btcoex
+boardflags=0x00480201
+boardflags2=0x40800000
+boardflags3=0x44200100
+phycal_tempdelta=15
+rxchain=1
+txchain=1
+aa2g=1
+aa5g=1
+tssipos5g=1
+tssipos2g=1
+femctrl=0
+AvVmid_c0=1,165,2,100,2,100,2,100,2,100
+pa2ga0=-129,6525,-718
+pa2ga1=-149,4408,-601
+pa5ga0=-185,6836,-815,-186,6838,-815,-184,6859,-815,-184,6882,-818
+pa5ga1=-202,4285,-574,-201,4312,-578,-196,4391,-586,-201,4294,-575
+itrsw=1
+pdoffsetcckma0=2
+pdoffset2gperchan=0,-2,1,0,1,0,1,1,1,0,0,-1,-1,0
+pdoffset2g40ma0=16
+pdoffset40ma0=0x8888
+pdoffset80ma0=0x8888
+extpagain5g=2
+extpagain2g=2
+tworangetssi2g=1
+tworangetssi5g=1
+# LTECX flags
+# WCI2
+ltecxmux=0
+ltecxpadnum=0x0504
+ltecxfnsel=0x22
+ltecxgcigpio=0x32
+
+maxp2ga0=80
+ofdmlrbw202gpo=0x0022
+dot11agofdmhrbw202gpo=0x4442
+mcsbw202gpo=0x98444422
+mcsbw402gpo=0x98444422
+maxp5ga0=82,82,82,82
+mcsbw205glpo=0xb9555000
+mcsbw205gmpo=0xb9555000
+mcsbw205ghpo=0xb9555000
+mcsbw405glpo=0xb9555000
+mcsbw405gmpo=0xb9555000
+mcsbw405ghpo=0xb9555000
+mcsbw805glpo=0xb9555000
+mcsbw805gmpo=0xb9555000
+mcsbw805ghpo=0xb9555000
+
+swctrlmap_2g=0x00000000,0x00000000,0x00000000,0x010000,0x3ff
+swctrlmap_5g=0x00100010,0x00200020,0x00200020,0x010000,0x3fe
+swctrlmapext_5g=0x00000000,0x00000000,0x00000000,0x000000,0x3
+swctrlmapext_2g=0x00000000,0x00000000,0x00000000,0x000000,0x3
+
+vcodivmode=1
+deadman_to=481500000
+
+ed_thresh2g=-54
+ed_thresh5g=-54
+eu_edthresh2g=-54
+eu_edthresh5g=-54
+ldo1=4
+rawtempsense=0x1ff
+cckPwrIdxCorr=3
+cckTssiDelay=150
+ofdmTssiDelay=150
+txpwr2gAdcScale=1
+txpwr5gAdcScale=1
+dot11b_opts=0x3aa85
+cbfilttype=1
+fdsslevel_ch11=6
+
+# Improved Bluetooth coexistence parameters from Cypress
+btc_mode=1
+btc_params8=0x4e20
+btc_params1=0x7530
+btc_params50=0x972c
diff --git a/package/firmware/linux-firmware/src/cyfmac43455-sdio.raspberrypi,5-model-b.bin b/package/firmware/linux-firmware/src/cyfmac43455-sdio.raspberrypi,5-model-b.bin
new file mode 100644
index 0000000000000000000000000000000000000000..cc9768bde24da6a4abcd1ef92609b5fdde4359a1
GIT binary patch
literal 548728
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
z%0A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

literal 0
HcmV?d00001

diff --git a/package/firmware/linux-firmware/src/cyfmac43455-sdio.raspberrypi,5-model-b.clm_blob.clm_blob b/package/firmware/linux-firmware/src/cyfmac43455-sdio.raspberrypi,5-model-b.clm_blob.clm_blob
new file mode 100644
index 0000000000000000000000000000000000000000..c905a503e0182c5d4eae657a587949b3df7ef7ae
GIT binary patch
literal 2676
zcmb_e&u<$=6n<}Z*Zadiw*;k9Q4}F7qLvA9>LND^)!N>~apO&l?fhuY2tm|Bg#r>4
zYB`h~s;cUNibD<+hn#vtLPFxgkt0Wry>dX}4*<E}tmm}`H8&>Noj2cn@4au{%<j6?
z+itBA(ZjnxzRBnnF5NU%4~TwVKYT9*aJz-EjsAW-7;CKEOXlO|s7aKA-=P2TVqL>i
zt+u#)<t6CBxqahi_vWonKRa5PuPt7>vRIp96MeBfzg&B#hX2b`_`>4C)rC(M?kpTH
zJbCx(@$vD)<0s!e$tcBWlu-^kSJ}8L&rVT)GN)+FWhTCX8JHJf#@c1fa|Dx8bOvZN
zA)IZ(O-DGJU?R*-Qk>1z1jE&GU{1-=W<ZMHq7*eIwuA!)3Xm++<r(@QmoF4c;knml
zUe942mhEI*&kwSk<$Nw*UMffBqw?3~2jxfQ(|S}tsz0co-g|KG(Y@2hr-a1Jma;;&
zEvFDFr=&6=O6Z2{t00upmm~XwNA}}WdwFTO_I3^bm*<yiE0>m6>Pz6*R^(7rpg1JQ
ziWEgIMFDwAn_03|9Hdh!&Javb#V*Au?oeDJN5zU_U*qTl&9@An3?IGbH@p<*h68fL
zPC-U8ha;Ojj!+WrTV($mvl;nbQZTgjkhKS&K?cQR$gouvTCpruMLMm$3T@D0K|`aM
zPFW2_TA7~JX1W5bRD0=_q?NGJN-&n`a18nShTs-8(%_`s5FEW;=&SK_vb8UFTpwe7
zfYTdxVrq!B=~H#aZOUyrfIe~QvC}tB-vQ5bRT27*-e_Fk;F>yfo`~W+(=Q+#f&4A5
zS-c~DLjM>1zlYDC9?_Su{{i+Zc)z3n+b6pF18m^BeT3@`_~~Y&|IpxHfvejerk{-d
zzq<}=L(}Kze?#Al$;mhwy4YMJ&-Z-tn>|6c#TZb&kS|cs90{_cE5#rm7^Kw{V@-_p
ziQ%_8f?N|rQna@59OEtHw+1GA%cStzO;UJVDQIsPuXfLH+KC`rWZ9NYetVm2$96y-
zP_a}j!PphfbumP0EDGaIGZk-7A_wsSW!#KQ-dfw_S`+fx(2&==Vn}_~2L|a#5jrj7
z-VyhXsm8^QxOb!ooxZrgh%+MBb3O7mHcgxjncCPf<gP^S_Q((Xfc)+j1=%1A<9*?X
z=B{kqwLWEY*&GF%;=Vbc9NwPf_e5CFc=<i?>Pga`RJA8nP1+_`A_pmv$cZdDkvb=`
z<U|xEk|NokoH0MSPK9EjNPZ&wwbh+$uD>PjTT=P015=-Eb0qwJbAkkYInRBO(cduS
zzQpOvLF$W)fruYSih<N{uxB=9D4b!(1RP4~hO*M3L>|h<4P`ka(KC|gVkE*wLLTjz
zV>}YC9U<=|W@=|>j9oc(yKClg*zKCBJ;}8%!uCg0!XM4=?^B3ImHh)chenm_QiKCj
zL%g!|Z=MW~tyyQbFc%WOejF7z4mrnTbs+$xRs&wuAJUXmOc94yOKgKNYt3ker5Ra_
zLr;$z80XpNG0(cBB8+lu>5)YYu9?86?S;AOvID}54T7Db=Utc}D4;N77e5!qs^IGQ
zRhO$!1lgezYDE?@R<m3!u?NyzCKZ`UMX9km?_tcVJ|nuyS_K`!;s$;w{AY|>r0o@7
kCsz1nQK?i`Du<QZmHU;G%F~sV!^7K8@1LBU;AKM30Y5MUAOHXW

literal 0
HcmV?d00001

diff --git a/target/linux/bcm27xx/image/Makefile b/target/linux/bcm27xx/image/Makefile
index cc1ac0c3f5..f638859fdf 100644
--- a/target/linux/bcm27xx/image/Makefile
+++ b/target/linux/bcm27xx/image/Makefile
@@ -162,8 +162,7 @@ define Device/rpi-4
 	raspberrypi,4-model-b
   DEVICE_PACKAGES := \
 	brcmfmac-sdio-firmware-4345-bt \
-	cypress-firmware-43455-sdio \
-	brcmfmac-nvram-43455-sdio \
+	brcmfmac-firmware-43455-rpi-4-sdio \
 	kmod-brcmfmac wpad-basic-mbedtls \
 	kmod-usb-net-lan78xx \
 	kmod-r8169
-- 
2.40.1


From 794fa2e90c93859662f4818f5164e9d8badb55e9 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Tue, 19 Dec 2023 12:22:53 -0500
Subject: [PATCH 19/24] bcm27xx: add new target bcm2712

This patch add support for raspberry pi 5

Specification:
- Processor Broadcom BCM2712 2.4GHz quad-core 64-bit Arm Cortex-A76 CPU,
  with cryptographic extension, 512KB L2 caches per core
Features:
- VideoCore VII GPU, supports OpenGL ES 3.1, Vulkan 1.2
- Dual 4Kp60 HDMI display output with HDR support 4Kp60 HEVC decoder
- LPDDR4X-4267 SDRAM 4GB and 8GB
- Dual-band 802.11ac Wi-Fi
- Bluetooth 5.0 / Bluetooth Low Energy
- microSD card slot, with support for SDR104 high-speed mode
- 2 x USB 3.0 ports
- 2 x USB 2.0 ports
- Gigabit Ethernet
- 2 x 4 lane MIPI camera/display
- PCIe 2.0 x1
- 5V/5A power via USB-C
- Raspberry Pi standard 40-pin header
- Real-time clock RTC
- Power button

Build system: x86_64
Build-tested: bcm2708, bcm2709, bcm2710, bcm2711, bcm2712
Run-tested: bcm2711/RPi4B, bcm2712/RPi5

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 target/linux/bcm27xx/Makefile                 |   4 +-
 .../bcm27xx/base-files/etc/board.d/02_network |   1 +
 target/linux/bcm27xx/base-files/etc/diag.sh   |   1 +
 target/linux/bcm27xx/bcm2712/config-6.1       | 600 ++++++++++++++++++
 target/linux/bcm27xx/bcm2712/target.mk        |  13 +
 target/linux/bcm27xx/image/Makefile           |  19 +
 target/linux/bcm27xx/image/config.txt         |   5 +
 target/linux/bcm27xx/image/distroconfig.txt   |   5 +
 8 files changed, 646 insertions(+), 2 deletions(-)
 create mode 100644 target/linux/bcm27xx/bcm2712/config-6.1
 create mode 100644 target/linux/bcm27xx/bcm2712/target.mk

diff --git a/target/linux/bcm27xx/Makefile b/target/linux/bcm27xx/Makefile
index 99c5fa75aa..7f27e503c0 100644
--- a/target/linux/bcm27xx/Makefile
+++ b/target/linux/bcm27xx/Makefile
@@ -8,8 +8,8 @@ include $(TOPDIR)/rules.mk
 ARCH:=arm
 BOARD:=bcm27xx
 BOARDNAME:=Broadcom BCM27xx
-FEATURES:=audio boot-part display ext4 fpu gpio rootfs-part rtc squashfs usb usbgadget
-SUBTARGETS:=bcm2708 bcm2709 bcm2710 bcm2711
+FEATURES:=audio boot-part display ext4 fpu gpio pci pcie rootfs-part rtc squashfs usb usbgadget
+SUBTARGETS:=bcm2708 bcm2709 bcm2710 bcm2711 bcm2712
 
 KERNEL_PATCHVER:=6.1
 
diff --git a/target/linux/bcm27xx/base-files/etc/board.d/02_network b/target/linux/bcm27xx/base-files/etc/board.d/02_network
index 3ab19f12c2..de2a6251e5 100644
--- a/target/linux/bcm27xx/base-files/etc/board.d/02_network
+++ b/target/linux/bcm27xx/base-files/etc/board.d/02_network
@@ -17,6 +17,7 @@ raspberrypi,3-model-b-plus |\
 raspberrypi,400 |\
 raspberrypi,4-compute-module |\
 raspberrypi,4-model-b |\
+raspberrypi,5-model-b |\
 raspberrypi,model-b |\
 raspberrypi,model-b-plus |\
 raspberrypi,model-b-rev2)
diff --git a/target/linux/bcm27xx/base-files/etc/diag.sh b/target/linux/bcm27xx/base-files/etc/diag.sh
index 180b31ec95..92d72bea11 100644
--- a/target/linux/bcm27xx/base-files/etc/diag.sh
+++ b/target/linux/bcm27xx/base-files/etc/diag.sh
@@ -14,6 +14,7 @@ set_state() {
 	raspberrypi,400 |\
 	raspberrypi,4-compute-module |\
 	raspberrypi,4-model-b |\
+	raspberrypi,5-model-b |\
 	raspberrypi,model-b-plus)
 		status_led="led1"
 		;;
diff --git a/target/linux/bcm27xx/bcm2712/config-6.1 b/target/linux/bcm27xx/bcm2712/config-6.1
new file mode 100644
index 0000000000..ecceea0e57
--- /dev/null
+++ b/target/linux/bcm27xx/bcm2712/config-6.1
@@ -0,0 +1,600 @@
+CONFIG_64BIT=y
+# CONFIG_AIO is not set
+CONFIG_APERTURE_HELPERS=y
+CONFIG_ARCH_BCM=y
+CONFIG_ARCH_BCM2835=y
+CONFIG_ARCH_BINFMT_ELF_EXTRA_PHDRS=y
+CONFIG_ARCH_BRCMSTB=y
+CONFIG_ARCH_CORRECT_STACKTRACE_ON_KRETPROBE=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+CONFIG_ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_STACKWALK=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_WANTS_NO_INSTR=y
+CONFIG_ARCH_WANTS_THP_SWAP=y
+CONFIG_ARM64=y
+CONFIG_ARM64_4K_PAGES=y
+CONFIG_ARM64_CNP=y
+CONFIG_ARM64_EPAN=y
+CONFIG_ARM64_ERRATUM_1165522=y
+CONFIG_ARM64_ERRATUM_1286807=y
+CONFIG_ARM64_ERRATUM_1463225=y
+CONFIG_ARM64_HW_AFDBM=y
+CONFIG_ARM64_LD_HAS_FIX_ERRATUM_843419=y
+CONFIG_ARM64_PAGE_SHIFT=12
+CONFIG_ARM64_PAN=y
+CONFIG_ARM64_PA_BITS=48
+CONFIG_ARM64_PA_BITS_48=y
+CONFIG_ARM64_PTR_AUTH=y
+CONFIG_ARM64_PTR_AUTH_KERNEL=y
+CONFIG_ARM64_SVE=y
+CONFIG_ARM64_TAGGED_ADDR_ABI=y
+CONFIG_ARM64_VA_BITS=39
+CONFIG_ARM64_VA_BITS_39=y
+CONFIG_ARM64_WORKAROUND_REPEAT_TLBI=y
+CONFIG_ARM64_WORKAROUND_SPECULATIVE_AT=y
+CONFIG_ARM_AMBA=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND=y
+CONFIG_ARM_BRCMSTB_AVS_CPUFREQ=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_V2M=y
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+CONFIG_ARM_GIC_V3_ITS_PCI=y
+# CONFIG_ARM_MHU_V2 is not set
+# CONFIG_ARM_PL172_MPMC is not set
+CONFIG_ARM_PSCI_FW=y
+CONFIG_ARM_RASPBERRYPI_CPUFREQ=y
+# CONFIG_ARM_SMMU is not set
+# CONFIG_ARM_SMMU_V3 is not set
+CONFIG_ARM_TIMER_SP804=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+CONFIG_BCM2708_VCMEM=y
+CONFIG_BCM2711_THERMAL=y
+CONFIG_BCM2712_IOMMU=y
+CONFIG_BCM2712_MIP=y
+CONFIG_BCM2835_MBOX=y
+CONFIG_BCM2835_POWER=y
+CONFIG_BCM2835_SMI=y
+CONFIG_BCM2835_SMI_DEV=m
+CONFIG_BCM2835_THERMAL=y
+CONFIG_BCM2835_VCHIQ=y
+# CONFIG_BCM2835_VCHIQ_MMAL is not set
+CONFIG_BCM2835_WDT=y
+CONFIG_BCM7038_L1_IRQ=y
+CONFIG_BCM7120_L2_IRQ=y
+CONFIG_BCM7XXX_PHY=y
+CONFIG_BCMA=y
+CONFIG_BCMA_BLOCKIO=y
+# CONFIG_BCMA_DEBUG is not set
+# CONFIG_BCMA_DRIVER_GMAC_CMN is not set
+CONFIG_BCMA_DRIVER_PCI=y
+CONFIG_BCMA_FALLBACK_SPROM=y
+CONFIG_BCMA_HOST_PCI=y
+CONFIG_BCMA_HOST_PCI_POSSIBLE=y
+# CONFIG_BCMA_HOST_SOC is not set
+CONFIG_BCMGENET=y
+CONFIG_BCM_NET_PHYLIB=y
+CONFIG_BCM_VCIO=y
+# CONFIG_BCM_VC_SM_CMA is not set
+CONFIG_BCM_VIDEOCORE=y
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_MQ_PCI=y
+CONFIG_BLK_PM=y
+CONFIG_BRCMSTB_DPFE=y
+CONFIG_BRCMSTB_L2_IRQ=y
+CONFIG_BRCMSTB_MEMC=y
+CONFIG_BRCMSTB_PM=y
+# CONFIG_BRCMSTB_THERMAL is not set
+CONFIG_BRCM_CHAR_DRIVERS=y
+CONFIG_BRCM_USB_PINMAP=y
+CONFIG_BROADCOM_PHY=y
+CONFIG_CC_HAVE_SHADOW_CALL_STACK=y
+CONFIG_CC_HAVE_STACKPROTECTOR_SYSREG=y
+CONFIG_CC_IMPLICIT_FALLTHROUGH="-Wimplicit-fallthrough=5"
+CONFIG_CC_NO_ARRAY_BOUNDS=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_CLK_BCM2711_DVP=y
+CONFIG_CLK_BCM2835=y
+CONFIG_CLK_RASPBERRYPI=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_CMA=y
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+# CONFIG_CMA_DEBUG is not set
+# CONFIG_CMA_DEBUGFS is not set
+CONFIG_CMA_SIZE_MBYTES=5
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SYSFS is not set
+CONFIG_COMMON_CLK=y
+CONFIG_COMMON_CLK_RP1=y
+# CONFIG_COMMON_CLK_RP1_SDIO is not set
+CONFIG_COMMON_CLK_XGENE=y
+CONFIG_COMPACT_UNEVICTABLE_DEFAULT=1
+# CONFIG_COMPAT_32BIT_TIME is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_CONTEXT_TRACKING=y
+CONFIG_CONTEXT_TRACKING_IDLE=y
+CONFIG_CONTIG_ALLOC=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPUFREQ_DT_PLATDEV=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_CPU_PM=y
+CONFIG_CPU_RMAP=y
+CONFIG_CRC16=y
+CONFIG_CRYPTO_AES_ARM64=y
+CONFIG_CRYPTO_AES_ARM64_BS=y
+CONFIG_CRYPTO_AES_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CRC32=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRYPTD=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC=y
+CONFIG_CRYPTO_LIB_SHA1=y
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_LIB_UTILS=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA256_ARM64=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA3=y
+CONFIG_CRYPTO_SHA3_ARM64=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_SHA512_ARM64=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=y
+CONFIG_CRYPTO_SM3=y
+CONFIG_CRYPTO_SM3_ARM64_CE=y
+CONFIG_CRYPTO_SM4=y
+CONFIG_CRYPTO_SM4_ARM64_CE=y
+CONFIG_CRYPTO_SM4_ARM64_CE_BLK=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DIMLIB=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMADEVICES=y
+CONFIG_DMA_BCM2708=y
+CONFIG_DMA_BCM2835=y
+CONFIG_DMA_CMA=y
+CONFIG_DMA_DIRECT_REMAP=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+CONFIG_DMA_OPS=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DNOTIFY=y
+CONFIG_DTC=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EXCLUSIVE_SYSTEM_RAM=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXTCON=y
+CONFIG_F2FS_FS=y
+CONFIG_FB=y
+CONFIG_FB_BCM2708=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_SIMPLE=y
+CONFIG_FIXED_PHY=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_FONT_8x16=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_SUPPORT=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_FRAME_POINTER=y
+CONFIG_FREEZER=y
+CONFIG_FSL_ERRATUM_A008585=y
+CONFIG_FS_ENCRYPTION=y
+CONFIG_FS_ENCRYPTION_ALGS=y
+CONFIG_FS_IOMAP=y
+CONFIG_FS_MBCACHE=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FWNODE_MDIO=y
+CONFIG_FW_CACHE=y
+CONFIG_FW_LOADER_PAGED_BUF=y
+CONFIG_FW_LOADER_SYSFS=y
+CONFIG_GCC11_NO_ARRAY_BOUNDS=y
+CONFIG_GCC_SUPPORTS_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_GENERIC_IOREMAP=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_INJECTION=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_LIB_DEVMEM_IS_ALLOWED=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_PINCONF=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GLOB=y
+CONFIG_GPIOLIB_IRQCHIP=y
+CONFIG_GPIO_BCM_VIRT=y
+CONFIG_GPIO_BRCMSTB=y
+CONFIG_GPIO_CDEV=y
+# CONFIG_GPIO_FSM is not set
+CONFIG_GPIO_GENERIC=y
+CONFIG_GPIO_RASPBERRYPI_EXP=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+CONFIG_HOTPLUG_PCI_SHPC=y
+CONFIG_HWMON=y
+CONFIG_HW_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_IPROC_RNG200=y
+CONFIG_I2C=y
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_BCM2708 is not set
+CONFIG_I2C_BCM2835=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_BRCMSTB=y
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_INPUT=y
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_RASPBERRYPI_BUTTON=y
+CONFIG_IOMMU_API=y
+# CONFIG_IOMMU_DEBUGFS is not set
+# CONFIG_IOMMU_DEFAULT_DMA_LAZY is not set
+CONFIG_IOMMU_DEFAULT_DMA_STRICT=y
+# CONFIG_IOMMU_DEFAULT_PASSTHROUGH is not set
+CONFIG_IOMMU_DMA=y
+CONFIG_IOMMU_IOVA=y
+# CONFIG_IOMMU_IO_PGTABLE_ARMV7S is not set
+# CONFIG_IOMMU_IO_PGTABLE_DART is not set
+# CONFIG_IOMMU_IO_PGTABLE_LPAE is not set
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_IRQCHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_IRQ_MSI_IOMMU=y
+CONFIG_IRQ_WORK=y
+CONFIG_JBD2=y
+CONFIG_KEYS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PWM=y
+CONFIG_LEDS_TRIGGER_ACTPWR=y
+CONFIG_LEDS_TRIGGER_INPUT=y
+CONFIG_LIBFDT=y
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_MACB=y
+CONFIG_MACB_PCI=y
+CONFIG_MACB_USE_HWSTAMP=y
+CONFIG_MAC_PARTITION=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAILBOX=y
+# CONFIG_MAILBOX_TEST is not set
+CONFIG_MDIO_BCM_UNIMAC=y
+CONFIG_MDIO_BUS=y
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_DEVRES=y
+CONFIG_MEMFD_CREATE=y
+CONFIG_MEMORY=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_MFD_CORE=y
+CONFIG_MFD_RP1=y
+CONFIG_MFD_SYSCON=y
+CONFIG_MICROCHIP_PHY=y
+CONFIG_MIGRATION=y
+CONFIG_MMC=y
+# CONFIG_MMC_BCM2835 is not set
+CONFIG_MMC_BCM2835_DMA=y
+CONFIG_MMC_BCM2835_MMC=y
+CONFIG_MMC_BCM2835_PIO_DMA_BARRIER=2
+CONFIG_MMC_BCM2835_SDHOST=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_CQHCI=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_BRCMSTB=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+CONFIG_MMC_SDHCI_IPROC=y
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_NET_FLOW_LIMIT=y
+CONFIG_NET_PTP_CLASSIFY=y
+CONFIG_NET_SELFTESTS=y
+CONFIG_NLS=y
+CONFIG_NLS_ASCII=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_NO_HZ=y
+CONFIG_NO_HZ_COMMON=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NR_CPUS=4
+CONFIG_NVMEM=y
+CONFIG_NVMEM_LAYOUTS=y
+CONFIG_NVME_CORE=y
+# CONFIG_NVME_HWMON is not set
+# CONFIG_NVME_MULTIPATH is not set
+CONFIG_OF=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_CONFIGFS=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_IOMMU=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_RESOLVE=y
+CONFIG_PADATA=y
+CONFIG_PAGE_POOL=y
+CONFIG_PAGE_SIZE_LESS_THAN_256KB=y
+CONFIG_PAGE_SIZE_LESS_THAN_64KB=y
+CONFIG_PARTITION_PERCPU=y
+CONFIG_PCI=y
+CONFIG_PCIEAER=y
+CONFIG_PCIEAER_INJECT=y
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEFAULT is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+# CONFIG_PCIEASPM_POWERSAVE is not set
+CONFIG_PCIEASPM_POWER_SUPERSAVE=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIE_BRCMSTB=y
+CONFIG_PCIE_DPC=y
+CONFIG_PCIE_DW=y
+CONFIG_PCIE_DW_HOST=y
+CONFIG_PCIE_DW_PLAT=y
+CONFIG_PCIE_DW_PLAT_HOST=y
+CONFIG_PCIE_MICROCHIP_HOST=y
+CONFIG_PCIE_PME=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
+CONFIG_PCI_ECAM=y
+CONFIG_PCI_HOST_COMMON=y
+CONFIG_PCI_HOST_GENERIC=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_PCI_STUB=y
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_PHYLIB=y
+CONFIG_PHYLINK=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+# CONFIG_PHY_BRCM_SATA is not set
+CONFIG_PHY_BRCM_USB=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_BCM2712=y
+CONFIG_PINCTRL_BCM2835=y
+CONFIG_PINCTRL_RP1=y
+CONFIG_PM=y
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_GPIO=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_PPS=y
+CONFIG_PREEMPT_NONE_BUILD=y
+CONFIG_PRINTK_TIME=y
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_PTP_1588_CLOCK_OPTIONAL=y
+CONFIG_PWM=y
+CONFIG_PWM_BCM2835=y
+CONFIG_PWM_BRCMSTB=y
+CONFIG_PWM_RP1=y
+CONFIG_PWM_SYSFS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_RANDSTRUCT_NONE=y
+CONFIG_RAS=y
+CONFIG_RASPBERRYPI_FIRMWARE=y
+CONFIG_RASPBERRYPI_GPIOMEM=y
+CONFIG_RASPBERRYPI_POWER=y
+CONFIG_RATIONAL=y
+# CONFIG_RAVE_SP_CORE is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_RESET_BRCMSTB=y
+CONFIG_RESET_BRCMSTB_RESCAL=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RESET_RASPBERRYPI=y
+CONFIG_RESET_SIMPLE=y
+CONFIG_RFS_ACCEL=y
+CONFIG_RODATA_FULL_DEFAULT_ENABLED=y
+# CONFIG_RPIVID_MEM is not set
+# CONFIG_RPI_POE_POWER is not set
+CONFIG_RPS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_BRCMSTB=y
+CONFIG_RTC_DRV_RPI=y
+CONFIG_RTC_I2C_AND_SPI=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_SCSI=y
+CONFIG_SCSI_COMMON=y
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_SENSORS_RASPBERRYPI_HWMON=y
+CONFIG_SENSORS_RP1_ADC=y
+CONFIG_SERIAL_8250_BCM2835AUX=y
+CONFIG_SERIAL_8250_BCM7271=y
+# CONFIG_SERIAL_8250_DMA is not set
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_FSL=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=0
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_SERIAL_DEV_CTRL_TTYPORT=y
+CONFIG_SERIAL_MCTRL_GPIO=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SG_POOL=y
+CONFIG_SMP=y
+CONFIG_SMSC_PHY=y
+CONFIG_SOCK_RX_QUEUE_MAPPING=y
+CONFIG_SOC_BRCMSTB=y
+CONFIG_SOC_BUS=y
+CONFIG_SOFTIRQ_ON_OWN_STACK=y
+CONFIG_SPARSEMEM=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_SRCU=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_SWIOTLB=y
+CONFIG_SWPHY=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+# CONFIG_TEXTSEARCH is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THREAD_INFO_IN_TASK=y
+CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TRACE_IRQFLAGS_NMI_SUPPORT=y
+CONFIG_TREE_RCU=y
+CONFIG_TREE_SRCU=y
+# CONFIG_UACCE is not set
+# CONFIG_UCLAMP_TASK is not set
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_UNMAP_KERNEL_AT_EL0=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_BRCMSTB is not set
+CONFIG_USB_COMMON=y
+CONFIG_USB_DWCOTG=y
+CONFIG_USB_GADGET=y
+# CONFIG_USB_HCD_BCMA is not set
+CONFIG_USB_PCI=y
+CONFIG_USB_PHY=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_UAS=y
+# CONFIG_USB_UHCI_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_VCHIQ_CDEV=y
+CONFIG_VMAP_STACK=y
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_XPS=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_ZONE_DMA32=y
diff --git a/target/linux/bcm27xx/bcm2712/target.mk b/target/linux/bcm27xx/bcm2712/target.mk
new file mode 100644
index 0000000000..ab1fe68ca3
--- /dev/null
+++ b/target/linux/bcm27xx/bcm2712/target.mk
@@ -0,0 +1,13 @@
+#
+# Copyright (C) 2023 OpenWrt.org
+#
+
+ARCH:=aarch64
+SUBTARGET:=bcm2712
+BOARDNAME:=BCM2712 boards (64 bit)
+CPU_TYPE:=cortex-a72
+
+define Target/Description
+	Build firmware image for BCM2712 devices.
+	This firmware features a 64 bit kernel.
+endef
diff --git a/target/linux/bcm27xx/image/Makefile b/target/linux/bcm27xx/image/Makefile
index f638859fdf..afd02108c4 100644
--- a/target/linux/bcm27xx/image/Makefile
+++ b/target/linux/bcm27xx/image/Makefile
@@ -173,4 +173,23 @@ ifeq ($(SUBTARGET),bcm2711)
   TARGET_DEVICES += rpi-4
 endif
 
+define Device/rpi-5
+  DEVICE_MODEL := 5
+  DEVICE_VARIANT := (64bit)
+  KERNEL_IMG := kernel_2712.img
+  DEVICE_DTS := broadcom/bcm2712-rpi-5-b
+  SUPPORTED_DEVICES := raspberrypi,5-model-b
+  DEVICE_PACKAGES := \
+	brcmfmac-firmware-43455-rpi-5-sdio \
+	brcmfmac-sdio-firmware-4345-bt \
+	kmod-brcmfmac wpad-basic-mbedtls \
+	kmod-hwmon-pwmfan kmod-thermal \
+	kmod-usb-dwc3 kmod-usb3
+  IMAGE/sysupgrade.img.gz := boot-common | boot-2711 | sdcard-img | gzip | append-metadata
+  IMAGE/factory.img.gz := boot-common | boot-2711 | sdcard-img | gzip
+endef
+ifeq ($(SUBTARGET),bcm2712)
+  TARGET_DEVICES += rpi-5
+endif
+
 $(eval $(call BuildImage))
diff --git a/target/linux/bcm27xx/image/config.txt b/target/linux/bcm27xx/image/config.txt
index f8ca1bf2d4..71a8a6817b 100644
--- a/target/linux/bcm27xx/image/config.txt
+++ b/target/linux/bcm27xx/image/config.txt
@@ -12,3 +12,8 @@ include distroconfig.txt
 
 [all]
 # Place your custom settings here.
+# usb_max_current_enable=1
+# Enable the PCIe external connector
+dtparam=pciex1
+# Force Gen 3.0 speeds
+dtparam=pciex1_gen=3
diff --git a/target/linux/bcm27xx/image/distroconfig.txt b/target/linux/bcm27xx/image/distroconfig.txt
index 7a2140a70d..6447a74009 100644
--- a/target/linux/bcm27xx/image/distroconfig.txt
+++ b/target/linux/bcm27xx/image/distroconfig.txt
@@ -16,5 +16,10 @@ dtoverlay=disable-bt
 # enable_uart=1
 # Enable Bluetooth over the PL011 (ttyAMA0) using the serial bus (serdev)
 # dtparam=krnbt=on
+[pi5]
+# Enable the Mini UART (ttyS0) as the console
+enable_uart=1
+# Enable Bluetooth over the PL011 (ttyAMA0) using the serial bus (serdev)
+dtparam=krnbt=on
 # Run as fast as firmware / board allows
 arm_boost=1
-- 
2.40.1


From b073c13ae2311690cdfecaadee0936aa9d52c67e Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Wed, 10 Jan 2024 12:02:10 -0500
Subject: [PATCH 20/24] kernel: Linux 6.1.72

https://lore.kernel.org/r/20240108153511.214254205@linuxfoundation.org

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 include/kernel-6.1                                        | 4 ++--
 .../950-0111-MMC-added-alternative-MMC-driver.patch       | 6 +++---
 ...79-bcmgenet-Better-coalescing-parameter-defaults.patch | 4 ++--
 ...-net-bcmgenet-Workaround-2-for-Pi4-Ethernet-fail.patch | 2 +-
 ...ia-i2c-imx477-Support-for-the-Sony-IMX477-sensor.patch | 2 +-
 ...ia-i2c-imx519-Support-for-the-Sony-IMX519-sensor.patch | 2 +-
 ...mentation-devicetree-Add-documentation-for-imx37.patch | 2 +-
 .../950-0270-net-bcmgenet-Reset-RBUF-on-first-open.patch  | 8 ++++----
 ...block-Don-t-do-single-sector-reads-during-recove.patch | 2 +-
 .../950-0513-net-bcmgenet-Add-eee-module-parameter.patch  | 2 +-
 ...indings-media-i2c-Add-IMX708-CMOS-sensor-binding.patch | 2 +-
 ...indings-media-i2c-Add-IMX296-CMOS-sensor-binding.patch | 2 +-
 .../950-0594-media-i2c-IMX296-camera-sensor-driver.patch  | 2 +-
 ...649-media-dt-bindings-Convert-imx290.txt-to-YAML.patch | 2 +-
 ...indings-media-i2c-Replace-IMX708-sensor-binding-.patch | 2 +-
 ...3-v6.3-net-pcs-add-driver-for-MediaTek-SGMII-PCS.patch | 2 +-
 ...10-net-dsa-mt7530-introduce-separate-MDIO-driver.patch | 2 +-
 ...dsa-mt7530-introduce-driver-for-MT7988-built-in-.patch | 2 +-
 ...Add-driver-for-Motorcomm-yt8521-gigabit-ethernet.patch | 2 +-
 .../650-netfilter-add-xt_FLOWOFFLOAD-target.patch         | 6 +++---
 target/linux/generic/hack-6.1/901-debloat_sock_diag.patch | 2 +-
 target/linux/generic/hack-6.1/902-debloat_proc.patch      | 2 +-
 ...ilter-nft_flow_offload-handle-netdevice-events-f.patch | 6 +++---
 23 files changed, 34 insertions(+), 34 deletions(-)

diff --git a/include/kernel-6.1 b/include/kernel-6.1
index c52b94712f..836cecf7de 100644
--- a/include/kernel-6.1
+++ b/include/kernel-6.1
@@ -1,2 +1,2 @@
-LINUX_VERSION-6.1 = .71
-LINUX_KERNEL_HASH-6.1.71 = 2df774dd53f9ffd4e57ebf804cf597709295df6a304fe261d25220a134b7f041
+LINUX_VERSION-6.1 = .72
+LINUX_KERNEL_HASH-6.1.72 = 98dce69077c35cffca799dcdbbd32a02242aad6b0950eb931936bb2ef69f0926
diff --git a/target/linux/bcm27xx/patches-6.1/950-0111-MMC-added-alternative-MMC-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0111-MMC-added-alternative-MMC-driver.patch
index a74b2cd62f..09402fbc35 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0111-MMC-added-alternative-MMC-driver.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0111-MMC-added-alternative-MMC-driver.patch
@@ -266,7 +266,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
  static inline int mmc_blk_part_switch(struct mmc_card *card,
  				      unsigned int part_type);
  static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
-@@ -2998,6 +3005,8 @@ static int mmc_blk_probe(struct mmc_card
+@@ -3000,6 +3007,8 @@ static int mmc_blk_probe(struct mmc_card
  {
  	struct mmc_blk_data *md;
  	int ret = 0;
@@ -275,7 +275,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
  
  	/*
  	 * Check that the card supports the command class(es) we need.
-@@ -3005,7 +3014,16 @@ static int mmc_blk_probe(struct mmc_card
+@@ -3007,7 +3016,16 @@ static int mmc_blk_probe(struct mmc_card
  	if (!(card->csd.cmdclass & CCC_BLOCK_READ))
  		return -ENODEV;
  
@@ -293,7 +293,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
  
  	card->complete_wq = alloc_workqueue("mmc_complete",
  					WQ_MEM_RECLAIM | WQ_HIGHPRI, 0);
-@@ -3020,6 +3038,17 @@ static int mmc_blk_probe(struct mmc_card
+@@ -3022,6 +3040,17 @@ static int mmc_blk_probe(struct mmc_card
  		goto out_free;
  	}
  
diff --git a/target/linux/bcm27xx/patches-6.1/950-0179-bcmgenet-Better-coalescing-parameter-defaults.patch b/target/linux/bcm27xx/patches-6.1/950-0179-bcmgenet-Better-coalescing-parameter-defaults.patch
index 4fc97de544..b805f1df30 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0179-bcmgenet-Better-coalescing-parameter-defaults.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0179-bcmgenet-Better-coalescing-parameter-defaults.patch
@@ -18,7 +18,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.org>
 
 --- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c
 +++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
-@@ -2657,7 +2657,7 @@ static void bcmgenet_init_tx_ring(struct
+@@ -2659,7 +2659,7 @@ static void bcmgenet_init_tx_ring(struct
  
  	bcmgenet_tdma_ring_writel(priv, index, 0, TDMA_PROD_INDEX);
  	bcmgenet_tdma_ring_writel(priv, index, 0, TDMA_CONS_INDEX);
@@ -27,7 +27,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.org>
  	/* Disable rate control for now */
  	bcmgenet_tdma_ring_writel(priv, index, flow_period_val,
  				  TDMA_FLOW_PERIOD);
-@@ -4138,9 +4138,12 @@ static int bcmgenet_probe(struct platfor
+@@ -4140,9 +4140,12 @@ static int bcmgenet_probe(struct platfor
  	netif_set_real_num_rx_queues(priv->dev, priv->hw_params->rx_queues + 1);
  
  	/* Set default coalescing parameters */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0189-net-bcmgenet-Workaround-2-for-Pi4-Ethernet-fail.patch b/target/linux/bcm27xx/patches-6.1/950-0189-net-bcmgenet-Workaround-2-for-Pi4-Ethernet-fail.patch
index ba1baac7d0..da60efe07f 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0189-net-bcmgenet-Workaround-2-for-Pi4-Ethernet-fail.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0189-net-bcmgenet-Workaround-2-for-Pi4-Ethernet-fail.patch
@@ -37,7 +37,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.org>
  
  static inline void bcmgenet_writel(u32 value, void __iomem *offset)
  {
-@@ -2488,6 +2491,11 @@ static void reset_umac(struct bcmgenet_p
+@@ -2490,6 +2493,11 @@ static void reset_umac(struct bcmgenet_p
  	bcmgenet_rbuf_ctrl_set(priv, 0);
  	udelay(10);
  
diff --git a/target/linux/bcm27xx/patches-6.1/950-0195-media-i2c-imx477-Support-for-the-Sony-IMX477-sensor.patch b/target/linux/bcm27xx/patches-6.1/950-0195-media-i2c-imx477-Support-for-the-Sony-IMX477-sensor.patch
index dc2e539f3a..89d7b4eea9 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0195-media-i2c-imx477-Support-for-the-Sony-IMX477-sensor.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0195-media-i2c-imx477-Support-for-the-Sony-IMX477-sensor.patch
@@ -343,7 +343,7 @@ Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
 +...
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -19279,6 +19279,14 @@ T:	git git://linuxtv.org/media_tree.git
+@@ -19281,6 +19281,14 @@ T:	git git://linuxtv.org/media_tree.git
  F:	Documentation/devicetree/bindings/media/i2c/sony,imx412.yaml
  F:	drivers/media/i2c/imx412.c
  
diff --git a/target/linux/bcm27xx/patches-6.1/950-0196-media-i2c-imx519-Support-for-the-Sony-IMX519-sensor.patch b/target/linux/bcm27xx/patches-6.1/950-0196-media-i2c-imx519-Support-for-the-Sony-IMX519-sensor.patch
index 8ba6f7e5fc..a7cf1bb1f2 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0196-media-i2c-imx519-Support-for-the-Sony-IMX519-sensor.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0196-media-i2c-imx519-Support-for-the-Sony-IMX519-sensor.patch
@@ -177,7 +177,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
 +...
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -19287,6 +19287,14 @@ T:	git git://linuxtv.org/media_tree.git
+@@ -19289,6 +19289,14 @@ T:	git git://linuxtv.org/media_tree.git
  F:	Documentation/devicetree/bindings/media/i2c/imx477.yaml
  F:	drivers/media/i2c/imx477.c
  
diff --git a/target/linux/bcm27xx/patches-6.1/950-0197-Documentation-devicetree-Add-documentation-for-imx37.patch b/target/linux/bcm27xx/patches-6.1/950-0197-Documentation-devicetree-Add-documentation-for-imx37.patch
index e564af578e..03628b3e9f 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0197-Documentation-devicetree-Add-documentation-for-imx37.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0197-Documentation-devicetree-Add-documentation-for-imx37.patch
@@ -132,7 +132,7 @@ Signed-off-by: David Plowman <david.plowman@raspberrypi.com>
 +...
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -19284,6 +19284,7 @@ M:	Raspberry Pi Kernel Maintenance <kern
+@@ -19286,6 +19286,7 @@ M:	Raspberry Pi Kernel Maintenance <kern
  L:	linux-media@vger.kernel.org
  S:	Maintained
  T:	git git://linuxtv.org/media_tree.git
diff --git a/target/linux/bcm27xx/patches-6.1/950-0270-net-bcmgenet-Reset-RBUF-on-first-open.patch b/target/linux/bcm27xx/patches-6.1/950-0270-net-bcmgenet-Reset-RBUF-on-first-open.patch
index 0c71db2d00..e21de6f79f 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0270-net-bcmgenet-Reset-RBUF-on-first-open.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0270-net-bcmgenet-Reset-RBUF-on-first-open.patch
@@ -24,7 +24,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
 
 --- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c
 +++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
-@@ -3304,7 +3304,7 @@ static void bcmgenet_get_hw_addr(struct
+@@ -3306,7 +3306,7 @@ static void bcmgenet_get_hw_addr(struct
  }
  
  /* Returns a reusable dma control register value */
@@ -33,7 +33,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
  {
  	unsigned int i;
  	u32 reg;
-@@ -3329,6 +3329,14 @@ static u32 bcmgenet_dma_disable(struct b
+@@ -3331,6 +3331,14 @@ static u32 bcmgenet_dma_disable(struct b
  	udelay(10);
  	bcmgenet_umac_writel(priv, 0, UMAC_TX_FLUSH);
  
@@ -48,7 +48,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
  	return dma_ctrl;
  }
  
-@@ -3392,8 +3400,8 @@ static int bcmgenet_open(struct net_devi
+@@ -3394,8 +3402,8 @@ static int bcmgenet_open(struct net_devi
  
  	bcmgenet_set_hw_addr(priv, dev->dev_addr);
  
@@ -59,7 +59,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
  
  	/* Reinitialize TDMA and RDMA and SW housekeeping */
  	ret = bcmgenet_init_dma(priv);
-@@ -4267,7 +4275,7 @@ static int bcmgenet_resume(struct device
+@@ -4269,7 +4277,7 @@ static int bcmgenet_resume(struct device
  			bcmgenet_hfb_create_rxnfc_filter(priv, rule);
  
  	/* Disable RX/TX DMA and flush TX queues */
diff --git a/target/linux/bcm27xx/patches-6.1/950-0418-mmc-block-Don-t-do-single-sector-reads-during-recove.patch b/target/linux/bcm27xx/patches-6.1/950-0418-mmc-block-Don-t-do-single-sector-reads-during-recove.patch
index de9378f79a..0335f00198 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0418-mmc-block-Don-t-do-single-sector-reads-during-recove.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0418-mmc-block-Don-t-do-single-sector-reads-during-recove.patch
@@ -23,7 +23,7 @@ Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
 
 --- a/drivers/mmc/core/block.c
 +++ b/drivers/mmc/core/block.c
-@@ -1928,7 +1928,7 @@ static void mmc_blk_mq_rw_recovery(struc
+@@ -1930,7 +1930,7 @@ static void mmc_blk_mq_rw_recovery(struc
  		return;
  	}
  
diff --git a/target/linux/bcm27xx/patches-6.1/950-0513-net-bcmgenet-Add-eee-module-parameter.patch b/target/linux/bcm27xx/patches-6.1/950-0513-net-bcmgenet-Add-eee-module-parameter.patch
index a145f6c48f..cd9820fc9d 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0513-net-bcmgenet-Add-eee-module-parameter.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0513-net-bcmgenet-Add-eee-module-parameter.patch
@@ -26,7 +26,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
  
  static inline void bcmgenet_writel(u32 value, void __iomem *offset)
  {
-@@ -3438,6 +3441,17 @@ static int bcmgenet_open(struct net_devi
+@@ -3440,6 +3443,17 @@ static int bcmgenet_open(struct net_devi
  
  	bcmgenet_phy_pause_set(dev, priv->rx_pause, priv->tx_pause);
  
diff --git a/target/linux/bcm27xx/patches-6.1/950-0528-dtbindings-media-i2c-Add-IMX708-CMOS-sensor-binding.patch b/target/linux/bcm27xx/patches-6.1/950-0528-dtbindings-media-i2c-Add-IMX708-CMOS-sensor-binding.patch
index 2e6188af4b..6e51500140 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0528-dtbindings-media-i2c-Add-IMX708-CMOS-sensor-binding.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0528-dtbindings-media-i2c-Add-IMX708-CMOS-sensor-binding.patch
@@ -138,7 +138,7 @@ Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
 +...
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -19328,6 +19328,14 @@ T:	git git://linuxtv.org/media_tree.git
+@@ -19330,6 +19330,14 @@ T:	git git://linuxtv.org/media_tree.git
  F:	Documentation/devicetree/bindings/media/i2c/imx519.yaml
  F:	drivers/media/i2c/imx519.c
  
diff --git a/target/linux/bcm27xx/patches-6.1/950-0593-dt-bindings-media-i2c-Add-IMX296-CMOS-sensor-binding.patch b/target/linux/bcm27xx/patches-6.1/950-0593-dt-bindings-media-i2c-Add-IMX296-CMOS-sensor-binding.patch
index cfdeef78ab..4d6227a378 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0593-dt-bindings-media-i2c-Add-IMX296-CMOS-sensor-binding.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0593-dt-bindings-media-i2c-Add-IMX296-CMOS-sensor-binding.patch
@@ -128,7 +128,7 @@ Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
 +...
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -19270,6 +19270,14 @@ T:	git git://linuxtv.org/media_tree.git
+@@ -19272,6 +19272,14 @@ T:	git git://linuxtv.org/media_tree.git
  F:	Documentation/devicetree/bindings/media/i2c/imx290.txt
  F:	drivers/media/i2c/imx290.c
  
diff --git a/target/linux/bcm27xx/patches-6.1/950-0594-media-i2c-IMX296-camera-sensor-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0594-media-i2c-IMX296-camera-sensor-driver.patch
index 94ddb850c3..de983ddb15 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0594-media-i2c-IMX296-camera-sensor-driver.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0594-media-i2c-IMX296-camera-sensor-driver.patch
@@ -23,7 +23,7 @@ Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
 
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -19277,6 +19277,7 @@ L:	linux-media@vger.kernel.org
+@@ -19279,6 +19279,7 @@ L:	linux-media@vger.kernel.org
  S:	Maintained
  T:	git git://linuxtv.org/media_tree.git
  F:	Documentation/devicetree/bindings/media/i2c/sony,imx296.yaml
diff --git a/target/linux/bcm27xx/patches-6.1/950-0649-media-dt-bindings-Convert-imx290.txt-to-YAML.patch b/target/linux/bcm27xx/patches-6.1/950-0649-media-dt-bindings-Convert-imx290.txt-to-YAML.patch
index 14a8a4a029..374069eca5 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0649-media-dt-bindings-Convert-imx290.txt-to-YAML.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0649-media-dt-bindings-Convert-imx290.txt-to-YAML.patch
@@ -219,7 +219,7 @@ Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
 +...
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -19267,7 +19267,7 @@ M:	Manivannan Sadhasivam <manivannan.sad
+@@ -19269,7 +19269,7 @@ M:	Manivannan Sadhasivam <manivannan.sad
  L:	linux-media@vger.kernel.org
  S:	Maintained
  T:	git git://linuxtv.org/media_tree.git
diff --git a/target/linux/bcm27xx/patches-6.1/950-0676-dt-bindings-media-i2c-Replace-IMX708-sensor-binding-.patch b/target/linux/bcm27xx/patches-6.1/950-0676-dt-bindings-media-i2c-Replace-IMX708-sensor-binding-.patch
index 35efa5413f..098e6b611d 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0676-dt-bindings-media-i2c-Replace-IMX708-sensor-binding-.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0676-dt-bindings-media-i2c-Replace-IMX708-sensor-binding-.patch
@@ -271,7 +271,7 @@ Signed-off-by: Naushir Patuck <naush@raspberrypi.com>
 +...
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -19342,7 +19342,7 @@ M:	Raspberry Pi Kernel Maintenance <kern
+@@ -19344,7 +19344,7 @@ M:	Raspberry Pi Kernel Maintenance <kern
  L:	linux-media@vger.kernel.org
  S:	Maintained
  T:	git git://linuxtv.org/media_tree.git
diff --git a/target/linux/generic/backport-6.1/723-v6.3-net-pcs-add-driver-for-MediaTek-SGMII-PCS.patch b/target/linux/generic/backport-6.1/723-v6.3-net-pcs-add-driver-for-MediaTek-SGMII-PCS.patch
index 980cb0f914..d56a142451 100644
--- a/target/linux/generic/backport-6.1/723-v6.3-net-pcs-add-driver-for-MediaTek-SGMII-PCS.patch
+++ b/target/linux/generic/backport-6.1/723-v6.3-net-pcs-add-driver-for-MediaTek-SGMII-PCS.patch
@@ -32,7 +32,7 @@ Signed-off-by: Jakub Kicinski <kuba@kernel.org>
 
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -12926,6 +12926,14 @@ L:	netdev@vger.kernel.org
+@@ -12928,6 +12928,14 @@ L:	netdev@vger.kernel.org
  S:	Maintained
  F:	drivers/net/ethernet/mediatek/
  
diff --git a/target/linux/generic/backport-6.1/790-v6.4-0010-net-dsa-mt7530-introduce-separate-MDIO-driver.patch b/target/linux/generic/backport-6.1/790-v6.4-0010-net-dsa-mt7530-introduce-separate-MDIO-driver.patch
index b75710ba57..d203711884 100644
--- a/target/linux/generic/backport-6.1/790-v6.4-0010-net-dsa-mt7530-introduce-separate-MDIO-driver.patch
+++ b/target/linux/generic/backport-6.1/790-v6.4-0010-net-dsa-mt7530-introduce-separate-MDIO-driver.patch
@@ -25,7 +25,7 @@ Signed-off-by: David S. Miller <davem@davemloft.net>
 
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -13060,6 +13060,7 @@ M:	Landen Chao <Landen.Chao@mediatek.com
+@@ -13062,6 +13062,7 @@ M:	Landen Chao <Landen.Chao@mediatek.com
  M:	DENG Qingfang <dqfext@gmail.com>
  L:	netdev@vger.kernel.org
  S:	Maintained
diff --git a/target/linux/generic/backport-6.1/790-v6.4-0012-net-dsa-mt7530-introduce-driver-for-MT7988-built-in-.patch b/target/linux/generic/backport-6.1/790-v6.4-0012-net-dsa-mt7530-introduce-driver-for-MT7988-built-in-.patch
index 934af995cd..63bf0e77fa 100644
--- a/target/linux/generic/backport-6.1/790-v6.4-0012-net-dsa-mt7530-introduce-driver-for-MT7988-built-in-.patch
+++ b/target/linux/generic/backport-6.1/790-v6.4-0012-net-dsa-mt7530-introduce-driver-for-MT7988-built-in-.patch
@@ -28,7 +28,7 @@ Signed-off-by: David S. Miller <davem@davemloft.net>
 
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -13058,9 +13058,11 @@ MEDIATEK SWITCH DRIVER
+@@ -13060,9 +13060,11 @@ MEDIATEK SWITCH DRIVER
  M:	Sean Wang <sean.wang@mediatek.com>
  M:	Landen Chao <Landen.Chao@mediatek.com>
  M:	DENG Qingfang <dqfext@gmail.com>
diff --git a/target/linux/generic/backport-6.1/791-v6.2-01-net-phy-Add-driver-for-Motorcomm-yt8521-gigabit-ethernet.patch b/target/linux/generic/backport-6.1/791-v6.2-01-net-phy-Add-driver-for-Motorcomm-yt8521-gigabit-ethernet.patch
index 06dddffcaa..4cdd67cdcc 100644
--- a/target/linux/generic/backport-6.1/791-v6.2-01-net-phy-Add-driver-for-Motorcomm-yt8521-gigabit-ethernet.patch
+++ b/target/linux/generic/backport-6.1/791-v6.2-01-net-phy-Add-driver-for-Motorcomm-yt8521-gigabit-ethernet.patch
@@ -21,7 +21,7 @@ Signed-off-by: David S. Miller <davem@davemloft.net>
 
 --- a/MAINTAINERS
 +++ b/MAINTAINERS
-@@ -13962,6 +13962,7 @@ F:	include/uapi/linux/meye.h
+@@ -13964,6 +13964,7 @@ F:	include/uapi/linux/meye.h
  
  MOTORCOMM PHY DRIVER
  M:	Peter Geis <pgwipeout@gmail.com>
diff --git a/target/linux/generic/hack-6.1/650-netfilter-add-xt_FLOWOFFLOAD-target.patch b/target/linux/generic/hack-6.1/650-netfilter-add-xt_FLOWOFFLOAD-target.patch
index 386291bfe8..9ff45a414e 100644
--- a/target/linux/generic/hack-6.1/650-netfilter-add-xt_FLOWOFFLOAD-target.patch
+++ b/target/linux/generic/hack-6.1/650-netfilter-add-xt_FLOWOFFLOAD-target.patch
@@ -654,7 +654,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +};
 +
 +static int nf_flow_rule_route_inet(struct net *net,
-+				   const struct flow_offload *flow,
++				   struct flow_offload *flow,
 +				   enum flow_offload_tuple_dir dir,
 +				   struct nf_flow_rule *flow_rule)
 +{
@@ -755,7 +755,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  		      void (*iter)(struct nf_flowtable *flowtable,
  				   struct flow_offload *flow, void *data),
  		      void *data)
-@@ -436,6 +434,7 @@ static void nf_flow_offload_gc_step(stru
+@@ -443,6 +441,7 @@ static void nf_flow_offload_gc_step(stru
  		nf_flow_offload_stats(flow_table, flow);
  	}
  }
@@ -785,7 +785,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +#endif /* _XT_FLOWOFFLOAD_H */
 --- a/include/net/netfilter/nf_flow_table.h
 +++ b/include/net/netfilter/nf_flow_table.h
-@@ -280,6 +280,11 @@ void nf_flow_table_free(struct nf_flowta
+@@ -293,6 +293,11 @@ void nf_flow_table_free(struct nf_flowta
  
  void flow_offload_teardown(struct flow_offload *flow);
  
diff --git a/target/linux/generic/hack-6.1/901-debloat_sock_diag.patch b/target/linux/generic/hack-6.1/901-debloat_sock_diag.patch
index b4403e82c8..ffa6e8ac60 100644
--- a/target/linux/generic/hack-6.1/901-debloat_sock_diag.patch
+++ b/target/linux/generic/hack-6.1/901-debloat_sock_diag.patch
@@ -79,7 +79,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  INDIRECT_CALLABLE_DECLARE(struct dst_entry *ip6_dst_check(struct dst_entry *,
  							  u32));
  INDIRECT_CALLABLE_DECLARE(struct dst_entry *ipv4_dst_check(struct dst_entry *,
-@@ -2180,9 +2194,11 @@ static void __sk_free(struct sock *sk)
+@@ -2187,9 +2201,11 @@ static void __sk_free(struct sock *sk)
  	if (likely(sk->sk_net_refcnt))
  		sock_inuse_add(sock_net(sk), -1);
  
diff --git a/target/linux/generic/hack-6.1/902-debloat_proc.patch b/target/linux/generic/hack-6.1/902-debloat_proc.patch
index a5db9b21c1..0d844994aa 100644
--- a/target/linux/generic/hack-6.1/902-debloat_proc.patch
+++ b/target/linux/generic/hack-6.1/902-debloat_proc.patch
@@ -330,7 +330,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
 --- a/net/core/sock.c
 +++ b/net/core/sock.c
-@@ -4105,6 +4105,8 @@ static __net_initdata struct pernet_oper
+@@ -4113,6 +4113,8 @@ static __net_initdata struct pernet_oper
  
  static int __init proto_init(void)
  {
diff --git a/target/linux/generic/pending-6.1/700-netfilter-nft_flow_offload-handle-netdevice-events-f.patch b/target/linux/generic/pending-6.1/700-netfilter-nft_flow_offload-handle-netdevice-events-f.patch
index 6050db3f5b..47c742cff0 100644
--- a/target/linux/generic/pending-6.1/700-netfilter-nft_flow_offload-handle-netdevice-events-f.patch
+++ b/target/linux/generic/pending-6.1/700-netfilter-nft_flow_offload-handle-netdevice-events-f.patch
@@ -10,7 +10,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
 
 --- a/net/netfilter/nf_flow_table_core.c
 +++ b/net/netfilter/nf_flow_table_core.c
-@@ -659,6 +659,23 @@ static struct pernet_operations nf_flow_
+@@ -666,6 +666,23 @@ static struct pernet_operations nf_flow_
  	.exit_batch = nf_flow_table_pernet_exit,
  };
  
@@ -34,7 +34,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
  static int __init nf_flow_table_module_init(void)
  {
  	int ret;
-@@ -671,8 +688,14 @@ static int __init nf_flow_table_module_i
+@@ -678,8 +695,14 @@ static int __init nf_flow_table_module_i
  	if (ret)
  		goto out_offload;
  
@@ -49,7 +49,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
  out_offload:
  	unregister_pernet_subsys(&nf_flow_table_net_ops);
  	return ret;
-@@ -680,6 +703,7 @@ out_offload:
+@@ -687,6 +710,7 @@ out_offload:
  
  static void __exit nf_flow_table_module_exit(void)
  {
-- 
2.40.1


From bd9671f099b0b613d4beb0628768025734fd57cc Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Mon, 8 Jan 2024 14:48:14 -0500
Subject: [PATCH 21/24] kernel: r8152: sync with linux-next

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 .../950-0106-Add-dwc_otg-driver.patch         |  2 +-
 ...-for-updating-interrupt-endpoint-int.patch |  2 +-
 ...-Hold-the-rtnl_lock-for-all-of-reset.patch | 88 +++++++++++++++++++
 ...-USB-config-with-choose_configuratio.patch | 70 +++++++++++++++
 ...orce-USB-generic_subclass-drivers-to.patch | 33 +++++++
 ...ubclassed-USB-drivers-to-override-us.patch | 76 ++++++++++++++++
 ...sh-w-usb_choose_configuration-if-no-.patch | 55 ++++++++++++
 ...-clock-gating-feature-on-Rockchip-So.patch | 26 ++++++
 8 files changed, 350 insertions(+), 2 deletions(-)
 create mode 100644 target/linux/generic/backport-6.1/795-v6.7-18-r8152-Hold-the-rtnl_lock-for-all-of-reset.patch
 create mode 100644 target/linux/generic/backport-6.1/795-v6.8-19-r8152-Choose-our-USB-config-with-choose_configuratio.patch
 create mode 100644 target/linux/generic/backport-6.1/795-v6.8-20-usb-core-Don-t-force-USB-generic_subclass-drivers-to.patch
 create mode 100644 target/linux/generic/backport-6.1/795-v6.8-21-usb-core-Allow-subclassed-USB-drivers-to-override-us.patch
 create mode 100644 target/linux/generic/backport-6.1/795-v6.8-22-usb-core-Fix-crash-w-usb_choose_configuration-if-no-.patch
 create mode 100644 target/linux/generic/backport-6.1/795-v6.8-25-usb-dwc2-Disable-clock-gating-feature-on-Rockchip-So.patch

diff --git a/target/linux/bcm27xx/patches-6.1/950-0106-Add-dwc_otg-driver.patch b/target/linux/bcm27xx/patches-6.1/950-0106-Add-dwc_otg-driver.patch
index 635e864f99..843ce36467 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0106-Add-dwc_otg-driver.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0106-Add-dwc_otg-driver.patch
@@ -1175,7 +1175,7 @@ Signed-off-by: Jonathan Bell <jonathan@raspberrypi.com>
  obj-$(CONFIG_USB_ISP1760)	+= isp1760/
 --- a/drivers/usb/core/generic.c
 +++ b/drivers/usb/core/generic.c
-@@ -190,6 +190,7 @@ int usb_choose_configuration(struct usb_
+@@ -206,6 +206,7 @@ int usb_choose_configuration(struct usb_
  		dev_warn(&udev->dev,
  			"no configuration chosen from %d choice%s\n",
  			num_configs, plural(num_configs));
diff --git a/target/linux/bcm27xx/patches-6.1/950-0181-usb-add-plumbing-for-updating-interrupt-endpoint-int.patch b/target/linux/bcm27xx/patches-6.1/950-0181-usb-add-plumbing-for-updating-interrupt-endpoint-int.patch
index 34b923fb23..f8076438b4 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0181-usb-add-plumbing-for-updating-interrupt-endpoint-int.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0181-usb-add-plumbing-for-updating-interrupt-endpoint-int.patch
@@ -70,7 +70,7 @@ Signed-off-by: Jonathan Bell <jonathan@raspberrypi.org>
   * @dev: the device whose endpoint is being disabled
 --- a/include/linux/usb.h
 +++ b/include/linux/usb.h
-@@ -1843,6 +1843,8 @@ extern int usb_clear_halt(struct usb_dev
+@@ -1849,6 +1849,8 @@ extern int usb_clear_halt(struct usb_dev
  extern int usb_reset_configuration(struct usb_device *dev);
  extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
  extern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);
diff --git a/target/linux/generic/backport-6.1/795-v6.7-18-r8152-Hold-the-rtnl_lock-for-all-of-reset.patch b/target/linux/generic/backport-6.1/795-v6.7-18-r8152-Hold-the-rtnl_lock-for-all-of-reset.patch
new file mode 100644
index 0000000000..cce28a5735
--- /dev/null
+++ b/target/linux/generic/backport-6.1/795-v6.7-18-r8152-Hold-the-rtnl_lock-for-all-of-reset.patch
@@ -0,0 +1,88 @@
+From e62adaeecdc6a1e8ae86e7f3f9f8223a3ede94f5 Mon Sep 17 00:00:00 2001
+From: Douglas Anderson <dianders@chromium.org>
+Date: Wed, 29 Nov 2023 13:25:20 -0800
+Subject: [PATCH] r8152: Hold the rtnl_lock for all of reset
+
+As of commit d9962b0d4202 ("r8152: Block future register access if
+register access fails") there is a race condition that can happen
+between the USB device reset thread and napi_enable() (not) getting
+called during rtl8152_open(). Specifically:
+* While rtl8152_open() is running we get a register access error
+  that's _not_ -ENODEV and queue up a USB reset.
+* rtl8152_open() exits before calling napi_enable() due to any reason
+  (including usb_submit_urb() returning an error).
+
+In that case:
+* Since the USB reset is perform in a separate thread asynchronously,
+  it can run at anytime USB device lock is not held - even before
+  rtl8152_open() has exited with an error and caused __dev_open() to
+  clear the __LINK_STATE_START bit.
+* The rtl8152_pre_reset() will notice that the netif_running() returns
+  true (since __LINK_STATE_START wasn't cleared) so it won't exit
+  early.
+* rtl8152_pre_reset() will then hang in napi_disable() because
+  napi_enable() was never called.
+
+We can fix the race by making sure that the r8152 reset routines don't
+run at the same time as we're opening the device. Specifically we need
+the reset routines in their entirety rely on the return value of
+netif_running(). The only way to reliably depend on that is for them
+to hold the rntl_lock() mutex for the duration of reset.
+
+Grabbing the rntl_lock() mutex for the duration of reset seems like a
+long time, but reset is not expected to be common and the rtnl_lock()
+mutex is already held for long durations since the core grabs it
+around the open/close calls.
+
+Fixes: d9962b0d4202 ("r8152: Block future register access if register access fails")
+Reviewed-by: Grant Grundler <grundler@chromium.org>
+Signed-off-by: Douglas Anderson <dianders@chromium.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/usb/r8152.c | 13 +++++++------
+ 1 file changed, 7 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/usb/r8152.c
++++ b/drivers/net/usb/r8152.c
+@@ -8410,6 +8410,8 @@ static int rtl8152_pre_reset(struct usb_
+ 	struct r8152 *tp = usb_get_intfdata(intf);
+ 	struct net_device *netdev;
+ 
++	rtnl_lock();
++
+ 	if (!tp || !test_bit(PROBED_WITH_NO_ERRORS, &tp->flags))
+ 		return 0;
+ 
+@@ -8441,20 +8443,17 @@ static int rtl8152_post_reset(struct usb
+ 	struct sockaddr sa;
+ 
+ 	if (!tp || !test_bit(PROBED_WITH_NO_ERRORS, &tp->flags))
+-		return 0;
++		goto exit;
+ 
+ 	rtl_set_accessible(tp);
+ 
+ 	/* reset the MAC address in case of policy change */
+-	if (determine_ethernet_addr(tp, &sa) >= 0) {
+-		rtnl_lock();
++	if (determine_ethernet_addr(tp, &sa) >= 0)
+ 		dev_set_mac_address (tp->netdev, &sa, NULL);
+-		rtnl_unlock();
+-	}
+ 
+ 	netdev = tp->netdev;
+ 	if (!netif_running(netdev))
+-		return 0;
++		goto exit;
+ 
+ 	set_bit(WORK_ENABLE, &tp->flags);
+ 	if (netif_carrier_ok(netdev)) {
+@@ -8473,6 +8472,8 @@ static int rtl8152_post_reset(struct usb
+ 	if (!list_empty(&tp->rx_done))
+ 		napi_schedule(&tp->napi);
+ 
++exit:
++	rtnl_unlock();
+ 	return 0;
+ }
+ 
diff --git a/target/linux/generic/backport-6.1/795-v6.8-19-r8152-Choose-our-USB-config-with-choose_configuratio.patch b/target/linux/generic/backport-6.1/795-v6.8-19-r8152-Choose-our-USB-config-with-choose_configuratio.patch
new file mode 100644
index 0000000000..05fb69bc21
--- /dev/null
+++ b/target/linux/generic/backport-6.1/795-v6.8-19-r8152-Choose-our-USB-config-with-choose_configuratio.patch
@@ -0,0 +1,70 @@
+From aa4f2b3e418e8673e55145de8b8016a7a9920306 Mon Sep 17 00:00:00 2001
+From: Douglas Anderson <dianders@chromium.org>
+Date: Fri, 1 Dec 2023 10:29:52 -0800
+Subject: [PATCH] r8152: Choose our USB config with choose_configuration()
+ rather than probe()
+
+If you deauthorize the r8152 device (by writing 0 to the "authorized"
+field in sysfs) and then reauthorize it (by writing a 1) then it no
+longer works. This is because when you do the above we lose the
+special configuration that we set in rtl8152_cfgselector_probe().
+Deauthorizing causes the config to be set to -1 and then reauthorizing
+runs the default logic for choosing the best config.
+
+I made an attempt to fix it so that the config is kept across
+deauthorizing / reauthorizing [1] but it was a bit ugly.
+
+Let's instead use the new USB core feature to override
+choose_configuration().
+
+This patch relies upon the patches ("usb: core: Don't force USB
+generic_subclass drivers to define probe()") and ("usb: core: Allow
+subclassed USB drivers to override usb_choose_configuration()")
+
+[1] https://lore.kernel.org/r/20231130154337.1.Ie00e07f07f87149c9ce0b27ae4e26991d307e14b@changeid
+
+Fixes: ec51fbd1b8a2 ("r8152: add USB device driver for config selection")
+Suggested-by: Alan Stern <stern@rowland.harvard.edu>
+Signed-off-by: Douglas Anderson <dianders@chromium.org>
+Reviewed-by: Grant Grundler <grundler@chromium.org>
+Link: https://lore.kernel.org/r/20231201102946.v2.3.Ie00e07f07f87149c9ce0b27ae4e26991d307e14b@changeid
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/net/usb/r8152.c | 16 +++++-----------
+ 1 file changed, 5 insertions(+), 11 deletions(-)
+
+--- a/drivers/net/usb/r8152.c
++++ b/drivers/net/usb/r8152.c
+@@ -10068,7 +10068,7 @@ static struct usb_driver rtl8152_driver
+ 	.disable_hub_initiated_lpm = 1,
+ };
+ 
+-static int rtl8152_cfgselector_probe(struct usb_device *udev)
++static int rtl8152_cfgselector_choose_configuration(struct usb_device *udev)
+ {
+ 	struct usb_host_config *c;
+ 	int i, num_configs;
+@@ -10095,19 +10095,13 @@ static int rtl8152_cfgselector_probe(str
+ 	if (i == num_configs)
+ 		return -ENODEV;
+ 
+-	if (usb_set_configuration(udev, c->desc.bConfigurationValue)) {
+-		dev_err(&udev->dev, "Failed to set configuration %d\n",
+-			c->desc.bConfigurationValue);
+-		return -ENODEV;
+-	}
+-
+-	return 0;
++	return c->desc.bConfigurationValue;
+ }
+ 
+ static struct usb_device_driver rtl8152_cfgselector_driver = {
+-	.name =		MODULENAME "-cfgselector",
+-	.probe =	rtl8152_cfgselector_probe,
+-	.id_table =	rtl8152_table,
++	.name =	MODULENAME "-cfgselector",
++	.choose_configuration = rtl8152_cfgselector_choose_configuration,
++	.id_table = rtl8152_table,
+ 	.generic_subclass = 1,
+ 	.supports_autosuspend = 1,
+ };
diff --git a/target/linux/generic/backport-6.1/795-v6.8-20-usb-core-Don-t-force-USB-generic_subclass-drivers-to.patch b/target/linux/generic/backport-6.1/795-v6.8-20-usb-core-Don-t-force-USB-generic_subclass-drivers-to.patch
new file mode 100644
index 0000000000..c5652c7a7b
--- /dev/null
+++ b/target/linux/generic/backport-6.1/795-v6.8-20-usb-core-Don-t-force-USB-generic_subclass-drivers-to.patch
@@ -0,0 +1,33 @@
+From c2d95fcff0f01fa00d9683dddeeea6732b74c779 Mon Sep 17 00:00:00 2001
+From: Douglas Anderson <dianders@chromium.org>
+Date: Fri, 1 Dec 2023 10:29:50 -0800
+Subject: [PATCH] usb: core: Don't force USB generic_subclass drivers to define
+ probe()
+
+There's no real reason that subclassed USB drivers _need_ to define
+probe() since they might want to subclass for some other reason. Make
+it optional to define probe() if we're a generic_subclass.
+
+Signed-off-by: Douglas Anderson <dianders@chromium.org>
+Reviewed-by: Grant Grundler <grundler@chromium.org>
+Reviewed-by: Alan Stern <stern@rowland.harvard.edu>
+Link: https://lore.kernel.org/r/20231201102946.v2.1.I7ea0dd55ee2acdb48b0e6d28c1a704ab2c29206f@changeid
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/usb/core/driver.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/drivers/usb/core/driver.c
++++ b/drivers/usb/core/driver.c
+@@ -290,7 +290,10 @@ static int usb_probe_device(struct devic
+ 	 * specialised device drivers prior to setting the
+ 	 * use_generic_driver bit.
+ 	 */
+-	error = udriver->probe(udev);
++	if (udriver->probe)
++		error = udriver->probe(udev);
++	else if (!udriver->generic_subclass)
++		error = -EINVAL;
+ 	if (error == -ENODEV && udriver != &usb_generic_driver &&
+ 	    (udriver->id_table || udriver->match)) {
+ 		udev->use_generic_driver = 1;
diff --git a/target/linux/generic/backport-6.1/795-v6.8-21-usb-core-Allow-subclassed-USB-drivers-to-override-us.patch b/target/linux/generic/backport-6.1/795-v6.8-21-usb-core-Allow-subclassed-USB-drivers-to-override-us.patch
new file mode 100644
index 0000000000..46db091a10
--- /dev/null
+++ b/target/linux/generic/backport-6.1/795-v6.8-21-usb-core-Allow-subclassed-USB-drivers-to-override-us.patch
@@ -0,0 +1,76 @@
+From a87b8e3be926af0fc3b9b1af42b1127bd1ff077c Mon Sep 17 00:00:00 2001
+From: Douglas Anderson <dianders@chromium.org>
+Date: Fri, 1 Dec 2023 10:29:51 -0800
+Subject: [PATCH] usb: core: Allow subclassed USB drivers to override
+ usb_choose_configuration()
+
+For some USB devices we might want to do something different for
+usb_choose_configuration(). One example here is the r8152 driver where
+we want to end up using the vendor driver with the preferred
+interface.
+
+The r8152 driver tried to make things work by implementing a USB
+generic_subclass driver and then overriding the normal config
+selection after it happened. This is less than ideal and also caused
+breakage if someone deauthorized and re-authorized the USB device
+because the USB core ended up going back to it's default logic for
+choosing the best config. I made an attempt to fix this [1] but it was
+a bit ugly.
+
+Let's do this better and allow USB generic_subclass drivers to
+override usb_choose_configuration().
+
+[1] https://lore.kernel.org/r/20231130154337.1.Ie00e07f07f87149c9ce0b27ae4e26991d307e14b@changeid
+
+Suggested-by: Alan Stern <stern@rowland.harvard.edu>
+Signed-off-by: Douglas Anderson <dianders@chromium.org>
+Reviewed-by: Alan Stern <stern@rowland.harvard.edu>
+Link: https://lore.kernel.org/r/20231201102946.v2.2.Iade5fa31997f1a0ca3e1dec0591633b02471df12@changeid
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/usb/core/generic.c | 7 +++++++
+ include/linux/usb.h        | 6 ++++++
+ 2 files changed, 13 insertions(+)
+
+--- a/drivers/usb/core/generic.c
++++ b/drivers/usb/core/generic.c
+@@ -59,10 +59,17 @@ int usb_choose_configuration(struct usb_
+ 	int num_configs;
+ 	int insufficient_power = 0;
+ 	struct usb_host_config *c, *best;
++	struct usb_device_driver *udriver = to_usb_device_driver(udev->dev.driver);
+ 
+ 	if (usb_device_is_owned(udev))
+ 		return 0;
+ 
++	if (udriver->choose_configuration) {
++		i = udriver->choose_configuration(udev);
++		if (i >= 0)
++			return i;
++	}
++
+ 	best = NULL;
+ 	c = udev->config;
+ 	num_configs = udev->descriptor.bNumConfigurations;
+--- a/include/linux/usb.h
++++ b/include/linux/usb.h
+@@ -1234,6 +1234,9 @@ struct usb_driver {
+  *	module is being unloaded.
+  * @suspend: Called when the device is going to be suspended by the system.
+  * @resume: Called when the device is being resumed by the system.
++ * @choose_configuration: If non-NULL, called instead of the default
++ *	usb_choose_configuration(). If this returns an error then we'll go
++ *	on to call the normal usb_choose_configuration().
+  * @dev_groups: Attributes attached to the device that will be created once it
+  *	is bound to the driver.
+  * @drvwrap: Driver-model core structure wrapper.
+@@ -1257,6 +1260,9 @@ struct usb_device_driver {
+ 
+ 	int (*suspend) (struct usb_device *udev, pm_message_t message);
+ 	int (*resume) (struct usb_device *udev, pm_message_t message);
++
++	int (*choose_configuration) (struct usb_device *udev);
++
+ 	const struct attribute_group **dev_groups;
+ 	struct usbdrv_wrap drvwrap;
+ 	const struct usb_device_id *id_table;
diff --git a/target/linux/generic/backport-6.1/795-v6.8-22-usb-core-Fix-crash-w-usb_choose_configuration-if-no-.patch b/target/linux/generic/backport-6.1/795-v6.8-22-usb-core-Fix-crash-w-usb_choose_configuration-if-no-.patch
new file mode 100644
index 0000000000..abfdcef37e
--- /dev/null
+++ b/target/linux/generic/backport-6.1/795-v6.8-22-usb-core-Fix-crash-w-usb_choose_configuration-if-no-.patch
@@ -0,0 +1,55 @@
+From 44995e6f07028f798efd0c3c11a1efc78330f600 Mon Sep 17 00:00:00 2001
+From: Douglas Anderson <dianders@chromium.org>
+Date: Mon, 11 Dec 2023 07:32:41 -0800
+Subject: [PATCH] usb: core: Fix crash w/ usb_choose_configuration() if no
+ driver
+
+It's possible that usb_choose_configuration() can get called when a
+USB device has no driver. In this case the recent commit a87b8e3be926
+("usb: core: Allow subclassed USB drivers to override
+usb_choose_configuration()") can cause a crash since it dereferenced
+the driver structure without checking for NULL. Let's add a check.
+
+A USB device with no driver is an anomaly, so make
+usb_choose_configuration() return immediately if there is no driver.
+
+This was seen in the real world when usbguard got ahold of a r8152
+device at the wrong time. It can also be simulated via this on a
+computer with one r8152-based USB Ethernet adapter:
+  cd /sys/bus/usb/drivers/r8152-cfgselector
+  to_unbind="$(ls -d *-*)"
+  real_dir="$(readlink -f "${to_unbind}")"
+  echo "${to_unbind}" > unbind
+  cd "${real_dir}"
+  echo 0 > authorized
+  echo 1 > authorized
+
+Fixes: a87b8e3be926 ("usb: core: Allow subclassed USB drivers to override usb_choose_configuration()")
+Reviewed-by: Alan Stern <stern@rowland.harvard.edu>
+Signed-off-by: Douglas Anderson <dianders@chromium.org>
+Link: https://lore.kernel.org/r/20231211073237.v3.1.If27eb3bf7812f91ab83810f232292f032f4203e0@changeid
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/usb/core/generic.c | 11 ++++++++++-
+ 1 file changed, 10 insertions(+), 1 deletion(-)
+
+--- a/drivers/usb/core/generic.c
++++ b/drivers/usb/core/generic.c
+@@ -59,7 +59,16 @@ int usb_choose_configuration(struct usb_
+ 	int num_configs;
+ 	int insufficient_power = 0;
+ 	struct usb_host_config *c, *best;
+-	struct usb_device_driver *udriver = to_usb_device_driver(udev->dev.driver);
++	struct usb_device_driver *udriver;
++
++	/*
++	 * If a USB device (not an interface) doesn't have a driver then the
++	 * kernel has no business trying to select or install a configuration
++	 * for it.
++	 */
++	if (!udev->dev.driver)
++		return -1;
++	udriver = to_usb_device_driver(udev->dev.driver);
+ 
+ 	if (usb_device_is_owned(udev))
+ 		return 0;
diff --git a/target/linux/generic/backport-6.1/795-v6.8-25-usb-dwc2-Disable-clock-gating-feature-on-Rockchip-So.patch b/target/linux/generic/backport-6.1/795-v6.8-25-usb-dwc2-Disable-clock-gating-feature-on-Rockchip-So.patch
new file mode 100644
index 0000000000..a9ba2b5b4a
--- /dev/null
+++ b/target/linux/generic/backport-6.1/795-v6.8-25-usb-dwc2-Disable-clock-gating-feature-on-Rockchip-So.patch
@@ -0,0 +1,26 @@
+From ca2dc35e555e7043de585f4e46123d8fbd2b5a21 Mon Sep 17 00:00:00 2001
+From: William Wu <william.wu@rock-chips.com>
+Date: Tue, 26 Dec 2023 15:19:59 +0800
+Subject: [PATCH] usb: dwc2: Disable clock gating feature on Rockchip SoCs
+
+The DWC2 IP on the Rockchip SoCs doesn't support clock gating.
+When a clock gating is enabled, system hangs.
+
+Signed-off-by: William Wu <william.wu@rock-chips.com>
+Acked-by: Minas Harutyunyan <hminas@synopsys.com>
+Link: https://lore.kernel.org/r/1703575199-23638-1-git-send-email-william.wu@rock-chips.com
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/usb/dwc2/params.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/usb/dwc2/params.c
++++ b/drivers/usb/dwc2/params.c
+@@ -155,6 +155,7 @@ static void dwc2_set_amlogic_g12a_params
+ 	p->lpm_clock_gating = false;
+ 	p->besl = false;
+ 	p->hird_threshold_en = false;
++	p->no_clock_gating = true;
+ }
+ 
+ static void dwc2_set_amcc_params(struct dwc2_hsotg *hsotg)
-- 
2.40.1


From 8b6f6ca2057ab414829e750de982d474df3bf905 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Mon, 15 Jan 2024 14:24:32 -0500
Subject: [PATCH 22/24] kernel: Linux 6.1.73

Link: https://lore.kernel.org/r/20240113094204.017594027@linuxfoundation.org

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 include/kernel-6.1                             |  4 ++--
 ...ing-with-source-address-failed-policy.patch | 18 +++++++++---------
 2 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/include/kernel-6.1 b/include/kernel-6.1
index 836cecf7de..fde32f3ca3 100644
--- a/include/kernel-6.1
+++ b/include/kernel-6.1
@@ -1,2 +1,2 @@
-LINUX_VERSION-6.1 = .72
-LINUX_KERNEL_HASH-6.1.72 = 98dce69077c35cffca799dcdbbd32a02242aad6b0950eb931936bb2ef69f0926
+LINUX_VERSION-6.1 = .73
+LINUX_KERNEL_HASH-6.1.73 = 6cad48706bf1cde342613dca2a2cd6dd4f79f88f9e4d356263564e4b2a5d7e87
diff --git a/target/linux/generic/pending-6.1/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch b/target/linux/generic/pending-6.1/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
index 003a0f20ac..72e8de2f1d 100644
--- a/target/linux/generic/pending-6.1/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
+++ b/target/linux/generic/pending-6.1/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
@@ -157,7 +157,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  	case RTN_THROW:
  	case RTN_UNREACHABLE:
  	default:
-@@ -4543,6 +4562,17 @@ static int ip6_pkt_prohibit_out(struct n
+@@ -4540,6 +4559,17 @@ static int ip6_pkt_prohibit_out(struct n
  	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
  }
  
@@ -175,7 +175,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  /*
   *	Allocate a dst for local (unicast / anycast) address.
   */
-@@ -5036,7 +5066,8 @@ static int rtm_to_fib6_config(struct sk_
+@@ -5033,7 +5063,8 @@ static int rtm_to_fib6_config(struct sk_
  	if (rtm->rtm_type == RTN_UNREACHABLE ||
  	    rtm->rtm_type == RTN_BLACKHOLE ||
  	    rtm->rtm_type == RTN_PROHIBIT ||
@@ -185,7 +185,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  		cfg->fc_flags |= RTF_REJECT;
  
  	if (rtm->rtm_type == RTN_LOCAL)
-@@ -6290,6 +6321,8 @@ static int ip6_route_dev_notify(struct n
+@@ -6287,6 +6318,8 @@ static int ip6_route_dev_notify(struct n
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
  		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
@@ -194,7 +194,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
  		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
  #endif
-@@ -6301,6 +6334,7 @@ static int ip6_route_dev_notify(struct n
+@@ -6298,6 +6331,7 @@ static int ip6_route_dev_notify(struct n
  		in6_dev_put_clear(&net->ipv6.ip6_null_entry->rt6i_idev);
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  		in6_dev_put_clear(&net->ipv6.ip6_prohibit_entry->rt6i_idev);
@@ -202,7 +202,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  		in6_dev_put_clear(&net->ipv6.ip6_blk_hole_entry->rt6i_idev);
  #endif
  	}
-@@ -6492,6 +6526,8 @@ static int __net_init ip6_route_net_init
+@@ -6489,6 +6523,8 @@ static int __net_init ip6_route_net_init
  
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  	net->ipv6.fib6_has_custom_rules = false;
@@ -211,7 +211,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  	net->ipv6.ip6_prohibit_entry = kmemdup(&ip6_prohibit_entry_template,
  					       sizeof(*net->ipv6.ip6_prohibit_entry),
  					       GFP_KERNEL);
-@@ -6502,11 +6538,21 @@ static int __net_init ip6_route_net_init
+@@ -6499,11 +6535,21 @@ static int __net_init ip6_route_net_init
  			 ip6_template_metrics, true);
  	INIT_LIST_HEAD(&net->ipv6.ip6_prohibit_entry->rt6i_uncached);
  
@@ -234,7 +234,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
  	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
  			 ip6_template_metrics, true);
-@@ -6533,6 +6579,8 @@ out:
+@@ -6530,6 +6576,8 @@ out:
  	return ret;
  
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
@@ -243,7 +243,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  out_ip6_prohibit_entry:
  	kfree(net->ipv6.ip6_prohibit_entry);
  out_ip6_null_entry:
-@@ -6552,6 +6600,7 @@ static void __net_exit ip6_route_net_exi
+@@ -6549,6 +6597,7 @@ static void __net_exit ip6_route_net_exi
  	kfree(net->ipv6.ip6_null_entry);
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  	kfree(net->ipv6.ip6_prohibit_entry);
@@ -251,7 +251,7 @@ Signed-off-by: Jonas Gorski <jogo@openwrt.org>
  	kfree(net->ipv6.ip6_blk_hole_entry);
  #endif
  	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
-@@ -6635,6 +6684,9 @@ void __init ip6_route_init_special_entri
+@@ -6632,6 +6681,9 @@ void __init ip6_route_init_special_entri
  	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
  	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
  	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
-- 
2.40.1


From 13c209098a3fe65462425d25a206dca4abee1abb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C3=81lvaro=20Fern=C3=A1ndez=20Rojas?= <noltari@gmail.com>
Date: Tue, 16 Jan 2024 14:52:05 +0100
Subject: [PATCH 23/24] bcm27xx-utils: add new package
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The raspberypi/userland repository has been deprecated and the RPi tools have
been moved to the raspberrypi/utils repository.
https://github.com/raspberrypi/userland/commit/96a7334ae9d5fc9db7ac92e59852377df63f1848

Signed-off-by: lvaro Fernndez Rojas <noltari@gmail.com>
---
 package/utils/bcm27xx-utils/Makefile          |  63 +++++
 .../0001-raspinfo-adapt-to-OpenWrt.patch      | 249 ++++++++++++++++++
 2 files changed, 312 insertions(+)
 create mode 100644 package/utils/bcm27xx-utils/Makefile
 create mode 100644 package/utils/bcm27xx-utils/patches/0001-raspinfo-adapt-to-OpenWrt.patch

diff --git a/package/utils/bcm27xx-utils/Makefile b/package/utils/bcm27xx-utils/Makefile
new file mode 100644
index 0000000000..ca8c3969c6
--- /dev/null
+++ b/package/utils/bcm27xx-utils/Makefile
@@ -0,0 +1,63 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=bcm27xx-utils
+PKG_VERSION:=2024-01-15
+PKG_RELEASE:=1
+
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_URL:=https://github.com/raspberrypi/utils.git
+PKG_SOURCE_VERSION:=32602f565c6cb854d1f2643b51a022991cea2b1b
+PKG_MIRROR_HASH:=efbfa0f1aabbe9ecb347c3a27629fb757f67ff283c8d3b1ee7376ddc6925127b
+
+PKG_FLAGS:=nonshared
+
+PKG_LICENSE:=BSD-3-Clause
+PKG_LICENSE_FILES:=LICENCE
+
+CMAKE_INSTALL:=1
+
+include $(INCLUDE_DIR)/package.mk
+include $(INCLUDE_DIR)/cmake.mk
+
+define Package/bcm27xx-utils
+  SECTION:=utils
+  CATEGORY:=Utilities
+  DEPENDS:=@TARGET_bcm27xx +libfdt
+  TITLE:=BCM27xx scripts and simple applications
+  PROVIDES:=bcm27xx-userland
+endef
+
+define Package/bcm27xx-utils/description
+  BCM27xx scripts and simple applications.
+  Replaces bcm27xx-userland scripts and applications.
+endef
+
+define Package/bcm27xx-utils/install
+	$(INSTALL_DIR) $(1)/usr/bin
+
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/dtmerge $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/dtoverlay $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/dtparam $(1)/usr/bin
+
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/eepdump $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/eepflash.sh $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/eepmake $(1)/usr/bin
+
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/otpset $(1)/usr/bin
+
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/overlaycheck $(1)/usr/bin
+	$(INSTALL_DATA) $(PKG_INSTALL_DIR)/usr/bin/overlaycheck_exclusions.txt $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/ovmerge $(1)/usr/bin
+
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/pinctrl $(1)/usr/bin
+
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/raspinfo $(1)/usr/bin
+
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/vcgencmd $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/vclog $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/vcmailbox $(1)/usr/bin
+endef
+
+$(eval $(call BuildPackage,bcm27xx-utils))
diff --git a/package/utils/bcm27xx-utils/patches/0001-raspinfo-adapt-to-OpenWrt.patch b/package/utils/bcm27xx-utils/patches/0001-raspinfo-adapt-to-OpenWrt.patch
new file mode 100644
index 0000000000..9341fbe820
--- /dev/null
+++ b/package/utils/bcm27xx-utils/patches/0001-raspinfo-adapt-to-OpenWrt.patch
@@ -0,0 +1,249 @@
+From 0db3fb3119eda8c2360454c2a01f84602a879c38 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?=C3=81lvaro=20Fern=C3=A1ndez=20Rojas?= <noltari@gmail.com>
+Date: Tue, 16 Jan 2024 15:32:12 +0100
+Subject: [PATCH] raspinfo: adapt to OpenWrt
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: lvaro Fernndez Rojas <noltari@gmail.com>
+---
+ raspinfo/raspinfo | 186 ++++------------------------------------------
+ 1 file changed, 13 insertions(+), 173 deletions(-)
+
+--- a/raspinfo/raspinfo
++++ b/raspinfo/raspinfo
+@@ -6,147 +6,6 @@
+ # IP4 d.d.d.d decimal	    "s/\([0-9]\{1,3\}\.\)\{3,3\}[0-9]\{1,3\}/x.x.x.x/g"
+ # mac address	            "s/\([0-9a-fA-F]\{2,2\}\:\)\{5,5\}[0-9a-fA-F]\{2,2\}/m.m.m.m/g"
+ 
+-
+-display_info_drm() {
+-   # If running X then can use xrandr, otherwise
+-   # dump the /sys/class entries for the displays
+-   if command -v xrandr > /dev/null &&
+-      DISPLAY=${DISPLAY:-:0} xrandr --listmonitors &>/dev/null;
+-   then
+-      echo "Running (F)KMS and X"
+-      echo
+-
+-      DISPLAY=${DISPLAY:-:0} xrandr --verbose
+-   else
+-      echo "Running (F)KMS, console"
+-      echo
+-
+-      for card in /sys/class/drm/card[0-9]-*;
+-      do
+-         echo $card
+-
+-         # if kmsprint isn't installed print basic mode info
+-         if ! command -v kmsprint > /dev/null; then
+-            if [ -f $card/modes ];
+-            then
+-               cat $card/modes
+-            else
+-               echo "No modes found"
+-            fi
+-         fi
+-
+-         if [ -f $card/edid ];
+-         then
+-            base64 $card/edid
+-         else
+-            echo "No EDID found"
+-         fi
+-         echo
+-      done
+-   fi
+-
+-   # kmsprint is more useful, but not always installed
+-   echo
+-   if command -v kmsprint > /dev/null; then
+-      kmsprint
+-      echo
+-      kmsprint -m
+-   else
+-      echo "kmsprint is not installed. Install with: sudo apt install kms++-utils"
+-   fi
+-
+-   echo
+-
+-   # dump the /sys/class entries for the displays
+-   cardfound=0
+-   for card in `seq 0 9`;
+-   do
+-      if sudo test -f "/sys/kernel/debug/dri/${card}/state";
+-      then
+-        for hdmi in 0 1;
+-        do
+-         if sudo test -f "/sys/kernel/debug/dri/${card}/hdmi${hdmi}_regs";
+-         then
+-            echo "HDMI${hdmi}: $(sudo cat /sys/kernel/debug/dri/$card/hdmi${hdmi}_regs | grep HOTPLUG)"
+-         fi
+-      done
+-      echo
+-      echo "/sys/kernel/debug/dri/$card/state:"
+-      sudo cat "/sys/kernel/debug/dri/$card/state"
+-      echo
+-      cardfound=1
+-      fi
+-   done
+-   if [ "$cardfound" == "0" ];
+-   then
+-      echo "kms state not found"
+-   fi
+-   echo
+-
+-}
+-
+-display_info_legacy() {
+-   # Legacy mode
+-   echo "Running Legacy framebuffer"
+-   echo
+-
+-   for card in `seq 0 9`;
+-   do
+-      F="/dev/fb${card}"
+-      if test -e $F;
+-      then
+-         echo Framebuffer: $F
+-         fbset -s -fb $F
+-      fi
+-   done
+-
+-   disps=`tvservice -l | awk '/Display Number/{print substr($3,1,1)}'`
+-
+-   tmp=$(mktemp)
+-
+-   for display in $disps
+-   do
+-      echo
+-      echo "Display: " $display
+-
+-      tvservice -v $display -s
+-      tvservice -v $display -n
+-      tvservice -v $display -m CEA
+-      tvservice -v $display -m DMT
+-
+-      echo
+-      tvservice -v $display -d $tmp > /dev/null
+-      base64 $tmp
+-   done
+-
+-   rm $tmp
+-}
+-
+-display_info() {
+-   # Check if we are running a KMS/DRM system
+-
+-   if [ -d "/dev/dri" ];
+-   then
+-      display_info_drm
+-   else
+-      display_info_legacy
+-   fi
+-}
+-
+-audio_info() {
+-   aplay -l
+-   echo
+-   aplay -L
+-   echo
+-   systemctl --user status pipewire.socket pipewire.service pulseaudio.service pulseaudio.socket
+-   echo
+-   if command -v pactl > /dev/null; then
+-      pactl info
+-   else
+-      echo pactl not installed
+-   fi
+-}
+-
+ OUT=raspinfo.txt
+ 
+ rm -f $OUT
+@@ -163,8 +22,6 @@ echo
+ cat /etc/os-release | head -4
+ echo
+ 
+-cat /etc/rpi-issue
+-echo
+ uname -a
+ 
+ cat /proc/cpuinfo | tail -3
+@@ -190,17 +47,6 @@ echo
+ cat /proc/swaps
+ 
+ echo
+-echo "Package version information"
+-echo "---------------------------"
+-
+-apt-cache policy raspberrypi-ui-mods | head -2
+-apt-cache policy raspberrypi-sys-mods | head -2
+-apt-cache policy openbox | head -2
+-apt-cache policy lxpanel | head -2
+-apt-cache policy pcmanfm | head -2
+-apt-cache policy rpd-plym-splash | head -2
+-
+-echo
+ echo "Networking Information"
+ echo "----------------------"
+ echo
+@@ -212,21 +58,11 @@ echo "USB Information"
+ echo "---------------"
+ echo
+ 
+-lsusb -t
+-
+-echo
+-echo "Display Information"
+-echo "-------------------"
+-echo
+-
+-display_info
+-
+-echo
+-echo "Audio Information"
+-echo "-------------------"
+-echo
+-
+-audio_info
++if command -v lsusb > /dev/null; then
++   lsusb -t
++else
++   echo usbutils not installed
++fi
+ 
+ echo
+ echo "config.txt"
+@@ -250,7 +86,7 @@ echo "-----------------"
+ echo
+ 
+ if command -v pinctrl > /dev/null; then
+-   sudo pinctrl 2>&1
++   pinctrl 2>&1
+ elif command -v raspi-gpio > /dev/null; then
+    raspi-gpio get 2>&1
+ else
+@@ -263,9 +99,9 @@ echo "------------------"
+ echo
+ 
+ if command -v vcdbg > /dev/null; then
+-   sudo vcdbg log msg 2>&1
++   vcdbg log msg 2>&1
+ elif command -v vclog > /dev/null; then
+-   sudo vclog --msg 2>&1
++   vclog --msg 2>&1
+ else
+    echo "vcdbg not found"
+ fi
+@@ -284,5 +120,9 @@ echo
+ echo "EEPROM"
+ echo "------"
+ echo
+-sudo rpi-eeprom-update
++if command -v rpi-eeprom-update > /dev/null; then
++   rpi-eeprom-update
++else
++   echo bcm27xx-eeprom not installed
++fi
+ fi
-- 
2.40.1


From d2a1e0598bc8105aec5cbe9002ca7c90e14cf6db Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Tue, 16 Jan 2024 20:18:05 -0500
Subject: [PATCH 24/24] kernel: queue/6.1.74

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 ...7xx-Read-modem-line-state-at-startup.patch |   2 +-
 ...icitly-null-terminate-the-xattr-list.patch |  34 +++
 ...inctrl-lochnagar-Don-t-build-on-MIPS.patch |  35 +++
 ...aker-and-headset-mic-pin-config-for-.patch |  52 ++++
 ...init-value-in-mptcp_incoming_options.patch |  28 ++
 ...211-lock-wiphy-mutex-for-rfkill-poll.patch |  29 +++
 ...d-offset-calculation-on-NULL-pointer.patch |  38 +++
 ...ndle-320-MHz-in-ieee80211_ht_cap_ie_.patch |  31 +++
 ...debugfs-fix-automount-d_fsdata-usage.patch | 138 ++++++++++
 ...-debugfs-handlers-vs.-removal-with-l.patch | 107 ++++++++
 ...hlt-Ignore-vbps-when-looking-for-DMI.patch |  97 +++++++
 ...memory-leak-in-nvme_ns_info_from_ide.patch |  43 +++
 ...y-update-dcn315-lpddr-pstate-latency.patch |  58 +++++
 ...at-debugfs-amdgpu_regs_didt-causes-k.patch |  49 ++++
 ...b-client-common-fix-fortify-warnings.patch | 202 +++++++++++++++
 ...nt-completed-flush-data-request-as-i.patch |  63 +++++
 ...e-core-check-for-too-small-lba-shift.patch |  35 +++
 ...tt-Handle-the-interrupt-in-hardirq-c.patch |  43 +++
 ...-hisi_ptt-Don-t-try-to-attach-a-task.patch |  31 +++
 ...oC-wm8974-Correct-boost-mixer-inputs.patch |  42 +++
 ...ip-fix-rk356x-pcie-msg-interrupt-nam.patch |  30 +++
 ...kylake-Fix-mem-leak-in-few-functions.patch |  50 ++++
 ...-incorrect-type-in-assignment-and-ca.patch |  68 +++++
 ...ke-mem-leak-in-skl-register-function.patch |  45 ++++
 ...-Fix-the-position-of-const-qualifier.patch |  36 +++
 ...-incorrect-frame-delay-configuration.patch |  27 ++
 ...mutex-to-avoid-the-jack-detection-fa.patch |  72 +++++
 ...da_dsp_generic-Drop-HDMI-routes-when.patch |  37 +++
 ...au-tu102-flush-all-pdbs-on-vmm-flush.patch |  31 +++
 ...DMI-entry-to-support-System76-Pangol.patch |  34 +++
 ...nditionally-register-dais-for-HDMI-a.patch |  89 +++++++
 ...fix-race-condition-in-tg3_reset_task.patch |  87 +++++++
 ...219-Support-low-DC-impedance-headset.patch |  29 +++
 ...rect-range-check-for-limiting-volume.patch |  33 +++
 ...ce-helper-function-to-get-ctrl-state.patch |  33 +++
 ...-prevent-potential-spectre-v1-gadget.patch |  47 ++++
 ...ip-Fix-PCI-node-addresses-on-rk3399-.patch |  67 +++++
 ...-rcutree_report_cpu_starting-earlier.patch |  70 +++++
 ...Use-channel_width-2-for-vram-table-3.patch |  38 +++
 ...dd-NULL-checks-for-function-pointers.patch |  48 ++++
 ...-potential-error-pointer-dereference.patch |  33 +++
 ...rm-exynos-fix-a-wrong-error-checking.patch |  55 ++++
 ...-corsair-psu-Fix-probe-when-built-in.patch |  50 ++++
 ...ch-Preserve-syscall-nr-across-execve.patch |  43 +++
 ...hip-rk3568-Add-PLL-rate-for-292.5MHz.patch |  32 +++
 ...ip-rk3128-Fix-HCLK_OTG-gate-register.patch |  28 ++
 ...-printing-of-write_flags-in-jbd2_wri.patch |  35 +++
 ...2-increase-the-journal-IO-s-priority.patch | 149 +++++++++++
 ...uninit-value-bug-in-drm_mode_setcrtc.patch |  72 +++++
 ...let-neigh_forced_gc-disable-preempti.patch |  58 +++++
 ...el-vbtn-Fix-missing-tablet-mode-swit.patch |  93 +++++++
 ...ckup-in-journal_finish_inode_data_bu.patch |  75 ++++++
 ...ge-events-show-up-as-LINE-TOO-BIG-in.patch |  72 +++++
 ...-check-when-printing-trace_marker-ou.patch |  60 +++++
 ...ngson-drop-useless-check-for-compati.patch |  38 +++
 ...n-drop-incorrect-dwmac-fallback-comp.patch |  48 ++++
 ...issue-when-open-the-hist-or-hist_deb.patch | 169 ++++++++++++
 ...ot-record-in-NMI-if-the-arch-does-no.patch |  38 +++
 ...able-Synaptics-InterTouch-for-ThinkP.patch |  43 +++
 ...hi6220-fix-Wvoid-pointer-to-enum-cas.patch |  32 +++
 ...p-ATKBD_CMD_GETID-in-translated-mode.patch | 119 +++++++++
 ...2-add-nomux-quirk-for-Acer-P459-G2-M.patch |  38 +++
 ...irtual-vs-physical-address-confusion.patch |  52 ++++
 ...queue-6.1.74-063-ARC-fix-spare-error.patch |  41 +++
 ...cie-avoid-a-NULL-pointer-dereference.patch |  32 +++
 ...-xpad-add-Razer-Wolverine-V2-support.patch |  27 ++
 ...lsa-fixed-a-print-formatting-warning.patch |  30 +++
 ...-initializer-element-is-not-constant.patch |  74 ++++++
 ...nkpad_acpi-fix-for-incorrect-fan-rep.patch | 245 ++++++++++++++++++
 ..._rt5640-Add-quirk-for-the-Medion-Lif.patch |  42 +++
 ..._rt5640-Add-new-swapped-speakers-qui.patch |  97 +++++++
 ...-Add-quirks-for-ASUS-Zenbook-2022-Mo.patch |  44 ++++
 ...nfig-so-DM_AUDIT-depends-on-BLK_DEV_.patch |  23 ++
 ...tendo-Prevent-divide-by-zero-on-code.patch |  95 +++++++
 ...ix-potential-OOB-in-smb2_dump_detail.patch |  84 ++++++
 ...potential-spinlock-recursion-on-poll.patch |  77 ++++++
 ...get-dprefclk-ss-info-from-integratio.patch |  75 ++++++
 ...6.1.74-077-pinctrl-cy8c95x0-Fix-typo.patch |  28 ++
 ...-078-pinctrl-cy8c95x0-Fix-get_pincfg.patch |  29 +++
 ...in-ida_free-when-the-bitmap-is-empty.patch |  90 +++++++
 ...snprintf-truncation-compiler-warning.patch |  76 ++++++
 ...turn-0-if-server-port-is-not-present.patch |  38 +++
 ...x-return-code-check-of-of_property_m.patch |  43 +++
 ...-crtc-fix-uninitialized-variable-use.patch |  47 ++++
 ...-only-v2-leases-handle-the-directory.patch |  30 +++
 85 files changed, 4926 insertions(+), 1 deletion(-)
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-001-f2fs-explicitly-null-terminate-the-xattr-list.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-002-pinctrl-lochnagar-Don-t-build-on-MIPS.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-003-ALSA-hda-Fix-speaker-and-headset-mic-pin-config-for-.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-004-mptcp-fix-uninit-value-in-mptcp_incoming_options.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-005-wifi-cfg80211-lock-wiphy-mutex-for-rfkill-poll.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-006-wifi-avoid-offset-calculation-on-NULL-pointer.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-007-wifi-mac80211-handle-320-MHz-in-ieee80211_ht_cap_ie_.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-008-debugfs-fix-automount-d_fsdata-usage.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-009-debugfs-annotate-debugfs-handlers-vs.-removal-with-l.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-010-ALSA-hda-intel-nhlt-Ignore-vbps-when-looking-for-DMI.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-011-nvme-core-fix-a-memory-leak-in-nvme_ns_info_from_ide.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-012-drm-amd-display-update-dcn315-lpddr-pstate-latency.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-013-drm-amdgpu-Fix-cat-debugfs-amdgpu_regs_didt-causes-k.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-014-smb-client-common-fix-fortify-warnings.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-015-blk-mq-don-t-count-completed-flush-data-request-as-i.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-016-nvme-core-check-for-too-small-lba-shift.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-017-hwtracing-hisi_ptt-Handle-the-interrupt-in-hardirq-c.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-018-hwtracing-hisi_ptt-Don-t-try-to-attach-a-task.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-019-ASoC-wm8974-Correct-boost-mixer-inputs.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-020-arm64-dts-rockchip-fix-rk356x-pcie-msg-interrupt-nam.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-021-ASoC-Intel-Skylake-Fix-mem-leak-in-few-functions.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-022-ASoC-nau8822-Fix-incorrect-type-in-assignment-and-ca.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-023-ASoC-Intel-Skylake-mem-leak-in-skl-register-function.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-024-ASoC-cs43130-Fix-the-position-of-const-qualifier.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-025-ASoC-cs43130-Fix-incorrect-frame-delay-configuration.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-026-ASoC-rt5650-add-mutex-to-avoid-the-jack-detection-fa.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-027-ASoC-Intel-skl_hda_dsp_generic-Drop-HDMI-routes-when.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-028-nouveau-tu102-flush-all-pdbs-on-vmm-flush.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-029-ASoC-amd-yc-Add-DMI-entry-to-support-System76-Pangol.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-030-ASoC-hdac_hda-Conditionally-register-dais-for-HDMI-a.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-031-net-tg3-fix-race-condition-in-tg3_reset_task.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-032-ASoC-da7219-Support-low-DC-impedance-headset.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-033-ASoC-ops-add-correct-range-check-for-limiting-volume.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-034-nvme-introduce-helper-function-to-get-ctrl-state.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-035-nvme-prevent-potential-spectre-v1-gadget.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-036-arm64-dts-rockchip-Fix-PCI-node-addresses-on-rk3399-.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-037-mips-smp-Call-rcutree_report_cpu_starting-earlier.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-038-drm-amd-display-Use-channel_width-2-for-vram-table-3.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-039-drm-amdgpu-Add-NULL-checks-for-function-pointers.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-040-drm-exynos-fix-a-potential-error-pointer-dereference.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-041-drm-exynos-fix-a-wrong-error-checking.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-042-hwmon-corsair-psu-Fix-probe-when-built-in.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-043-LoongArch-Preserve-syscall-nr-across-execve.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-044-clk-rockchip-rk3568-Add-PLL-rate-for-292.5MHz.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-045-clk-rockchip-rk3128-Fix-HCLK_OTG-gate-register.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-046-jbd2-correct-the-printing-of-write_flags-in-jbd2_wri.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-047-jbd2-increase-the-journal-IO-s-priority.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-048-drm-crtc-Fix-uninit-value-bug-in-drm_mode_setcrtc.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-049-neighbour-Don-t-let-neigh_forced_gc-disable-preempti.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-050-platform-x86-intel-vbtn-Fix-missing-tablet-mode-swit.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-051-jbd2-fix-soft-lockup-in-journal_finish_inode_data_bu.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-052-tracing-Have-large-events-show-up-as-LINE-TOO-BIG-in.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-053-tracing-Add-size-check-when-printing-trace_marker-ou.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-054-stmmac-dwmac-loongson-drop-useless-check-for-compati.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-055-MIPS-dts-loongson-drop-incorrect-dwmac-fallback-comp.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-056-tracing-Fix-uaf-issue-when-open-the-hist-or-hist_deb.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-057-ring-buffer-Do-not-record-in-NMI-if-the-arch-does-no.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-058-Input-psmouse-enable-Synaptics-InterTouch-for-ThinkP.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-059-reset-hisilicon-hi6220-fix-Wvoid-pointer-to-enum-cas.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-060-Input-atkbd-skip-ATKBD_CMD_GETID-in-translated-mode.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-061-Input-i8042-add-nomux-quirk-for-Acer-P459-G2-M.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-062-s390-scm-fix-virtual-vs-physical-address-confusion.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-063-ARC-fix-spare-error.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-064-wifi-iwlwifi-pcie-avoid-a-NULL-pointer-dereference.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-065-Input-xpad-add-Razer-Wolverine-V2-support.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-066-kselftest-alsa-fixed-a-print-formatting-warning.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-067-HID-nintendo-fix-initializer-element-is-not-constant.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-068-platform-x86-thinkpad_acpi-fix-for-incorrect-fan-rep.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-069-ASoC-Intel-bytcr_rt5640-Add-quirk-for-the-Medion-Lif.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-070-ASoC-Intel-bytcr_rt5640-Add-new-swapped-speakers-qui.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-071-ALSA-hda-realtek-Add-quirks-for-ASUS-Zenbook-2022-Mo.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-072-dm-audit-fix-Kconfig-so-DM_AUDIT-depends-on-BLK_DEV_.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-073-HID-nintendo-Prevent-divide-by-zero-on-code.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-074-smb-client-fix-potential-OOB-in-smb2_dump_detail.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-075-i2c-rk3x-fix-potential-spinlock-recursion-on-poll.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-076-drm-amd-display-get-dprefclk-ss-info-from-integratio.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-077-pinctrl-cy8c95x0-Fix-typo.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-078-pinctrl-cy8c95x0-Fix-get_pincfg.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-079-ida-Fix-crash-in-ida_free-when-the-bitmap-is-empty.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-080-virtio_blk-fix-snprintf-truncation-compiler-warning.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-081-net-qrtr-ns-Return-0-if-server-port-is-not-present.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-082-ARM-sun9i-smp-fix-return-code-check-of-of_property_m.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-083-drm-crtc-fix-uninitialized-variable-use.patch
 create mode 100644 target/linux/generic/backport-6.1/0-queue-6.1.74-084-ksmbd-only-v2-leases-handle-the-directory.patch

diff --git a/target/linux/bcm27xx/patches-6.1/950-0791-serial-sc16is7xx-Read-modem-line-state-at-startup.patch b/target/linux/bcm27xx/patches-6.1/950-0791-serial-sc16is7xx-Read-modem-line-state-at-startup.patch
index c54c4472ed..c93ebf3e7e 100644
--- a/target/linux/bcm27xx/patches-6.1/950-0791-serial-sc16is7xx-Read-modem-line-state-at-startup.patch
+++ b/target/linux/bcm27xx/patches-6.1/950-0791-serial-sc16is7xx-Read-modem-line-state-at-startup.patch
@@ -16,7 +16,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.com>
 
 --- a/drivers/tty/serial/sc16is7xx.c
 +++ b/drivers/tty/serial/sc16is7xx.c
-@@ -1223,6 +1223,9 @@ static int sc16is7xx_startup(struct uart
+@@ -1221,6 +1221,9 @@ static int sc16is7xx_startup(struct uart
  	      SC16IS7XX_IER_MSI_BIT;
  	sc16is7xx_port_write(port, SC16IS7XX_IER_REG, val);
  
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-001-f2fs-explicitly-null-terminate-the-xattr-list.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-001-f2fs-explicitly-null-terminate-the-xattr-list.patch
new file mode 100644
index 0000000000..7d954facbd
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-001-f2fs-explicitly-null-terminate-the-xattr-list.patch
@@ -0,0 +1,34 @@
+From 4da7ef1b0cb186fc21aa0c209e095299b1af370a Mon Sep 17 00:00:00 2001
+From: Eric Biggers <ebiggers@google.com>
+Date: Mon, 6 Nov 2023 20:44:34 -0800
+Subject: [PATCH] f2fs: explicitly null-terminate the xattr list
+
+commit e26b6d39270f5eab0087453d9b544189a38c8564 upstream.
+
+When setting an xattr, explicitly null-terminate the xattr list.  This
+eliminates the fragile assumption that the unused xattr space is always
+zeroed.
+
+Signed-off-by: Eric Biggers <ebiggers@google.com>
+Reviewed-by: Chao Yu <chao@kernel.org>
+Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ fs/f2fs/xattr.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/fs/f2fs/xattr.c
++++ b/fs/f2fs/xattr.c
+@@ -754,6 +754,12 @@ retry:
+ 		memcpy(pval, value, size);
+ 		last->e_value_size = cpu_to_le16(size);
+ 		new_hsize += newsize;
++		/*
++		 * Explicitly add the null terminator.  The unused xattr space
++		 * is supposed to always be zeroed, which would make this
++		 * unnecessary, but don't depend on that.
++		 */
++		*(u32 *)((u8 *)last + newsize) = 0;
+ 	}
+ 
+ 	error = write_all_xattrs(inode, new_hsize, base_addr, ipage);
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-002-pinctrl-lochnagar-Don-t-build-on-MIPS.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-002-pinctrl-lochnagar-Don-t-build-on-MIPS.patch
new file mode 100644
index 0000000000..b8fef41413
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-002-pinctrl-lochnagar-Don-t-build-on-MIPS.patch
@@ -0,0 +1,35 @@
+From 9133da388927b2aaabe643bffa5adebd14f958ec Mon Sep 17 00:00:00 2001
+From: Charles Keepax <ckeepax@opensource.cirrus.com>
+Date: Wed, 15 Nov 2023 16:28:53 +0000
+Subject: [PATCH] pinctrl: lochnagar: Don't build on MIPS
+
+[ Upstream commit 6588732445ff19f6183f0fa72ddedf67e5a5be32 ]
+
+MIPS appears to define a RST symbol at a high level, which clashes
+with some register naming in the driver. Since there is currently
+no case for running this driver on MIPS devices simply cut off the
+build of this driver on MIPS.
+
+Reported-by: kernel test robot <lkp@intel.com>
+Closes: https://lore.kernel.org/oe-kbuild-all/202311071303.JJMAOjy4-lkp@intel.com/
+Suggested-by: Linus Walleij <linus.walleij@linaro.org>
+Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
+Link: https://lore.kernel.org/r/20231115162853.1891940-1-ckeepax@opensource.cirrus.com
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/pinctrl/cirrus/Kconfig | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/pinctrl/cirrus/Kconfig
++++ b/drivers/pinctrl/cirrus/Kconfig
+@@ -1,7 +1,8 @@
+ # SPDX-License-Identifier: GPL-2.0-only
+ config PINCTRL_LOCHNAGAR
+ 	tristate "Cirrus Logic Lochnagar pinctrl driver"
+-	depends on MFD_LOCHNAGAR
++	# Avoid clash caused by MIPS defining RST, which is used in the driver
++	depends on MFD_LOCHNAGAR && !MIPS
+ 	select GPIOLIB
+ 	select PINMUX
+ 	select PINCONF
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-003-ALSA-hda-Fix-speaker-and-headset-mic-pin-config-for-.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-003-ALSA-hda-Fix-speaker-and-headset-mic-pin-config-for-.patch
new file mode 100644
index 0000000000..4f4ddbee4a
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-003-ALSA-hda-Fix-speaker-and-headset-mic-pin-config-for-.patch
@@ -0,0 +1,52 @@
+From f081042f04ea1a4863dcb97e19e8e168ea74f9d4 Mon Sep 17 00:00:00 2001
+From: Vasiliy Kovalev <kovalev@altlinux.org>
+Date: Fri, 17 Nov 2023 20:09:23 +0300
+Subject: [PATCH] ALSA: hda - Fix speaker and headset mic pin config for CHUWI
+ CoreBook XPro
+
+[ Upstream commit 7c9caa299335df94ad1c58f70a22f16a540eab60 ]
+
+This patch corrected the speaker and headset mic pin config to the more
+appropriate values.
+
+Signed-off-by: Vasiliy Kovalev <kovalev@altlinux.org>
+Link: https://lore.kernel.org/r/20231117170923.106822-1-kovalev@altlinux.org
+Signed-off-by: Takashi Iwai <tiwai@suse.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/pci/hda/patch_realtek.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/sound/pci/hda/patch_realtek.c
++++ b/sound/pci/hda/patch_realtek.c
+@@ -7108,6 +7108,7 @@ enum {
+ 	ALC290_FIXUP_SUBWOOFER_HSJACK,
+ 	ALC269_FIXUP_THINKPAD_ACPI,
+ 	ALC269_FIXUP_DMIC_THINKPAD_ACPI,
++	ALC269VB_FIXUP_CHUWI_COREBOOK_XPRO,
+ 	ALC255_FIXUP_ACER_MIC_NO_PRESENCE,
+ 	ALC255_FIXUP_ASUS_MIC_NO_PRESENCE,
+ 	ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
+@@ -7454,6 +7455,14 @@ static const struct hda_fixup alc269_fix
+ 		.type = HDA_FIXUP_FUNC,
+ 		.v.func = alc269_fixup_pincfg_U7x7_headset_mic,
+ 	},
++	[ALC269VB_FIXUP_CHUWI_COREBOOK_XPRO] = {
++		.type = HDA_FIXUP_PINS,
++		.v.pins = (const struct hda_pintbl[]) {
++			{ 0x18, 0x03a19020 }, /* headset mic */
++			{ 0x1b, 0x90170150 }, /* speaker */
++			{ }
++		},
++	},
+ 	[ALC269_FIXUP_AMIC] = {
+ 		.type = HDA_FIXUP_PINS,
+ 		.v.pins = (const struct hda_pintbl[]) {
+@@ -10032,6 +10041,7 @@ static const struct snd_pci_quirk alc269
+ 	SND_PCI_QUIRK(0x1d72, 0x1901, "RedmiBook 14", ALC256_FIXUP_ASUS_HEADSET_MIC),
+ 	SND_PCI_QUIRK(0x1d72, 0x1945, "Redmi G", ALC256_FIXUP_ASUS_HEADSET_MIC),
+ 	SND_PCI_QUIRK(0x1d72, 0x1947, "RedmiBook Air", ALC255_FIXUP_XIAOMI_HEADSET_MIC),
++	SND_PCI_QUIRK(0x2782, 0x0232, "CHUWI CoreBook XPro", ALC269VB_FIXUP_CHUWI_COREBOOK_XPRO),
+ 	SND_PCI_QUIRK(0x8086, 0x2074, "Intel NUC 8", ALC233_FIXUP_INTEL_NUC8_DMIC),
+ 	SND_PCI_QUIRK(0x8086, 0x2080, "Intel NUC 8 Rugged", ALC256_FIXUP_INTEL_NUC8_RUGGED),
+ 	SND_PCI_QUIRK(0x8086, 0x2081, "Intel NUC 10", ALC256_FIXUP_INTEL_NUC10),
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-004-mptcp-fix-uninit-value-in-mptcp_incoming_options.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-004-mptcp-fix-uninit-value-in-mptcp_incoming_options.patch
new file mode 100644
index 0000000000..eba19e58da
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-004-mptcp-fix-uninit-value-in-mptcp_incoming_options.patch
@@ -0,0 +1,28 @@
+From 02d9b44f1cfe8db0b1fcae95c346b789bf8e2cb5 Mon Sep 17 00:00:00 2001
+From: Edward Adam Davis <eadavis@qq.com>
+Date: Thu, 23 Nov 2023 09:23:39 +0800
+Subject: [PATCH] mptcp: fix uninit-value in mptcp_incoming_options
+
+[ Upstream commit 237ff253f2d4f6307b7b20434d7cbcc67693298b ]
+
+Added initialization use_ack to mptcp_parse_option().
+
+Reported-by: syzbot+b834a6b2decad004cfa1@syzkaller.appspotmail.com
+Signed-off-by: Edward Adam Davis <eadavis@qq.com>
+Acked-by: Paolo Abeni <pabeni@redhat.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ net/mptcp/options.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/mptcp/options.c
++++ b/net/mptcp/options.c
+@@ -103,6 +103,7 @@ static void mptcp_parse_option(const str
+ 			mp_opt->suboptions |= OPTION_MPTCP_DSS;
+ 			mp_opt->use_map = 1;
+ 			mp_opt->mpc_map = 1;
++			mp_opt->use_ack = 0;
+ 			mp_opt->data_len = get_unaligned_be16(ptr);
+ 			ptr += 2;
+ 		}
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-005-wifi-cfg80211-lock-wiphy-mutex-for-rfkill-poll.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-005-wifi-cfg80211-lock-wiphy-mutex-for-rfkill-poll.patch
new file mode 100644
index 0000000000..1524400d33
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-005-wifi-cfg80211-lock-wiphy-mutex-for-rfkill-poll.patch
@@ -0,0 +1,29 @@
+From 455bd00064b24299b3f8cc08888d791fa968a187 Mon Sep 17 00:00:00 2001
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Wed, 8 Nov 2023 13:41:25 +0100
+Subject: [PATCH] wifi: cfg80211: lock wiphy mutex for rfkill poll
+
+[ Upstream commit 8e2f6f2366219b3304b227bdd2f04b64c92e3e12 ]
+
+We want to guarantee the mutex is held for pretty much
+all operations, so ensure that here as well.
+
+Reported-by: syzbot+7e59a5bfc7a897247e18@syzkaller.appspotmail.com
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ net/wireless/core.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/net/wireless/core.c
++++ b/net/wireless/core.c
+@@ -216,7 +216,9 @@ static void cfg80211_rfkill_poll(struct
+ {
+ 	struct cfg80211_registered_device *rdev = data;
+ 
++	wiphy_lock(&rdev->wiphy);
+ 	rdev_rfkill_poll(rdev);
++	wiphy_unlock(&rdev->wiphy);
+ }
+ 
+ void cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-006-wifi-avoid-offset-calculation-on-NULL-pointer.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-006-wifi-avoid-offset-calculation-on-NULL-pointer.patch
new file mode 100644
index 0000000000..239c6f4689
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-006-wifi-avoid-offset-calculation-on-NULL-pointer.patch
@@ -0,0 +1,38 @@
+From 9037c7daf9233060ada9c1ee1db20a1026e7672c Mon Sep 17 00:00:00 2001
+From: Michael-CY Lee <michael-cy.lee@mediatek.com>
+Date: Wed, 22 Nov 2023 11:02:37 +0800
+Subject: [PATCH] wifi: avoid offset calculation on NULL pointer
+
+[ Upstream commit ef5828805842204dd0259ecfc132b5916c8a77ae ]
+
+ieee80211_he_6ghz_oper() can be passed a NULL pointer
+and checks for that, but already did the calculation
+to inside of it before. Move it after the check.
+
+Signed-off-by: Michael-CY Lee <michael-cy.lee@mediatek.com>
+Link: https://lore.kernel.org/r/20231122030237.31276-1-michael-cy.lee@mediatek.com
+[rewrite commit message]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ include/linux/ieee80211.h | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/include/linux/ieee80211.h
++++ b/include/linux/ieee80211.h
+@@ -2658,12 +2658,14 @@ ieee80211_he_oper_size(const u8 *he_oper
+ static inline const struct ieee80211_he_6ghz_oper *
+ ieee80211_he_6ghz_oper(const struct ieee80211_he_operation *he_oper)
+ {
+-	const u8 *ret = (const void *)&he_oper->optional;
++	const u8 *ret;
+ 	u32 he_oper_params;
+ 
+ 	if (!he_oper)
+ 		return NULL;
+ 
++	ret = (const void *)&he_oper->optional;
++
+ 	he_oper_params = le32_to_cpu(he_oper->he_oper_params);
+ 
+ 	if (!(he_oper_params & IEEE80211_HE_OPERATION_6GHZ_OP_INFO))
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-007-wifi-mac80211-handle-320-MHz-in-ieee80211_ht_cap_ie_.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-007-wifi-mac80211-handle-320-MHz-in-ieee80211_ht_cap_ie_.patch
new file mode 100644
index 0000000000..e3cd410c56
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-007-wifi-mac80211-handle-320-MHz-in-ieee80211_ht_cap_ie_.patch
@@ -0,0 +1,31 @@
+From 447188ec8769e9dbd047d524a2340ba5e55a831e Mon Sep 17 00:00:00 2001
+From: Ben Greear <greearb@candelatech.com>
+Date: Thu, 9 Nov 2023 10:22:01 -0800
+Subject: [PATCH] wifi: mac80211: handle 320 MHz in
+ ieee80211_ht_cap_ie_to_sta_ht_cap
+
+[ Upstream commit 00f7d153f3358a7c7e35aef66fcd9ceb95d90430 ]
+
+The new 320 MHz channel width wasn't handled, so connecting
+a station to a 320 MHz AP would limit the station to 20 MHz
+(on HT) after a warning, handle 320 MHz to fix that.
+
+Signed-off-by: Ben Greear <greearb@candelatech.com>
+Link: https://lore.kernel.org/r/20231109182201.495381-1-greearb@candelatech.com
+[write a proper commit message]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ net/mac80211/ht.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/mac80211/ht.c
++++ b/net/mac80211/ht.c
+@@ -271,6 +271,7 @@ bool ieee80211_ht_cap_ie_to_sta_ht_cap(s
+ 	case NL80211_CHAN_WIDTH_80:
+ 	case NL80211_CHAN_WIDTH_80P80:
+ 	case NL80211_CHAN_WIDTH_160:
++	case NL80211_CHAN_WIDTH_320:
+ 		bw = ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?
+ 				IEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;
+ 		break;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-008-debugfs-fix-automount-d_fsdata-usage.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-008-debugfs-fix-automount-d_fsdata-usage.patch
new file mode 100644
index 0000000000..e470fe78f4
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-008-debugfs-fix-automount-d_fsdata-usage.patch
@@ -0,0 +1,138 @@
+From dbe0ef2b8fdbcbfd095c36f0db9c9bc6fea7c8ad Mon Sep 17 00:00:00 2001
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Fri, 24 Nov 2023 17:25:24 +0100
+Subject: [PATCH] debugfs: fix automount d_fsdata usage
+
+[ Upstream commit 0ed04a1847a10297595ac24dc7d46b35fb35f90a ]
+
+debugfs_create_automount() stores a function pointer in d_fsdata,
+but since commit 7c8d469877b1 ("debugfs: add support for more
+elaborate ->d_fsdata") debugfs_release_dentry() will free it, now
+conditionally on DEBUGFS_FSDATA_IS_REAL_FOPS_BIT, but that's not
+set for the function pointer in automount. As a result, removing
+an automount dentry would attempt to free the function pointer.
+Luckily, the only user of this (tracing) never removes it.
+
+Nevertheless, it's safer if we just handle the fsdata in one way,
+namely either DEBUGFS_FSDATA_IS_REAL_FOPS_BIT or allocated. Thus,
+change the automount to allocate it, and use the real_fops in the
+data to indicate whether or not automount is filled, rather than
+adding a type tag. At least for now this isn't actually needed,
+but the next changes will require it.
+
+Also check in debugfs_file_get() that it gets only called
+on regular files, just to make things clearer.
+
+Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ fs/debugfs/file.c     |  8 ++++++++
+ fs/debugfs/inode.c    | 27 ++++++++++++++++++++-------
+ fs/debugfs/internal.h | 10 ++++++++--
+ 3 files changed, 36 insertions(+), 9 deletions(-)
+
+--- a/fs/debugfs/file.c
++++ b/fs/debugfs/file.c
+@@ -84,6 +84,14 @@ int debugfs_file_get(struct dentry *dent
+ 	struct debugfs_fsdata *fsd;
+ 	void *d_fsd;
+ 
++	/*
++	 * This could only happen if some debugfs user erroneously calls
++	 * debugfs_file_get() on a dentry that isn't even a file, let
++	 * them know about it.
++	 */
++	if (WARN_ON(!d_is_reg(dentry)))
++		return -EINVAL;
++
+ 	d_fsd = READ_ONCE(dentry->d_fsdata);
+ 	if (!((unsigned long)d_fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT)) {
+ 		fsd = d_fsd;
+--- a/fs/debugfs/inode.c
++++ b/fs/debugfs/inode.c
+@@ -237,17 +237,19 @@ static const struct super_operations deb
+ 
+ static void debugfs_release_dentry(struct dentry *dentry)
+ {
+-	void *fsd = dentry->d_fsdata;
++	struct debugfs_fsdata *fsd = dentry->d_fsdata;
+ 
+-	if (!((unsigned long)fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT))
+-		kfree(dentry->d_fsdata);
++	if ((unsigned long)fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT)
++		return;
++
++	kfree(fsd);
+ }
+ 
+ static struct vfsmount *debugfs_automount(struct path *path)
+ {
+-	debugfs_automount_t f;
+-	f = (debugfs_automount_t)path->dentry->d_fsdata;
+-	return f(path->dentry, d_inode(path->dentry)->i_private);
++	struct debugfs_fsdata *fsd = path->dentry->d_fsdata;
++
++	return fsd->automount(path->dentry, d_inode(path->dentry)->i_private);
+ }
+ 
+ static const struct dentry_operations debugfs_dops = {
+@@ -635,13 +637,23 @@ struct dentry *debugfs_create_automount(
+ 					void *data)
+ {
+ 	struct dentry *dentry = start_creating(name, parent);
++	struct debugfs_fsdata *fsd;
+ 	struct inode *inode;
+ 
+ 	if (IS_ERR(dentry))
+ 		return dentry;
+ 
++	fsd = kzalloc(sizeof(*fsd), GFP_KERNEL);
++	if (!fsd) {
++		failed_creating(dentry);
++		return ERR_PTR(-ENOMEM);
++	}
++
++	fsd->automount = f;
++
+ 	if (!(debugfs_allow & DEBUGFS_ALLOW_API)) {
+ 		failed_creating(dentry);
++		kfree(fsd);
+ 		return ERR_PTR(-EPERM);
+ 	}
+ 
+@@ -649,13 +661,14 @@ struct dentry *debugfs_create_automount(
+ 	if (unlikely(!inode)) {
+ 		pr_err("out of free dentries, can not create automount '%s'\n",
+ 		       name);
++		kfree(fsd);
+ 		return failed_creating(dentry);
+ 	}
+ 
+ 	make_empty_dir_inode(inode);
+ 	inode->i_flags |= S_AUTOMOUNT;
+ 	inode->i_private = data;
+-	dentry->d_fsdata = (void *)f;
++	dentry->d_fsdata = fsd;
+ 	/* directory inodes start off with i_nlink == 2 (for "." entry) */
+ 	inc_nlink(inode);
+ 	d_instantiate(dentry, inode);
+--- a/fs/debugfs/internal.h
++++ b/fs/debugfs/internal.h
+@@ -17,8 +17,14 @@ extern const struct file_operations debu
+ 
+ struct debugfs_fsdata {
+ 	const struct file_operations *real_fops;
+-	refcount_t active_users;
+-	struct completion active_users_drained;
++	union {
++		/* automount_fn is used when real_fops is NULL */
++		debugfs_automount_t automount;
++		struct {
++			refcount_t active_users;
++			struct completion active_users_drained;
++		};
++	};
+ };
+ 
+ /*
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-009-debugfs-annotate-debugfs-handlers-vs.-removal-with-l.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-009-debugfs-annotate-debugfs-handlers-vs.-removal-with-l.patch
new file mode 100644
index 0000000000..64ccae8472
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-009-debugfs-annotate-debugfs-handlers-vs.-removal-with-l.patch
@@ -0,0 +1,107 @@
+From 2afe9c83b07f8d3538bdb85381cc6d07c4a80e5e Mon Sep 17 00:00:00 2001
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Fri, 24 Nov 2023 17:25:25 +0100
+Subject: [PATCH] debugfs: annotate debugfs handlers vs. removal with lockdep
+
+[ Upstream commit f4acfcd4deb158b96595250cc332901b282d15b0 ]
+
+When you take a lock in a debugfs handler but also try
+to remove the debugfs file under that lock, things can
+deadlock since the removal has to wait for all users
+to finish.
+
+Add lockdep annotations in debugfs_file_get()/_put()
+to catch such issues.
+
+Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ fs/debugfs/file.c     | 10 ++++++++++
+ fs/debugfs/inode.c    | 12 ++++++++++++
+ fs/debugfs/internal.h |  6 ++++++
+ 3 files changed, 28 insertions(+)
+
+--- a/fs/debugfs/file.c
++++ b/fs/debugfs/file.c
+@@ -108,6 +108,12 @@ int debugfs_file_get(struct dentry *dent
+ 			kfree(fsd);
+ 			fsd = READ_ONCE(dentry->d_fsdata);
+ 		}
++#ifdef CONFIG_LOCKDEP
++		fsd->lock_name = kasprintf(GFP_KERNEL, "debugfs:%pd", dentry);
++		lockdep_register_key(&fsd->key);
++		lockdep_init_map(&fsd->lockdep_map, fsd->lock_name ?: "debugfs",
++				 &fsd->key, 0);
++#endif
+ 	}
+ 
+ 	/*
+@@ -124,6 +130,8 @@ int debugfs_file_get(struct dentry *dent
+ 	if (!refcount_inc_not_zero(&fsd->active_users))
+ 		return -EIO;
+ 
++	lock_map_acquire_read(&fsd->lockdep_map);
++
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(debugfs_file_get);
+@@ -141,6 +149,8 @@ void debugfs_file_put(struct dentry *den
+ {
+ 	struct debugfs_fsdata *fsd = READ_ONCE(dentry->d_fsdata);
+ 
++	lock_map_release(&fsd->lockdep_map);
++
+ 	if (refcount_dec_and_test(&fsd->active_users))
+ 		complete(&fsd->active_users_drained);
+ }
+--- a/fs/debugfs/inode.c
++++ b/fs/debugfs/inode.c
+@@ -242,6 +242,14 @@ static void debugfs_release_dentry(struc
+ 	if ((unsigned long)fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT)
+ 		return;
+ 
++	/* check it wasn't a dir (no fsdata) or automount (no real_fops) */
++	if (fsd && fsd->real_fops) {
++#ifdef CONFIG_LOCKDEP
++		lockdep_unregister_key(&fsd->key);
++		kfree(fsd->lock_name);
++#endif
++	}
++
+ 	kfree(fsd);
+ }
+ 
+@@ -745,6 +753,10 @@ static void __debugfs_file_removed(struc
+ 	fsd = READ_ONCE(dentry->d_fsdata);
+ 	if ((unsigned long)fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT)
+ 		return;
++
++	lock_map_acquire(&fsd->lockdep_map);
++	lock_map_release(&fsd->lockdep_map);
++
+ 	if (!refcount_dec_and_test(&fsd->active_users))
+ 		wait_for_completion(&fsd->active_users_drained);
+ }
+--- a/fs/debugfs/internal.h
++++ b/fs/debugfs/internal.h
+@@ -7,6 +7,7 @@
+ 
+ #ifndef _DEBUGFS_INTERNAL_H_
+ #define _DEBUGFS_INTERNAL_H_
++#include <linux/lockdep.h>
+ 
+ struct file_operations;
+ 
+@@ -23,6 +24,11 @@ struct debugfs_fsdata {
+ 		struct {
+ 			refcount_t active_users;
+ 			struct completion active_users_drained;
++#ifdef CONFIG_LOCKDEP
++			struct lockdep_map lockdep_map;
++			struct lock_class_key key;
++			char *lock_name;
++#endif
+ 		};
+ 	};
+ };
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-010-ALSA-hda-intel-nhlt-Ignore-vbps-when-looking-for-DMI.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-010-ALSA-hda-intel-nhlt-Ignore-vbps-when-looking-for-DMI.patch
new file mode 100644
index 0000000000..1f58fb21e3
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-010-ALSA-hda-intel-nhlt-Ignore-vbps-when-looking-for-DMI.patch
@@ -0,0 +1,97 @@
+From b168c2fecd03fe7bcfcc02df4ed296a53d55808f Mon Sep 17 00:00:00 2001
+From: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
+Date: Mon, 27 Nov 2023 13:16:58 +0200
+Subject: [PATCH] ALSA: hda: intel-nhlt: Ignore vbps when looking for DMIC 32
+ bps format
+
+[ Upstream commit 7b4c93a50a2ebbbaf656cc4fa6aca74a6166d85b ]
+
+When looking up DMIC blob from the NHLT table and the format is 32 bits,
+ignore the vbps matching for 32 bps for DMIC since some NHLT table have
+the vbps as 24, some have it as 32.
+The DMIC hardware supports only one type of 32 bit sample size, which is
+24 bit sampling on the MSB side and bits[1:0] is used for indicating the
+channel number.
+
+Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
+Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
+Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
+Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
+Link: https://lore.kernel.org/r/20231127111658.17275-1-peter.ujfalusi@linux.intel.com
+Signed-off-by: Takashi Iwai <tiwai@suse.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/hda/intel-nhlt.c | 33 +++++++++++++++++++++++++++++----
+ 1 file changed, 29 insertions(+), 4 deletions(-)
+
+--- a/sound/hda/intel-nhlt.c
++++ b/sound/hda/intel-nhlt.c
+@@ -238,7 +238,7 @@ EXPORT_SYMBOL(intel_nhlt_ssp_mclk_mask);
+ 
+ static struct nhlt_specific_cfg *
+ nhlt_get_specific_cfg(struct device *dev, struct nhlt_fmt *fmt, u8 num_ch,
+-		      u32 rate, u8 vbps, u8 bps)
++		      u32 rate, u8 vbps, u8 bps, bool ignore_vbps)
+ {
+ 	struct nhlt_fmt_cfg *cfg = fmt->fmt_config;
+ 	struct wav_fmt *wfmt;
+@@ -255,8 +255,12 @@ nhlt_get_specific_cfg(struct device *dev
+ 		dev_dbg(dev, "Endpoint format: ch=%d fmt=%d/%d rate=%d\n",
+ 			wfmt->channels, _vbps, _bps, wfmt->samples_per_sec);
+ 
++		/*
++		 * When looking for exact match of configuration ignore the vbps
++		 * from NHLT table when ignore_vbps is true
++		 */
+ 		if (wfmt->channels == num_ch && wfmt->samples_per_sec == rate &&
+-		    vbps == _vbps && bps == _bps)
++		    (ignore_vbps || vbps == _vbps) && bps == _bps)
+ 			return &cfg->config;
+ 
+ 		cfg = (struct nhlt_fmt_cfg *)(cfg->config.caps + cfg->config.size);
+@@ -289,6 +293,7 @@ intel_nhlt_get_endpoint_blob(struct devi
+ {
+ 	struct nhlt_specific_cfg *cfg;
+ 	struct nhlt_endpoint *epnt;
++	bool ignore_vbps = false;
+ 	struct nhlt_fmt *fmt;
+ 	int i;
+ 
+@@ -298,7 +303,26 @@ intel_nhlt_get_endpoint_blob(struct devi
+ 	dev_dbg(dev, "Looking for configuration:\n");
+ 	dev_dbg(dev, "  vbus_id=%d link_type=%d dir=%d, dev_type=%d\n",
+ 		bus_id, link_type, dir, dev_type);
+-	dev_dbg(dev, "  ch=%d fmt=%d/%d rate=%d\n", num_ch, vbps, bps, rate);
++	if (link_type == NHLT_LINK_DMIC && bps == 32 && (vbps == 24 || vbps == 32)) {
++		/*
++		 * The DMIC hardware supports only one type of 32 bits sample
++		 * size, which is 24 bit sampling on the MSB side and bits[1:0]
++		 * are used for indicating the channel number.
++		 * It has been observed that some NHLT tables have the vbps
++		 * specified as 32 while some uses 24.
++		 * The format these variations describe are identical, the
++		 * hardware is configured and behaves the same way.
++		 * Note: when the samples assumed to be vbps=32 then the 'noise'
++		 * introduced by the lower two bits (channel number) have no
++		 * real life implication on audio quality.
++		 */
++		dev_dbg(dev,
++			"  ch=%d fmt=%d rate=%d (vbps is ignored for DMIC 32bit format)\n",
++			num_ch, bps, rate);
++		ignore_vbps = true;
++	} else {
++		dev_dbg(dev, "  ch=%d fmt=%d/%d rate=%d\n", num_ch, vbps, bps, rate);
++	}
+ 	dev_dbg(dev, "Endpoint count=%d\n", nhlt->endpoint_count);
+ 
+ 	epnt = (struct nhlt_endpoint *)nhlt->desc;
+@@ -307,7 +331,8 @@ intel_nhlt_get_endpoint_blob(struct devi
+ 		if (nhlt_check_ep_match(dev, epnt, bus_id, link_type, dir, dev_type)) {
+ 			fmt = (struct nhlt_fmt *)(epnt->config.caps + epnt->config.size);
+ 
+-			cfg = nhlt_get_specific_cfg(dev, fmt, num_ch, rate, vbps, bps);
++			cfg = nhlt_get_specific_cfg(dev, fmt, num_ch, rate,
++						    vbps, bps, ignore_vbps);
+ 			if (cfg)
+ 				return cfg;
+ 		}
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-011-nvme-core-fix-a-memory-leak-in-nvme_ns_info_from_ide.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-011-nvme-core-fix-a-memory-leak-in-nvme_ns_info_from_ide.patch
new file mode 100644
index 0000000000..82551f5ac3
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-011-nvme-core-fix-a-memory-leak-in-nvme_ns_info_from_ide.patch
@@ -0,0 +1,43 @@
+From a328340d7c59fc536b13a4078dc3905499927f0a Mon Sep 17 00:00:00 2001
+From: Maurizio Lombardi <mlombard@redhat.com>
+Date: Thu, 23 Nov 2023 15:07:41 +0100
+Subject: [PATCH] nvme-core: fix a memory leak in nvme_ns_info_from_identify()
+
+[ Upstream commit e3139cef8257fcab1725441e2fd5fd0ccb5481b1 ]
+
+In case of error, free the nvme_id_ns structure that was allocated
+by nvme_identify_ns().
+
+Signed-off-by: Maurizio Lombardi <mlombard@redhat.com>
+Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
+Reviewed-by: Kanchan Joshi <joshi.k@samsung.com>
+Signed-off-by: Keith Busch <kbusch@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/nvme/host/core.c | 7 +++++--
+ 1 file changed, 5 insertions(+), 2 deletions(-)
+
+--- a/drivers/nvme/host/core.c
++++ b/drivers/nvme/host/core.c
+@@ -1511,7 +1511,8 @@ static int nvme_ns_info_from_identify(st
+ 	if (id->ncap == 0) {
+ 		/* namespace not allocated or attached */
+ 		info->is_removed = true;
+-		return -ENODEV;
++		ret = -ENODEV;
++		goto error;
+ 	}
+ 
+ 	info->anagrpid = id->anagrpid;
+@@ -1529,8 +1530,10 @@ static int nvme_ns_info_from_identify(st
+ 		    !memchr_inv(ids->nguid, 0, sizeof(ids->nguid)))
+ 			memcpy(ids->nguid, id->nguid, sizeof(ids->nguid));
+ 	}
++
++error:
+ 	kfree(id);
+-	return 0;
++	return ret;
+ }
+ 
+ static int nvme_ns_info_from_id_cs_indep(struct nvme_ctrl *ctrl,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-012-drm-amd-display-update-dcn315-lpddr-pstate-latency.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-012-drm-amd-display-update-dcn315-lpddr-pstate-latency.patch
new file mode 100644
index 0000000000..a646df6d09
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-012-drm-amd-display-update-dcn315-lpddr-pstate-latency.patch
@@ -0,0 +1,58 @@
+From c0e5c6fcfd38f4b7b9f7834f9723286dabb15536 Mon Sep 17 00:00:00 2001
+From: Dmytro Laktyushkin <dmytro.laktyushkin@amd.com>
+Date: Fri, 3 Nov 2023 14:55:37 -0400
+Subject: [PATCH] drm/amd/display: update dcn315 lpddr pstate latency
+
+[ Upstream commit c92da0403d373c03ea5c65c0260c7db6762013b0 ]
+
+[WHY/HOW]
+Increase the pstate latency to improve ac/dc transition
+
+Reviewed-by: Charlene Liu <charlene.liu@amd.com>
+Acked-by: Tom Chung <chiahsuan.chung@amd.com>
+Signed-off-by: Dmytro Laktyushkin <dmytro.laktyushkin@amd.com>
+Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
+Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ .../drm/amd/display/dc/clk_mgr/dcn315/dcn315_clk_mgr.c    | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn315/dcn315_clk_mgr.c
++++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn315/dcn315_clk_mgr.c
+@@ -324,7 +324,7 @@ static struct wm_table lpddr5_wm_table =
+ 		{
+ 			.wm_inst = WM_A,
+ 			.wm_type = WM_TYPE_PSTATE_CHG,
+-			.pstate_latency_us = 11.65333,
++			.pstate_latency_us = 129.0,
+ 			.sr_exit_time_us = 11.5,
+ 			.sr_enter_plus_exit_time_us = 14.5,
+ 			.valid = true,
+@@ -332,7 +332,7 @@ static struct wm_table lpddr5_wm_table =
+ 		{
+ 			.wm_inst = WM_B,
+ 			.wm_type = WM_TYPE_PSTATE_CHG,
+-			.pstate_latency_us = 11.65333,
++			.pstate_latency_us = 129.0,
+ 			.sr_exit_time_us = 11.5,
+ 			.sr_enter_plus_exit_time_us = 14.5,
+ 			.valid = true,
+@@ -340,7 +340,7 @@ static struct wm_table lpddr5_wm_table =
+ 		{
+ 			.wm_inst = WM_C,
+ 			.wm_type = WM_TYPE_PSTATE_CHG,
+-			.pstate_latency_us = 11.65333,
++			.pstate_latency_us = 129.0,
+ 			.sr_exit_time_us = 11.5,
+ 			.sr_enter_plus_exit_time_us = 14.5,
+ 			.valid = true,
+@@ -348,7 +348,7 @@ static struct wm_table lpddr5_wm_table =
+ 		{
+ 			.wm_inst = WM_D,
+ 			.wm_type = WM_TYPE_PSTATE_CHG,
+-			.pstate_latency_us = 11.65333,
++			.pstate_latency_us = 129.0,
+ 			.sr_exit_time_us = 11.5,
+ 			.sr_enter_plus_exit_time_us = 14.5,
+ 			.valid = true,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-013-drm-amdgpu-Fix-cat-debugfs-amdgpu_regs_didt-causes-k.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-013-drm-amdgpu-Fix-cat-debugfs-amdgpu_regs_didt-causes-k.patch
new file mode 100644
index 0000000000..bf1b44bd79
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-013-drm-amdgpu-Fix-cat-debugfs-amdgpu_regs_didt-causes-k.patch
@@ -0,0 +1,49 @@
+From 05eb635667b12fed9ec3490a10b6240188954e60 Mon Sep 17 00:00:00 2001
+From: Lu Yao <yaolu@kylinos.cn>
+Date: Thu, 23 Nov 2023 09:22:34 +0800
+Subject: [PATCH] drm/amdgpu: Fix cat debugfs amdgpu_regs_didt causes kernel
+ null pointer
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+[ Upstream commit 2161e09cd05a50d80736fe397145340d2e8f6c05 ]
+
+For 'AMDGPU_FAMILY_SI' family cards, in 'si_common_early_init' func, init
+'didt_rreg' and 'didt_wreg' to 'NULL'. But in func
+'amdgpu_debugfs_regs_didt_read/write', using 'RREG32_DIDT' 'WREG32_DIDT'
+lacks of relevant judgment. And other 'amdgpu_ip_block_version' that use
+these two definitions won't be added for 'AMDGPU_FAMILY_SI'.
+
+So, add null pointer judgment before calling.
+
+Reviewed-by: Christian Knig <christian.koenig@amd.com>
+Signed-off-by: Lu Yao <yaolu@kylinos.cn>
+Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c
++++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c
+@@ -479,6 +479,9 @@ static ssize_t amdgpu_debugfs_regs_didt_
+ 	if (size & 0x3 || *pos & 0x3)
+ 		return -EINVAL;
+ 
++	if (!adev->didt_rreg)
++		return -EOPNOTSUPP;
++
+ 	r = pm_runtime_get_sync(adev_to_drm(adev)->dev);
+ 	if (r < 0) {
+ 		pm_runtime_put_autosuspend(adev_to_drm(adev)->dev);
+@@ -535,6 +538,9 @@ static ssize_t amdgpu_debugfs_regs_didt_
+ 	if (size & 0x3 || *pos & 0x3)
+ 		return -EINVAL;
+ 
++	if (!adev->didt_wreg)
++		return -EOPNOTSUPP;
++
+ 	r = pm_runtime_get_sync(adev_to_drm(adev)->dev);
+ 	if (r < 0) {
+ 		pm_runtime_put_autosuspend(adev_to_drm(adev)->dev);
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-014-smb-client-common-fix-fortify-warnings.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-014-smb-client-common-fix-fortify-warnings.patch
new file mode 100644
index 0000000000..256f603d42
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-014-smb-client-common-fix-fortify-warnings.patch
@@ -0,0 +1,202 @@
+From 307babce56e8eb29a919df41f6bcfcbd43bd2250 Mon Sep 17 00:00:00 2001
+From: Dmitry Antipov <dmantipov@yandex.ru>
+Date: Tue, 28 Nov 2023 13:53:47 +0300
+Subject: [PATCH] smb: client, common: fix fortify warnings
+
+[ Upstream commit 0015eb6e12384ff1c589928e84deac2ad1ceb236 ]
+
+When compiling with gcc version 14.0.0 20231126 (experimental)
+and CONFIG_FORTIFY_SOURCE=y, I've noticed the following:
+
+In file included from ./include/linux/string.h:295,
+                 from ./include/linux/bitmap.h:12,
+                 from ./include/linux/cpumask.h:12,
+                 from ./arch/x86/include/asm/paravirt.h:17,
+                 from ./arch/x86/include/asm/cpuid.h:62,
+                 from ./arch/x86/include/asm/processor.h:19,
+                 from ./arch/x86/include/asm/cpufeature.h:5,
+                 from ./arch/x86/include/asm/thread_info.h:53,
+                 from ./include/linux/thread_info.h:60,
+                 from ./arch/x86/include/asm/preempt.h:9,
+                 from ./include/linux/preempt.h:79,
+                 from ./include/linux/spinlock.h:56,
+                 from ./include/linux/wait.h:9,
+                 from ./include/linux/wait_bit.h:8,
+                 from ./include/linux/fs.h:6,
+                 from fs/smb/client/smb2pdu.c:18:
+In function 'fortify_memcpy_chk',
+    inlined from '__SMB2_close' at fs/smb/client/smb2pdu.c:3480:4:
+./include/linux/fortify-string.h:588:25: warning: call to '__read_overflow2_field'
+declared with attribute warning: detected read beyond size of field (2nd parameter);
+maybe use struct_group()? [-Wattribute-warning]
+  588 |                         __read_overflow2_field(q_size_field, size);
+      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+and:
+
+In file included from ./include/linux/string.h:295,
+                 from ./include/linux/bitmap.h:12,
+                 from ./include/linux/cpumask.h:12,
+                 from ./arch/x86/include/asm/paravirt.h:17,
+                 from ./arch/x86/include/asm/cpuid.h:62,
+                 from ./arch/x86/include/asm/processor.h:19,
+                 from ./arch/x86/include/asm/cpufeature.h:5,
+                 from ./arch/x86/include/asm/thread_info.h:53,
+                 from ./include/linux/thread_info.h:60,
+                 from ./arch/x86/include/asm/preempt.h:9,
+                 from ./include/linux/preempt.h:79,
+                 from ./include/linux/spinlock.h:56,
+                 from ./include/linux/wait.h:9,
+                 from ./include/linux/wait_bit.h:8,
+                 from ./include/linux/fs.h:6,
+                 from fs/smb/client/cifssmb.c:17:
+In function 'fortify_memcpy_chk',
+    inlined from 'CIFS_open' at fs/smb/client/cifssmb.c:1248:3:
+./include/linux/fortify-string.h:588:25: warning: call to '__read_overflow2_field'
+declared with attribute warning: detected read beyond size of field (2nd parameter);
+maybe use struct_group()? [-Wattribute-warning]
+  588 |                         __read_overflow2_field(q_size_field, size);
+      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+In both cases, the fortification logic inteprets calls to 'memcpy()' as an
+attempts to copy an amount of data which exceeds the size of the specified
+field (i.e. more than 8 bytes from __le64 value) and thus issues an overread
+warning. Both of these warnings may be silenced by using the convenient
+'struct_group()' quirk.
+
+Signed-off-by: Dmitry Antipov <dmantipov@yandex.ru>
+Acked-by: Namjae Jeon <linkinjeon@kernel.org>
+Signed-off-by: Steve French <stfrench@microsoft.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ fs/smb/client/cifspdu.h | 24 ++++++++++++++----------
+ fs/smb/client/cifssmb.c |  6 ++++--
+ fs/smb/client/smb2pdu.c |  8 +++-----
+ fs/smb/client/smb2pdu.h | 16 +++++++++-------
+ fs/smb/common/smb2pdu.h | 17 ++++++++++-------
+ 5 files changed, 40 insertions(+), 31 deletions(-)
+
+--- a/fs/smb/client/cifspdu.h
++++ b/fs/smb/client/cifspdu.h
+@@ -882,11 +882,13 @@ typedef struct smb_com_open_rsp {
+ 	__u8 OplockLevel;
+ 	__u16 Fid;
+ 	__le32 CreateAction;
+-	__le64 CreationTime;
+-	__le64 LastAccessTime;
+-	__le64 LastWriteTime;
+-	__le64 ChangeTime;
+-	__le32 FileAttributes;
++	struct_group(common_attributes,
++		__le64 CreationTime;
++		__le64 LastAccessTime;
++		__le64 LastWriteTime;
++		__le64 ChangeTime;
++		__le32 FileAttributes;
++	);
+ 	__le64 AllocationSize;
+ 	__le64 EndOfFile;
+ 	__le16 FileType;
+@@ -2268,11 +2270,13 @@ typedef struct {
+ /* QueryFileInfo/QueryPathinfo (also for SetPath/SetFile) data buffer formats */
+ /******************************************************************************/
+ typedef struct { /* data block encoding of response to level 263 QPathInfo */
+-	__le64 CreationTime;
+-	__le64 LastAccessTime;
+-	__le64 LastWriteTime;
+-	__le64 ChangeTime;
+-	__le32 Attributes;
++	struct_group(common_attributes,
++		__le64 CreationTime;
++		__le64 LastAccessTime;
++		__le64 LastWriteTime;
++		__le64 ChangeTime;
++		__le32 Attributes;
++	);
+ 	__u32 Pad1;
+ 	__le64 AllocationSize;
+ 	__le64 EndOfFile;	/* size ie offset to first free byte in file */
+--- a/fs/smb/client/cifssmb.c
++++ b/fs/smb/client/cifssmb.c
+@@ -1234,8 +1234,10 @@ openRetry:
+ 		*oplock |= CIFS_CREATE_ACTION;
+ 
+ 	if (buf) {
+-		/* copy from CreationTime to Attributes */
+-		memcpy((char *)buf, (char *)&rsp->CreationTime, 36);
++		/* copy commonly used attributes */
++		memcpy(&buf->common_attributes,
++		       &rsp->common_attributes,
++		       sizeof(buf->common_attributes));
+ 		/* the file_info buf is endian converted by caller */
+ 		buf->AllocationSize = rsp->AllocationSize;
+ 		buf->EndOfFile = rsp->EndOfFile;
+--- a/fs/smb/client/smb2pdu.c
++++ b/fs/smb/client/smb2pdu.c
+@@ -3429,12 +3429,10 @@ __SMB2_close(const unsigned int xid, str
+ 	} else {
+ 		trace_smb3_close_done(xid, persistent_fid, tcon->tid,
+ 				      ses->Suid);
+-		/*
+-		 * Note that have to subtract 4 since struct network_open_info
+-		 * has a final 4 byte pad that close response does not have
+-		 */
+ 		if (pbuf)
+-			memcpy(pbuf, (char *)&rsp->CreationTime, sizeof(*pbuf) - 4);
++			memcpy(&pbuf->network_open_info,
++			       &rsp->network_open_info,
++			       sizeof(pbuf->network_open_info));
+ 	}
+ 
+ 	atomic_dec(&tcon->num_remote_opens);
+--- a/fs/smb/client/smb2pdu.h
++++ b/fs/smb/client/smb2pdu.h
+@@ -339,13 +339,15 @@ struct smb2_file_reparse_point_info {
+ } __packed;
+ 
+ struct smb2_file_network_open_info {
+-	__le64 CreationTime;
+-	__le64 LastAccessTime;
+-	__le64 LastWriteTime;
+-	__le64 ChangeTime;
+-	__le64 AllocationSize;
+-	__le64 EndOfFile;
+-	__le32 Attributes;
++	struct_group(network_open_info,
++		__le64 CreationTime;
++		__le64 LastAccessTime;
++		__le64 LastWriteTime;
++		__le64 ChangeTime;
++		__le64 AllocationSize;
++		__le64 EndOfFile;
++		__le32 Attributes;
++	);
+ 	__le32 Reserved;
+ } __packed; /* level 34 Query also similar returned in close rsp and open rsp */
+ 
+--- a/fs/smb/common/smb2pdu.h
++++ b/fs/smb/common/smb2pdu.h
+@@ -699,13 +699,16 @@ struct smb2_close_rsp {
+ 	__le16 StructureSize; /* 60 */
+ 	__le16 Flags;
+ 	__le32 Reserved;
+-	__le64 CreationTime;
+-	__le64 LastAccessTime;
+-	__le64 LastWriteTime;
+-	__le64 ChangeTime;
+-	__le64 AllocationSize;	/* Beginning of FILE_STANDARD_INFO equivalent */
+-	__le64 EndOfFile;
+-	__le32 Attributes;
++	struct_group(network_open_info,
++		__le64 CreationTime;
++		__le64 LastAccessTime;
++		__le64 LastWriteTime;
++		__le64 ChangeTime;
++		/* Beginning of FILE_STANDARD_INFO equivalent */
++		__le64 AllocationSize;
++		__le64 EndOfFile;
++		__le32 Attributes;
++	);
+ } __packed;
+ 
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-015-blk-mq-don-t-count-completed-flush-data-request-as-i.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-015-blk-mq-don-t-count-completed-flush-data-request-as-i.patch
new file mode 100644
index 0000000000..dc76058ac5
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-015-blk-mq-don-t-count-completed-flush-data-request-as-i.patch
@@ -0,0 +1,63 @@
+From ad41b305a52c7824d5d0d19fd9c487f043ac3fd9 Mon Sep 17 00:00:00 2001
+From: Ming Lei <ming.lei@redhat.com>
+Date: Fri, 1 Dec 2023 16:56:05 +0800
+Subject: [PATCH] blk-mq: don't count completed flush data request as inflight
+ in case of quiesce
+
+[ Upstream commit 0e4237ae8d159e3d28f3cd83146a46f576ffb586 ]
+
+Request queue quiesce may interrupt flush sequence, and the original request
+may have been marked as COMPLETE, but can't get finished because of
+queue quiesce.
+
+This way is fine from driver viewpoint, because flush sequence is block
+layer concept, and it isn't related with driver.
+
+However, driver(such as dm-rq) can call blk_mq_queue_inflight() to count &
+drain inflight requests, then the wait & drain never gets done because
+the completed & not-finished flush request is counted as inflight.
+
+Fix this issue by not counting completed flush data request as inflight in
+case of quiesce.
+
+Cc: Mike Snitzer <snitzer@kernel.org>
+Cc: David Jeffery <djeffery@redhat.com>
+Cc: John Pittman <jpittman@redhat.com>
+Signed-off-by: Ming Lei <ming.lei@redhat.com>
+Link: https://lore.kernel.org/r/20231201085605.577730-1-ming.lei@redhat.com
+Signed-off-by: Jens Axboe <axboe@kernel.dk>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ block/blk-mq.c | 14 +++++++++++++-
+ 1 file changed, 13 insertions(+), 1 deletion(-)
+
+--- a/block/blk-mq.c
++++ b/block/blk-mq.c
+@@ -1500,14 +1500,26 @@ void blk_mq_delay_kick_requeue_list(stru
+ }
+ EXPORT_SYMBOL(blk_mq_delay_kick_requeue_list);
+ 
++static bool blk_is_flush_data_rq(struct request *rq)
++{
++	return (rq->rq_flags & RQF_FLUSH_SEQ) && !is_flush_rq(rq);
++}
++
+ static bool blk_mq_rq_inflight(struct request *rq, void *priv)
+ {
+ 	/*
+ 	 * If we find a request that isn't idle we know the queue is busy
+ 	 * as it's checked in the iter.
+ 	 * Return false to stop the iteration.
++	 *
++	 * In case of queue quiesce, if one flush data request is completed,
++	 * don't count it as inflight given the flush sequence is suspended,
++	 * and the original flush data request is invisible to driver, just
++	 * like other pending requests because of quiesce
+ 	 */
+-	if (blk_mq_request_started(rq)) {
++	if (blk_mq_request_started(rq) && !(blk_queue_quiesced(rq->q) &&
++				blk_is_flush_data_rq(rq) &&
++				blk_mq_request_completed(rq))) {
+ 		bool *busy = priv;
+ 
+ 		*busy = true;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-016-nvme-core-check-for-too-small-lba-shift.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-016-nvme-core-check-for-too-small-lba-shift.patch
new file mode 100644
index 0000000000..cfad6f2b8e
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-016-nvme-core-check-for-too-small-lba-shift.patch
@@ -0,0 +1,35 @@
+From a1ae33cced9f311d912803b56d7ca32e21c011b3 Mon Sep 17 00:00:00 2001
+From: Keith Busch <kbusch@kernel.org>
+Date: Tue, 28 Nov 2023 09:36:04 -0800
+Subject: [PATCH] nvme-core: check for too small lba shift
+
+[ Upstream commit 74fbc88e161424b3b96a22b23a8e3e1edab9d05c ]
+
+The block layer doesn't support logical block sizes smaller than 512
+bytes. The nvme spec doesn't support that small either, but the driver
+isn't checking to make sure the device responded with usable data.
+Failing to catch this will result in a kernel bug, either from a
+division by zero when stacking, or a zero length bio.
+
+Reviewed-by: Jens Axboe <axboe@kernel.dk>
+Signed-off-by: Keith Busch <kbusch@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/nvme/host/core.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+--- a/drivers/nvme/host/core.c
++++ b/drivers/nvme/host/core.c
+@@ -1925,9 +1925,10 @@ static void nvme_update_disk_info(struct
+ 
+ 	/*
+ 	 * The block layer can't support LBA sizes larger than the page size
+-	 * yet, so catch this early and don't allow block I/O.
++	 * or smaller than a sector size yet, so catch this early and don't
++	 * allow block I/O.
+ 	 */
+-	if (ns->lba_shift > PAGE_SHIFT) {
++	if (ns->lba_shift > PAGE_SHIFT || ns->lba_shift < SECTOR_SHIFT) {
+ 		capacity = 0;
+ 		bs = (1 << 9);
+ 	}
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-017-hwtracing-hisi_ptt-Handle-the-interrupt-in-hardirq-c.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-017-hwtracing-hisi_ptt-Handle-the-interrupt-in-hardirq-c.patch
new file mode 100644
index 0000000000..cc9cf9dd08
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-017-hwtracing-hisi_ptt-Handle-the-interrupt-in-hardirq-c.patch
@@ -0,0 +1,43 @@
+From efbc2b9f438015f025078f5e38959c562e59583c Mon Sep 17 00:00:00 2001
+From: Yicong Yang <yangyicong@hisilicon.com>
+Date: Tue, 10 Oct 2023 16:47:28 +0800
+Subject: [PATCH] hwtracing: hisi_ptt: Handle the interrupt in hardirq context
+
+[ Upstream commit e0dd27ad8af00f147ac3c9de88e0687986afc3ea ]
+
+Handle the trace interrupt in the hardirq context, make sure the irq
+core won't threaded it by declaring IRQF_NO_THREAD and userspace won't
+balance it by declaring IRQF_NOBALANCING. Otherwise we may violate the
+synchronization requirements of the perf core, referenced to the
+change of arm-ccn PMU
+  commit 0811ef7e2f54 ("bus: arm-ccn: fix PMU interrupt flags").
+
+In the interrupt handler we mainly doing 2 things:
+- Copy the data from the local DMA buffer to the AUX buffer
+- Commit the data in the AUX buffer
+
+Signed-off-by: Yicong Yang <yangyicong@hisilicon.com>
+Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
+[ Fixed commit description to suppress checkpatch warning ]
+Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
+Link: https://lore.kernel.org/r/20231010084731.30450-3-yangyicong@huawei.com
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/hwtracing/ptt/hisi_ptt.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/hwtracing/ptt/hisi_ptt.c
++++ b/drivers/hwtracing/ptt/hisi_ptt.c
+@@ -342,9 +342,9 @@ static int hisi_ptt_register_irq(struct
+ 		return ret;
+ 
+ 	hisi_ptt->trace_irq = pci_irq_vector(pdev, HISI_PTT_TRACE_DMA_IRQ);
+-	ret = devm_request_threaded_irq(&pdev->dev, hisi_ptt->trace_irq,
+-					NULL, hisi_ptt_isr, 0,
+-					DRV_NAME, hisi_ptt);
++	ret = devm_request_irq(&pdev->dev, hisi_ptt->trace_irq, hisi_ptt_isr,
++				IRQF_NOBALANCING | IRQF_NO_THREAD, DRV_NAME,
++				hisi_ptt);
+ 	if (ret) {
+ 		pci_err(pdev, "failed to request irq %d, ret = %d\n",
+ 			hisi_ptt->trace_irq, ret);
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-018-hwtracing-hisi_ptt-Don-t-try-to-attach-a-task.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-018-hwtracing-hisi_ptt-Don-t-try-to-attach-a-task.patch
new file mode 100644
index 0000000000..27bb1a6487
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-018-hwtracing-hisi_ptt-Don-t-try-to-attach-a-task.patch
@@ -0,0 +1,31 @@
+From 527285988eb0f17341000128ce9f5c5da8cb4e69 Mon Sep 17 00:00:00 2001
+From: Yicong Yang <yangyicong@hisilicon.com>
+Date: Tue, 10 Oct 2023 16:47:30 +0800
+Subject: [PATCH] hwtracing: hisi_ptt: Don't try to attach a task
+
+[ Upstream commit aff787f64ad7cbb54614b51b82c682fe06411ef3 ]
+
+PTT is an uncore PMU and shouldn't be attached to any task. Block
+the usage in pmu::event_init().
+
+Signed-off-by: Yicong Yang <yangyicong@hisilicon.com>
+Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
+Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
+Link: https://lore.kernel.org/r/20231010084731.30450-5-yangyicong@huawei.com
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/hwtracing/ptt/hisi_ptt.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/hwtracing/ptt/hisi_ptt.c
++++ b/drivers/hwtracing/ptt/hisi_ptt.c
+@@ -659,6 +659,9 @@ static int hisi_ptt_pmu_event_init(struc
+ 		return -EOPNOTSUPP;
+ 	}
+ 
++	if (event->attach_state & PERF_ATTACH_TASK)
++		return -EOPNOTSUPP;
++
+ 	if (event->attr.type != hisi_ptt->hisi_ptt_pmu.type)
+ 		return -ENOENT;
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-019-ASoC-wm8974-Correct-boost-mixer-inputs.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-019-ASoC-wm8974-Correct-boost-mixer-inputs.patch
new file mode 100644
index 0000000000..27f3335337
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-019-ASoC-wm8974-Correct-boost-mixer-inputs.patch
@@ -0,0 +1,42 @@
+From c5e5dc82773a118a81f1c95ed7e8d6d00f70d325 Mon Sep 17 00:00:00 2001
+From: Charles Keepax <ckeepax@opensource.cirrus.com>
+Date: Mon, 13 Nov 2023 15:59:16 +0000
+Subject: [PATCH] ASoC: wm8974: Correct boost mixer inputs
+
+[ Upstream commit 37e6fd0cebf0b9f71afb38fd95b10408799d1f0b ]
+
+Bit 6 of INPPGA (INPPGAMUTE) does not control the Aux path, it controls
+the input PGA path, as can been seen from Figure 8 Input Boost Stage in
+the datasheet. Update the naming of things in the driver to match this
+and update the routing to also reflect this.
+
+Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
+Link: https://lore.kernel.org/r/20231113155916.1741027-1-ckeepax@opensource.cirrus.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/codecs/wm8974.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/sound/soc/codecs/wm8974.c
++++ b/sound/soc/codecs/wm8974.c
+@@ -186,7 +186,7 @@ SOC_DAPM_SINGLE("PCM Playback Switch", W
+ 
+ /* Boost mixer */
+ static const struct snd_kcontrol_new wm8974_boost_mixer[] = {
+-SOC_DAPM_SINGLE("Aux Switch", WM8974_INPPGA, 6, 1, 1),
++SOC_DAPM_SINGLE("PGA Switch", WM8974_INPPGA, 6, 1, 1),
+ };
+ 
+ /* Input PGA */
+@@ -246,8 +246,8 @@ static const struct snd_soc_dapm_route w
+ 
+ 	/* Boost Mixer */
+ 	{"ADC", NULL, "Boost Mixer"},
+-	{"Boost Mixer", "Aux Switch", "Aux Input"},
+-	{"Boost Mixer", NULL, "Input PGA"},
++	{"Boost Mixer", NULL, "Aux Input"},
++	{"Boost Mixer", "PGA Switch", "Input PGA"},
+ 	{"Boost Mixer", NULL, "MICP"},
+ 
+ 	/* Input PGA */
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-020-arm64-dts-rockchip-fix-rk356x-pcie-msg-interrupt-nam.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-020-arm64-dts-rockchip-fix-rk356x-pcie-msg-interrupt-nam.patch
new file mode 100644
index 0000000000..d65b48afd2
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-020-arm64-dts-rockchip-fix-rk356x-pcie-msg-interrupt-nam.patch
@@ -0,0 +1,30 @@
+From 9b4ea4353716679f17ad9840ea19e196bfd14983 Mon Sep 17 00:00:00 2001
+From: Heiko Stuebner <heiko@sntech.de>
+Date: Tue, 14 Nov 2023 16:38:34 +0100
+Subject: [PATCH] arm64: dts: rockchip: fix rk356x pcie msg interrupt name
+
+[ Upstream commit 3cee9c635f27d1003d46f624d816f3455698b625 ]
+
+The expected name by the binding at this position is "msg" and the SoC's
+manual also calls the interrupt in question "msg", so fix the rk356x dtsi
+to use the correct name.
+
+Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
+Signed-off-by: Heiko Stuebner <heiko@sntech.de>
+Link: https://lore.kernel.org/r/20231114153834.934978-1-heiko@sntech.de
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ arch/arm64/boot/dts/rockchip/rk356x.dtsi | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/rockchip/rk356x.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk356x.dtsi
+@@ -958,7 +958,7 @@
+ 			     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+ 			     <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+ 			     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
+-		interrupt-names = "sys", "pmc", "msi", "legacy", "err";
++		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
+ 		bus-range = <0x0 0xf>;
+ 		clocks = <&cru ACLK_PCIE20_MST>, <&cru ACLK_PCIE20_SLV>,
+ 			 <&cru ACLK_PCIE20_DBI>, <&cru PCLK_PCIE20>,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-021-ASoC-Intel-Skylake-Fix-mem-leak-in-few-functions.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-021-ASoC-Intel-Skylake-Fix-mem-leak-in-few-functions.patch
new file mode 100644
index 0000000000..305436e052
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-021-ASoC-Intel-Skylake-Fix-mem-leak-in-few-functions.patch
@@ -0,0 +1,50 @@
+From aac62635899e680ef0b5e99be1b9007f3f1f24a8 Mon Sep 17 00:00:00 2001
+From: Kamil Duljas <kamil.duljas@gmail.com>
+Date: Thu, 16 Nov 2023 13:51:50 +0100
+Subject: [PATCH] ASoC: Intel: Skylake: Fix mem leak in few functions
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+[ Upstream commit d5c65be34df73fa01ed05611aafb73b440d89e29 ]
+
+The resources should be freed when function return error.
+
+Signed-off-by: Kamil Duljas <kamil.duljas@gmail.com>
+Reviewed-by: Amadeusz Sawiski <amadeuszx.slawinski@linux.intel.com>
+Link: https://lore.kernel.org/r/20231116125150.1436-1-kamil.duljas@gmail.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/intel/skylake/skl-pcm.c     | 4 +++-
+ sound/soc/intel/skylake/skl-sst-ipc.c | 4 +++-
+ 2 files changed, 6 insertions(+), 2 deletions(-)
+
+--- a/sound/soc/intel/skylake/skl-pcm.c
++++ b/sound/soc/intel/skylake/skl-pcm.c
+@@ -251,8 +251,10 @@ static int skl_pcm_open(struct snd_pcm_s
+ 	snd_pcm_set_sync(substream);
+ 
+ 	mconfig = skl_tplg_fe_get_cpr_module(dai, substream->stream);
+-	if (!mconfig)
++	if (!mconfig) {
++		kfree(dma_params);
+ 		return -EINVAL;
++	}
+ 
+ 	skl_tplg_d0i3_get(skl, mconfig->d0i3_caps);
+ 
+--- a/sound/soc/intel/skylake/skl-sst-ipc.c
++++ b/sound/soc/intel/skylake/skl-sst-ipc.c
+@@ -1003,8 +1003,10 @@ int skl_ipc_get_large_config(struct sst_
+ 
+ 	reply.size = (reply.header >> 32) & IPC_DATA_OFFSET_SZ_MASK;
+ 	buf = krealloc(reply.data, reply.size, GFP_KERNEL);
+-	if (!buf)
++	if (!buf) {
++		kfree(reply.data);
+ 		return -ENOMEM;
++	}
+ 	*payload = buf;
+ 	*bytes = reply.size;
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-022-ASoC-nau8822-Fix-incorrect-type-in-assignment-and-ca.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-022-ASoC-nau8822-Fix-incorrect-type-in-assignment-and-ca.patch
new file mode 100644
index 0000000000..3aa0ba5456
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-022-ASoC-nau8822-Fix-incorrect-type-in-assignment-and-ca.patch
@@ -0,0 +1,68 @@
+From 4a08ec55f12cbb3c5fddfa214cc1f1bbc59e92c3 Mon Sep 17 00:00:00 2001
+From: David Lin <CTLIN0@nuvoton.com>
+Date: Fri, 17 Nov 2023 12:30:12 +0800
+Subject: [PATCH] ASoC: nau8822: Fix incorrect type in assignment and cast to
+ restricted __be16
+
+[ Upstream commit c1501f2597dd08601acd42256a4b0a0fc36bf302 ]
+
+This issue is reproduced when W=1 build in compiler gcc-12.
+The following are sparse warnings:
+
+sound/soc/codecs/nau8822.c:199:25: sparse: sparse: incorrect type in assignment
+sound/soc/codecs/nau8822.c:199:25: sparse: expected unsigned short
+sound/soc/codecs/nau8822.c:199:25: sparse: got restricted __be16
+sound/soc/codecs/nau8822.c:235:25: sparse: sparse: cast to restricted __be16
+sound/soc/codecs/nau8822.c:235:25: sparse: sparse: cast to restricted __be16
+sound/soc/codecs/nau8822.c:235:25: sparse: sparse: cast to restricted __be16
+sound/soc/codecs/nau8822.c:235:25: sparse: sparse: cast to restricted __be16
+
+Reported-by: kernel test robot <lkp@intel.com>
+Closes: https://lore.kernel.org/oe-kbuild-all/202311122320.T1opZVkP-lkp@intel.com/
+Signed-off-by: David Lin <CTLIN0@nuvoton.com>
+Link: https://lore.kernel.org/r/20231117043011.1747594-1-CTLIN0@nuvoton.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/codecs/nau8822.c | 9 ++++++---
+ 1 file changed, 6 insertions(+), 3 deletions(-)
+
+--- a/sound/soc/codecs/nau8822.c
++++ b/sound/soc/codecs/nau8822.c
+@@ -184,6 +184,7 @@ static int nau8822_eq_get(struct snd_kco
+ 	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
+ 	int i, reg;
+ 	u16 reg_val, *val;
++	__be16 tmp;
+ 
+ 	val = (u16 *)ucontrol->value.bytes.data;
+ 	reg = NAU8822_REG_EQ1;
+@@ -192,8 +193,8 @@ static int nau8822_eq_get(struct snd_kco
+ 		/* conversion of 16-bit integers between native CPU format
+ 		 * and big endian format
+ 		 */
+-		reg_val = cpu_to_be16(reg_val);
+-		memcpy(val + i, &reg_val, sizeof(reg_val));
++		tmp = cpu_to_be16(reg_val);
++		memcpy(val + i, &tmp, sizeof(tmp));
+ 	}
+ 
+ 	return 0;
+@@ -216,6 +217,7 @@ static int nau8822_eq_put(struct snd_kco
+ 	void *data;
+ 	u16 *val, value;
+ 	int i, reg, ret;
++	__be16 *tmp;
+ 
+ 	data = kmemdup(ucontrol->value.bytes.data,
+ 		params->max, GFP_KERNEL | GFP_DMA);
+@@ -228,7 +230,8 @@ static int nau8822_eq_put(struct snd_kco
+ 		/* conversion of 16-bit integers between native CPU format
+ 		 * and big endian format
+ 		 */
+-		value = be16_to_cpu(*(val + i));
++		tmp = (__be16 *)(val + i);
++		value = be16_to_cpup(tmp);
+ 		ret = snd_soc_component_write(component, reg + i, value);
+ 		if (ret) {
+ 			dev_err(component->dev,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-023-ASoC-Intel-Skylake-mem-leak-in-skl-register-function.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-023-ASoC-Intel-Skylake-mem-leak-in-skl-register-function.patch
new file mode 100644
index 0000000000..c316bdc12d
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-023-ASoC-Intel-Skylake-mem-leak-in-skl-register-function.patch
@@ -0,0 +1,45 @@
+From 8960b26c39a2aad1a78db3fb9484cab7c6361931 Mon Sep 17 00:00:00 2001
+From: Kamil Duljas <kamil.duljas@gmail.com>
+Date: Thu, 16 Nov 2023 23:41:13 +0100
+Subject: [PATCH] ASoC: Intel: Skylake: mem leak in skl register function
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+[ Upstream commit f8ba14b780273fd290ddf7ee0d7d7decb44cc365 ]
+
+skl_platform_register() uses krealloc. When krealloc is fail,
+then previous memory is not freed. The leak is also when soc
+component registration failed.
+
+Signed-off-by: Kamil Duljas <kamil.duljas@gmail.com>
+Reviewed-by: Amadeusz Sawiski <amadeuszx.slawinski@linux.intel.com>
+Link: https://lore.kernel.org/r/20231116224112.2209-2-kamil.duljas@gmail.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/intel/skylake/skl-pcm.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/sound/soc/intel/skylake/skl-pcm.c
++++ b/sound/soc/intel/skylake/skl-pcm.c
+@@ -1473,6 +1473,7 @@ int skl_platform_register(struct device
+ 		dais = krealloc(skl->dais, sizeof(skl_fe_dai) +
+ 				sizeof(skl_platform_dai), GFP_KERNEL);
+ 		if (!dais) {
++			kfree(skl->dais);
+ 			ret = -ENOMEM;
+ 			goto err;
+ 		}
+@@ -1485,8 +1486,10 @@ int skl_platform_register(struct device
+ 
+ 	ret = devm_snd_soc_register_component(dev, &skl_component,
+ 					 skl->dais, num_dais);
+-	if (ret)
++	if (ret) {
++		kfree(skl->dais);
+ 		dev_err(dev, "soc component registration failed %d\n", ret);
++	}
+ err:
+ 	return ret;
+ }
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-024-ASoC-cs43130-Fix-the-position-of-const-qualifier.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-024-ASoC-cs43130-Fix-the-position-of-const-qualifier.patch
new file mode 100644
index 0000000000..34ba669183
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-024-ASoC-cs43130-Fix-the-position-of-const-qualifier.patch
@@ -0,0 +1,36 @@
+From 8a8bed719d7af58d0c812ad1897b0cb9b5f97484 Mon Sep 17 00:00:00 2001
+From: Maciej Strozek <mstrozek@opensource.cirrus.com>
+Date: Fri, 17 Nov 2023 14:13:38 +0000
+Subject: [PATCH] ASoC: cs43130: Fix the position of const qualifier
+
+[ Upstream commit e7f289a59e76a5890a57bc27b198f69f175f75d9 ]
+
+Signed-off-by: Maciej Strozek <mstrozek@opensource.cirrus.com>
+Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
+Link: https://lore.kernel.org/r/20231117141344.64320-2-mstrozek@opensource.cirrus.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/codecs/cs43130.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/sound/soc/codecs/cs43130.c
++++ b/sound/soc/codecs/cs43130.c
+@@ -1683,7 +1683,7 @@ static ssize_t hpload_dc_r_show(struct d
+ 	return cs43130_show_dc(dev, buf, HP_RIGHT);
+ }
+ 
+-static u16 const cs43130_ac_freq[CS43130_AC_FREQ] = {
++static const u16 cs43130_ac_freq[CS43130_AC_FREQ] = {
+ 	24,
+ 	43,
+ 	93,
+@@ -2363,7 +2363,7 @@ static const struct regmap_config cs4313
+ 	.use_single_write	= true,
+ };
+ 
+-static u16 const cs43130_dc_threshold[CS43130_DC_THRESHOLD] = {
++static const u16 cs43130_dc_threshold[CS43130_DC_THRESHOLD] = {
+ 	50,
+ 	120,
+ };
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-025-ASoC-cs43130-Fix-incorrect-frame-delay-configuration.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-025-ASoC-cs43130-Fix-incorrect-frame-delay-configuration.patch
new file mode 100644
index 0000000000..f2a86136b6
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-025-ASoC-cs43130-Fix-incorrect-frame-delay-configuration.patch
@@ -0,0 +1,27 @@
+From 59ebc39f03a7b6b36467dd2be642f459624bcdeb Mon Sep 17 00:00:00 2001
+From: Maciej Strozek <mstrozek@opensource.cirrus.com>
+Date: Fri, 17 Nov 2023 14:13:39 +0000
+Subject: [PATCH] ASoC: cs43130: Fix incorrect frame delay configuration
+
+[ Upstream commit aa7e8e5e4011571022dc06e4d7a2f108feb53d1a ]
+
+Signed-off-by: Maciej Strozek <mstrozek@opensource.cirrus.com>
+Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
+Link: https://lore.kernel.org/r/20231117141344.64320-3-mstrozek@opensource.cirrus.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/codecs/cs43130.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/sound/soc/codecs/cs43130.c
++++ b/sound/soc/codecs/cs43130.c
+@@ -579,7 +579,7 @@ static int cs43130_set_sp_fmt(int dai_id
+ 		break;
+ 	case SND_SOC_DAIFMT_LEFT_J:
+ 		hi_size = bitwidth_sclk;
+-		frm_delay = 2;
++		frm_delay = 0;
+ 		frm_phase = 1;
+ 		break;
+ 	case SND_SOC_DAIFMT_DSP_A:
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-026-ASoC-rt5650-add-mutex-to-avoid-the-jack-detection-fa.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-026-ASoC-rt5650-add-mutex-to-avoid-the-jack-detection-fa.patch
new file mode 100644
index 0000000000..69a84fa200
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-026-ASoC-rt5650-add-mutex-to-avoid-the-jack-detection-fa.patch
@@ -0,0 +1,72 @@
+From f5af9a4fa071cefc74c2624ca4149f4f004d85cc Mon Sep 17 00:00:00 2001
+From: Shuming Fan <shumingf@realtek.com>
+Date: Wed, 22 Nov 2023 18:01:23 +0800
+Subject: [PATCH] ASoC: rt5650: add mutex to avoid the jack detection failure
+
+[ Upstream commit cdba4301adda7c60a2064bf808e48fccd352aaa9 ]
+
+This patch adds the jd_mutex to protect the jack detection control flow.
+And only the headset type could check the button status.
+
+Signed-off-by: Shuming Fan <shumingf@realtek.com>
+Link: https://lore.kernel.org/r/20231122100123.2831753-1-shumingf@realtek.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/codecs/rt5645.c | 10 +++++++++-
+ 1 file changed, 9 insertions(+), 1 deletion(-)
+
+--- a/sound/soc/codecs/rt5645.c
++++ b/sound/soc/codecs/rt5645.c
+@@ -448,6 +448,7 @@ struct rt5645_priv {
+ 	struct regulator_bulk_data supplies[ARRAY_SIZE(rt5645_supply_names)];
+ 	struct rt5645_eq_param_s *eq_param;
+ 	struct timer_list btn_check_timer;
++	struct mutex jd_mutex;
+ 
+ 	int codec_type;
+ 	int sysclk;
+@@ -3189,6 +3190,8 @@ static int rt5645_jack_detect(struct snd
+ 				rt5645_enable_push_button_irq(component, true);
+ 			}
+ 		} else {
++			if (rt5645->en_button_func)
++				rt5645_enable_push_button_irq(component, false);
+ 			snd_soc_dapm_disable_pin(dapm, "Mic Det Power");
+ 			snd_soc_dapm_sync(dapm);
+ 			rt5645->jack_type = SND_JACK_HEADPHONE;
+@@ -3269,6 +3272,8 @@ static void rt5645_jack_detect_work(stru
+ 	if (!rt5645->component)
+ 		return;
+ 
++	mutex_lock(&rt5645->jd_mutex);
++
+ 	switch (rt5645->pdata.jd_mode) {
+ 	case 0: /* Not using rt5645 JD */
+ 		if (rt5645->gpiod_hp_det) {
+@@ -3295,7 +3300,7 @@ static void rt5645_jack_detect_work(stru
+ 
+ 	if (!val && (rt5645->jack_type == 0)) { /* jack in */
+ 		report = rt5645_jack_detect(rt5645->component, 1);
+-	} else if (!val && rt5645->jack_type != 0) {
++	} else if (!val && rt5645->jack_type == SND_JACK_HEADSET) {
+ 		/* for push button and jack out */
+ 		btn_type = 0;
+ 		if (snd_soc_component_read(rt5645->component, RT5645_INT_IRQ_ST) & 0x4) {
+@@ -3351,6 +3356,8 @@ static void rt5645_jack_detect_work(stru
+ 		rt5645_jack_detect(rt5645->component, 0);
+ 	}
+ 
++	mutex_unlock(&rt5645->jd_mutex);
++
+ 	snd_soc_jack_report(rt5645->hp_jack, report, SND_JACK_HEADPHONE);
+ 	snd_soc_jack_report(rt5645->mic_jack, report, SND_JACK_MICROPHONE);
+ 	if (rt5645->en_button_func)
+@@ -4119,6 +4126,7 @@ static int rt5645_i2c_probe(struct i2c_c
+ 	}
+ 	timer_setup(&rt5645->btn_check_timer, rt5645_btn_check_callback, 0);
+ 
++	mutex_init(&rt5645->jd_mutex);
+ 	INIT_DELAYED_WORK(&rt5645->jack_detect_work, rt5645_jack_detect_work);
+ 	INIT_DELAYED_WORK(&rt5645->rcclock_work, rt5645_rcclock_work);
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-027-ASoC-Intel-skl_hda_dsp_generic-Drop-HDMI-routes-when.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-027-ASoC-Intel-skl_hda_dsp_generic-Drop-HDMI-routes-when.patch
new file mode 100644
index 0000000000..5a60aa7f5e
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-027-ASoC-Intel-skl_hda_dsp_generic-Drop-HDMI-routes-when.patch
@@ -0,0 +1,37 @@
+From 812289cd364d77f635b6c5e5d69c4d5dcc99c092 Mon Sep 17 00:00:00 2001
+From: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
+Date: Fri, 24 Nov 2023 14:40:15 +0200
+Subject: [PATCH] ASoC: Intel: skl_hda_dsp_generic: Drop HDMI routes when HDMI
+ is not available
+
+[ Upstream commit 3d1dc8b1030df8ca0fdfd4905c88ee10db943bf8 ]
+
+When the HDMI is not present due to disabled display support
+we will use dummy codec and the HDMI routes will refer to non existent
+DAPM widgets.
+
+Trim the route list from the HDMI routes to be able to probe the card even
+if the HDMI dais are not registered.
+
+Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
+Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
+Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
+Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
+Link: https://lore.kernel.org/r/20231124124015.15878-1-peter.ujfalusi@linux.intel.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/intel/boards/skl_hda_dsp_generic.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/sound/soc/intel/boards/skl_hda_dsp_generic.c
++++ b/sound/soc/intel/boards/skl_hda_dsp_generic.c
+@@ -157,6 +157,8 @@ static int skl_hda_fill_card_info(struct
+ 		card->dapm_widgets = skl_hda_widgets;
+ 		card->num_dapm_widgets = ARRAY_SIZE(skl_hda_widgets);
+ 		if (!ctx->idisp_codec) {
++			card->dapm_routes = &skl_hda_map[IDISP_ROUTE_COUNT];
++			num_route -= IDISP_ROUTE_COUNT;
+ 			for (i = 0; i < IDISP_DAI_COUNT; i++) {
+ 				skl_hda_be_dai_links[i].codecs = dummy_codec;
+ 				skl_hda_be_dai_links[i].num_codecs =
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-028-nouveau-tu102-flush-all-pdbs-on-vmm-flush.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-028-nouveau-tu102-flush-all-pdbs-on-vmm-flush.patch
new file mode 100644
index 0000000000..b7fed00cf7
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-028-nouveau-tu102-flush-all-pdbs-on-vmm-flush.patch
@@ -0,0 +1,31 @@
+From 42946b06020c78aadf0c99e3fa1299d6809607de Mon Sep 17 00:00:00 2001
+From: Dave Airlie <airlied@redhat.com>
+Date: Thu, 30 Nov 2023 11:08:52 +1000
+Subject: [PATCH] nouveau/tu102: flush all pdbs on vmm flush
+
+[ Upstream commit cb9c919364653eeafb49e7ff5cd32f1ad64063ac ]
+
+This is a hack around a bug exposed with the GSP code, I'm not sure
+what is happening exactly, but it appears some of our flushes don't
+result in proper tlb invalidation for out BAR2 and we get a BAR2
+fault from GSP and it all dies.
+
+Signed-off-by: Dave Airlie <airlied@redhat.com>
+Signed-off-by: Danilo Krummrich <dakr@redhat.com>
+Link: https://patchwork.freedesktop.org/patch/msgid/20231130010852.4034774-1-airlied@gmail.com
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmmtu102.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmmtu102.c
++++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmmtu102.c
+@@ -31,7 +31,7 @@ tu102_vmm_flush(struct nvkm_vmm *vmm, in
+ 
+ 	type |= 0x00000001; /* PAGE_ALL */
+ 	if (atomic_read(&vmm->engref[NVKM_SUBDEV_BAR]))
+-		type |= 0x00000004; /* HUB_ONLY */
++		type |= 0x00000006; /* HUB_ONLY | ALL PDB (hack) */
+ 
+ 	mutex_lock(&vmm->mmu->mutex);
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-029-ASoC-amd-yc-Add-DMI-entry-to-support-System76-Pangol.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-029-ASoC-amd-yc-Add-DMI-entry-to-support-System76-Pangol.patch
new file mode 100644
index 0000000000..e5dfc066c0
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-029-ASoC-amd-yc-Add-DMI-entry-to-support-System76-Pangol.patch
@@ -0,0 +1,34 @@
+From c056b36f857112223b15ff505e3b2500b9aa9644 Mon Sep 17 00:00:00 2001
+From: Jeremy Soller <jeremy@system76.com>
+Date: Mon, 27 Nov 2023 11:42:38 -0700
+Subject: [PATCH] ASoC: amd: yc: Add DMI entry to support System76 Pangolin 13
+
+[ Upstream commit 19650c0f402f53abe48a55a1c49c8ed9576a088c ]
+
+Add pang13 quirk to enable the internal microphone.
+
+Signed-off-by: Jeremy Soller <jeremy@system76.com>
+Signed-off-by: Tim Crawford <tcrawford@system76.com>
+Link: https://lore.kernel.org/r/20231127184237.32077-2-tcrawford@system76.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/amd/yc/acp6x-mach.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+--- a/sound/soc/amd/yc/acp6x-mach.c
++++ b/sound/soc/amd/yc/acp6x-mach.c
+@@ -353,6 +353,13 @@ static const struct dmi_system_id yc_acp
+ 			DMI_MATCH(DMI_PRODUCT_VERSION, "pang12"),
+ 		}
+ 	},
++	{
++		.driver_data = &acp6x_card,
++		.matches = {
++			DMI_MATCH(DMI_BOARD_VENDOR, "System76"),
++			DMI_MATCH(DMI_PRODUCT_VERSION, "pang13"),
++		}
++	},
+ 	{}
+ };
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-030-ASoC-hdac_hda-Conditionally-register-dais-for-HDMI-a.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-030-ASoC-hdac_hda-Conditionally-register-dais-for-HDMI-a.patch
new file mode 100644
index 0000000000..b30c3dacab
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-030-ASoC-hdac_hda-Conditionally-register-dais-for-HDMI-a.patch
@@ -0,0 +1,89 @@
+From 3a8e118db6bb95b5fe9844efd14d826a7fda4cd4 Mon Sep 17 00:00:00 2001
+From: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
+Date: Tue, 28 Nov 2023 14:39:14 +0200
+Subject: [PATCH] ASoC: hdac_hda: Conditionally register dais for HDMI and
+ Analog
+
+[ Upstream commit a0575b4add21a243cc3257e75ad913cd5377d5f2 ]
+
+The current driver is registering the same dais for each hdev found in the
+system which results duplicated widgets to be registered and the kernel
+log contains similar prints:
+snd_hda_codec_realtek ehdaudio0D0: ASoC: sink widget AIF1TX overwritten
+snd_hda_codec_realtek ehdaudio0D0: ASoC: source widget AIF1RX overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: sink widget hifi3 overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: sink widget hifi2 overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: sink widget hifi1 overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: source widget Codec Output Pin1 overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: sink widget Codec Input Pin1 overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: sink widget Analog Codec Playback overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: sink widget Digital Codec Playback overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: sink widget Alt Analog Codec Playback overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: source widget Analog Codec Capture overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: source widget Digital Codec Capture overwritten
+skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: source widget Alt Analog Codec Capture overwritten
+
+To avoid such issue, split the dai array into HDMI and non HDMI array and
+register them conditionally:
+for HDMI hdev only register the dais needed for HDMI
+for non HDMI hdev do not  register the HDMI dais.
+
+Depends-on: 3d1dc8b1030d ("ASoC: Intel: skl_hda_dsp_generic: Drop HDMI routes when HDMI is not available")
+Link: https://github.com/thesofproject/linux/issues/4509
+Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
+Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
+Link: https://lore.kernel.org/r/20231128123914.3986-1-peter.ujfalusi@linux.intel.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/codecs/hdac_hda.c | 23 ++++++++++++++++++++---
+ 1 file changed, 20 insertions(+), 3 deletions(-)
+
+--- a/sound/soc/codecs/hdac_hda.c
++++ b/sound/soc/codecs/hdac_hda.c
+@@ -124,6 +124,9 @@ static struct snd_soc_dai_driver hdac_hd
+ 		.sig_bits = 24,
+ 	},
+ },
++};
++
++static struct snd_soc_dai_driver hdac_hda_hdmi_dais[] = {
+ {
+ 	.id = HDAC_HDMI_0_DAI_ID,
+ 	.name = "intel-hdmi-hifi1",
+@@ -578,8 +581,16 @@ static const struct snd_soc_component_dr
+ 	.endianness		= 1,
+ };
+ 
++static const struct snd_soc_component_driver hdac_hda_hdmi_codec = {
++	.probe			= hdac_hda_codec_probe,
++	.remove			= hdac_hda_codec_remove,
++	.idle_bias_on		= false,
++	.endianness		= 1,
++};
++
+ static int hdac_hda_dev_probe(struct hdac_device *hdev)
+ {
++	struct hdac_hda_priv *hda_pvt = dev_get_drvdata(&hdev->dev);
+ 	struct hdac_ext_link *hlink;
+ 	int ret;
+ 
+@@ -592,9 +603,15 @@ static int hdac_hda_dev_probe(struct hda
+ 	snd_hdac_ext_bus_link_get(hdev->bus, hlink);
+ 
+ 	/* ASoC specific initialization */
+-	ret = devm_snd_soc_register_component(&hdev->dev,
+-					 &hdac_hda_codec, hdac_hda_dais,
+-					 ARRAY_SIZE(hdac_hda_dais));
++	if (hda_pvt->need_display_power)
++		ret = devm_snd_soc_register_component(&hdev->dev,
++						&hdac_hda_hdmi_codec, hdac_hda_hdmi_dais,
++						ARRAY_SIZE(hdac_hda_hdmi_dais));
++	else
++		ret = devm_snd_soc_register_component(&hdev->dev,
++						&hdac_hda_codec, hdac_hda_dais,
++						ARRAY_SIZE(hdac_hda_dais));
++
+ 	if (ret < 0) {
+ 		dev_err(&hdev->dev, "failed to register HDA codec %d\n", ret);
+ 		return ret;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-031-net-tg3-fix-race-condition-in-tg3_reset_task.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-031-net-tg3-fix-race-condition-in-tg3_reset_task.patch
new file mode 100644
index 0000000000..e4da2ffba2
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-031-net-tg3-fix-race-condition-in-tg3_reset_task.patch
@@ -0,0 +1,87 @@
+From 882ea0b68372ba12c2d119feafe83d76e59107c3 Mon Sep 17 00:00:00 2001
+From: Thinh Tran <thinhtr@linux.vnet.ibm.com>
+Date: Thu, 30 Nov 2023 18:19:11 -0600
+Subject: [PATCH] net/tg3: fix race condition in tg3_reset_task()
+
+[ Upstream commit 16b55b1f2269962fb6b5154b8bf43f37c9a96637 ]
+
+When an EEH error is encountered by a PCI adapter, the EEH driver
+modifies the PCI channel's state as shown below:
+
+   enum {
+      /* I/O channel is in normal state */
+      pci_channel_io_normal = (__force pci_channel_state_t) 1,
+
+      /* I/O to channel is blocked */
+      pci_channel_io_frozen = (__force pci_channel_state_t) 2,
+
+      /* PCI card is dead */
+      pci_channel_io_perm_failure = (__force pci_channel_state_t) 3,
+   };
+
+If the same EEH error then causes the tg3 driver's transmit timeout
+logic to execute, the tg3_tx_timeout() function schedules a reset
+task via tg3_reset_task_schedule(), which may cause a race condition
+between the tg3 and EEH driver as both attempt to recover the HW via
+a reset action.
+
+EEH driver gets error event
+--> eeh_set_channel_state()
+    and set device to one of
+    error state above           scheduler: tg3_reset_task() get
+                                returned error from tg3_init_hw()
+                             --> dev_close() shuts down the interface
+tg3_io_slot_reset() and
+tg3_io_resume() fail to
+reset/resume the device
+
+To resolve this issue, we avoid the race condition by checking the PCI
+channel state in the tg3_reset_task() function and skip the tg3 driver
+initiated reset when the PCI channel is not in the normal state.  (The
+driver has no access to tg3 device registers at this point and cannot
+even complete the reset task successfully without external assistance.)
+We'll leave the reset procedure to be managed by the EEH driver which
+calls the tg3_io_error_detected(), tg3_io_slot_reset() and
+tg3_io_resume() functions as appropriate.
+
+Adding the same checking in tg3_dump_state() to avoid dumping all
+device registers when the PCI channel is not in the normal state.
+
+Signed-off-by: Thinh Tran <thinhtr@linux.vnet.ibm.com>
+Tested-by: Venkata Sai Duggi <venkata.sai.duggi@ibm.com>
+Reviewed-by: David Christensen <drc@linux.vnet.ibm.com>
+Reviewed-by: Michael Chan <michael.chan@broadcom.com>
+Link: https://lore.kernel.org/r/20231201001911.656-1-thinhtr@linux.vnet.ibm.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/net/ethernet/broadcom/tg3.c | 11 ++++++++++-
+ 1 file changed, 10 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/tg3.c
++++ b/drivers/net/ethernet/broadcom/tg3.c
+@@ -6447,6 +6447,14 @@ static void tg3_dump_state(struct tg3 *t
+ 	int i;
+ 	u32 *regs;
+ 
++	/* If it is a PCI error, all registers will be 0xffff,
++	 * we don't dump them out, just report the error and return
++	 */
++	if (tp->pdev->error_state != pci_channel_io_normal) {
++		netdev_err(tp->dev, "PCI channel ERROR!\n");
++		return;
++	}
++
+ 	regs = kzalloc(TG3_REG_BLK_SIZE, GFP_ATOMIC);
+ 	if (!regs)
+ 		return;
+@@ -11184,7 +11192,8 @@ static void tg3_reset_task(struct work_s
+ 	rtnl_lock();
+ 	tg3_full_lock(tp, 0);
+ 
+-	if (tp->pcierr_recovery || !netif_running(tp->dev)) {
++	if (tp->pcierr_recovery || !netif_running(tp->dev) ||
++	    tp->pdev->error_state != pci_channel_io_normal) {
+ 		tg3_flag_clear(tp, RESET_TASK_PENDING);
+ 		tg3_full_unlock(tp);
+ 		rtnl_unlock();
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-032-ASoC-da7219-Support-low-DC-impedance-headset.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-032-ASoC-da7219-Support-low-DC-impedance-headset.patch
new file mode 100644
index 0000000000..1ca685cecb
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-032-ASoC-da7219-Support-low-DC-impedance-headset.patch
@@ -0,0 +1,29 @@
+From 4e6f197d509ee4873f70c0349204635a3a9481d8 Mon Sep 17 00:00:00 2001
+From: David Rau <David.Rau.opensource@dm.renesas.com>
+Date: Fri, 1 Dec 2023 12:29:33 +0800
+Subject: [PATCH] ASoC: da7219: Support low DC impedance headset
+
+[ Upstream commit 5f44de697383fcc9a9a1a78f99e09d1838704b90 ]
+
+Change the default MIC detection impedance threshold to 200ohm
+to support low mic DC impedance headset.
+
+Signed-off-by: David Rau <David.Rau.opensource@dm.renesas.com>
+Link: https://lore.kernel.org/r/20231201042933.26392-1-David.Rau.opensource@dm.renesas.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/codecs/da7219-aad.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/sound/soc/codecs/da7219-aad.c
++++ b/sound/soc/codecs/da7219-aad.c
+@@ -663,7 +663,7 @@ static struct da7219_aad_pdata *da7219_a
+ 		aad_pdata->mic_det_thr =
+ 			da7219_aad_fw_mic_det_thr(dev, fw_val32);
+ 	else
+-		aad_pdata->mic_det_thr = DA7219_AAD_MIC_DET_THR_500_OHMS;
++		aad_pdata->mic_det_thr = DA7219_AAD_MIC_DET_THR_200_OHMS;
+ 
+ 	if (fwnode_property_read_u32(aad_np, "dlg,jack-ins-deb", &fw_val32) >= 0)
+ 		aad_pdata->jack_ins_deb =
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-033-ASoC-ops-add-correct-range-check-for-limiting-volume.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-033-ASoC-ops-add-correct-range-check-for-limiting-volume.patch
new file mode 100644
index 0000000000..03c9d4d215
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-033-ASoC-ops-add-correct-range-check-for-limiting-volume.patch
@@ -0,0 +1,33 @@
+From 54c02a8828daa7b8f57a078f15edde7284899a56 Mon Sep 17 00:00:00 2001
+From: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+Date: Mon, 4 Dec 2023 12:47:35 +0000
+Subject: [PATCH] ASoC: ops: add correct range check for limiting volume
+
+[ Upstream commit fb9ad24485087e0f00d84bee7a5914640b2b9024 ]
+
+Volume can have ranges that start with negative values, ex: -84dB to
++40dB. Apply correct range check in snd_soc_limit_volume before setting
+the platform_max. Without this patch, for example setting a 0dB limit on
+a volume range of -84dB to +40dB would fail.
+
+Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+Tested-by: Johan Hovold <johan+linaro@kernel.org>
+Reviewed-by: Johan Hovold <johan+linaro@kernel.org>
+Link: https://lore.kernel.org/r/20231204124736.132185-2-srinivas.kandagatla@linaro.org
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/soc-ops.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/sound/soc/soc-ops.c
++++ b/sound/soc/soc-ops.c
+@@ -661,7 +661,7 @@ int snd_soc_limit_volume(struct snd_soc_
+ 	kctl = snd_soc_card_get_kcontrol(card, name);
+ 	if (kctl) {
+ 		struct soc_mixer_control *mc = (struct soc_mixer_control *)kctl->private_value;
+-		if (max <= mc->max) {
++		if (max <= mc->max - mc->min) {
+ 			mc->platform_max = max;
+ 			ret = 0;
+ 		}
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-034-nvme-introduce-helper-function-to-get-ctrl-state.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-034-nvme-introduce-helper-function-to-get-ctrl-state.patch
new file mode 100644
index 0000000000..63d75b1661
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-034-nvme-introduce-helper-function-to-get-ctrl-state.patch
@@ -0,0 +1,33 @@
+From 895569c6f5cfd980801271ee373e1e4298dcf8b7 Mon Sep 17 00:00:00 2001
+From: Keith Busch <kbusch@kernel.org>
+Date: Mon, 30 Oct 2023 08:13:09 -0700
+Subject: [PATCH] nvme: introduce helper function to get ctrl state
+
+[ Upstream commit 5c687c287c46fadb14644091823298875a5216aa ]
+
+The controller state is typically written by another CPU, so reading it
+should ensure no optimizations are taken. This is a repeated pattern in
+the driver, so start with adding a convenience function that returns the
+controller state with READ_ONCE().
+
+Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
+Signed-off-by: Keith Busch <kbusch@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/nvme/host/nvme.h | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/nvme/host/nvme.h
++++ b/drivers/nvme/host/nvme.h
+@@ -382,6 +382,11 @@ struct nvme_ctrl {
+ 	enum nvme_dctype dctype;
+ };
+ 
++static inline enum nvme_ctrl_state nvme_ctrl_state(struct nvme_ctrl *ctrl)
++{
++	return READ_ONCE(ctrl->state);
++}
++
+ enum nvme_iopolicy {
+ 	NVME_IOPOLICY_NUMA,
+ 	NVME_IOPOLICY_RR,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-035-nvme-prevent-potential-spectre-v1-gadget.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-035-nvme-prevent-potential-spectre-v1-gadget.patch
new file mode 100644
index 0000000000..b32022a0a1
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-035-nvme-prevent-potential-spectre-v1-gadget.patch
@@ -0,0 +1,47 @@
+From 54593fb382852349c36d311d0329841bcfe20311 Mon Sep 17 00:00:00 2001
+From: Nitesh Shetty <nj.shetty@samsung.com>
+Date: Tue, 28 Nov 2023 17:59:57 +0530
+Subject: [PATCH] nvme: prevent potential spectre v1 gadget
+
+[ Upstream commit 20dc66f2d76b4a410df14e4675e373b718babc34 ]
+
+This patch fixes the smatch warning, "nvmet_ns_ana_grpid_store() warn:
+potential spectre issue 'nvmet_ana_group_enabled' [w] (local cap)"
+Prevent the contents of kernel memory from being leaked to  user space
+via speculative execution by using array_index_nospec.
+
+Signed-off-by: Nitesh Shetty <nj.shetty@samsung.com>
+Reviewed-by: Christoph Hellwig <hch@lst.de>
+Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
+Signed-off-by: Keith Busch <kbusch@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/nvme/target/configfs.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/nvme/target/configfs.c
++++ b/drivers/nvme/target/configfs.c
+@@ -16,6 +16,7 @@
+ #endif
+ #include <crypto/hash.h>
+ #include <crypto/kpp.h>
++#include <linux/nospec.h>
+ 
+ #include "nvmet.h"
+ 
+@@ -508,6 +509,7 @@ static ssize_t nvmet_ns_ana_grpid_store(
+ 
+ 	down_write(&nvmet_ana_sem);
+ 	oldgrpid = ns->anagrpid;
++	newgrpid = array_index_nospec(newgrpid, NVMET_MAX_ANAGRPS);
+ 	nvmet_ana_group_enabled[newgrpid]++;
+ 	ns->anagrpid = newgrpid;
+ 	nvmet_ana_group_enabled[oldgrpid]--;
+@@ -1580,6 +1582,7 @@ static struct config_group *nvmet_ana_gr
+ 	grp->grpid = grpid;
+ 
+ 	down_write(&nvmet_ana_sem);
++	grpid = array_index_nospec(grpid, NVMET_MAX_ANAGRPS);
+ 	nvmet_ana_group_enabled[grpid]++;
+ 	up_write(&nvmet_ana_sem);
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-036-arm64-dts-rockchip-Fix-PCI-node-addresses-on-rk3399-.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-036-arm64-dts-rockchip-Fix-PCI-node-addresses-on-rk3399-.patch
new file mode 100644
index 0000000000..9e38cb63b3
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-036-arm64-dts-rockchip-Fix-PCI-node-addresses-on-rk3399-.patch
@@ -0,0 +1,67 @@
+From c414f00e86c94eb147452bd9bc9005ec109c2d41 Mon Sep 17 00:00:00 2001
+From: Rob Herring <robh@kernel.org>
+Date: Thu, 30 Nov 2023 13:18:29 -0600
+Subject: [PATCH] arm64: dts: rockchip: Fix PCI node addresses on rk3399-gru
+
+[ Upstream commit c13c823a78b77ea0e5f1f73112d910e259911101 ]
+
+The rk3399-gru PCI node addresses are wrong.
+
+In rk3399-gru-scarlet, the bus number in the address should be 0. This is
+because bus number assignment is dynamic and not known up front. For FDT,
+the bus number is simply ignored.
+
+In rk3399-gru-chromebook, the addresses are simply invalid. The first
+"reg" entry must be the configuration space for the device. The entry
+should be all 0s except for device/slot and function numbers. The existing
+64-bit memory space (0x83000000) entries are not valid because they must
+have the BAR address in the lower byte of the first cell.
+
+Warnings for these are enabled by adding the missing 'device_type = "pci"'
+for the root port node.
+
+Signed-off-by: Rob Herring <robh@kernel.org>
+Link: https://lore.kernel.org/r/20231130191830.2424361-1-robh@kernel.org
+Signed-off-by: Heiko Stuebner <heiko@sntech.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ arch/arm64/boot/dts/rockchip/rk3399-gru-chromebook.dtsi  | 3 +--
+ arch/arm64/boot/dts/rockchip/rk3399-gru-scarlet-dumo.dts | 4 ++--
+ arch/arm64/boot/dts/rockchip/rk3399-gru.dtsi             | 1 +
+ 3 files changed, 4 insertions(+), 4 deletions(-)
+
+--- a/arch/arm64/boot/dts/rockchip/rk3399-gru-chromebook.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3399-gru-chromebook.dtsi
+@@ -510,8 +510,7 @@ ap_i2c_tp: &i2c5 {
+ &pci_rootport {
+ 	mvl_wifi: wifi@0,0 {
+ 		compatible = "pci1b4b,2b42";
+-		reg = <0x83010000 0x0 0x00000000 0x0 0x00100000
+-		       0x83010000 0x0 0x00100000 0x0 0x00100000>;
++		reg = <0x0000 0x0 0x0 0x0 0x0>;
+ 		interrupt-parent = <&gpio0>;
+ 		interrupts = <8 IRQ_TYPE_LEVEL_LOW>;
+ 		pinctrl-names = "default";
+--- a/arch/arm64/boot/dts/rockchip/rk3399-gru-scarlet-dumo.dts
++++ b/arch/arm64/boot/dts/rockchip/rk3399-gru-scarlet-dumo.dts
+@@ -34,8 +34,8 @@
+ &pci_rootport {
+ 	wifi@0,0 {
+ 		compatible = "qcom,ath10k";
+-		reg = <0x00010000 0x0 0x00000000 0x0 0x00000000>,
+-		      <0x03010010 0x0 0x00000000 0x0 0x00200000>;
++		reg = <0x00000000 0x0 0x00000000 0x0 0x00000000>,
++		      <0x03000010 0x0 0x00000000 0x0 0x00200000>;
+ 		qcom,ath10k-calibration-variant = "GO_DUMO";
+ 	};
+ };
+--- a/arch/arm64/boot/dts/rockchip/rk3399-gru.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3399-gru.dtsi
+@@ -489,6 +489,7 @@ ap_i2c_audio: &i2c8 {
+ 		#address-cells = <3>;
+ 		#size-cells = <2>;
+ 		ranges;
++		device_type = "pci";
+ 	};
+ };
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-037-mips-smp-Call-rcutree_report_cpu_starting-earlier.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-037-mips-smp-Call-rcutree_report_cpu_starting-earlier.patch
new file mode 100644
index 0000000000..13b6c7d7d4
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-037-mips-smp-Call-rcutree_report_cpu_starting-earlier.patch
@@ -0,0 +1,70 @@
+From 8138af99528fde0ade8c24af17c10652cf92bfa0 Mon Sep 17 00:00:00 2001
+From: Stefan Wiehler <stefan.wiehler@nokia.com>
+Date: Mon, 6 Nov 2023 13:12:07 +0100
+Subject: [PATCH] mips/smp: Call rcutree_report_cpu_starting() earlier
+
+[ Upstream commit 55702ec9603ebeffb15e6f7b113623fe1d8872f4 ]
+
+rcutree_report_cpu_starting() must be called before
+clockevents_register_device() to avoid the following lockdep splat triggered by
+calling list_add() when CONFIG_PROVE_RCU_LIST=y:
+
+  WARNING: suspicious RCU usage
+  ...
+  -----------------------------
+  kernel/locking/lockdep.c:3680 RCU-list traversed in non-reader section!!
+
+  other info that might help us debug this:
+
+  RCU used illegally from offline CPU!
+  rcu_scheduler_active = 1, debug_locks = 1
+  no locks held by swapper/1/0.
+  ...
+  Call Trace:
+  [<ffffffff8012a434>] show_stack+0x64/0x158
+  [<ffffffff80a93d98>] dump_stack_lvl+0x90/0xc4
+  [<ffffffff801c9e9c>] __lock_acquire+0x1404/0x2940
+  [<ffffffff801cbf3c>] lock_acquire+0x14c/0x448
+  [<ffffffff80aa4260>] _raw_spin_lock_irqsave+0x50/0x88
+  [<ffffffff8021e0c8>] clockevents_register_device+0x60/0x1e8
+  [<ffffffff80130ff0>] r4k_clockevent_init+0x220/0x3a0
+  [<ffffffff801339d0>] start_secondary+0x50/0x3b8
+
+raw_smp_processor_id() is required in order to avoid calling into lockdep
+before RCU has declared the CPU to be watched for readers.
+
+See also commit 29368e093921 ("x86/smpboot:  Move rcu_cpu_starting() earlier"),
+commit de5d9dae150c ("s390/smp: move rcu_cpu_starting() earlier") and commit
+99f070b62322 ("powerpc/smp: Call rcu_cpu_starting() earlier").
+
+Signed-off-by: Stefan Wiehler <stefan.wiehler@nokia.com>
+Reviewed-by: Huacai Chen <chenhuacai@loongson.cn>
+Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ arch/mips/kernel/smp.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/arch/mips/kernel/smp.c
++++ b/arch/mips/kernel/smp.c
+@@ -333,10 +333,11 @@ early_initcall(mips_smp_ipi_init);
+  */
+ asmlinkage void start_secondary(void)
+ {
+-	unsigned int cpu;
++	unsigned int cpu = raw_smp_processor_id();
+ 
+ 	cpu_probe();
+ 	per_cpu_trap_init(false);
++	rcutree_report_cpu_starting(cpu);
+ 	mips_clockevent_init();
+ 	mp_ops->init_secondary();
+ 	cpu_report();
+@@ -348,7 +349,6 @@ asmlinkage void start_secondary(void)
+ 	 */
+ 
+ 	calibrate_delay();
+-	cpu = smp_processor_id();
+ 	cpu_data[cpu].udelay_val = loops_per_jiffy;
+ 
+ 	set_cpu_sibling_map(cpu);
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-038-drm-amd-display-Use-channel_width-2-for-vram-table-3.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-038-drm-amd-display-Use-channel_width-2-for-vram-table-3.patch
new file mode 100644
index 0000000000..bd3e634af5
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-038-drm-amd-display-Use-channel_width-2-for-vram-table-3.patch
@@ -0,0 +1,38 @@
+From 076de8e69ad2b5ffdec82e315c9fd6fa4d70b538 Mon Sep 17 00:00:00 2001
+From: Alvin Lee <alvin.lee2@amd.com>
+Date: Fri, 1 Dec 2023 06:25:07 -0700
+Subject: [PATCH] drm/amd/display: Use channel_width = 2 for vram table 3.0
+
+[ Upstream commit fec05adc40c25a028c9dfa9d540f800a2d433f80 ]
+
+VBIOS has suggested to use channel_width=2 for any ASIC that uses vram
+info 3.0. This is because channel_width in the vram table no longer
+represents the memory width
+
+Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
+Reviewed-by: Samson Tam <samson.tam@amd.com>
+Acked-by: Rodrigo Siqueira <rodrigo.siqueira@amd.com>
+Signed-off-by: Alvin Lee <alvin.lee2@amd.com>
+Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
+
+--- a/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
++++ b/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
+@@ -2402,7 +2402,13 @@ static enum bp_result get_vram_info_v30(
+ 		return BP_RESULT_BADBIOSTABLE;
+ 
+ 	info->num_chans = info_v30->channel_num;
+-	info->dram_channel_width_bytes = (1 << info_v30->channel_width) / 8;
++	/* As suggested by VBIOS we should always use
++	 * dram_channel_width_bytes = 2 when using VRAM
++	 * table version 3.0. This is because the channel_width
++	 * param in the VRAM info table is changed in 7000 series and
++	 * no longer represents the memory channel width.
++	 */
++	info->dram_channel_width_bytes = 2;
+ 
+ 	return result;
+ }
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-039-drm-amdgpu-Add-NULL-checks-for-function-pointers.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-039-drm-amdgpu-Add-NULL-checks-for-function-pointers.patch
new file mode 100644
index 0000000000..17bc16b0b8
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-039-drm-amdgpu-Add-NULL-checks-for-function-pointers.patch
@@ -0,0 +1,48 @@
+From 2f88eccc990b6e5af212336f6f975a4bbd307cf6 Mon Sep 17 00:00:00 2001
+From: Lijo Lazar <lijo.lazar@amd.com>
+Date: Wed, 29 Nov 2023 12:37:34 +0530
+Subject: [PATCH] drm/amdgpu: Add NULL checks for function pointers
+
+[ Upstream commit 81577503efb49f4ad76af22f9941d72900ef4aab ]
+
+Check if function is implemented before making the call.
+
+Signed-off-by: Lijo Lazar <lijo.lazar@amd.com>
+Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
+Acked-by: Alex Deucher <alexander.deucher@amd.com>
+Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/gpu/drm/amd/amdgpu/soc15.c | 12 ++++++++----
+ 1 file changed, 8 insertions(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/amd/amdgpu/soc15.c
++++ b/drivers/gpu/drm/amd/amdgpu/soc15.c
+@@ -1411,9 +1411,11 @@ static void soc15_common_get_clockgating
+ 	if (amdgpu_sriov_vf(adev))
+ 		*flags = 0;
+ 
+-	adev->nbio.funcs->get_clockgating_state(adev, flags);
++	if (adev->nbio.funcs && adev->nbio.funcs->get_clockgating_state)
++		adev->nbio.funcs->get_clockgating_state(adev, flags);
+ 
+-	adev->hdp.funcs->get_clock_gating_state(adev, flags);
++	if (adev->hdp.funcs && adev->hdp.funcs->get_clock_gating_state)
++		adev->hdp.funcs->get_clock_gating_state(adev, flags);
+ 
+ 	if (adev->ip_versions[MP0_HWIP][0] != IP_VERSION(13, 0, 2)) {
+ 
+@@ -1429,9 +1431,11 @@ static void soc15_common_get_clockgating
+ 	}
+ 
+ 	/* AMD_CG_SUPPORT_ROM_MGCG */
+-	adev->smuio.funcs->get_clock_gating_state(adev, flags);
++	if (adev->smuio.funcs && adev->smuio.funcs->get_clock_gating_state)
++		adev->smuio.funcs->get_clock_gating_state(adev, flags);
+ 
+-	adev->df.funcs->get_clockgating_state(adev, flags);
++	if (adev->df.funcs && adev->df.funcs->get_clockgating_state)
++		adev->df.funcs->get_clockgating_state(adev, flags);
+ }
+ 
+ static int soc15_common_set_powergating_state(void *handle,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-040-drm-exynos-fix-a-potential-error-pointer-dereference.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-040-drm-exynos-fix-a-potential-error-pointer-dereference.patch
new file mode 100644
index 0000000000..eb210b355b
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-040-drm-exynos-fix-a-potential-error-pointer-dereference.patch
@@ -0,0 +1,33 @@
+From e1ced9137251f2f78160063ae3cd5f77e3613105 Mon Sep 17 00:00:00 2001
+From: Xiang Yang <xiangyang3@huawei.com>
+Date: Sat, 12 Aug 2023 14:27:48 +0800
+Subject: [PATCH] drm/exynos: fix a potential error pointer dereference
+
+[ Upstream commit 73bf1c9ae6c054c53b8e84452c5e46f86dd28246 ]
+
+Smatch reports the warning below:
+drivers/gpu/drm/exynos/exynos_hdmi.c:1864 hdmi_bind()
+error: 'crtc' dereferencing possible ERR_PTR()
+
+The return value of exynos_drm_crtc_get_by_type maybe ERR_PTR(-ENODEV),
+which can not be used directly. Fix this by checking the return value
+before using it.
+
+Signed-off-by: Xiang Yang <xiangyang3@huawei.com>
+Signed-off-by: Inki Dae <inki.dae@samsung.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/gpu/drm/exynos/exynos_hdmi.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/gpu/drm/exynos/exynos_hdmi.c
++++ b/drivers/gpu/drm/exynos/exynos_hdmi.c
+@@ -1861,6 +1861,8 @@ static int hdmi_bind(struct device *dev,
+ 		return ret;
+ 
+ 	crtc = exynos_drm_crtc_get_by_type(drm_dev, EXYNOS_DISPLAY_TYPE_HDMI);
++	if (IS_ERR(crtc))
++		return PTR_ERR(crtc);
+ 	crtc->pipe_clk = &hdata->phy_clk;
+ 
+ 	ret = hdmi_create_connector(encoder);
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-041-drm-exynos-fix-a-wrong-error-checking.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-041-drm-exynos-fix-a-wrong-error-checking.patch
new file mode 100644
index 0000000000..99b5529569
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-041-drm-exynos-fix-a-wrong-error-checking.patch
@@ -0,0 +1,55 @@
+From e167290ea3dc73afee5a11d515f1e0a809007827 Mon Sep 17 00:00:00 2001
+From: Inki Dae <inki.dae@samsung.com>
+Date: Wed, 1 Nov 2023 18:36:51 +0900
+Subject: [PATCH] drm/exynos: fix a wrong error checking
+
+[ Upstream commit 8d1b7809684c688005706125b804e1f9792d2b1b ]
+
+Fix a wrong error checking in exynos_drm_dma.c module.
+
+In the exynos_drm_register_dma function, both arm_iommu_create_mapping()
+and iommu_get_domain_for_dev() functions are expected to return NULL as
+an error.
+
+However, the error checking is performed using the statement
+if(IS_ERR(mapping)), which doesn't provide a suitable error value.
+So check if 'mapping' is NULL, and if it is, return -ENODEV.
+
+This issue[1] was reported by Dan.
+
+Changelog v1:
+- fix build warning.
+
+[1] https://lore.kernel.org/all/33e52277-1349-472b-a55b-ab5c3462bfcf@moroto.mountain/
+
+Reported-by : Dan Carpenter <dan.carpenter@linaro.org>
+Signed-off-by: Inki Dae <inki.dae@samsung.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/gpu/drm/exynos/exynos_drm_dma.c | 8 +++-----
+ 1 file changed, 3 insertions(+), 5 deletions(-)
+
+--- a/drivers/gpu/drm/exynos/exynos_drm_dma.c
++++ b/drivers/gpu/drm/exynos/exynos_drm_dma.c
+@@ -107,18 +107,16 @@ int exynos_drm_register_dma(struct drm_d
+ 		return 0;
+ 
+ 	if (!priv->mapping) {
+-		void *mapping;
++		void *mapping = NULL;
+ 
+ 		if (IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU))
+ 			mapping = arm_iommu_create_mapping(&platform_bus_type,
+ 				EXYNOS_DEV_ADDR_START, EXYNOS_DEV_ADDR_SIZE);
+ 		else if (IS_ENABLED(CONFIG_IOMMU_DMA))
+ 			mapping = iommu_get_domain_for_dev(priv->dma_dev);
+-		else
+-			mapping = ERR_PTR(-ENODEV);
+ 
+-		if (IS_ERR(mapping))
+-			return PTR_ERR(mapping);
++		if (!mapping)
++			return -ENODEV;
+ 		priv->mapping = mapping;
+ 	}
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-042-hwmon-corsair-psu-Fix-probe-when-built-in.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-042-hwmon-corsair-psu-Fix-probe-when-built-in.patch
new file mode 100644
index 0000000000..fdfdc047a5
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-042-hwmon-corsair-psu-Fix-probe-when-built-in.patch
@@ -0,0 +1,50 @@
+From 403a3ca972d5b57286ffa4322eacec1bf8d2a8de Mon Sep 17 00:00:00 2001
+From: Armin Wolf <W_Armin@gmx.de>
+Date: Thu, 7 Dec 2023 22:07:23 +0100
+Subject: [PATCH] hwmon: (corsair-psu) Fix probe when built-in
+
+[ Upstream commit 307004e8b254ad28e150b63f299ab9caa4bc7c3e ]
+
+It seems that when the driver is built-in, the HID bus is
+initialized after the driver is loaded, which whould cause
+module_hid_driver() to fail.
+Fix this by registering the driver after the HID bus using
+late_initcall() in accordance with other hwmon HID drivers.
+
+Signed-off-by: Armin Wolf <W_Armin@gmx.de>
+Link: https://lore.kernel.org/r/20231207210723.222552-1-W_Armin@gmx.de
+[groeck: Dropped "compile tested" comment; the patch has been tested
+ but the tester did not provide a Tested-by: tag]
+Signed-off-by: Guenter Roeck <linux@roeck-us.net>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/hwmon/corsair-psu.c | 18 +++++++++++++++++-
+ 1 file changed, 17 insertions(+), 1 deletion(-)
+
+--- a/drivers/hwmon/corsair-psu.c
++++ b/drivers/hwmon/corsair-psu.c
+@@ -837,7 +837,23 @@ static struct hid_driver corsairpsu_driv
+ 	.reset_resume	= corsairpsu_resume,
+ #endif
+ };
+-module_hid_driver(corsairpsu_driver);
++
++static int __init corsair_init(void)
++{
++	return hid_register_driver(&corsairpsu_driver);
++}
++
++static void __exit corsair_exit(void)
++{
++	hid_unregister_driver(&corsairpsu_driver);
++}
++
++/*
++ * With module_init() the driver would load before the HID bus when
++ * built-in, so use late_initcall() instead.
++ */
++late_initcall(corsair_init);
++module_exit(corsair_exit);
+ 
+ MODULE_LICENSE("GPL");
+ MODULE_AUTHOR("Wilken Gottwalt <wilken.gottwalt@posteo.net>");
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-043-LoongArch-Preserve-syscall-nr-across-execve.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-043-LoongArch-Preserve-syscall-nr-across-execve.patch
new file mode 100644
index 0000000000..2c90e8eb59
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-043-LoongArch-Preserve-syscall-nr-across-execve.patch
@@ -0,0 +1,43 @@
+From 5cc8f97549e9a458a942e03bb77e2e227b15220b Mon Sep 17 00:00:00 2001
+From: Hengqi Chen <hengqi.chen@gmail.com>
+Date: Sat, 9 Dec 2023 15:49:15 +0800
+Subject: [PATCH] LoongArch: Preserve syscall nr across execve()
+
+[ Upstream commit d6c5f06e46a836e6a70c7cfd95bb38a67d9252ec ]
+
+Currently, we store syscall nr in pt_regs::regs[11] and syscall execve()
+accidentally overrides it during its execution:
+
+    sys_execve()
+      -> do_execve()
+        -> do_execveat_common()
+          -> bprm_execve()
+            -> exec_binprm()
+              -> search_binary_handler()
+                -> load_elf_binary()
+                  -> ELF_PLAT_INIT()
+
+ELF_PLAT_INIT() reset regs[11] to 0, so in syscall_exit_to_user_mode()
+we later get a wrong syscall nr. This breaks tools like execsnoop since
+it relies on execve() tracepoints.
+
+Skip pt_regs::regs[11] reset in ELF_PLAT_INIT() to fix the issue.
+
+Signed-off-by: Hengqi Chen <hengqi.chen@gmail.com>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ arch/loongarch/include/asm/elf.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/loongarch/include/asm/elf.h
++++ b/arch/loongarch/include/asm/elf.h
+@@ -293,7 +293,7 @@ extern const char *__elf_platform;
+ #define ELF_PLAT_INIT(_r, load_addr)	do { \
+ 	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
+ 	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
+-	_r->regs[9] = _r->regs[10] = _r->regs[11] = _r->regs[12] = 0;	\
++	_r->regs[9] = _r->regs[10] /* syscall n */ = _r->regs[12] = 0;	\
+ 	_r->regs[13] = _r->regs[14] = _r->regs[15] = _r->regs[16] = 0;	\
+ 	_r->regs[17] = _r->regs[18] = _r->regs[19] = _r->regs[20] = 0;	\
+ 	_r->regs[21] = _r->regs[22] = _r->regs[23] = _r->regs[24] = 0;	\
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-044-clk-rockchip-rk3568-Add-PLL-rate-for-292.5MHz.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-044-clk-rockchip-rk3568-Add-PLL-rate-for-292.5MHz.patch
new file mode 100644
index 0000000000..b7b6ec01c6
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-044-clk-rockchip-rk3568-Add-PLL-rate-for-292.5MHz.patch
@@ -0,0 +1,32 @@
+From 7b0cb596e8bfc99e1047d856bcef52de9cadea42 Mon Sep 17 00:00:00 2001
+From: Chris Morgan <macromorgan@hotmail.com>
+Date: Wed, 18 Oct 2023 10:33:55 -0500
+Subject: [PATCH] clk: rockchip: rk3568: Add PLL rate for 292.5MHz
+
+[ Upstream commit 1af27671f62ce919f1fb76082ed81f71cb090989 ]
+
+Add support for a PLL rate of 292.5MHz so that the Powkiddy RGB30 panel
+can run at a requested 60hz (59.96, close enough).
+
+I have confirmed this rate fits with all the constraints
+listed in the TRM for the VPLL (as an integer PLL) in Part 1 "Chapter
+2 Clock & Reset Unit (CRU)."
+
+Signed-off-by: Chris Morgan <macromorgan@hotmail.com>
+Link: https://lore.kernel.org/r/20231018153357.343142-2-macroalpha82@gmail.com
+Signed-off-by: Heiko Stuebner <heiko@sntech.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/clk/rockchip/clk-rk3568.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/clk/rockchip/clk-rk3568.c
++++ b/drivers/clk/rockchip/clk-rk3568.c
+@@ -72,6 +72,7 @@ static struct rockchip_pll_rate_table rk
+ 	RK3036_PLL_RATE(408000000, 1, 68, 2, 2, 1, 0),
+ 	RK3036_PLL_RATE(312000000, 1, 78, 6, 1, 1, 0),
+ 	RK3036_PLL_RATE(297000000, 2, 99, 4, 1, 1, 0),
++	RK3036_PLL_RATE(292500000, 1, 195, 4, 4, 1, 0),
+ 	RK3036_PLL_RATE(241500000, 2, 161, 4, 2, 1, 0),
+ 	RK3036_PLL_RATE(216000000, 1, 72, 4, 2, 1, 0),
+ 	RK3036_PLL_RATE(200000000, 1, 100, 3, 4, 1, 0),
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-045-clk-rockchip-rk3128-Fix-HCLK_OTG-gate-register.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-045-clk-rockchip-rk3128-Fix-HCLK_OTG-gate-register.patch
new file mode 100644
index 0000000000..eecbedfc01
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-045-clk-rockchip-rk3128-Fix-HCLK_OTG-gate-register.patch
@@ -0,0 +1,28 @@
+From 5386a0337351d8bc3c85fd4313b601e4d5355cbc Mon Sep 17 00:00:00 2001
+From: Weihao Li <cn.liweihao@gmail.com>
+Date: Tue, 31 Oct 2023 19:18:16 +0800
+Subject: [PATCH] clk: rockchip: rk3128: Fix HCLK_OTG gate register
+
+[ Upstream commit c6c5a5580dcb6631aa6369dabe12ef3ce784d1d2 ]
+
+The HCLK_OTG gate control is in CRU_CLKGATE5_CON, not CRU_CLKGATE3_CON.
+
+Signed-off-by: Weihao Li <cn.liweihao@gmail.com>
+Link: https://lore.kernel.org/r/20231031111816.8777-1-cn.liweihao@gmail.com
+Signed-off-by: Heiko Stuebner <heiko@sntech.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/clk/rockchip/clk-rk3128.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/clk/rockchip/clk-rk3128.c
++++ b/drivers/clk/rockchip/clk-rk3128.c
+@@ -490,7 +490,7 @@ static struct rockchip_clk_branch common
+ 	GATE(HCLK_I2S_2CH, "hclk_i2s_2ch", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 2, GFLAGS),
+ 	GATE(0, "hclk_usb_peri", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 13, GFLAGS),
+ 	GATE(HCLK_HOST2, "hclk_host2", "hclk_peri", 0, RK2928_CLKGATE_CON(7), 3, GFLAGS),
+-	GATE(HCLK_OTG, "hclk_otg", "hclk_peri", 0, RK2928_CLKGATE_CON(3), 13, GFLAGS),
++	GATE(HCLK_OTG, "hclk_otg", "hclk_peri", 0, RK2928_CLKGATE_CON(5), 13, GFLAGS),
+ 	GATE(0, "hclk_peri_ahb", "hclk_peri", CLK_IGNORE_UNUSED, RK2928_CLKGATE_CON(9), 14, GFLAGS),
+ 	GATE(HCLK_SPDIF, "hclk_spdif", "hclk_peri", 0, RK2928_CLKGATE_CON(10), 9, GFLAGS),
+ 	GATE(HCLK_TSP, "hclk_tsp", "hclk_peri", 0, RK2928_CLKGATE_CON(10), 12, GFLAGS),
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-046-jbd2-correct-the-printing-of-write_flags-in-jbd2_wri.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-046-jbd2-correct-the-printing-of-write_flags-in-jbd2_wri.patch
new file mode 100644
index 0000000000..ea9b8b96fc
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-046-jbd2-correct-the-printing-of-write_flags-in-jbd2_wri.patch
@@ -0,0 +1,35 @@
+From b46a4ac92eeabb5d197c77b3328135eda63a746e Mon Sep 17 00:00:00 2001
+From: Zhang Yi <yi.zhang@huawei.com>
+Date: Wed, 29 Nov 2023 19:47:39 +0800
+Subject: [PATCH] jbd2: correct the printing of write_flags in
+ jbd2_write_superblock()
+
+[ Upstream commit 85559227211020b270728104c3b89918f7af27ac ]
+
+The write_flags print in the trace of jbd2_write_superblock() is not
+real, so move the modification before the trace.
+
+Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
+Reviewed-by: Jan Kara <jack@suse.cz>
+Link: https://lore.kernel.org/r/20231129114740.2686201-1-yi.zhang@huaweicloud.com
+Signed-off-by: Theodore Ts'o <tytso@mit.edu>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ fs/jbd2/journal.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/fs/jbd2/journal.c
++++ b/fs/jbd2/journal.c
+@@ -1620,9 +1620,11 @@ static int jbd2_write_superblock(journal
+ 		return -EIO;
+ 	}
+ 
+-	trace_jbd2_write_superblock(journal, write_flags);
+ 	if (!(journal->j_flags & JBD2_BARRIER))
+ 		write_flags &= ~(REQ_FUA | REQ_PREFLUSH);
++
++	trace_jbd2_write_superblock(journal, write_flags);
++
+ 	if (buffer_write_io_error(bh)) {
+ 		/*
+ 		 * Oh, dear.  A previous attempt to write the journal
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-047-jbd2-increase-the-journal-IO-s-priority.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-047-jbd2-increase-the-journal-IO-s-priority.patch
new file mode 100644
index 0000000000..e1ede3e247
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-047-jbd2-increase-the-journal-IO-s-priority.patch
@@ -0,0 +1,149 @@
+From bbbceb3a49dd152adae586dea12356040230175b Mon Sep 17 00:00:00 2001
+From: Zhang Yi <yi.zhang@huawei.com>
+Date: Wed, 29 Nov 2023 19:47:40 +0800
+Subject: [PATCH] jbd2: increase the journal IO's priority
+
+[ Upstream commit 6a3afb6ac6dfab158ebdd4b87941178f58c8939f ]
+
+Current jbd2 only add REQ_SYNC for descriptor block, metadata log
+buffer, commit buffer and superblock buffer, the submitted IO could be
+throttled by writeback throttle in block layer, that could lead to
+priority inversion in some cases. The log IO looks like a kind of high
+priority metadata IO, so it should not be throttled by WBT like QOS
+policies in block layer, let's add REQ_SYNC | REQ_IDLE to exempt from
+writeback throttle, and also add REQ_META together indicates it's a
+metadata IO.
+
+Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
+Reviewed-by: Jan Kara <jack@suse.cz>
+Link: https://lore.kernel.org/r/20231129114740.2686201-2-yi.zhang@huaweicloud.com
+Signed-off-by: Theodore Ts'o <tytso@mit.edu>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ fs/jbd2/commit.c     |  9 +++++----
+ fs/jbd2/journal.c    | 20 +++++++++++---------
+ include/linux/jbd2.h |  3 +++
+ 3 files changed, 19 insertions(+), 13 deletions(-)
+
+--- a/fs/jbd2/commit.c
++++ b/fs/jbd2/commit.c
+@@ -123,7 +123,7 @@ static int journal_submit_commit_record(
+ 	struct commit_header *tmp;
+ 	struct buffer_head *bh;
+ 	struct timespec64 now;
+-	blk_opf_t write_flags = REQ_OP_WRITE | REQ_SYNC;
++	blk_opf_t write_flags = REQ_OP_WRITE | JBD2_JOURNAL_REQ_FLAGS;
+ 
+ 	*cbh = NULL;
+ 
+@@ -429,8 +429,7 @@ void jbd2_journal_commit_transaction(jou
+ 		 */
+ 		jbd2_journal_update_sb_log_tail(journal,
+ 						journal->j_tail_sequence,
+-						journal->j_tail,
+-						REQ_SYNC);
++						journal->j_tail, 0);
+ 		mutex_unlock(&journal->j_checkpoint_mutex);
+ 	} else {
+ 		jbd2_debug(3, "superblock not updated\n");
+@@ -749,6 +748,7 @@ start_journal_io:
+ 
+ 			for (i = 0; i < bufs; i++) {
+ 				struct buffer_head *bh = wbuf[i];
++
+ 				/*
+ 				 * Compute checksum.
+ 				 */
+@@ -761,7 +761,8 @@ start_journal_io:
+ 				clear_buffer_dirty(bh);
+ 				set_buffer_uptodate(bh);
+ 				bh->b_end_io = journal_end_buffer_io_sync;
+-				submit_bh(REQ_OP_WRITE | REQ_SYNC, bh);
++				submit_bh(REQ_OP_WRITE | JBD2_JOURNAL_REQ_FLAGS,
++					  bh);
+ 			}
+ 			cond_resched();
+ 
+--- a/fs/jbd2/journal.c
++++ b/fs/jbd2/journal.c
+@@ -1109,8 +1109,7 @@ int __jbd2_update_log_tail(journal_t *jo
+ 	 * space and if we lose sb update during power failure we'd replay
+ 	 * old transaction with possibly newly overwritten data.
+ 	 */
+-	ret = jbd2_journal_update_sb_log_tail(journal, tid, block,
+-					      REQ_SYNC | REQ_FUA);
++	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, REQ_FUA);
+ 	if (ret)
+ 		goto out;
+ 
+@@ -1597,8 +1596,7 @@ static int journal_reset(journal_t *jour
+ 		 */
+ 		jbd2_journal_update_sb_log_tail(journal,
+ 						journal->j_tail_sequence,
+-						journal->j_tail,
+-						REQ_SYNC | REQ_FUA);
++						journal->j_tail, REQ_FUA);
+ 		mutex_unlock(&journal->j_checkpoint_mutex);
+ 	}
+ 	return jbd2_journal_start_thread(journal);
+@@ -1620,6 +1618,11 @@ static int jbd2_write_superblock(journal
+ 		return -EIO;
+ 	}
+ 
++	/*
++	 * Always set high priority flags to exempt from block layer's
++	 * QOS policies, e.g. writeback throttle.
++	 */
++	write_flags |= JBD2_JOURNAL_REQ_FLAGS;
+ 	if (!(journal->j_flags & JBD2_BARRIER))
+ 		write_flags &= ~(REQ_FUA | REQ_PREFLUSH);
+ 
+@@ -1873,7 +1876,7 @@ void jbd2_journal_update_sb_errno(journa
+ 	jbd2_debug(1, "JBD2: updating superblock error (errno %d)\n", errcode);
+ 	sb->s_errno    = cpu_to_be32(errcode);
+ 
+-	jbd2_write_superblock(journal, REQ_SYNC | REQ_FUA);
++	jbd2_write_superblock(journal, REQ_FUA);
+ }
+ EXPORT_SYMBOL(jbd2_journal_update_sb_errno);
+ 
+@@ -2178,8 +2181,7 @@ int jbd2_journal_destroy(journal_t *jour
+ 				++journal->j_transaction_sequence;
+ 			write_unlock(&journal->j_state_lock);
+ 
+-			jbd2_mark_journal_empty(journal,
+-					REQ_SYNC | REQ_PREFLUSH | REQ_FUA);
++			jbd2_mark_journal_empty(journal, REQ_PREFLUSH | REQ_FUA);
+ 			mutex_unlock(&journal->j_checkpoint_mutex);
+ 		} else
+ 			err = -EIO;
+@@ -2488,7 +2490,7 @@ int jbd2_journal_flush(journal_t *journa
+ 	 * the magic code for a fully-recovered superblock.  Any future
+ 	 * commits of data to the journal will restore the current
+ 	 * s_start value. */
+-	jbd2_mark_journal_empty(journal, REQ_SYNC | REQ_FUA);
++	jbd2_mark_journal_empty(journal, REQ_FUA);
+ 
+ 	if (flags)
+ 		err = __jbd2_journal_erase(journal, flags);
+@@ -2538,7 +2540,7 @@ int jbd2_journal_wipe(journal_t *journal
+ 	if (write) {
+ 		/* Lock to make assertions happy... */
+ 		mutex_lock_io(&journal->j_checkpoint_mutex);
+-		jbd2_mark_journal_empty(journal, REQ_SYNC | REQ_FUA);
++		jbd2_mark_journal_empty(journal, REQ_FUA);
+ 		mutex_unlock(&journal->j_checkpoint_mutex);
+ 	}
+ 
+--- a/include/linux/jbd2.h
++++ b/include/linux/jbd2.h
+@@ -1374,6 +1374,9 @@ JBD2_FEATURE_INCOMPAT_FUNCS(csum2,		CSUM
+ JBD2_FEATURE_INCOMPAT_FUNCS(csum3,		CSUM_V3)
+ JBD2_FEATURE_INCOMPAT_FUNCS(fast_commit,	FAST_COMMIT)
+ 
++/* Journal high priority write IO operation flags */
++#define JBD2_JOURNAL_REQ_FLAGS		(REQ_META | REQ_SYNC | REQ_IDLE)
++
+ /*
+  * Journal flag definitions
+  */
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-048-drm-crtc-Fix-uninit-value-bug-in-drm_mode_setcrtc.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-048-drm-crtc-Fix-uninit-value-bug-in-drm_mode_setcrtc.patch
new file mode 100644
index 0000000000..458c534cff
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-048-drm-crtc-Fix-uninit-value-bug-in-drm_mode_setcrtc.patch
@@ -0,0 +1,72 @@
+From b97aaf74638258222bef2e5a92328eacd247e86a Mon Sep 17 00:00:00 2001
+From: Ziqi Zhao <astrajoan@yahoo.com>
+Date: Fri, 21 Jul 2023 09:14:46 -0700
+Subject: [PATCH] drm/crtc: Fix uninit-value bug in drm_mode_setcrtc
+
+[ Upstream commit 3823119b9c2b5f9e9b760336f75bc989b805cde6 ]
+
+The connector_set contains uninitialized values when allocated with
+kmalloc_array. However, in the "out" branch, the logic assumes that any
+element in connector_set would be equal to NULL if failed to
+initialize, which causes the bug reported by Syzbot. The fix is to use
+an extra variable to keep track of how many connectors are initialized
+indeed, and use that variable to decrease any refcounts in the "out"
+branch.
+
+Reported-by: syzbot+4fad2e57beb6397ab2fc@syzkaller.appspotmail.com
+Signed-off-by: Ziqi Zhao <astrajoan@yahoo.com>
+Reported-and-tested-by: syzbot+4fad2e57beb6397ab2fc@syzkaller.appspotmail.com
+Tested-by: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>
+Link: https://lore.kernel.org/r/20230721161446.8602-1-astrajoan@yahoo.com
+Signed-off-by: Maxime Ripard <mripard@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/gpu/drm/drm_crtc.c | 9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+--- a/drivers/gpu/drm/drm_crtc.c
++++ b/drivers/gpu/drm/drm_crtc.c
+@@ -715,8 +715,7 @@ int drm_mode_setcrtc(struct drm_device *
+ 	struct drm_mode_set set;
+ 	uint32_t __user *set_connectors_ptr;
+ 	struct drm_modeset_acquire_ctx ctx;
+-	int ret;
+-	int i;
++	int ret, i, num_connectors;
+ 
+ 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
+ 		return -EOPNOTSUPP;
+@@ -851,6 +850,7 @@ int drm_mode_setcrtc(struct drm_device *
+ 			goto out;
+ 		}
+ 
++		num_connectors = 0;
+ 		for (i = 0; i < crtc_req->count_connectors; i++) {
+ 			connector_set[i] = NULL;
+ 			set_connectors_ptr = (uint32_t __user *)(unsigned long)crtc_req->set_connectors_ptr;
+@@ -871,6 +871,7 @@ int drm_mode_setcrtc(struct drm_device *
+ 					connector->name);
+ 
+ 			connector_set[i] = connector;
++			num_connectors++;
+ 		}
+ 	}
+ 
+@@ -879,7 +880,7 @@ int drm_mode_setcrtc(struct drm_device *
+ 	set.y = crtc_req->y;
+ 	set.mode = mode;
+ 	set.connectors = connector_set;
+-	set.num_connectors = crtc_req->count_connectors;
++	set.num_connectors = num_connectors;
+ 	set.fb = fb;
+ 
+ 	if (drm_drv_uses_atomic_modeset(dev))
+@@ -892,7 +893,7 @@ out:
+ 		drm_framebuffer_put(fb);
+ 
+ 	if (connector_set) {
+-		for (i = 0; i < crtc_req->count_connectors; i++) {
++		for (i = 0; i < num_connectors; i++) {
+ 			if (connector_set[i])
+ 				drm_connector_put(connector_set[i]);
+ 		}
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-049-neighbour-Don-t-let-neigh_forced_gc-disable-preempti.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-049-neighbour-Don-t-let-neigh_forced_gc-disable-preempti.patch
new file mode 100644
index 0000000000..0c913777fa
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-049-neighbour-Don-t-let-neigh_forced_gc-disable-preempti.patch
@@ -0,0 +1,58 @@
+From 77c5bda68aa5ddbe6befb98e2718997a861b8f5f Mon Sep 17 00:00:00 2001
+From: Judy Hsiao <judyhsiao@chromium.org>
+Date: Wed, 6 Dec 2023 03:38:33 +0000
+Subject: [PATCH] neighbour: Don't let neigh_forced_gc() disable preemption for
+ long
+
+[ Upstream commit e5dc5afff62f3e97e86c3643ec9fcad23de4f2d3 ]
+
+We are seeing cases where neigh_cleanup_and_release() is called by
+neigh_forced_gc() many times in a row with preemption turned off.
+When running on a low powered CPU at a low CPU frequency, this has
+been measured to keep preemption off for ~10 ms. That's not great on a
+system with HZ=1000 which expects tasks to be able to schedule in
+with ~1ms latency.
+
+Suggested-by: Douglas Anderson <dianders@chromium.org>
+Signed-off-by: Judy Hsiao <judyhsiao@chromium.org>
+Reviewed-by: David Ahern <dsahern@kernel.org>
+Reviewed-by: Eric Dumazet <edumazet@google.com>
+Reviewed-by: Douglas Anderson <dianders@chromium.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ net/core/neighbour.c | 9 ++++++++-
+ 1 file changed, 8 insertions(+), 1 deletion(-)
+
+--- a/net/core/neighbour.c
++++ b/net/core/neighbour.c
+@@ -253,9 +253,11 @@ static int neigh_forced_gc(struct neigh_
+ {
+ 	int max_clean = atomic_read(&tbl->gc_entries) -
+ 			READ_ONCE(tbl->gc_thresh2);
++	u64 tmax = ktime_get_ns() + NSEC_PER_MSEC;
+ 	unsigned long tref = jiffies - 5 * HZ;
+ 	struct neighbour *n, *tmp;
+ 	int shrunk = 0;
++	int loop = 0;
+ 
+ 	NEIGH_CACHE_STAT_INC(tbl, forced_gc_runs);
+ 
+@@ -278,11 +280,16 @@ static int neigh_forced_gc(struct neigh_
+ 				shrunk++;
+ 			if (shrunk >= max_clean)
+ 				break;
++			if (++loop == 16) {
++				if (ktime_get_ns() > tmax)
++					goto unlock;
++				loop = 0;
++			}
+ 		}
+ 	}
+ 
+ 	WRITE_ONCE(tbl->last_flush, jiffies);
+-
++unlock:
+ 	write_unlock_bh(&tbl->lock);
+ 
+ 	return shrunk;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-050-platform-x86-intel-vbtn-Fix-missing-tablet-mode-swit.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-050-platform-x86-intel-vbtn-Fix-missing-tablet-mode-swit.patch
new file mode 100644
index 0000000000..71565d9e66
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-050-platform-x86-intel-vbtn-Fix-missing-tablet-mode-swit.patch
@@ -0,0 +1,93 @@
+From 1e947e77527fdb7eb33934d513f53a7e56660056 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Mon, 4 Dec 2023 16:06:01 +0100
+Subject: [PATCH] platform/x86: intel-vbtn: Fix missing tablet-mode-switch
+ events
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+[ Upstream commit 14c200b7ca46b9a9f4af9e81d258a58274320b6f ]
+
+2 issues have been reported on the Dell Inspiron 7352:
+
+1. Sometimes the tablet-mode-switch stops reporting tablet-mode
+   change events.
+
+   Add a "VBDL" call to notify_handler() to work around this.
+
+2. Sometimes the tablet-mode is incorrect after suspend/resume
+
+   Add a detect_tablet_mode() to resume() to fix this.
+
+Reported-by: Arnold Gozum <arngozum@gmail.com>
+Closes: https://lore.kernel.org/platform-driver-x86/87271a74-c831-4eec-b7a4-1371d0e42471@gmail.com/
+Tested-by: Arnold Gozum <arngozum@gmail.com>
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Reviewed-by: Andy Shevchenko <andy@kernel.org>
+Link: https://lore.kernel.org/r/20231204150601.46976-1-hdegoede@redhat.com
+Reviewed-by: Ilpo Jrvinen <ilpo.jarvinen@linux.intel.com>
+Signed-off-by: Ilpo Jrvinen <ilpo.jarvinen@linux.intel.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/platform/x86/intel/vbtn.c | 19 +++++++++++++++----
+ 1 file changed, 15 insertions(+), 4 deletions(-)
+
+--- a/drivers/platform/x86/intel/vbtn.c
++++ b/drivers/platform/x86/intel/vbtn.c
+@@ -73,10 +73,10 @@ struct intel_vbtn_priv {
+ 	bool wakeup_mode;
+ };
+ 
+-static void detect_tablet_mode(struct platform_device *device)
++static void detect_tablet_mode(struct device *dev)
+ {
+-	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
+-	acpi_handle handle = ACPI_HANDLE(&device->dev);
++	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
++	acpi_handle handle = ACPI_HANDLE(dev);
+ 	unsigned long long vgbs;
+ 	acpi_status status;
+ 	int m;
+@@ -89,6 +89,8 @@ static void detect_tablet_mode(struct pl
+ 	input_report_switch(priv->switches_dev, SW_TABLET_MODE, m);
+ 	m = (vgbs & VGBS_DOCK_MODE_FLAG) ? 1 : 0;
+ 	input_report_switch(priv->switches_dev, SW_DOCK, m);
++
++	input_sync(priv->switches_dev);
+ }
+ 
+ /*
+@@ -134,7 +136,7 @@ static int intel_vbtn_input_setup(struct
+ 	priv->switches_dev->id.bustype = BUS_HOST;
+ 
+ 	if (priv->has_switches) {
+-		detect_tablet_mode(device);
++		detect_tablet_mode(&device->dev);
+ 
+ 		ret = input_register_device(priv->switches_dev);
+ 		if (ret)
+@@ -198,6 +200,9 @@ static void notify_handler(acpi_handle h
+ 	autorelease = val && (!ke_rel || ke_rel->type == KE_IGNORE);
+ 
+ 	sparse_keymap_report_event(input_dev, event, val, autorelease);
++
++	/* Some devices need this to report further events */
++	acpi_evaluate_object(handle, "VBDL", NULL, NULL);
+ }
+ 
+ /*
+@@ -358,7 +363,13 @@ static void intel_vbtn_pm_complete(struc
+ 
+ static int intel_vbtn_pm_resume(struct device *dev)
+ {
++	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
++
+ 	intel_vbtn_pm_complete(dev);
++
++	if (priv->has_switches)
++		detect_tablet_mode(dev);
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-051-jbd2-fix-soft-lockup-in-journal_finish_inode_data_bu.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-051-jbd2-fix-soft-lockup-in-journal_finish_inode_data_bu.patch
new file mode 100644
index 0000000000..6f47289b84
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-051-jbd2-fix-soft-lockup-in-journal_finish_inode_data_bu.patch
@@ -0,0 +1,75 @@
+From 4514f70e9c90f59dcf3f0aa5463e383efe9f9d9f Mon Sep 17 00:00:00 2001
+From: Ye Bin <yebin10@huawei.com>
+Date: Mon, 11 Dec 2023 19:25:44 +0800
+Subject: [PATCH] jbd2: fix soft lockup in journal_finish_inode_data_buffers()
+
+[ Upstream commit 6c02757c936063f0631b4e43fe156f8c8f1f351f ]
+
+There's issue when do io test:
+WARN: soft lockup - CPU#45 stuck for 11s! [jbd2/dm-2-8:4170]
+CPU: 45 PID: 4170 Comm: jbd2/dm-2-8 Kdump: loaded Tainted: G  OE
+Call trace:
+ dump_backtrace+0x0/0x1a0
+ show_stack+0x24/0x30
+ dump_stack+0xb0/0x100
+ watchdog_timer_fn+0x254/0x3f8
+ __hrtimer_run_queues+0x11c/0x380
+ hrtimer_interrupt+0xfc/0x2f8
+ arch_timer_handler_phys+0x38/0x58
+ handle_percpu_devid_irq+0x90/0x248
+ generic_handle_irq+0x3c/0x58
+ __handle_domain_irq+0x68/0xc0
+ gic_handle_irq+0x90/0x320
+ el1_irq+0xcc/0x180
+ queued_spin_lock_slowpath+0x1d8/0x320
+ jbd2_journal_commit_transaction+0x10f4/0x1c78 [jbd2]
+ kjournald2+0xec/0x2f0 [jbd2]
+ kthread+0x134/0x138
+ ret_from_fork+0x10/0x18
+
+Analyzed informations from vmcore as follows:
+(1) There are about 5k+ jbd2_inode in 'commit_transaction->t_inode_list';
+(2) Now is processing the 855th jbd2_inode;
+(3) JBD2 task has TIF_NEED_RESCHED flag;
+(4) There's no pags in address_space around the 855th jbd2_inode;
+(5) There are some process is doing drop caches;
+(6) Mounted with 'nodioread_nolock' option;
+(7) 128 CPUs;
+
+According to informations from vmcore we know 'journal->j_list_lock' spin lock
+competition is fierce. So journal_finish_inode_data_buffers() maybe process
+slowly. Theoretically, there is scheduling point in the filemap_fdatawait_range_keep_errors().
+However, if inode's address_space has no pages which taged with PAGECACHE_TAG_WRITEBACK,
+will not call cond_resched(). So may lead to soft lockup.
+journal_finish_inode_data_buffers
+  filemap_fdatawait_range_keep_errors
+    __filemap_fdatawait_range
+      while (index <= end)
+        nr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index, end, PAGECACHE_TAG_WRITEBACK);
+        if (!nr_pages)
+           break;    --> If 'nr_pages' is equal zero will break, then will not call cond_resched()
+        for (i = 0; i < nr_pages; i++)
+          wait_on_page_writeback(page);
+        cond_resched();
+
+To solve above issue, add scheduling point in the journal_finish_inode_data_buffers();
+
+Signed-off-by: Ye Bin <yebin10@huawei.com>
+Reviewed-by: Jan Kara <jack@suse.cz>
+Link: https://lore.kernel.org/r/20231211112544.3879780-1-yebin10@huawei.com
+Signed-off-by: Theodore Ts'o <tytso@mit.edu>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ fs/jbd2/commit.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/fs/jbd2/commit.c
++++ b/fs/jbd2/commit.c
+@@ -300,6 +300,7 @@ static int journal_finish_inode_data_buf
+ 			if (!ret)
+ 				ret = err;
+ 		}
++		cond_resched();
+ 		spin_lock(&journal->j_list_lock);
+ 		jinode->i_flags &= ~JI_COMMIT_RUNNING;
+ 		smp_mb();
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-052-tracing-Have-large-events-show-up-as-LINE-TOO-BIG-in.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-052-tracing-Have-large-events-show-up-as-LINE-TOO-BIG-in.patch
new file mode 100644
index 0000000000..72e9ce2ffd
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-052-tracing-Have-large-events-show-up-as-LINE-TOO-BIG-in.patch
@@ -0,0 +1,72 @@
+From 724ac47c05d2aa22f0d9a683bb4bc4f0b5c0bbf3 Mon Sep 17 00:00:00 2001
+From: "Steven Rostedt (Google)" <rostedt@goodmis.org>
+Date: Sat, 9 Dec 2023 17:10:58 -0500
+Subject: [PATCH] tracing: Have large events show up as '[LINE TOO BIG]'
+ instead of nothing
+
+[ Upstream commit b55b0a0d7c4aa2dac3579aa7e6802d1f57445096 ]
+
+If a large event was added to the ring buffer that is larger than what the
+trace_seq can handle, it just drops the output:
+
+ ~# cat /sys/kernel/tracing/trace
+ # tracer: nop
+ #
+ # entries-in-buffer/entries-written: 2/2   #P:8
+ #
+ #                                _-----=> irqs-off/BH-disabled
+ #                               / _----=> need-resched
+ #                              | / _---=> hardirq/softirq
+ #                              || / _--=> preempt-depth
+ #                              ||| / _-=> migrate-disable
+ #                              |||| /     delay
+ #           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
+ #              | |         |   |||||     |         |
+            <...>-859     [001] .....   141.118951: tracing_mark_write           <...>-859     [001] .....   141.148201: tracing_mark_write: 78901234
+
+Instead, catch this case and add some context:
+
+ ~# cat /sys/kernel/tracing/trace
+ # tracer: nop
+ #
+ # entries-in-buffer/entries-written: 2/2   #P:8
+ #
+ #                                _-----=> irqs-off/BH-disabled
+ #                               / _----=> need-resched
+ #                              | / _---=> hardirq/softirq
+ #                              || / _--=> preempt-depth
+ #                              ||| / _-=> migrate-disable
+ #                              |||| /     delay
+ #           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
+ #              | |         |   |||||     |         |
+            <...>-852     [001] .....   121.550551: tracing_mark_write[LINE TOO BIG]
+            <...>-852     [001] .....   121.550581: tracing_mark_write: 78901234
+
+This now emulates the same output as trace_pipe.
+
+Link: https://lore.kernel.org/linux-trace-kernel/20231209171058.78c1a026@gandalf.local.home
+
+Cc: Mark Rutland <mark.rutland@arm.com>
+Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
+Reviewed-by: Masami Hiramatsu (Google) <mhiramat@kernel.org>
+Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ kernel/trace/trace.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/kernel/trace/trace.c
++++ b/kernel/trace/trace.c
+@@ -4679,7 +4679,11 @@ static int s_show(struct seq_file *m, vo
+ 		iter->leftover = ret;
+ 
+ 	} else {
+-		print_trace_line(iter);
++		ret = print_trace_line(iter);
++		if (ret == TRACE_TYPE_PARTIAL_LINE) {
++			iter->seq.full = 0;
++			trace_seq_puts(&iter->seq, "[LINE TOO BIG]\n");
++		}
+ 		ret = trace_print_seq(m, &iter->seq);
+ 		/*
+ 		 * If we overflow the seq_file buffer, then it will
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-053-tracing-Add-size-check-when-printing-trace_marker-ou.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-053-tracing-Add-size-check-when-printing-trace_marker-ou.patch
new file mode 100644
index 0000000000..0b35be54ee
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-053-tracing-Add-size-check-when-printing-trace_marker-ou.patch
@@ -0,0 +1,60 @@
+From 6088107b64e773bef123c3a54cf8d06eef22e916 Mon Sep 17 00:00:00 2001
+From: "Steven Rostedt (Google)" <rostedt@goodmis.org>
+Date: Tue, 12 Dec 2023 08:44:44 -0500
+Subject: [PATCH] tracing: Add size check when printing trace_marker output
+
+[ Upstream commit 60be76eeabb3d83858cc6577fc65c7d0f36ffd42 ]
+
+If for some reason the trace_marker write does not have a nul byte for the
+string, it will overflow the print:
+
+  trace_seq_printf(s, ": %s", field->buf);
+
+The field->buf could be missing the nul byte. To prevent overflow, add the
+max size that the buf can be by using the event size and the field
+location.
+
+  int max = iter->ent_size - offsetof(struct print_entry, buf);
+
+  trace_seq_printf(s, ": %*.s", max, field->buf);
+
+Link: https://lore.kernel.org/linux-trace-kernel/20231212084444.4619b8ce@gandalf.local.home
+
+Cc: Mark Rutland <mark.rutland@arm.com>
+Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
+Reviewed-by: Masami Hiramatsu (Google) <mhiramat@kernel.org>
+Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ kernel/trace/trace_output.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
+
+--- a/kernel/trace/trace_output.c
++++ b/kernel/trace/trace_output.c
+@@ -1445,11 +1445,12 @@ static enum print_line_t trace_print_pri
+ {
+ 	struct print_entry *field;
+ 	struct trace_seq *s = &iter->seq;
++	int max = iter->ent_size - offsetof(struct print_entry, buf);
+ 
+ 	trace_assign_type(field, iter->ent);
+ 
+ 	seq_print_ip_sym(s, field->ip, flags);
+-	trace_seq_printf(s, ": %s", field->buf);
++	trace_seq_printf(s, ": %.*s", max, field->buf);
+ 
+ 	return trace_handle_return(s);
+ }
+@@ -1458,10 +1459,11 @@ static enum print_line_t trace_print_raw
+ 					 struct trace_event *event)
+ {
+ 	struct print_entry *field;
++	int max = iter->ent_size - offsetof(struct print_entry, buf);
+ 
+ 	trace_assign_type(field, iter->ent);
+ 
+-	trace_seq_printf(&iter->seq, "# %lx %s", field->ip, field->buf);
++	trace_seq_printf(&iter->seq, "# %lx %.*s", field->ip, max, field->buf);
+ 
+ 	return trace_handle_return(&iter->seq);
+ }
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-054-stmmac-dwmac-loongson-drop-useless-check-for-compati.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-054-stmmac-dwmac-loongson-drop-useless-check-for-compati.patch
new file mode 100644
index 0000000000..f3528ece8e
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-054-stmmac-dwmac-loongson-drop-useless-check-for-compati.patch
@@ -0,0 +1,38 @@
+From 00b016bba7eea7a7d2610d3ce5a5221946221bb2 Mon Sep 17 00:00:00 2001
+From: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Date: Mon, 11 Dec 2023 18:33:53 +0800
+Subject: [PATCH] stmmac: dwmac-loongson: drop useless check for compatible
+ fallback
+
+[ Upstream commit 31fea092c6f9f8fb2c40a08137907f5fbeae55dd ]
+
+Device binds to proper PCI ID (LOONGSON, 0x7a03), already listed in DTS,
+so checking for some other compatible does not make sense.  It cannot be
+bound to unsupported platform.
+
+Drop useless, incorrect (space in between) and undocumented compatible.
+
+Signed-off-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Yanteng Si <siyanteng@loongson.cn>
+Reviewed-by: Conor Dooley <conor.dooley@microchip.com>
+Acked-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/net/ethernet/stmicro/stmmac/dwmac-loongson.c | 5 -----
+ 1 file changed, 5 deletions(-)
+
+--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-loongson.c
++++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-loongson.c
+@@ -59,11 +59,6 @@ static int loongson_dwmac_probe(struct p
+ 		return -ENODEV;
+ 	}
+ 
+-	if (!of_device_is_compatible(np, "loongson, pci-gmac")) {
+-		pr_info("dwmac_loongson_pci: Incompatible OF node\n");
+-		return -ENODEV;
+-	}
+-
+ 	plat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);
+ 	if (!plat)
+ 		return -ENOMEM;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-055-MIPS-dts-loongson-drop-incorrect-dwmac-fallback-comp.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-055-MIPS-dts-loongson-drop-incorrect-dwmac-fallback-comp.patch
new file mode 100644
index 0000000000..d8e5ef319d
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-055-MIPS-dts-loongson-drop-incorrect-dwmac-fallback-comp.patch
@@ -0,0 +1,48 @@
+From d58b2c4067d4a084383edfd0e032958b8793b107 Mon Sep 17 00:00:00 2001
+From: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Date: Mon, 11 Dec 2023 18:33:54 +0800
+Subject: [PATCH] MIPS: dts: loongson: drop incorrect dwmac fallback compatible
+
+[ Upstream commit 4907a3f54b12b8209864572a312cf967befcae80 ]
+
+Device binds to proper PCI ID (LOONGSON, 0x7a03), already listed in DTS,
+so checking for some other compatible does not make sense.  It cannot be
+bound to unsupported platform.
+
+Drop useless, incorrect (space in between) and undocumented compatible.
+
+Signed-off-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Yanteng Si <siyanteng@loongson.cn>
+Reviewed-by: Conor Dooley <conor.dooley@microchip.com>
+Acked-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ arch/mips/boot/dts/loongson/loongson64-2k1000.dtsi | 3 +--
+ arch/mips/boot/dts/loongson/ls7a-pch.dtsi          | 3 +--
+ 2 files changed, 2 insertions(+), 4 deletions(-)
+
+--- a/arch/mips/boot/dts/loongson/loongson64-2k1000.dtsi
++++ b/arch/mips/boot/dts/loongson/loongson64-2k1000.dtsi
+@@ -123,8 +123,7 @@
+ 				compatible = "pci0014,7a03.0",
+ 						   "pci0014,7a03",
+ 						   "pciclass0c0320",
+-						   "pciclass0c03",
+-						   "loongson, pci-gmac";
++						   "pciclass0c03";
+ 
+ 				reg = <0x1800 0x0 0x0 0x0 0x0>;
+ 				interrupts = <12 IRQ_TYPE_LEVEL_LOW>,
+--- a/arch/mips/boot/dts/loongson/ls7a-pch.dtsi
++++ b/arch/mips/boot/dts/loongson/ls7a-pch.dtsi
+@@ -186,8 +186,7 @@
+ 				compatible = "pci0014,7a03.0",
+ 						   "pci0014,7a03",
+ 						   "pciclass020000",
+-						   "pciclass0200",
+-						   "loongson, pci-gmac";
++						   "pciclass0200";
+ 
+ 				reg = <0x1800 0x0 0x0 0x0 0x0>;
+ 				interrupts = <12 IRQ_TYPE_LEVEL_HIGH>,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-056-tracing-Fix-uaf-issue-when-open-the-hist-or-hist_deb.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-056-tracing-Fix-uaf-issue-when-open-the-hist-or-hist_deb.patch
new file mode 100644
index 0000000000..547676944b
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-056-tracing-Fix-uaf-issue-when-open-the-hist-or-hist_deb.patch
@@ -0,0 +1,169 @@
+From 209b41d32812bce7c2030d81ae1c63c6ed54918f Mon Sep 17 00:00:00 2001
+From: Zheng Yejian <zhengyejian1@huawei.com>
+Date: Thu, 14 Dec 2023 09:21:53 +0800
+Subject: [PATCH] tracing: Fix uaf issue when open the hist or hist_debug file
+
+[ Upstream commit 1cc111b9cddc71ce161cd388f11f0e9048edffdb ]
+
+KASAN report following issue. The root cause is when opening 'hist'
+file of an instance and accessing 'trace_event_file' in hist_show(),
+but 'trace_event_file' has been freed due to the instance being removed.
+'hist_debug' file has the same problem. To fix it, call
+tracing_{open,release}_file_tr() in file_operations callback to have
+the ref count and avoid 'trace_event_file' being freed.
+
+  BUG: KASAN: slab-use-after-free in hist_show+0x11e0/0x1278
+  Read of size 8 at addr ffff242541e336b8 by task head/190
+
+  CPU: 4 PID: 190 Comm: head Not tainted 6.7.0-rc5-g26aff849438c #133
+  Hardware name: linux,dummy-virt (DT)
+  Call trace:
+   dump_backtrace+0x98/0xf8
+   show_stack+0x1c/0x30
+   dump_stack_lvl+0x44/0x58
+   print_report+0xf0/0x5a0
+   kasan_report+0x80/0xc0
+   __asan_report_load8_noabort+0x1c/0x28
+   hist_show+0x11e0/0x1278
+   seq_read_iter+0x344/0xd78
+   seq_read+0x128/0x1c0
+   vfs_read+0x198/0x6c8
+   ksys_read+0xf4/0x1e0
+   __arm64_sys_read+0x70/0xa8
+   invoke_syscall+0x70/0x260
+   el0_svc_common.constprop.0+0xb0/0x280
+   do_el0_svc+0x44/0x60
+   el0_svc+0x34/0x68
+   el0t_64_sync_handler+0xb8/0xc0
+   el0t_64_sync+0x168/0x170
+
+  Allocated by task 188:
+   kasan_save_stack+0x28/0x50
+   kasan_set_track+0x28/0x38
+   kasan_save_alloc_info+0x20/0x30
+   __kasan_slab_alloc+0x6c/0x80
+   kmem_cache_alloc+0x15c/0x4a8
+   trace_create_new_event+0x84/0x348
+   __trace_add_new_event+0x18/0x88
+   event_trace_add_tracer+0xc4/0x1a0
+   trace_array_create_dir+0x6c/0x100
+   trace_array_create+0x2e8/0x568
+   instance_mkdir+0x48/0x80
+   tracefs_syscall_mkdir+0x90/0xe8
+   vfs_mkdir+0x3c4/0x610
+   do_mkdirat+0x144/0x200
+   __arm64_sys_mkdirat+0x8c/0xc0
+   invoke_syscall+0x70/0x260
+   el0_svc_common.constprop.0+0xb0/0x280
+   do_el0_svc+0x44/0x60
+   el0_svc+0x34/0x68
+   el0t_64_sync_handler+0xb8/0xc0
+   el0t_64_sync+0x168/0x170
+
+  Freed by task 191:
+   kasan_save_stack+0x28/0x50
+   kasan_set_track+0x28/0x38
+   kasan_save_free_info+0x34/0x58
+   __kasan_slab_free+0xe4/0x158
+   kmem_cache_free+0x19c/0x508
+   event_file_put+0xa0/0x120
+   remove_event_file_dir+0x180/0x320
+   event_trace_del_tracer+0xb0/0x180
+   __remove_instance+0x224/0x508
+   instance_rmdir+0x44/0x78
+   tracefs_syscall_rmdir+0xbc/0x140
+   vfs_rmdir+0x1cc/0x4c8
+   do_rmdir+0x220/0x2b8
+   __arm64_sys_unlinkat+0xc0/0x100
+   invoke_syscall+0x70/0x260
+   el0_svc_common.constprop.0+0xb0/0x280
+   do_el0_svc+0x44/0x60
+   el0_svc+0x34/0x68
+   el0t_64_sync_handler+0xb8/0xc0
+   el0t_64_sync+0x168/0x170
+
+Link: https://lore.kernel.org/linux-trace-kernel/20231214012153.676155-1-zhengyejian1@huawei.com
+
+Suggested-by: Steven Rostedt <rostedt@goodmis.org>
+Signed-off-by: Zheng Yejian <zhengyejian1@huawei.com>
+Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ kernel/trace/trace.c             |  6 ++++++
+ kernel/trace/trace.h             |  1 +
+ kernel/trace/trace_events_hist.c | 12 ++++++++----
+ 3 files changed, 15 insertions(+), 4 deletions(-)
+
+--- a/kernel/trace/trace.c
++++ b/kernel/trace/trace.c
+@@ -4916,6 +4916,12 @@ int tracing_release_file_tr(struct inode
+ 	return 0;
+ }
+ 
++int tracing_single_release_file_tr(struct inode *inode, struct file *filp)
++{
++	tracing_release_file_tr(inode, filp);
++	return single_release(inode, filp);
++}
++
+ static int tracing_mark_open(struct inode *inode, struct file *filp)
+ {
+ 	stream_open(inode, filp);
+--- a/kernel/trace/trace.h
++++ b/kernel/trace/trace.h
+@@ -592,6 +592,7 @@ int tracing_open_generic(struct inode *i
+ int tracing_open_generic_tr(struct inode *inode, struct file *filp);
+ int tracing_open_file_tr(struct inode *inode, struct file *filp);
+ int tracing_release_file_tr(struct inode *inode, struct file *filp);
++int tracing_single_release_file_tr(struct inode *inode, struct file *filp);
+ bool tracing_is_disabled(void);
+ bool tracer_tracing_is_on(struct trace_array *tr);
+ void tracer_tracing_on(struct trace_array *tr);
+--- a/kernel/trace/trace_events_hist.c
++++ b/kernel/trace/trace_events_hist.c
+@@ -5532,10 +5532,12 @@ static int event_hist_open(struct inode
+ {
+ 	int ret;
+ 
+-	ret = security_locked_down(LOCKDOWN_TRACEFS);
++	ret = tracing_open_file_tr(inode, file);
+ 	if (ret)
+ 		return ret;
+ 
++	/* Clear private_data to avoid warning in single_open() */
++	file->private_data = NULL;
+ 	return single_open(file, hist_show, file);
+ }
+ 
+@@ -5543,7 +5545,7 @@ const struct file_operations event_hist_
+ 	.open = event_hist_open,
+ 	.read = seq_read,
+ 	.llseek = seq_lseek,
+-	.release = single_release,
++	.release = tracing_single_release_file_tr,
+ };
+ 
+ #ifdef CONFIG_HIST_TRIGGERS_DEBUG
+@@ -5809,10 +5811,12 @@ static int event_hist_debug_open(struct
+ {
+ 	int ret;
+ 
+-	ret = security_locked_down(LOCKDOWN_TRACEFS);
++	ret = tracing_open_file_tr(inode, file);
+ 	if (ret)
+ 		return ret;
+ 
++	/* Clear private_data to avoid warning in single_open() */
++	file->private_data = NULL;
+ 	return single_open(file, hist_debug_show, file);
+ }
+ 
+@@ -5820,7 +5824,7 @@ const struct file_operations event_hist_
+ 	.open = event_hist_debug_open,
+ 	.read = seq_read,
+ 	.llseek = seq_lseek,
+-	.release = single_release,
++	.release = tracing_single_release_file_tr,
+ };
+ #endif
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-057-ring-buffer-Do-not-record-in-NMI-if-the-arch-does-no.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-057-ring-buffer-Do-not-record-in-NMI-if-the-arch-does-no.patch
new file mode 100644
index 0000000000..82eab559c4
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-057-ring-buffer-Do-not-record-in-NMI-if-the-arch-does-no.patch
@@ -0,0 +1,38 @@
+From 74dbb0ef21e64d4b6a4a10e612eb62bbc3dfd7ce Mon Sep 17 00:00:00 2001
+From: "Steven Rostedt (Google)" <rostedt@goodmis.org>
+Date: Wed, 13 Dec 2023 17:54:03 -0500
+Subject: [PATCH] ring-buffer: Do not record in NMI if the arch does not
+ support cmpxchg in NMI
+
+[ Upstream commit 712292308af2265cd9b126aedfa987f10f452a33 ]
+
+As the ring buffer recording requires cmpxchg() to work, if the
+architecture does not support cmpxchg in NMI, then do not do any recording
+within an NMI.
+
+Link: https://lore.kernel.org/linux-trace-kernel/20231213175403.6fc18540@gandalf.local.home
+
+Cc: Masami Hiramatsu <mhiramat@kernel.org>
+Cc: Mark Rutland <mark.rutland@arm.com>
+Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
+Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ kernel/trace/ring_buffer.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/kernel/trace/ring_buffer.c
++++ b/kernel/trace/ring_buffer.c
+@@ -3644,6 +3644,12 @@ rb_reserve_next_event(struct trace_buffe
+ 	int nr_loops = 0;
+ 	int add_ts_default;
+ 
++	/* ring buffer does cmpxchg, make sure it is safe in NMI context */
++	if (!IS_ENABLED(CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG) &&
++	    (unlikely(in_nmi()))) {
++		return NULL;
++	}
++
+ 	rb_start_commit(cpu_buffer);
+ 	/* The commit page can not change after this */
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-058-Input-psmouse-enable-Synaptics-InterTouch-for-ThinkP.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-058-Input-psmouse-enable-Synaptics-InterTouch-for-ThinkP.patch
new file mode 100644
index 0000000000..4b6aaf1387
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-058-Input-psmouse-enable-Synaptics-InterTouch-for-ThinkP.patch
@@ -0,0 +1,43 @@
+From b82421d2f4d298bcf46cb0c12ca4cd51362c95fd Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Jos=C3=A9=20Pekkarinen?= <jose.pekkarinen@foxhound.fi>
+Date: Wed, 15 Nov 2023 16:50:23 +0000
+Subject: [PATCH] Input: psmouse - enable Synaptics InterTouch for ThinkPad L14
+ G1
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+[ Upstream commit c1f342f35f820b33390571293498c3e2e9bc77ec ]
+
+Observed on dmesg of my laptop I see the following
+output:
+
+[   19.898700] psmouse serio1: synaptics: queried max coordinates: x [..5678], y [..4694]
+[   19.936057] psmouse serio1: synaptics: queried min coordinates: x [1266..], y [1162..]
+[   19.936076] psmouse serio1: synaptics: Your touchpad (PNP: LEN0411 PNP0f13) says it can support a different bus. If i2c-hid and hid-rmi are not used, you might want to try setting psmouse.synaptics_intertouch to 1 and report this to linux-input@vger.kernel.org.
+[   20.008901] psmouse serio1: synaptics: Touchpad model: 1, fw: 10.32, id: 0x1e2a1, caps: 0xf014a3/0x940300/0x12e800/0x500000, board id: 3471, fw id: 2909640
+[   20.008925] psmouse serio1: synaptics: serio: Synaptics pass-through port at isa0060/serio1/input0
+[   20.053344] input: SynPS/2 Synaptics TouchPad as /devices/platform/i8042/serio1/input/input7
+[   20.397608] mousedev: PS/2 mouse device common for all mice
+
+This patch will add its pnp id to the smbus list to
+produce the setup of intertouch for the device.
+
+Signed-off-by: Jos Pekkarinen <jose.pekkarinen@foxhound.fi>
+Link: https://lore.kernel.org/r/20231114063607.71772-1-jose.pekkarinen@foxhound.fi
+Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/input/mouse/synaptics.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/input/mouse/synaptics.c
++++ b/drivers/input/mouse/synaptics.c
+@@ -183,6 +183,7 @@ static const char * const smbus_pnp_ids[
+ 	"LEN009b", /* T580 */
+ 	"LEN0402", /* X1 Extreme Gen 2 / P1 Gen 2 */
+ 	"LEN040f", /* P1 Gen 3 */
++	"LEN0411", /* L14 Gen 1 */
+ 	"LEN200f", /* T450s */
+ 	"LEN2044", /* L470  */
+ 	"LEN2054", /* E480 */
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-059-reset-hisilicon-hi6220-fix-Wvoid-pointer-to-enum-cas.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-059-reset-hisilicon-hi6220-fix-Wvoid-pointer-to-enum-cas.patch
new file mode 100644
index 0000000000..ff497435ef
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-059-reset-hisilicon-hi6220-fix-Wvoid-pointer-to-enum-cas.patch
@@ -0,0 +1,32 @@
+From cce1ebcd60b669485b8fad76416bc2921254ea2b Mon Sep 17 00:00:00 2001
+From: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Date: Thu, 10 Aug 2023 11:13:00 +0200
+Subject: [PATCH] reset: hisilicon: hi6220: fix Wvoid-pointer-to-enum-cast
+ warning
+
+[ Upstream commit b5ec294472794ed9ecba0cb4b8208372842e7e0d ]
+
+'type' is an enum, thus cast of pointer on 64-bit compile test with W=1
+causes:
+
+  hi6220_reset.c:166:9: error: cast to smaller integer type 'enum hi6220_reset_ctrl_type' from 'const void *' [-Werror,-Wvoid-pointer-to-enum-cast]
+
+Signed-off-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Link: https://lore.kernel.org/r/20230810091300.70197-1-krzysztof.kozlowski@linaro.org
+Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/reset/hisilicon/hi6220_reset.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/reset/hisilicon/hi6220_reset.c
++++ b/drivers/reset/hisilicon/hi6220_reset.c
+@@ -164,7 +164,7 @@ static int hi6220_reset_probe(struct pla
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+-	type = (enum hi6220_reset_ctrl_type)of_device_get_match_data(dev);
++	type = (uintptr_t)of_device_get_match_data(dev);
+ 
+ 	regmap = syscon_node_to_regmap(np);
+ 	if (IS_ERR(regmap)) {
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-060-Input-atkbd-skip-ATKBD_CMD_GETID-in-translated-mode.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-060-Input-atkbd-skip-ATKBD_CMD_GETID-in-translated-mode.patch
new file mode 100644
index 0000000000..f6e21cdb06
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-060-Input-atkbd-skip-ATKBD_CMD_GETID-in-translated-mode.patch
@@ -0,0 +1,119 @@
+From 32f0da9ee1e073fd0501fa64b22d156ac40150b9 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Fri, 24 Nov 2023 19:59:24 -0800
+Subject: [PATCH] Input: atkbd - skip ATKBD_CMD_GETID in translated mode
+
+[ Upstream commit 936e4d49ecbc8c404790504386e1422b599dec39 ]
+
+There have been multiple reports of keyboard issues on recent laptop models
+which can be worked around by setting i8042.dumbkbd, with the downside
+being this breaks the capslock LED.
+
+It seems that these issues are caused by recent laptops getting confused by
+ATKBD_CMD_GETID. Rather then adding and endless growing list of quirks for
+this, just skip ATKBD_CMD_GETID alltogether on laptops in translated mode.
+
+The main goal of sending ATKBD_CMD_GETID is to skip binding to ps/2
+mice/touchpads and those are never used in translated mode.
+
+Examples of laptop models which benefit from skipping ATKBD_CMD_GETID:
+
+* "HP Laptop 15s-fq2xxx", "HP laptop 15s-fq4xxx" and "HP Laptop 15-dy2xxx"
+  models the kbd stops working for the first 2 - 5 minutes after boot
+  (waiting for EC watchdog reset?)
+
+* On "HP Spectre x360 13-aw2xxx" atkbd fails to probe the keyboard
+
+* At least 9 different Lenovo models have issues with ATKBD_CMD_GETID, see:
+  https://github.com/yescallop/atkbd-nogetid
+
+This has been tested on:
+
+1. A MSI B550M PRO-VDH WIFI desktop, where the i8042 controller is not
+   in translated mode when no keyboard is plugged in and with a ps/2 kbd
+   a "AT Translated Set 2 keyboard" /dev/input/event# node shows up
+
+2. A Lenovo ThinkPad X1 Yoga gen 8 (always has a translated set 2 keyboard)
+
+Reported-by: Shang Ye <yesh25@mail2.sysu.edu.cn>
+Closes: https://lore.kernel.org/linux-input/886D6167733841AE+20231017135318.11142-1-yesh25@mail2.sysu.edu.cn/
+Closes: https://github.com/yescallop/atkbd-nogetid
+Reported-by: gurevitch <mail@gurevit.ch>
+Closes: https://lore.kernel.org/linux-input/2iAJTwqZV6lQs26cTb38RNYqxvsink6SRmrZ5h0cBUSuf9NT0tZTsf9fEAbbto2maavHJEOP8GA1evlKa6xjKOsaskDhtJWxjcnrgPigzVo=@gurevit.ch/
+Reported-by: Egor Ignatov <egori@altlinux.org>
+Closes: https://lore.kernel.org/all/20210609073333.8425-1-egori@altlinux.org/
+Reported-by: Anton Zhilyaev <anton@cpp.in>
+Closes: https://lore.kernel.org/linux-input/20210201160336.16008-1-anton@cpp.in/
+Closes: https://bugzilla.redhat.com/show_bug.cgi?id=2086156
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Link: https://lore.kernel.org/r/20231115174625.7462-1-hdegoede@redhat.com
+Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/input/keyboard/atkbd.c | 46 +++++++++++++++++++++++++++++++---
+ 1 file changed, 42 insertions(+), 4 deletions(-)
+
+--- a/drivers/input/keyboard/atkbd.c
++++ b/drivers/input/keyboard/atkbd.c
+@@ -746,6 +746,44 @@ static void atkbd_deactivate(struct atkb
+ 			ps2dev->serio->phys);
+ }
+ 
++#ifdef CONFIG_X86
++static bool atkbd_is_portable_device(void)
++{
++	static const char * const chassis_types[] = {
++		"8",	/* Portable */
++		"9",	/* Laptop */
++		"10",	/* Notebook */
++		"14",	/* Sub-Notebook */
++		"31",	/* Convertible */
++		"32",	/* Detachable */
++	};
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(chassis_types); i++)
++		if (dmi_match(DMI_CHASSIS_TYPE, chassis_types[i]))
++			return true;
++
++	return false;
++}
++
++/*
++ * On many modern laptops ATKBD_CMD_GETID may cause problems, on these laptops
++ * the controller is always in translated mode. In this mode mice/touchpads will
++ * not work. So in this case simply assume a keyboard is connected to avoid
++ * confusing some laptop keyboards.
++ *
++ * Skipping ATKBD_CMD_GETID ends up using a fake keyboard id. Using a fake id is
++ * ok in translated mode, only atkbd_select_set() checks atkbd->id and in
++ * translated mode that is a no-op.
++ */
++static bool atkbd_skip_getid(struct atkbd *atkbd)
++{
++	return atkbd->translated && atkbd_is_portable_device();
++}
++#else
++static inline bool atkbd_skip_getid(struct atkbd *atkbd) { return false; }
++#endif
++
+ /*
+  * atkbd_probe() probes for an AT keyboard on a serio port.
+  */
+@@ -775,12 +813,12 @@ static int atkbd_probe(struct atkbd *atk
+  */
+ 
+ 	param[0] = param[1] = 0xa5;	/* initialize with invalid values */
+-	if (ps2_command(ps2dev, param, ATKBD_CMD_GETID)) {
++	if (atkbd_skip_getid(atkbd) || ps2_command(ps2dev, param, ATKBD_CMD_GETID)) {
+ 
+ /*
+- * If the get ID command failed, we check if we can at least set the LEDs on
+- * the keyboard. This should work on every keyboard out there. It also turns
+- * the LEDs off, which we want anyway.
++ * If the get ID command was skipped or failed, we check if we can at least set
++ * the LEDs on the keyboard. This should work on every keyboard out there.
++ * It also turns the LEDs off, which we want anyway.
+  */
+ 		param[0] = 0;
+ 		if (ps2_command(ps2dev, param, ATKBD_CMD_SETLEDS))
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-061-Input-i8042-add-nomux-quirk-for-Acer-P459-G2-M.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-061-Input-i8042-add-nomux-quirk-for-Acer-P459-G2-M.patch
new file mode 100644
index 0000000000..e75658fba4
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-061-Input-i8042-add-nomux-quirk-for-Acer-P459-G2-M.patch
@@ -0,0 +1,38 @@
+From 2efa67b08c5dd99aa889219ae3b6a49f3619c3a2 Mon Sep 17 00:00:00 2001
+From: Esther Shimanovich <eshimanovich@chromium.org>
+Date: Thu, 30 Nov 2023 19:56:19 +0000
+Subject: [PATCH] Input: i8042 - add nomux quirk for Acer P459-G2-M
+
+[ Upstream commit 335fe00319e030d481a54d5e0e68d50c5e672c0e ]
+
+After the laptop lid is opened, and the device resumes from S3 deep
+sleep, if the user presses a keyboard key while the screen is still black,
+the mouse and keyboard become unusable.
+
+Enabling this quirk prevents this behavior from occurring.
+
+Signed-off-by: Esther Shimanovich <eshimanovich@chromium.org>
+Link: https://lore.kernel.org/r/20231130195615.v2.1.Ibe78a9df97ecd18dc227a5cff67d3029631d9c11@changeid
+Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/input/serio/i8042-acpipnpio.h | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/drivers/input/serio/i8042-acpipnpio.h
++++ b/drivers/input/serio/i8042-acpipnpio.h
+@@ -361,6 +361,14 @@ static const struct dmi_system_id i8042_
+ 		.driver_data = (void *)(SERIO_QUIRK_DRITEK)
+ 	},
+ 	{
++		/* Acer TravelMate P459-G2-M */
++		.matches = {
++			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
++			DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate P459-G2-M"),
++		},
++		.driver_data = (void *)(SERIO_QUIRK_NOMUX)
++	},
++	{
+ 		/* Amoi M636/A737 */
+ 		.matches = {
+ 			DMI_MATCH(DMI_SYS_VENDOR, "Amoi Electronics CO.,LTD."),
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-062-s390-scm-fix-virtual-vs-physical-address-confusion.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-062-s390-scm-fix-virtual-vs-physical-address-confusion.patch
new file mode 100644
index 0000000000..091653d4a5
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-062-s390-scm-fix-virtual-vs-physical-address-confusion.patch
@@ -0,0 +1,52 @@
+From 553a02594de0b7c5d372e75ea594d7a76714df2f Mon Sep 17 00:00:00 2001
+From: Vineeth Vijayan <vneethv@linux.ibm.com>
+Date: Thu, 23 Nov 2023 22:52:53 +0100
+Subject: [PATCH] s390/scm: fix virtual vs physical address confusion
+
+[ Upstream commit b1a6a1a77f0666a5a6dc0893ab6ec8fcae46f24c ]
+
+Fix virtual vs physical address confusion (which currently are the same).
+
+Signed-off-by: Vineeth Vijayan <vneethv@linux.ibm.com>
+Reviewed-by: Peter Oberparleiter <oberpar@linux.ibm.com>
+Acked-by: Alexander Gordeev <agordeev@linux.ibm.com>
+Signed-off-by: Alexander Gordeev <agordeev@linux.ibm.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/s390/block/scm_blk.c | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+--- a/drivers/s390/block/scm_blk.c
++++ b/drivers/s390/block/scm_blk.c
+@@ -17,6 +17,7 @@
+ #include <linux/blk-mq.h>
+ #include <linux/slab.h>
+ #include <linux/list.h>
++#include <linux/io.h>
+ #include <asm/eadm.h>
+ #include "scm_blk.h"
+ 
+@@ -130,7 +131,7 @@ static void scm_request_done(struct scm_
+ 
+ 	for (i = 0; i < nr_requests_per_io && scmrq->request[i]; i++) {
+ 		msb = &scmrq->aob->msb[i];
+-		aidaw = msb->data_addr;
++		aidaw = (u64)phys_to_virt(msb->data_addr);
+ 
+ 		if ((msb->flags & MSB_FLAG_IDA) && aidaw &&
+ 		    IS_ALIGNED(aidaw, PAGE_SIZE))
+@@ -195,12 +196,12 @@ static int scm_request_prepare(struct sc
+ 	msb->scm_addr = scmdev->address + ((u64) blk_rq_pos(req) << 9);
+ 	msb->oc = (rq_data_dir(req) == READ) ? MSB_OC_READ : MSB_OC_WRITE;
+ 	msb->flags |= MSB_FLAG_IDA;
+-	msb->data_addr = (u64) aidaw;
++	msb->data_addr = (u64)virt_to_phys(aidaw);
+ 
+ 	rq_for_each_segment(bv, req, iter) {
+ 		WARN_ON(bv.bv_offset);
+ 		msb->blk_count += bv.bv_len >> 12;
+-		aidaw->data_addr = (u64) page_address(bv.bv_page);
++		aidaw->data_addr = virt_to_phys(page_address(bv.bv_page));
+ 		aidaw++;
+ 	}
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-063-ARC-fix-spare-error.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-063-ARC-fix-spare-error.patch
new file mode 100644
index 0000000000..bf6b3640ff
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-063-ARC-fix-spare-error.patch
@@ -0,0 +1,41 @@
+From 46952f982b36d0fdcee4dc60b375259a4b79a777 Mon Sep 17 00:00:00 2001
+From: Vineet Gupta <vgupta@kernel.org>
+Date: Fri, 8 Dec 2023 15:57:07 -0800
+Subject: [PATCH] ARC: fix spare error
+
+[ Upstream commit aca02d933f63ba8bc84258bf35f9ffaf6b664336 ]
+
+Reported-by: kernel test robot <lkp@intel.com>
+Closes: https://lore.kernel.org/oe-kbuild-all/202312082320.VDN5A9hb-lkp@intel.com/
+Signed-off-by: Vineet Gupta <vgupta@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ arch/arc/kernel/signal.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/arch/arc/kernel/signal.c
++++ b/arch/arc/kernel/signal.c
+@@ -61,7 +61,7 @@ struct rt_sigframe {
+ 	unsigned int sigret_magic;
+ };
+ 
+-static int save_arcv2_regs(struct sigcontext *mctx, struct pt_regs *regs)
++static int save_arcv2_regs(struct sigcontext __user *mctx, struct pt_regs *regs)
+ {
+ 	int err = 0;
+ #ifndef CONFIG_ISA_ARCOMPACT
+@@ -74,12 +74,12 @@ static int save_arcv2_regs(struct sigcon
+ #else
+ 	v2abi.r58 = v2abi.r59 = 0;
+ #endif
+-	err = __copy_to_user(&mctx->v2abi, &v2abi, sizeof(v2abi));
++	err = __copy_to_user(&mctx->v2abi, (void const *)&v2abi, sizeof(v2abi));
+ #endif
+ 	return err;
+ }
+ 
+-static int restore_arcv2_regs(struct sigcontext *mctx, struct pt_regs *regs)
++static int restore_arcv2_regs(struct sigcontext __user *mctx, struct pt_regs *regs)
+ {
+ 	int err = 0;
+ #ifndef CONFIG_ISA_ARCOMPACT
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-064-wifi-iwlwifi-pcie-avoid-a-NULL-pointer-dereference.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-064-wifi-iwlwifi-pcie-avoid-a-NULL-pointer-dereference.patch
new file mode 100644
index 0000000000..3eed7a5069
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-064-wifi-iwlwifi-pcie-avoid-a-NULL-pointer-dereference.patch
@@ -0,0 +1,32 @@
+From eea630f81429ea5a09509591920e9a93dd03af37 Mon Sep 17 00:00:00 2001
+From: Avraham Stern <avraham.stern@intel.com>
+Date: Thu, 7 Dec 2023 04:50:17 +0200
+Subject: [PATCH] wifi: iwlwifi: pcie: avoid a NULL pointer dereference
+
+[ Upstream commit ce038edfce43fb345f8dfdca0f7b17f535896701 ]
+
+It possible that while the rx rb is being handled, the transport has
+been stopped and re-started. In this case the tx queue pointer is not
+yet initialized, which will lead to a NULL pointer dereference.
+Fix it.
+
+Signed-off-by: Avraham Stern <avraham.stern@intel.com>
+Signed-off-by: Miri Korenblit <miriam.rachel.korenblit@intel.com>
+Link: https://msgid.link/20231207044813.cd0898cafd89.I0b84daae753ba9612092bf383f5c6f761446e964@changeid
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/net/wireless/intel/iwlwifi/pcie/rx.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/intel/iwlwifi/pcie/rx.c
++++ b/drivers/net/wireless/intel/iwlwifi/pcie/rx.c
+@@ -1381,7 +1381,7 @@ static void iwl_pcie_rx_handle_rb(struct
+ 		 * if it is true then one of the handlers took the page.
+ 		 */
+ 
+-		if (reclaim) {
++		if (reclaim && txq) {
+ 			u16 sequence = le16_to_cpu(pkt->hdr.sequence);
+ 			int index = SEQ_TO_INDEX(sequence);
+ 			int cmd_index = iwl_txq_get_cmd_index(txq, index);
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-065-Input-xpad-add-Razer-Wolverine-V2-support.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-065-Input-xpad-add-Razer-Wolverine-V2-support.patch
new file mode 100644
index 0000000000..b7d9a686c7
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-065-Input-xpad-add-Razer-Wolverine-V2-support.patch
@@ -0,0 +1,27 @@
+From 0945026b1e75a1870199f1b65e8c1c08b97c7e2f Mon Sep 17 00:00:00 2001
+From: Luca Weiss <luca@z3ntu.xyz>
+Date: Sat, 25 Nov 2023 17:22:15 +0100
+Subject: [PATCH] Input: xpad - add Razer Wolverine V2 support
+
+[ Upstream commit c3d1610345b79cbe29ef6ca04a4780eff0d360c7 ]
+
+Add the VID and PID of Razer Wolverine V2 to xpad_device.
+
+Signed-off-by: Luca Weiss <luca@z3ntu.xyz>
+Link: https://lore.kernel.org/r/20231125-razer-wolverine-v2-v1-1-979fe9f9288e@z3ntu.xyz
+Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/input/joystick/xpad.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/input/joystick/xpad.c
++++ b/drivers/input/joystick/xpad.c
+@@ -286,6 +286,7 @@ static const struct xpad_device {
+ 	{ 0x146b, 0x0604, "Bigben Interactive DAIJA Arcade Stick", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
+ 	{ 0x1532, 0x0a00, "Razer Atrox Arcade Stick", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOXONE },
+ 	{ 0x1532, 0x0a03, "Razer Wildcat", 0, XTYPE_XBOXONE },
++	{ 0x1532, 0x0a29, "Razer Wolverine V2", 0, XTYPE_XBOXONE },
+ 	{ 0x15e4, 0x3f00, "Power A Mini Pro Elite", 0, XTYPE_XBOX360 },
+ 	{ 0x15e4, 0x3f0a, "Xbox Airflo wired controller", 0, XTYPE_XBOX360 },
+ 	{ 0x15e4, 0x3f10, "Batarang Xbox 360 controller", 0, XTYPE_XBOX360 },
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-066-kselftest-alsa-fixed-a-print-formatting-warning.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-066-kselftest-alsa-fixed-a-print-formatting-warning.patch
new file mode 100644
index 0000000000..aebaf93ecc
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-066-kselftest-alsa-fixed-a-print-formatting-warning.patch
@@ -0,0 +1,30 @@
+From 3f3b18902e7329ec5f45a4aac021f4169a1505d9 Mon Sep 17 00:00:00 2001
+From: Ghanshyam Agrawal <ghanshyam1898@gmail.com>
+Date: Sun, 17 Dec 2023 13:30:19 +0530
+Subject: [PATCH] kselftest: alsa: fixed a print formatting warning
+
+[ Upstream commit 13d605e32e4cfdedcecdf3d98d21710ffe887708 ]
+
+A statement used %d print formatter where %s should have
+been used. The same has been fixed in this commit.
+
+Signed-off-by: Ghanshyam Agrawal <ghanshyam1898@gmail.com>
+Link: 5aaf9efffc57 ("kselftest: alsa: Add simplistic test for ALSA mixer controls kselftest")
+Link: https://lore.kernel.org/r/20231217080019.1063476-1-ghanshyam1898@gmail.com
+Signed-off-by: Takashi Iwai <tiwai@suse.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ tools/testing/selftests/alsa/mixer-test.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/tools/testing/selftests/alsa/mixer-test.c
++++ b/tools/testing/selftests/alsa/mixer-test.c
+@@ -177,7 +177,7 @@ static void find_controls(void)
+ 			err = snd_ctl_elem_info(card_data->handle,
+ 						ctl_data->info);
+ 			if (err < 0) {
+-				ksft_print_msg("%s getting info for %d\n",
++				ksft_print_msg("%s getting info for %s\n",
+ 					       snd_strerror(err),
+ 					       ctl_data->name);
+ 			}
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-067-HID-nintendo-fix-initializer-element-is-not-constant.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-067-HID-nintendo-fix-initializer-element-is-not-constant.patch
new file mode 100644
index 0000000000..2a8f85b665
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-067-HID-nintendo-fix-initializer-element-is-not-constant.patch
@@ -0,0 +1,74 @@
+From d60c130f4c1557783857063a746dad33048b16bc Mon Sep 17 00:00:00 2001
+From: Ryan McClelland <rymcclel@gmail.com>
+Date: Thu, 14 Dec 2023 09:25:41 -0800
+Subject: [PATCH] HID: nintendo: fix initializer element is not constant error
+
+[ Upstream commit 0b7dd38c1c520b650a889a81919838671b689eb9 ]
+
+With gcc-7 builds, an error happens with the controller button values being
+defined as const. Change to a define.
+
+Reported-by: kernel test robot <lkp@intel.com>
+Closes: https://lore.kernel.org/oe-kbuild-all/202312141227.C2h1IzfI-lkp@intel.com/
+
+Signed-off-by: Ryan McClelland <rymcclel@gmail.com>
+Reviewed-by: Daniel J. Ogorchock <djogorchock@gmail.com>
+Signed-off-by: Jiri Kosina <jkosina@suse.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/hid/hid-nintendo.c | 44 +++++++++++++++++++-------------------
+ 1 file changed, 22 insertions(+), 22 deletions(-)
+
+--- a/drivers/hid/hid-nintendo.c
++++ b/drivers/hid/hid-nintendo.c
+@@ -325,28 +325,28 @@ struct joycon_imu_cal {
+  * All the controller's button values are stored in a u32.
+  * They can be accessed with bitwise ANDs.
+  */
+-static const u32 JC_BTN_Y	= BIT(0);
+-static const u32 JC_BTN_X	= BIT(1);
+-static const u32 JC_BTN_B	= BIT(2);
+-static const u32 JC_BTN_A	= BIT(3);
+-static const u32 JC_BTN_SR_R	= BIT(4);
+-static const u32 JC_BTN_SL_R	= BIT(5);
+-static const u32 JC_BTN_R	= BIT(6);
+-static const u32 JC_BTN_ZR	= BIT(7);
+-static const u32 JC_BTN_MINUS	= BIT(8);
+-static const u32 JC_BTN_PLUS	= BIT(9);
+-static const u32 JC_BTN_RSTICK	= BIT(10);
+-static const u32 JC_BTN_LSTICK	= BIT(11);
+-static const u32 JC_BTN_HOME	= BIT(12);
+-static const u32 JC_BTN_CAP	= BIT(13); /* capture button */
+-static const u32 JC_BTN_DOWN	= BIT(16);
+-static const u32 JC_BTN_UP	= BIT(17);
+-static const u32 JC_BTN_RIGHT	= BIT(18);
+-static const u32 JC_BTN_LEFT	= BIT(19);
+-static const u32 JC_BTN_SR_L	= BIT(20);
+-static const u32 JC_BTN_SL_L	= BIT(21);
+-static const u32 JC_BTN_L	= BIT(22);
+-static const u32 JC_BTN_ZL	= BIT(23);
++#define JC_BTN_Y	 BIT(0)
++#define JC_BTN_X	 BIT(1)
++#define JC_BTN_B	 BIT(2)
++#define JC_BTN_A	 BIT(3)
++#define JC_BTN_SR_R	 BIT(4)
++#define JC_BTN_SL_R	 BIT(5)
++#define JC_BTN_R	 BIT(6)
++#define JC_BTN_ZR	 BIT(7)
++#define JC_BTN_MINUS	 BIT(8)
++#define JC_BTN_PLUS	 BIT(9)
++#define JC_BTN_RSTICK	 BIT(10)
++#define JC_BTN_LSTICK	 BIT(11)
++#define JC_BTN_HOME	 BIT(12)
++#define JC_BTN_CAP	 BIT(13) /* capture button */
++#define JC_BTN_DOWN	 BIT(16)
++#define JC_BTN_UP	 BIT(17)
++#define JC_BTN_RIGHT	 BIT(18)
++#define JC_BTN_LEFT	 BIT(19)
++#define JC_BTN_SR_L	 BIT(20)
++#define JC_BTN_SL_L	 BIT(21)
++#define JC_BTN_L	 BIT(22)
++#define JC_BTN_ZL	 BIT(23)
+ 
+ enum joycon_msg_type {
+ 	JOYCON_MSG_TYPE_NONE,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-068-platform-x86-thinkpad_acpi-fix-for-incorrect-fan-rep.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-068-platform-x86-thinkpad_acpi-fix-for-incorrect-fan-rep.patch
new file mode 100644
index 0000000000..978ac765d6
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-068-platform-x86-thinkpad_acpi-fix-for-incorrect-fan-rep.patch
@@ -0,0 +1,245 @@
+From af3c40a35e200e59c7e5bfbc786efcceb4ec035a Mon Sep 17 00:00:00 2001
+From: Vishnu Sankar <vishnuocv@gmail.com>
+Date: Thu, 14 Dec 2023 22:47:02 +0900
+Subject: [PATCH] platform/x86: thinkpad_acpi: fix for incorrect fan reporting
+ on some ThinkPad systems
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+[ Upstream commit 66e92e23a72761f5b53f970aeb1badc5fd92fc74 ]
+
+Some ThinkPad systems ECFW use non-standard addresses for fan control
+and reporting. This patch adds support for such ECFW so that it can report
+the correct fan values.
+Tested on Thinkpads L13 Yoga Gen 2 and X13 Yoga Gen 2.
+
+Suggested-by: Mark Pearson <mpearson-lenovo@squebb.ca>
+Signed-off-by: Vishnu Sankar <vishnuocv@gmail.com>
+Reviewed-by: Hans de Goede <hdegoede@redhat.com>
+Reviewed-by: Ilpo Jrvinen <ilpo.jarvinen@linux.intel.com>
+Link: https://lore.kernel.org/r/20231214134702.166464-1-vishnuocv@gmail.com
+Signed-off-by: Ilpo Jrvinen <ilpo.jarvinen@linux.intel.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/platform/x86/thinkpad_acpi.c | 98 ++++++++++++++++++++++++----
+ 1 file changed, 85 insertions(+), 13 deletions(-)
+
+--- a/drivers/platform/x86/thinkpad_acpi.c
++++ b/drivers/platform/x86/thinkpad_acpi.c
+@@ -8149,8 +8149,19 @@ static struct ibm_struct volume_driver_d
+  * 	TPACPI_FAN_WR_TPEC is also available and should be used to
+  * 	command the fan.  The X31/X40/X41 seems to have 8 fan levels,
+  * 	but the ACPI tables just mention level 7.
++ *
++ * TPACPI_FAN_RD_TPEC_NS:
++ *	This mode is used for a few ThinkPads (L13 Yoga Gen2, X13 Yoga Gen2 etc.)
++ *	that are using non-standard EC locations for reporting fan speeds.
++ *	Currently these platforms only provide fan rpm reporting.
++ *
+  */
+ 
++#define FAN_RPM_CAL_CONST 491520	/* FAN RPM calculation offset for some non-standard ECFW */
++
++#define FAN_NS_CTRL_STATUS	BIT(2)		/* Bit which determines control is enabled or not */
++#define FAN_NS_CTRL		BIT(4)		/* Bit which determines control is by host or EC */
++
+ enum {					/* Fan control constants */
+ 	fan_status_offset = 0x2f,	/* EC register 0x2f */
+ 	fan_rpm_offset = 0x84,		/* EC register 0x84: LSB, 0x85 MSB (RPM)
+@@ -8158,6 +8169,11 @@ enum {					/* Fan control constants */
+ 	fan_select_offset = 0x31,	/* EC register 0x31 (Firmware 7M)
+ 					   bit 0 selects which fan is active */
+ 
++	fan_status_offset_ns = 0x93,	/* Special status/control offset for non-standard EC Fan1 */
++	fan2_status_offset_ns = 0x96,	/* Special status/control offset for non-standard EC Fan2 */
++	fan_rpm_status_ns = 0x95,	/* Special offset for Fan1 RPM status for non-standard EC */
++	fan2_rpm_status_ns = 0x98,	/* Special offset for Fan2 RPM status for non-standard EC */
++
+ 	TP_EC_FAN_FULLSPEED = 0x40,	/* EC fan mode: full speed */
+ 	TP_EC_FAN_AUTO	    = 0x80,	/* EC fan mode: auto fan control */
+ 
+@@ -8168,6 +8184,7 @@ enum fan_status_access_mode {
+ 	TPACPI_FAN_NONE = 0,		/* No fan status or control */
+ 	TPACPI_FAN_RD_ACPI_GFAN,	/* Use ACPI GFAN */
+ 	TPACPI_FAN_RD_TPEC,		/* Use ACPI EC regs 0x2f, 0x84-0x85 */
++	TPACPI_FAN_RD_TPEC_NS,		/* Use non-standard ACPI EC regs (eg: L13 Yoga gen2 etc.) */
+ };
+ 
+ enum fan_control_access_mode {
+@@ -8195,6 +8212,8 @@ static u8 fan_control_desired_level;
+ static u8 fan_control_resume_level;
+ static int fan_watchdog_maxinterval;
+ 
++static bool fan_with_ns_addr;
++
+ static struct mutex fan_mutex;
+ 
+ static void fan_watchdog_fire(struct work_struct *ignored);
+@@ -8325,6 +8344,15 @@ static int fan_get_status(u8 *status)
+ 		}
+ 
+ 		break;
++	case TPACPI_FAN_RD_TPEC_NS:
++		/* Default mode is AUTO which means controlled by EC */
++		if (!acpi_ec_read(fan_status_offset_ns, &s))
++			return -EIO;
++
++		if (status)
++			*status = s;
++
++		break;
+ 
+ 	default:
+ 		return -ENXIO;
+@@ -8341,7 +8369,8 @@ static int fan_get_status_safe(u8 *statu
+ 	if (mutex_lock_killable(&fan_mutex))
+ 		return -ERESTARTSYS;
+ 	rc = fan_get_status(&s);
+-	if (!rc)
++	/* NS EC doesn't have register with level settings */
++	if (!rc && !fan_with_ns_addr)
+ 		fan_update_desired_level(s);
+ 	mutex_unlock(&fan_mutex);
+ 
+@@ -8368,7 +8397,13 @@ static int fan_get_speed(unsigned int *s
+ 
+ 		if (likely(speed))
+ 			*speed = (hi << 8) | lo;
++		break;
++	case TPACPI_FAN_RD_TPEC_NS:
++		if (!acpi_ec_read(fan_rpm_status_ns, &lo))
++			return -EIO;
+ 
++		if (speed)
++			*speed = lo ? FAN_RPM_CAL_CONST / lo : 0;
+ 		break;
+ 
+ 	default:
+@@ -8380,7 +8415,7 @@ static int fan_get_speed(unsigned int *s
+ 
+ static int fan2_get_speed(unsigned int *speed)
+ {
+-	u8 hi, lo;
++	u8 hi, lo, status;
+ 	bool rc;
+ 
+ 	switch (fan_status_access_mode) {
+@@ -8396,7 +8431,21 @@ static int fan2_get_speed(unsigned int *
+ 
+ 		if (likely(speed))
+ 			*speed = (hi << 8) | lo;
++		break;
+ 
++	case TPACPI_FAN_RD_TPEC_NS:
++		rc = !acpi_ec_read(fan2_status_offset_ns, &status);
++		if (rc)
++			return -EIO;
++		if (!(status & FAN_NS_CTRL_STATUS)) {
++			pr_info("secondary fan control not supported\n");
++			return -EIO;
++		}
++		rc = !acpi_ec_read(fan2_rpm_status_ns, &lo);
++		if (rc)
++			return -EIO;
++		if (speed)
++			*speed = lo ? FAN_RPM_CAL_CONST / lo : 0;
+ 		break;
+ 
+ 	default:
+@@ -8899,6 +8948,7 @@ static const struct attribute_group fan_
+ #define TPACPI_FAN_2FAN		0x0002		/* EC 0x31 bit 0 selects fan2 */
+ #define TPACPI_FAN_2CTL		0x0004		/* selects fan2 control */
+ #define TPACPI_FAN_NOFAN	0x0008		/* no fan available */
++#define TPACPI_FAN_NS		0x0010		/* For EC with non-Standard register addresses */
+ 
+ static const struct tpacpi_quirk fan_quirk_table[] __initconst = {
+ 	TPACPI_QEC_IBM('1', 'Y', TPACPI_FAN_Q1),
+@@ -8917,6 +8967,8 @@ static const struct tpacpi_quirk fan_qui
+ 	TPACPI_Q_LNV3('N', '2', 'O', TPACPI_FAN_2CTL),	/* P1 / X1 Extreme (2nd gen) */
+ 	TPACPI_Q_LNV3('N', '3', '0', TPACPI_FAN_2CTL),	/* P15 (1st gen) / P15v (1st gen) */
+ 	TPACPI_Q_LNV3('N', '3', '7', TPACPI_FAN_2CTL),  /* T15g (2nd gen) */
++	TPACPI_Q_LNV3('R', '1', 'F', TPACPI_FAN_NS),	/* L13 Yoga Gen 2 */
++	TPACPI_Q_LNV3('N', '2', 'U', TPACPI_FAN_NS),	/* X13 Yoga Gen 2*/
+ 	TPACPI_Q_LNV3('N', '1', 'O', TPACPI_FAN_NOFAN),	/* X1 Tablet (2nd gen) */
+ };
+ 
+@@ -8951,18 +9003,27 @@ static int __init fan_init(struct ibm_in
+ 		return -ENODEV;
+ 	}
+ 
++	if (quirks & TPACPI_FAN_NS) {
++		pr_info("ECFW with non-standard fan reg control found\n");
++		fan_with_ns_addr = 1;
++		/* Fan ctrl support from host is undefined for now */
++		tp_features.fan_ctrl_status_undef = 1;
++	}
++
+ 	if (gfan_handle) {
+ 		/* 570, 600e/x, 770e, 770x */
+ 		fan_status_access_mode = TPACPI_FAN_RD_ACPI_GFAN;
+ 	} else {
+ 		/* all other ThinkPads: note that even old-style
+ 		 * ThinkPad ECs supports the fan control register */
+-		if (likely(acpi_ec_read(fan_status_offset,
+-					&fan_control_initial_status))) {
++		if (fan_with_ns_addr ||
++		    likely(acpi_ec_read(fan_status_offset, &fan_control_initial_status))) {
+ 			int res;
+ 			unsigned int speed;
+ 
+-			fan_status_access_mode = TPACPI_FAN_RD_TPEC;
++			fan_status_access_mode = fan_with_ns_addr ?
++				TPACPI_FAN_RD_TPEC_NS : TPACPI_FAN_RD_TPEC;
++
+ 			if (quirks & TPACPI_FAN_Q1)
+ 				fan_quirk1_setup();
+ 			/* Try and probe the 2nd fan */
+@@ -8971,7 +9032,8 @@ static int __init fan_init(struct ibm_in
+ 			if (res >= 0 && speed != FAN_NOT_PRESENT) {
+ 				/* It responded - so let's assume it's there */
+ 				tp_features.second_fan = 1;
+-				tp_features.second_fan_ctl = 1;
++				/* fan control not currently available for ns ECFW */
++				tp_features.second_fan_ctl = !fan_with_ns_addr;
+ 				pr_info("secondary fan control detected & enabled\n");
+ 			} else {
+ 				/* Fan not auto-detected */
+@@ -9146,6 +9208,7 @@ static int fan_read(struct seq_file *m)
+ 			       str_enabled_disabled(status), status);
+ 		break;
+ 
++	case TPACPI_FAN_RD_TPEC_NS:
+ 	case TPACPI_FAN_RD_TPEC:
+ 		/* all except 570, 600e/x, 770e, 770x */
+ 		rc = fan_get_status_safe(&status);
+@@ -9160,13 +9223,22 @@ static int fan_read(struct seq_file *m)
+ 
+ 		seq_printf(m, "speed:\t\t%d\n", speed);
+ 
+-		if (status & TP_EC_FAN_FULLSPEED)
+-			/* Disengaged mode takes precedence */
+-			seq_printf(m, "level:\t\tdisengaged\n");
+-		else if (status & TP_EC_FAN_AUTO)
+-			seq_printf(m, "level:\t\tauto\n");
+-		else
+-			seq_printf(m, "level:\t\t%d\n", status);
++		if (fan_status_access_mode == TPACPI_FAN_RD_TPEC_NS) {
++			/*
++			 * No full speed bit in NS EC
++			 * EC Auto mode is set by default.
++			 * No other levels settings available
++			 */
++			seq_printf(m, "level:\t\t%s\n", status & FAN_NS_CTRL ? "unknown" : "auto");
++		} else {
++			if (status & TP_EC_FAN_FULLSPEED)
++				/* Disengaged mode takes precedence */
++				seq_printf(m, "level:\t\tdisengaged\n");
++			else if (status & TP_EC_FAN_AUTO)
++				seq_printf(m, "level:\t\tauto\n");
++			else
++				seq_printf(m, "level:\t\t%d\n", status);
++		}
+ 		break;
+ 
+ 	case TPACPI_FAN_NONE:
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-069-ASoC-Intel-bytcr_rt5640-Add-quirk-for-the-Medion-Lif.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-069-ASoC-Intel-bytcr_rt5640-Add-quirk-for-the-Medion-Lif.patch
new file mode 100644
index 0000000000..40b3dd0dce
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-069-ASoC-Intel-bytcr_rt5640-Add-quirk-for-the-Medion-Lif.patch
@@ -0,0 +1,42 @@
+From 71ee502a80ce35e2a2af00199a04837fa917eb55 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Sun, 17 Dec 2023 22:32:20 +0100
+Subject: [PATCH] ASoC: Intel: bytcr_rt5640: Add quirk for the Medion Lifetab
+ S10346
+
+[ Upstream commit 99c7bb44f5749373bc01b73af02b50b69bcbf43d ]
+
+Add a quirk for the Medion Lifetab S10346, this BYTCR tablet has no CHAN
+package in its ACPI tables and uses SSP0-AIF1 rather then SSP0-AIF2 which
+is the default for BYTCR devices.
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Acked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
+Link: https://msgid.link/r/20231217213221.49424-1-hdegoede@redhat.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/intel/boards/bytcr_rt5640.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/sound/soc/intel/boards/bytcr_rt5640.c
++++ b/sound/soc/intel/boards/bytcr_rt5640.c
+@@ -884,6 +884,18 @@ static const struct dmi_system_id byt_rt
+ 					BYT_RT5640_SSP0_AIF1 |
+ 					BYT_RT5640_MCLK_EN),
+ 	},
++	{
++		/* Medion Lifetab S10346 */
++		.matches = {
++			DMI_MATCH(DMI_BOARD_VENDOR, "AMI Corporation"),
++			DMI_MATCH(DMI_BOARD_NAME, "Aptio CRB"),
++			/* Above strings are much too generic, also match on BIOS date */
++			DMI_MATCH(DMI_BIOS_DATE, "10/22/2015"),
++		},
++		.driver_data = (void *)(BYTCR_INPUT_DEFAULTS |
++					BYT_RT5640_SSP0_AIF1 |
++					BYT_RT5640_MCLK_EN),
++	},
+ 	{	/* Mele PCG03 Mini PC */
+ 		.matches = {
+ 			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "Mini PC"),
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-070-ASoC-Intel-bytcr_rt5640-Add-new-swapped-speakers-qui.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-070-ASoC-Intel-bytcr_rt5640-Add-new-swapped-speakers-qui.patch
new file mode 100644
index 0000000000..8de3d85688
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-070-ASoC-Intel-bytcr_rt5640-Add-new-swapped-speakers-qui.patch
@@ -0,0 +1,97 @@
+From 9809d56658d06c9ac3c5018adc6abcc6b7e6279d Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Sun, 17 Dec 2023 22:32:21 +0100
+Subject: [PATCH] ASoC: Intel: bytcr_rt5640: Add new swapped-speakers quirk
+
+[ Upstream commit b1b6131bca35a55a69fadc39d51577968fa2ee97 ]
+
+Some BYTCR x86 tablets with a rt5640 codec have the left and right channels
+of their speakers swapped.
+
+Add a new BYT_RT5640_SWAPPED_SPEAKERS quirk for this which sets
+cfg-spk:swapped in the components string to let userspace know
+about the swapping so that the UCM profile can configure the mixer
+to correct this.
+
+Enable this new quirk on the Medion Lifetab S10346 which has its
+speakers swapped.
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Acked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
+Link: https://msgid.link/r/20231217213221.49424-2-hdegoede@redhat.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/soc/intel/boards/bytcr_rt5640.c | 19 +++++++++++++------
+ 1 file changed, 13 insertions(+), 6 deletions(-)
+
+--- a/sound/soc/intel/boards/bytcr_rt5640.c
++++ b/sound/soc/intel/boards/bytcr_rt5640.c
+@@ -83,6 +83,7 @@ enum {
+ #define BYT_RT5640_HSMIC2_ON_IN1	BIT(27)
+ #define BYT_RT5640_JD_HP_ELITEP_1000G2	BIT(28)
+ #define BYT_RT5640_USE_AMCR0F28		BIT(29)
++#define BYT_RT5640_SWAPPED_SPEAKERS	BIT(30)
+ 
+ #define BYTCR_INPUT_DEFAULTS				\
+ 	(BYT_RT5640_IN3_MAP |				\
+@@ -157,6 +158,8 @@ static void log_quirks(struct device *de
+ 		dev_info(dev, "quirk MONO_SPEAKER enabled\n");
+ 	if (byt_rt5640_quirk & BYT_RT5640_NO_SPEAKERS)
+ 		dev_info(dev, "quirk NO_SPEAKERS enabled\n");
++	if (byt_rt5640_quirk & BYT_RT5640_SWAPPED_SPEAKERS)
++		dev_info(dev, "quirk SWAPPED_SPEAKERS enabled\n");
+ 	if (byt_rt5640_quirk & BYT_RT5640_LINEOUT)
+ 		dev_info(dev, "quirk LINEOUT enabled\n");
+ 	if (byt_rt5640_quirk & BYT_RT5640_LINEOUT_AS_HP2)
+@@ -893,6 +896,7 @@ static const struct dmi_system_id byt_rt
+ 			DMI_MATCH(DMI_BIOS_DATE, "10/22/2015"),
+ 		},
+ 		.driver_data = (void *)(BYTCR_INPUT_DEFAULTS |
++					BYT_RT5640_SWAPPED_SPEAKERS |
+ 					BYT_RT5640_SSP0_AIF1 |
+ 					BYT_RT5640_MCLK_EN),
+ 	},
+@@ -1621,11 +1625,11 @@ static int snd_byt_rt5640_mc_probe(struc
+ 	const char *platform_name;
+ 	struct acpi_device *adev;
+ 	struct device *codec_dev;
++	const char *cfg_spk;
+ 	bool sof_parent;
+ 	int ret_val = 0;
+ 	int dai_index = 0;
+-	int i, cfg_spk;
+-	int aif;
++	int i, aif;
+ 
+ 	is_bytcr = false;
+ 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+@@ -1785,13 +1789,16 @@ static int snd_byt_rt5640_mc_probe(struc
+ 	}
+ 
+ 	if (byt_rt5640_quirk & BYT_RT5640_NO_SPEAKERS) {
+-		cfg_spk = 0;
++		cfg_spk = "0";
+ 		spk_type = "none";
+ 	} else if (byt_rt5640_quirk & BYT_RT5640_MONO_SPEAKER) {
+-		cfg_spk = 1;
++		cfg_spk = "1";
+ 		spk_type = "mono";
++	} else if (byt_rt5640_quirk & BYT_RT5640_SWAPPED_SPEAKERS) {
++		cfg_spk = "swapped";
++		spk_type = "swapped";
+ 	} else {
+-		cfg_spk = 2;
++		cfg_spk = "2";
+ 		spk_type = "stereo";
+ 	}
+ 
+@@ -1806,7 +1813,7 @@ static int snd_byt_rt5640_mc_probe(struc
+ 		headset2_string = " cfg-hs2:in1";
+ 
+ 	snprintf(byt_rt5640_components, sizeof(byt_rt5640_components),
+-		 "cfg-spk:%d cfg-mic:%s aif:%d%s%s", cfg_spk,
++		 "cfg-spk:%s cfg-mic:%s aif:%d%s%s", cfg_spk,
+ 		 map_name[BYT_RT5640_MAP(byt_rt5640_quirk)], aif,
+ 		 lineout_string, headset2_string);
+ 	byt_rt5640_card.components = byt_rt5640_components;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-071-ALSA-hda-realtek-Add-quirks-for-ASUS-Zenbook-2022-Mo.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-071-ALSA-hda-realtek-Add-quirks-for-ASUS-Zenbook-2022-Mo.patch
new file mode 100644
index 0000000000..6dec3e1d42
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-071-ALSA-hda-realtek-Add-quirks-for-ASUS-Zenbook-2022-Mo.patch
@@ -0,0 +1,44 @@
+From daaf7a142f2b8e4ef5a6e71025f2152fb7741584 Mon Sep 17 00:00:00 2001
+From: Stefan Binding <sbinding@opensource.cirrus.com>
+Date: Mon, 18 Dec 2023 15:12:19 +0000
+Subject: [PATCH] ALSA: hda/realtek: Add quirks for ASUS Zenbook 2022 Models
+
+[ Upstream commit 51d976079976c800ef19ed1b542602fcf63f0edb ]
+
+These models use 2xCS35L41amps with HDA using SPI and I2C.
+Models use internal and external boost.
+All models require DSD support to be added inside
+cs35l41_hda_property.c
+
+Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
+Link: https://lore.kernel.org/r/20231218151221.388745-6-sbinding@opensource.cirrus.com
+Signed-off-by: Takashi Iwai <tiwai@suse.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ sound/pci/hda/patch_realtek.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/sound/pci/hda/patch_realtek.c
++++ b/sound/pci/hda/patch_realtek.c
+@@ -9779,17 +9779,20 @@ static const struct snd_pci_quirk alc269
+ 	SND_PCI_QUIRK(0x1043, 0x1d1f, "ASUS ROG Strix G17 2023 (G713PV)", ALC287_FIXUP_CS35L41_I2C_2),
+ 	SND_PCI_QUIRK(0x1043, 0x1d42, "ASUS Zephyrus G14 2022", ALC289_FIXUP_ASUS_GA401),
+ 	SND_PCI_QUIRK(0x1043, 0x1d4e, "ASUS TM420", ALC256_FIXUP_ASUS_HPE),
++	SND_PCI_QUIRK(0x1043, 0x1da2, "ASUS UP6502ZA/ZD", ALC245_FIXUP_CS35L41_SPI_2),
+ 	SND_PCI_QUIRK(0x1043, 0x1e02, "ASUS UX3402ZA", ALC245_FIXUP_CS35L41_SPI_2),
+ 	SND_PCI_QUIRK(0x1043, 0x16a3, "ASUS UX3402VA", ALC245_FIXUP_CS35L41_SPI_2),
+ 	SND_PCI_QUIRK(0x1043, 0x1f62, "ASUS UX7602ZM", ALC245_FIXUP_CS35L41_SPI_2),
+ 	SND_PCI_QUIRK(0x1043, 0x1e11, "ASUS Zephyrus G15", ALC289_FIXUP_ASUS_GA502),
+-	SND_PCI_QUIRK(0x1043, 0x1e12, "ASUS UM3402", ALC287_FIXUP_CS35L41_I2C_2),
++	SND_PCI_QUIRK(0x1043, 0x1e12, "ASUS UM6702RA/RC", ALC287_FIXUP_CS35L41_I2C_2),
+ 	SND_PCI_QUIRK(0x1043, 0x1e51, "ASUS Zephyrus M15", ALC294_FIXUP_ASUS_GU502_PINS),
+ 	SND_PCI_QUIRK(0x1043, 0x1e5e, "ASUS ROG Strix G513", ALC294_FIXUP_ASUS_G513_PINS),
+ 	SND_PCI_QUIRK(0x1043, 0x1e8e, "ASUS Zephyrus G15", ALC289_FIXUP_ASUS_GA401),
++	SND_PCI_QUIRK(0x1043, 0x1ee2, "ASUS UM3402", ALC287_FIXUP_CS35L41_I2C_2),
+ 	SND_PCI_QUIRK(0x1043, 0x1c52, "ASUS Zephyrus G15 2022", ALC289_FIXUP_ASUS_GA401),
+ 	SND_PCI_QUIRK(0x1043, 0x1f11, "ASUS Zephyrus G14", ALC289_FIXUP_ASUS_GA401),
+ 	SND_PCI_QUIRK(0x1043, 0x1f12, "ASUS UM5302", ALC287_FIXUP_CS35L41_I2C_2),
++	SND_PCI_QUIRK(0x1043, 0x1f62, "ASUS UX7602ZM", ALC245_FIXUP_CS35L41_SPI_2),
+ 	SND_PCI_QUIRK(0x1043, 0x1f92, "ASUS ROG Flow X16", ALC289_FIXUP_ASUS_GA401),
+ 	SND_PCI_QUIRK(0x1043, 0x3030, "ASUS ZN270IE", ALC256_FIXUP_ASUS_AIO_GPIO2),
+ 	SND_PCI_QUIRK(0x1043, 0x3a20, "ASUS G614JZR", ALC245_FIXUP_CS35L41_SPI_2),
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-072-dm-audit-fix-Kconfig-so-DM_AUDIT-depends-on-BLK_DEV_.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-072-dm-audit-fix-Kconfig-so-DM_AUDIT-depends-on-BLK_DEV_.patch
new file mode 100644
index 0000000000..38ac68cd77
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-072-dm-audit-fix-Kconfig-so-DM_AUDIT-depends-on-BLK_DEV_.patch
@@ -0,0 +1,23 @@
+From 3aff42af15a40ccee900cd032bdb80b7725537fc Mon Sep 17 00:00:00 2001
+From: Mike Snitzer <snitzer@kernel.org>
+Date: Wed, 13 Dec 2023 14:46:19 -0500
+Subject: [PATCH] dm audit: fix Kconfig so DM_AUDIT depends on BLK_DEV_DM
+
+[ Upstream commit 6849302fdff126997765d16df355b73231f130d4 ]
+
+Signed-off-by: Mike Snitzer <snitzer@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/md/Kconfig | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/md/Kconfig
++++ b/drivers/md/Kconfig
+@@ -650,6 +650,7 @@ config DM_ZONED
+ 
+ config DM_AUDIT
+ 	bool "DM audit events"
++	depends on BLK_DEV_DM
+ 	depends on AUDIT
+ 	help
+ 	  Generate audit events for device-mapper.
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-073-HID-nintendo-Prevent-divide-by-zero-on-code.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-073-HID-nintendo-Prevent-divide-by-zero-on-code.patch
new file mode 100644
index 0000000000..df6a3547af
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-073-HID-nintendo-Prevent-divide-by-zero-on-code.patch
@@ -0,0 +1,95 @@
+From 501a174716324fc82b83a30fefb1c7ebc02ec56d Mon Sep 17 00:00:00 2001
+From: "Guilherme G. Piccoli" <gpiccoli@igalia.com>
+Date: Tue, 5 Dec 2023 18:15:51 -0300
+Subject: [PATCH] HID: nintendo: Prevent divide-by-zero on code
+
+[ Upstream commit 6eb04ca8c52e3f8c8ea7102ade81d642eee87f4a ]
+
+It was reported [0] that adding a generic joycon to the system caused
+a kernel crash on Steam Deck, with the below panic spew:
+
+divide error: 0000 [#1] PREEMPT SMP NOPTI
+[...]
+Hardware name: Valve Jupiter/Jupiter, BIOS F7A0119 10/24/2023
+RIP: 0010:nintendo_hid_event+0x340/0xcc1 [hid_nintendo]
+[...]
+Call Trace:
+ [...]
+ ? exc_divide_error+0x38/0x50
+ ? nintendo_hid_event+0x340/0xcc1 [hid_nintendo]
+ ? asm_exc_divide_error+0x1a/0x20
+ ? nintendo_hid_event+0x307/0xcc1 [hid_nintendo]
+ hid_input_report+0x143/0x160
+ hidp_session_run+0x1ce/0x700 [hidp]
+
+Since it's a divide-by-0 error, by tracking the code for potential
+denominator issues, we've spotted 2 places in which this could happen;
+so let's guard against the possibility and log in the kernel if the
+condition happens. This is specially useful since some data that
+fills some denominators are read from the joycon HW in some cases,
+increasing the potential for flaws.
+
+[0] https://github.com/ValveSoftware/SteamOS/issues/1070
+
+Signed-off-by: Guilherme G. Piccoli <gpiccoli@igalia.com>
+Tested-by: Sam Lantinga <slouken@libsdl.org>
+Signed-off-by: Jiri Kosina <jkosina@suse.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/hid/hid-nintendo.c | 27 ++++++++++++++++++++-------
+ 1 file changed, 20 insertions(+), 7 deletions(-)
+
+--- a/drivers/hid/hid-nintendo.c
++++ b/drivers/hid/hid-nintendo.c
+@@ -859,14 +859,27 @@ static int joycon_request_calibration(st
+  */
+ static void joycon_calc_imu_cal_divisors(struct joycon_ctlr *ctlr)
+ {
+-	int i;
++	int i, divz = 0;
+ 
+ 	for (i = 0; i < 3; i++) {
+ 		ctlr->imu_cal_accel_divisor[i] = ctlr->accel_cal.scale[i] -
+ 						ctlr->accel_cal.offset[i];
+ 		ctlr->imu_cal_gyro_divisor[i] = ctlr->gyro_cal.scale[i] -
+ 						ctlr->gyro_cal.offset[i];
++
++		if (ctlr->imu_cal_accel_divisor[i] == 0) {
++			ctlr->imu_cal_accel_divisor[i] = 1;
++			divz++;
++		}
++
++		if (ctlr->imu_cal_gyro_divisor[i] == 0) {
++			ctlr->imu_cal_gyro_divisor[i] = 1;
++			divz++;
++		}
+ 	}
++
++	if (divz)
++		hid_warn(ctlr->hdev, "inaccurate IMU divisors (%d)\n", divz);
+ }
+ 
+ static const s16 DFLT_ACCEL_OFFSET /*= 0*/;
+@@ -1095,16 +1108,16 @@ static void joycon_parse_imu_report(stru
+ 		    JC_IMU_SAMPLES_PER_DELTA_AVG) {
+ 			ctlr->imu_avg_delta_ms = ctlr->imu_delta_samples_sum /
+ 						 ctlr->imu_delta_samples_count;
+-			/* don't ever want divide by zero shenanigans */
+-			if (ctlr->imu_avg_delta_ms == 0) {
+-				ctlr->imu_avg_delta_ms = 1;
+-				hid_warn(ctlr->hdev,
+-					 "calculated avg imu delta of 0\n");
+-			}
+ 			ctlr->imu_delta_samples_count = 0;
+ 			ctlr->imu_delta_samples_sum = 0;
+ 		}
+ 
++		/* don't ever want divide by zero shenanigans */
++		if (ctlr->imu_avg_delta_ms == 0) {
++			ctlr->imu_avg_delta_ms = 1;
++			hid_warn(ctlr->hdev, "calculated avg imu delta of 0\n");
++		}
++
+ 		/* useful for debugging IMU sample rate */
+ 		hid_dbg(ctlr->hdev,
+ 			"imu_report: ms=%u last_ms=%u delta=%u avg_delta=%u\n",
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-074-smb-client-fix-potential-OOB-in-smb2_dump_detail.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-074-smb-client-fix-potential-OOB-in-smb2_dump_detail.patch
new file mode 100644
index 0000000000..2373d330d3
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-074-smb-client-fix-potential-OOB-in-smb2_dump_detail.patch
@@ -0,0 +1,84 @@
+From 7aeb4bb3f3155eafb712a46fb20a1a63f3e9f970 Mon Sep 17 00:00:00 2001
+From: Paulo Alcantara <pc@manguebit.com>
+Date: Tue, 19 Dec 2023 13:10:31 -0300
+Subject: [PATCH] smb: client: fix potential OOB in smb2_dump_detail()
+
+[ Upstream commit 567320c46a60a3c39b69aa1df802d753817a3f86 ]
+
+Validate SMB message with ->check_message() before calling
+->calc_smb_size().
+
+This fixes CVE-2023-6610.
+
+Reported-by: j51569436@gmail.com
+Closes: https://bugzilla.kernel.org/show_bug.cgi?id=218219
+Cc; stable@vger.kernel.org
+Signed-off-by: Paulo Alcantara <pc@manguebit.com>
+Signed-off-by: Steve French <stfrench@microsoft.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ fs/smb/client/smb2misc.c | 30 +++++++++++++++---------------
+ fs/smb/client/smb2ops.c  |  6 ++++--
+ 2 files changed, 19 insertions(+), 17 deletions(-)
+
+--- a/fs/smb/client/smb2misc.c
++++ b/fs/smb/client/smb2misc.c
+@@ -173,6 +173,21 @@ smb2_check_message(char *buf, unsigned i
+ 	}
+ 
+ 	mid = le64_to_cpu(shdr->MessageId);
++	if (check_smb2_hdr(shdr, mid))
++		return 1;
++
++	if (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {
++		cifs_dbg(VFS, "Invalid structure size %u\n",
++			 le16_to_cpu(shdr->StructureSize));
++		return 1;
++	}
++
++	command = le16_to_cpu(shdr->Command);
++	if (command >= NUMBER_OF_SMB2_COMMANDS) {
++		cifs_dbg(VFS, "Invalid SMB2 command %d\n", command);
++		return 1;
++	}
++
+ 	if (len < pdu_size) {
+ 		if ((len >= hdr_size)
+ 		    && (shdr->Status != 0)) {
+@@ -193,21 +208,6 @@ smb2_check_message(char *buf, unsigned i
+ 		return 1;
+ 	}
+ 
+-	if (check_smb2_hdr(shdr, mid))
+-		return 1;
+-
+-	if (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {
+-		cifs_dbg(VFS, "Invalid structure size %u\n",
+-			 le16_to_cpu(shdr->StructureSize));
+-		return 1;
+-	}
+-
+-	command = le16_to_cpu(shdr->Command);
+-	if (command >= NUMBER_OF_SMB2_COMMANDS) {
+-		cifs_dbg(VFS, "Invalid SMB2 command %d\n", command);
+-		return 1;
+-	}
+-
+ 	if (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {
+ 		if (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||
+ 		    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {
+--- a/fs/smb/client/smb2ops.c
++++ b/fs/smb/client/smb2ops.c
+@@ -398,8 +398,10 @@ smb2_dump_detail(void *buf, struct TCP_S
+ 	cifs_server_dbg(VFS, "Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\n",
+ 		 shdr->Command, shdr->Status, shdr->Flags, shdr->MessageId,
+ 		 shdr->Id.SyncId.ProcessId);
+-	cifs_server_dbg(VFS, "smb buf %p len %u\n", buf,
+-		 server->ops->calc_smb_size(buf));
++	if (!server->ops->check_message(buf, server->total_read, server)) {
++		cifs_server_dbg(VFS, "smb buf %p len %u\n", buf,
++				server->ops->calc_smb_size(buf));
++	}
+ #endif
+ }
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-075-i2c-rk3x-fix-potential-spinlock-recursion-on-poll.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-075-i2c-rk3x-fix-potential-spinlock-recursion-on-poll.patch
new file mode 100644
index 0000000000..985b36f3ff
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-075-i2c-rk3x-fix-potential-spinlock-recursion-on-poll.patch
@@ -0,0 +1,77 @@
+From 880083ed8354e9aa173743943f126ffc5ed637e1 Mon Sep 17 00:00:00 2001
+From: Jensen Huang <jensenhuang@friendlyarm.com>
+Date: Thu, 7 Dec 2023 16:21:59 +0800
+Subject: [PATCH] i2c: rk3x: fix potential spinlock recursion on poll
+
+[ Upstream commit 19cde9c92b8d3b7ee555d0da3bcb0232d3a784f4 ]
+
+Possible deadlock scenario (on reboot):
+rk3x_i2c_xfer_common(polling)
+    -> rk3x_i2c_wait_xfer_poll()
+        -> rk3x_i2c_irq(0, i2c);
+            --> spin_lock(&i2c->lock);
+            ...
+        <rk3x i2c interrupt>
+        -> rk3x_i2c_irq(0, i2c);
+            --> spin_lock(&i2c->lock); (deadlock here)
+
+Store the IRQ number and disable/enable it around the polling transfer.
+This patch has been tested on NanoPC-T4.
+
+Signed-off-by: Jensen Huang <jensenhuang@friendlyarm.com>
+Reviewed-by: Heiko Stuebner <heiko@sntech.de>
+Reviewed-by: Andi Shyti <andi.shyti@kernel.org>
+Signed-off-by: Wolfram Sang <wsa@kernel.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/i2c/busses/i2c-rk3x.c | 13 +++++++++++--
+ 1 file changed, 11 insertions(+), 2 deletions(-)
+
+--- a/drivers/i2c/busses/i2c-rk3x.c
++++ b/drivers/i2c/busses/i2c-rk3x.c
+@@ -178,6 +178,7 @@ struct rk3x_i2c_soc_data {
+  * @clk: function clk for rk3399 or function & Bus clks for others
+  * @pclk: Bus clk for rk3399
+  * @clk_rate_nb: i2c clk rate change notify
++ * @irq: irq number
+  * @t: I2C known timing information
+  * @lock: spinlock for the i2c bus
+  * @wait: the waitqueue to wait for i2c transfer
+@@ -200,6 +201,7 @@ struct rk3x_i2c {
+ 	struct clk *clk;
+ 	struct clk *pclk;
+ 	struct notifier_block clk_rate_nb;
++	int irq;
+ 
+ 	/* Settings */
+ 	struct i2c_timings t;
+@@ -1087,13 +1089,18 @@ static int rk3x_i2c_xfer_common(struct i
+ 
+ 		spin_unlock_irqrestore(&i2c->lock, flags);
+ 
+-		rk3x_i2c_start(i2c);
+-
+ 		if (!polling) {
++			rk3x_i2c_start(i2c);
++
+ 			timeout = wait_event_timeout(i2c->wait, !i2c->busy,
+ 						     msecs_to_jiffies(WAIT_TIMEOUT));
+ 		} else {
++			disable_irq(i2c->irq);
++			rk3x_i2c_start(i2c);
++
+ 			timeout = rk3x_i2c_wait_xfer_poll(i2c);
++
++			enable_irq(i2c->irq);
+ 		}
+ 
+ 		spin_lock_irqsave(&i2c->lock, flags);
+@@ -1310,6 +1317,8 @@ static int rk3x_i2c_probe(struct platfor
+ 		return ret;
+ 	}
+ 
++	i2c->irq = irq;
++
+ 	platform_set_drvdata(pdev, i2c);
+ 
+ 	if (i2c->soc_data->calc_timings == rk3x_i2c_v0_calc_timings) {
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-076-drm-amd-display-get-dprefclk-ss-info-from-integratio.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-076-drm-amd-display-get-dprefclk-ss-info-from-integratio.patch
new file mode 100644
index 0000000000..c5dc90af5d
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-076-drm-amd-display-get-dprefclk-ss-info-from-integratio.patch
@@ -0,0 +1,75 @@
+From 3ee24f85f028fc66348e1d3a223e0ca29eb81b35 Mon Sep 17 00:00:00 2001
+From: Charlene Liu <charlene.liu@amd.com>
+Date: Wed, 6 Dec 2023 17:14:48 -0500
+Subject: [PATCH] drm/amd/display: get dprefclk ss info from integration info
+ table
+
+[ Upstream commit 51e7b64690776a9981355428b537af9048308a95 ]
+
+[why & how]
+we have two SSC_En:
+we get ssc_info from dce_info for MPLL_SSC_EN.
+we used to call VBIOS cmdtbl's smu_info's SS persentage for DPRECLK SS info,
+is used for DP AUDIO and VBIOS' smu_info table was from systemIntegrationInfoTable.
+
+since dcn35 VBIOS removed smu_info, driver need to use integrationInfotable directly.
+
+Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
+Acked-by: Wayne Lin <wayne.lin@amd.com>
+Signed-off-by: Charlene Liu <charlene.liu@amd.com>
+Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
+Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ .../drm/amd/display/dc/bios/bios_parser2.c    | 19 ++++++++++++++-----
+ .../display/include/grph_object_ctrl_defs.h   |  2 ++
+ 2 files changed, 16 insertions(+), 5 deletions(-)
+
+--- a/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
++++ b/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
+@@ -1018,13 +1018,20 @@ static enum bp_result get_ss_info_v4_5(
+ 		DC_LOG_BIOS("AS_SIGNAL_TYPE_HDMI ss_percentage: %d\n", ss_info->spread_spectrum_percentage);
+ 		break;
+ 	case AS_SIGNAL_TYPE_DISPLAY_PORT:
+-		ss_info->spread_spectrum_percentage =
++		if (bp->base.integrated_info) {
++			DC_LOG_BIOS("gpuclk_ss_percentage (unit of 0.001 percent): %d\n", bp->base.integrated_info->gpuclk_ss_percentage);
++			ss_info->spread_spectrum_percentage =
++					bp->base.integrated_info->gpuclk_ss_percentage;
++			ss_info->type.CENTER_MODE =
++					bp->base.integrated_info->gpuclk_ss_type;
++		} else {
++			ss_info->spread_spectrum_percentage =
+ 				disp_cntl_tbl->dp_ss_percentage;
+-		ss_info->spread_spectrum_range =
++			ss_info->spread_spectrum_range =
+ 				disp_cntl_tbl->dp_ss_rate_10hz * 10;
+-		if (disp_cntl_tbl->dp_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)
+-			ss_info->type.CENTER_MODE = true;
+-
++			if (disp_cntl_tbl->dp_ss_mode & ATOM_SS_CENTRE_SPREAD_MODE)
++				ss_info->type.CENTER_MODE = true;
++		}
+ 		DC_LOG_BIOS("AS_SIGNAL_TYPE_DISPLAY_PORT ss_percentage: %d\n", ss_info->spread_spectrum_percentage);
+ 		break;
+ 	case AS_SIGNAL_TYPE_GPU_PLL:
+@@ -2836,6 +2843,8 @@ static enum bp_result get_integrated_inf
+ 	info->ma_channel_number = info_v2_2->umachannelnumber;
+ 	info->dp_ss_control =
+ 		le16_to_cpu(info_v2_2->reserved1);
++	info->gpuclk_ss_percentage = info_v2_2->gpuclk_ss_percentage;
++	info->gpuclk_ss_type = info_v2_2->gpuclk_ss_type;
+ 
+ 	for (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; ++i) {
+ 		info->ext_disp_conn_info.gu_id[i] =
+--- a/drivers/gpu/drm/amd/display/include/grph_object_ctrl_defs.h
++++ b/drivers/gpu/drm/amd/display/include/grph_object_ctrl_defs.h
+@@ -417,6 +417,8 @@ struct integrated_info {
+ 	/* V2.1 */
+ 	struct edp_info edp1_info;
+ 	struct edp_info edp2_info;
++	uint32_t gpuclk_ss_percentage;
++	uint32_t gpuclk_ss_type;
+ };
+ 
+ /*
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-077-pinctrl-cy8c95x0-Fix-typo.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-077-pinctrl-cy8c95x0-Fix-typo.patch
new file mode 100644
index 0000000000..ebd0184bbe
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-077-pinctrl-cy8c95x0-Fix-typo.patch
@@ -0,0 +1,28 @@
+From 0d5bf979e4ab430d6caad469319034b03cc77f42 Mon Sep 17 00:00:00 2001
+From: Patrick Rudolph <patrick.rudolph@9elements.com>
+Date: Tue, 19 Dec 2023 13:51:16 +0100
+Subject: [PATCH] pinctrl: cy8c95x0: Fix typo
+
+[ Upstream commit 47b1fa48116238208c1b1198dba10f56fc1b6eb2 ]
+
+Fix typo to make pinctrl-cy8c95x compile again.
+
+Signed-off-by: Patrick Rudolph <patrick.rudolph@9elements.com>
+Link: https://lore.kernel.org/r/20231219125120.4028862-1-patrick.rudolph@9elements.com
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/pinctrl/pinctrl-cy8c95x0.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/pinctrl/pinctrl-cy8c95x0.c
++++ b/drivers/pinctrl/pinctrl-cy8c95x0.c
+@@ -857,7 +857,7 @@ static int cy8c95x0_setup_gpiochip(struc
+ 	gc->get_direction = cy8c95x0_gpio_get_direction;
+ 	gc->get_multiple = cy8c95x0_gpio_get_multiple;
+ 	gc->set_multiple = cy8c95x0_gpio_set_multiple;
+-	gc->set_config = gpiochip_generic_config,
++	gc->set_config = gpiochip_generic_config;
+ 	gc->can_sleep = true;
+ 	gc->add_pin_ranges = cy8c95x0_add_pin_ranges;
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-078-pinctrl-cy8c95x0-Fix-get_pincfg.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-078-pinctrl-cy8c95x0-Fix-get_pincfg.patch
new file mode 100644
index 0000000000..fa55fc349b
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-078-pinctrl-cy8c95x0-Fix-get_pincfg.patch
@@ -0,0 +1,29 @@
+From ba3c85fa3162b0d0eff20e361240e0f666ac0896 Mon Sep 17 00:00:00 2001
+From: Patrick Rudolph <patrick.rudolph@9elements.com>
+Date: Tue, 19 Dec 2023 13:51:18 +0100
+Subject: [PATCH] pinctrl: cy8c95x0: Fix get_pincfg
+
+[ Upstream commit 94c71705cc49092cef60ece13a28680809096fd4 ]
+
+Invert the register value for PIN_CONFIG_OUTPUT_ENABLE to return
+the opposite of PIN_CONFIG_INPUT_ENABLE.
+
+Signed-off-by: Patrick Rudolph <patrick.rudolph@9elements.com>
+Link: https://lore.kernel.org/r/20231219125120.4028862-3-patrick.rudolph@9elements.com
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/pinctrl/pinctrl-cy8c95x0.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/pinctrl/pinctrl-cy8c95x0.c
++++ b/drivers/pinctrl/pinctrl-cy8c95x0.c
+@@ -749,6 +749,8 @@ static int cy8c95x0_gpio_get_pincfg(stru
+ 	ret = regmap_read(chip->regmap, reg, &reg_val);
+ 	if (reg_val & bit)
+ 		arg = 1;
++	if (param == PIN_CONFIG_OUTPUT_ENABLE)
++		arg = !arg;
+ 
+ 	*config = pinconf_to_config_packed(param, (u16)arg);
+ out:
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-079-ida-Fix-crash-in-ida_free-when-the-bitmap-is-empty.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-079-ida-Fix-crash-in-ida_free-when-the-bitmap-is-empty.patch
new file mode 100644
index 0000000000..9c82855c0e
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-079-ida-Fix-crash-in-ida_free-when-the-bitmap-is-empty.patch
@@ -0,0 +1,90 @@
+From ecc9df2da97052d6b9d2da9c4146235275dddddd Mon Sep 17 00:00:00 2001
+From: "Matthew Wilcox (Oracle)" <willy@infradead.org>
+Date: Thu, 21 Dec 2023 16:53:57 +0000
+Subject: [PATCH] ida: Fix crash in ida_free when the bitmap is empty
+
+[ Upstream commit af73483f4e8b6f5c68c9aa63257bdd929a9c194a ]
+
+The IDA usually detects double-frees, but that detection failed to
+consider the case when there are no nearby IDs allocated and so we have a
+NULL bitmap rather than simply having a clear bit.  Add some tests to the
+test-suite to be sure we don't inadvertently reintroduce this problem.
+Unfortunately they're quite noisy so include a message to disregard
+the warnings.
+
+Reported-by: Zhenghan Wang <wzhmmmmm@gmail.com>
+Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
+Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ lib/idr.c      |  2 +-
+ lib/test_ida.c | 40 ++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 41 insertions(+), 1 deletion(-)
+
+--- a/lib/idr.c
++++ b/lib/idr.c
+@@ -508,7 +508,7 @@ void ida_free(struct ida *ida, unsigned
+ 			goto delete;
+ 		xas_store(&xas, xa_mk_value(v));
+ 	} else {
+-		if (!test_bit(bit, bitmap->bitmap))
++		if (!bitmap || !test_bit(bit, bitmap->bitmap))
+ 			goto err;
+ 		__clear_bit(bit, bitmap->bitmap);
+ 		xas_set_mark(&xas, XA_FREE_MARK);
+--- a/lib/test_ida.c
++++ b/lib/test_ida.c
+@@ -150,6 +150,45 @@ static void ida_check_conv(struct ida *i
+ 	IDA_BUG_ON(ida, !ida_is_empty(ida));
+ }
+ 
++/*
++ * Check various situations where we attempt to free an ID we don't own.
++ */
++static void ida_check_bad_free(struct ida *ida)
++{
++	unsigned long i;
++
++	printk("vvv Ignore \"not allocated\" warnings\n");
++	/* IDA is empty; all of these will fail */
++	ida_free(ida, 0);
++	for (i = 0; i < 31; i++)
++		ida_free(ida, 1 << i);
++
++	/* IDA contains a single value entry */
++	IDA_BUG_ON(ida, ida_alloc_min(ida, 3, GFP_KERNEL) != 3);
++	ida_free(ida, 0);
++	for (i = 0; i < 31; i++)
++		ida_free(ida, 1 << i);
++
++	/* IDA contains a single bitmap */
++	IDA_BUG_ON(ida, ida_alloc_min(ida, 1023, GFP_KERNEL) != 1023);
++	ida_free(ida, 0);
++	for (i = 0; i < 31; i++)
++		ida_free(ida, 1 << i);
++
++	/* IDA contains a tree */
++	IDA_BUG_ON(ida, ida_alloc_min(ida, (1 << 20) - 1, GFP_KERNEL) != (1 << 20) - 1);
++	ida_free(ida, 0);
++	for (i = 0; i < 31; i++)
++		ida_free(ida, 1 << i);
++	printk("^^^ \"not allocated\" warnings over\n");
++
++	ida_free(ida, 3);
++	ida_free(ida, 1023);
++	ida_free(ida, (1 << 20) - 1);
++
++	IDA_BUG_ON(ida, !ida_is_empty(ida));
++}
++
+ static DEFINE_IDA(ida);
+ 
+ static int ida_checks(void)
+@@ -162,6 +201,7 @@ static int ida_checks(void)
+ 	ida_check_leaf(&ida, 1024 * 64);
+ 	ida_check_max(&ida);
+ 	ida_check_conv(&ida);
++	ida_check_bad_free(&ida);
+ 
+ 	printk("IDA: %u of %u tests passed\n", tests_passed, tests_run);
+ 	return (tests_run != tests_passed) ? 0 : -EINVAL;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-080-virtio_blk-fix-snprintf-truncation-compiler-warning.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-080-virtio_blk-fix-snprintf-truncation-compiler-warning.patch
new file mode 100644
index 0000000000..73fc122184
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-080-virtio_blk-fix-snprintf-truncation-compiler-warning.patch
@@ -0,0 +1,76 @@
+From df9426241c5aa74b6dbee30ce35282bc8654a8d9 Mon Sep 17 00:00:00 2001
+From: Stefan Hajnoczi <stefanha@redhat.com>
+Date: Mon, 4 Dec 2023 09:07:43 -0500
+Subject: [PATCH] virtio_blk: fix snprintf truncation compiler warning
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+[ Upstream commit b8e0792449928943c15d1af9f63816911d139267 ]
+
+Commit 4e0400525691 ("virtio-blk: support polling I/O") triggers the
+following gcc 13 W=1 warnings:
+
+drivers/block/virtio_blk.c: In function init_vq:
+drivers/block/virtio_blk.c:1077:68: warning: %d directive output may be truncated writing between 1 and 11 bytes into a region of size 7 [-Wformat-truncation=]
+ 1077 |                 snprintf(vblk->vqs[i].name, VQ_NAME_LEN, "req_poll.%d", i);
+      |                                                                    ^~
+drivers/block/virtio_blk.c:1077:58: note: directive argument in the range [-2147483648, 65534]
+ 1077 |                 snprintf(vblk->vqs[i].name, VQ_NAME_LEN, "req_poll.%d", i);
+      |                                                          ^~~~~~~~~~~~~
+drivers/block/virtio_blk.c:1077:17: note: snprintf output between 11 and 21 bytes into a destination of size 16
+ 1077 |                 snprintf(vblk->vqs[i].name, VQ_NAME_LEN, "req_poll.%d", i);
+      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+This is a false positive because the lower bound -2147483648 is
+incorrect. The true range of i is [0, num_vqs - 1] where 0 < num_vqs <
+65536.
+
+The code mixes int, unsigned short, and unsigned int types in addition
+to using "%d" for an unsigned value. Use unsigned short and "%u"
+consistently to solve the compiler warning.
+
+Cc: Suwan Kim <suwan.kim027@gmail.com>
+Reported-by: kernel test robot <lkp@intel.com>
+Closes: https://lore.kernel.org/oe-kbuild-all/202312041509.DIyvEt9h-lkp@intel.com/
+Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
+Message-Id: <20231204140743.1487843-1-stefanha@redhat.com>
+Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/block/virtio_blk.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/block/virtio_blk.c
++++ b/drivers/block/virtio_blk.c
+@@ -609,12 +609,12 @@ static void virtblk_config_changed(struc
+ static int init_vq(struct virtio_blk *vblk)
+ {
+ 	int err;
+-	int i;
++	unsigned short i;
+ 	vq_callback_t **callbacks;
+ 	const char **names;
+ 	struct virtqueue **vqs;
+ 	unsigned short num_vqs;
+-	unsigned int num_poll_vqs;
++	unsigned short num_poll_vqs;
+ 	struct virtio_device *vdev = vblk->vdev;
+ 	struct irq_affinity desc = { 0, };
+ 
+@@ -658,13 +658,13 @@ static int init_vq(struct virtio_blk *vb
+ 
+ 	for (i = 0; i < num_vqs - num_poll_vqs; i++) {
+ 		callbacks[i] = virtblk_done;
+-		snprintf(vblk->vqs[i].name, VQ_NAME_LEN, "req.%d", i);
++		snprintf(vblk->vqs[i].name, VQ_NAME_LEN, "req.%u", i);
+ 		names[i] = vblk->vqs[i].name;
+ 	}
+ 
+ 	for (; i < num_vqs; i++) {
+ 		callbacks[i] = NULL;
+-		snprintf(vblk->vqs[i].name, VQ_NAME_LEN, "req_poll.%d", i);
++		snprintf(vblk->vqs[i].name, VQ_NAME_LEN, "req_poll.%u", i);
+ 		names[i] = vblk->vqs[i].name;
+ 	}
+ 
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-081-net-qrtr-ns-Return-0-if-server-port-is-not-present.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-081-net-qrtr-ns-Return-0-if-server-port-is-not-present.patch
new file mode 100644
index 0000000000..a9e11e83ce
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-081-net-qrtr-ns-Return-0-if-server-port-is-not-present.patch
@@ -0,0 +1,38 @@
+From c4a8a128184b852c9c82100c6a0c393d611b0dfc Mon Sep 17 00:00:00 2001
+From: Sarannya S <quic_sarannya@quicinc.com>
+Date: Thu, 21 Dec 2023 15:36:51 +0530
+Subject: [PATCH] net: qrtr: ns: Return 0 if server port is not present
+
+[ Upstream commit 9bf2e9165f90dc9f416af53c902be7e33930f728 ]
+
+When a 'DEL_CLIENT' message is received from the remote, the corresponding
+server port gets deleted. A DEL_SERVER message is then announced for this
+server. As part of handling the subsequent DEL_SERVER message, the name-
+server attempts to delete the server port which results in a '-ENOENT' error.
+The return value from server_del() is then propagated back to qrtr_ns_worker,
+causing excessive error prints.
+To address this, return 0 from control_cmd_del_server() without checking the
+return value of server_del(), since the above scenario is not an error case
+and hence server_del() doesn't have any other error return value.
+
+Signed-off-by: Sarannya Sasikumar <quic_sarannya@quicinc.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ net/qrtr/ns.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/net/qrtr/ns.c
++++ b/net/qrtr/ns.c
+@@ -569,7 +569,9 @@ static int ctrl_cmd_del_server(struct so
+ 	if (!node)
+ 		return -ENOENT;
+ 
+-	return server_del(node, port, true);
++	server_del(node, port, true);
++
++	return 0;
+ }
+ 
+ static int ctrl_cmd_new_lookup(struct sockaddr_qrtr *from,
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-082-ARM-sun9i-smp-fix-return-code-check-of-of_property_m.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-082-ARM-sun9i-smp-fix-return-code-check-of-of_property_m.patch
new file mode 100644
index 0000000000..01afc1a221
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-082-ARM-sun9i-smp-fix-return-code-check-of-of_property_m.patch
@@ -0,0 +1,43 @@
+From 3e0e03997396778909b64a6099b413af0d812b46 Mon Sep 17 00:00:00 2001
+From: Stefan Wahren <wahrenst@gmx.net>
+Date: Thu, 28 Dec 2023 20:39:03 +0100
+Subject: [PATCH] ARM: sun9i: smp: fix return code check of
+ of_property_match_string
+
+[ Upstream commit 643fe70e7bcdcc9e2d96952f7fc2bab56385cce5 ]
+
+of_property_match_string returns an int; either an index from 0 or
+greater if successful or negative on failure. Even it's very
+unlikely that the DT CPU node contains multiple enable-methods
+these checks should be fixed.
+
+This patch was inspired by the work of Nick Desaulniers.
+
+Link: https://lore.kernel.org/lkml/20230516-sunxi-v1-1-ac4b9651a8c1@google.com/T/
+Cc: Nick Desaulniers <ndesaulniers@google.com>
+Signed-off-by: Stefan Wahren <wahrenst@gmx.net>
+Link: https://lore.kernel.org/r/20231228193903.9078-2-wahrenst@gmx.net
+Reviewed-by: Chen-Yu Tsai <wens@csie.org>
+Signed-off-by: Arnd Bergmann <arnd@arndb.de>
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ arch/arm/mach-sunxi/mc_smp.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/arch/arm/mach-sunxi/mc_smp.c
++++ b/arch/arm/mach-sunxi/mc_smp.c
+@@ -804,12 +804,12 @@ static int __init sunxi_mc_smp_init(void
+ 	for (i = 0; i < ARRAY_SIZE(sunxi_mc_smp_data); i++) {
+ 		ret = of_property_match_string(node, "enable-method",
+ 					       sunxi_mc_smp_data[i].enable_method);
+-		if (!ret)
++		if (ret >= 0)
+ 			break;
+ 	}
+ 
+ 	of_node_put(node);
+-	if (ret)
++	if (ret < 0)
+ 		return -ENODEV;
+ 
+ 	is_a83t = sunxi_mc_smp_data[i].is_a83t;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-083-drm-crtc-fix-uninitialized-variable-use.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-083-drm-crtc-fix-uninitialized-variable-use.patch
new file mode 100644
index 0000000000..1fd22714e2
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-083-drm-crtc-fix-uninitialized-variable-use.patch
@@ -0,0 +1,47 @@
+From 1cc2ec63081b49f69026d5e47b35ace2bc7e862a Mon Sep 17 00:00:00 2001
+From: Jani Nikula <jani.nikula@intel.com>
+Date: Fri, 8 Dec 2023 15:12:38 +0200
+Subject: [PATCH] drm/crtc: fix uninitialized variable use
+
+[ Upstream commit 6e455f5dcdd15fa28edf0ffb5b44d3508512dccf ]
+
+Commit 3823119b9c2b ("drm/crtc: Fix uninit-value bug in
+drm_mode_setcrtc") was supposed to fix use of an uninitialized variable,
+but introduced another.
+
+num_connectors is only initialized if crtc_req->count_connectors > 0,
+but it's used regardless. Fix it.
+
+Fixes: 3823119b9c2b ("drm/crtc: Fix uninit-value bug in drm_mode_setcrtc")
+Cc: syzbot+4fad2e57beb6397ab2fc@syzkaller.appspotmail.com
+Cc: Ziqi Zhao <astrajoan@yahoo.com>
+Cc: Maxime Ripard <mripard@kernel.org>
+Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
+Cc: Thomas Zimmermann <tzimmermann@suse.de>
+Signed-off-by: Jani Nikula <jani.nikula@intel.com>
+Signed-off-by: Maxime Ripard <mripard@kernel.org>
+Link: https://patchwork.freedesktop.org/patch/msgid/20231208131238.2924571-1-jani.nikula@intel.com
+Signed-off-by: Sasha Levin <sashal@kernel.org>
+---
+ drivers/gpu/drm/drm_crtc.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+--- a/drivers/gpu/drm/drm_crtc.c
++++ b/drivers/gpu/drm/drm_crtc.c
+@@ -715,7 +715,7 @@ int drm_mode_setcrtc(struct drm_device *
+ 	struct drm_mode_set set;
+ 	uint32_t __user *set_connectors_ptr;
+ 	struct drm_modeset_acquire_ctx ctx;
+-	int ret, i, num_connectors;
++	int ret, i, num_connectors = 0;
+ 
+ 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
+ 		return -EOPNOTSUPP;
+@@ -850,7 +850,6 @@ int drm_mode_setcrtc(struct drm_device *
+ 			goto out;
+ 		}
+ 
+-		num_connectors = 0;
+ 		for (i = 0; i < crtc_req->count_connectors; i++) {
+ 			connector_set[i] = NULL;
+ 			set_connectors_ptr = (uint32_t __user *)(unsigned long)crtc_req->set_connectors_ptr;
diff --git a/target/linux/generic/backport-6.1/0-queue-6.1.74-084-ksmbd-only-v2-leases-handle-the-directory.patch b/target/linux/generic/backport-6.1/0-queue-6.1.74-084-ksmbd-only-v2-leases-handle-the-directory.patch
new file mode 100644
index 0000000000..ada63b4953
--- /dev/null
+++ b/target/linux/generic/backport-6.1/0-queue-6.1.74-084-ksmbd-only-v2-leases-handle-the-directory.patch
@@ -0,0 +1,30 @@
+From 49603ff4241a68c5540e48ee61a2b51168a85b55 Mon Sep 17 00:00:00 2001
+From: Namjae Jeon <linkinjeon@kernel.org>
+Date: Mon, 15 Jan 2024 10:34:32 +0900
+Subject: [PATCH] ksmbd: only v2 leases handle the directory
+
+When smb2 leases is disable, ksmbd can send oplock break notification
+and cause wait oplock break ack timeout. It may appear like hang when
+accessing a directory. This patch make only v2 leases handle the
+directory.
+
+Signed-off-by: Namjae Jeon <linkinjeon@kernel.org>
+---
+ fs/smb/server/oplock.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/fs/smb/server/oplock.c
++++ b/fs/smb/server/oplock.c
+@@ -1191,6 +1191,12 @@ int smb_grant_oplock(struct ksmbd_work *
+ 	bool prev_op_has_lease;
+ 	__le32 prev_op_state = 0;
+ 
++	/* Only v2 leases handle the directory */
++	if (S_ISDIR(file_inode(fp->filp)->i_mode)) {
++		if (!lctx || lctx->version != 2)
++			return 0;
++	}
++
+ 	opinfo = alloc_opinfo(work, pid, tid);
+ 	if (!opinfo)
+ 		return -ENOMEM;
-- 
2.40.1

